
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type alta_novellPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovell: number
    fecha_recepcion: Date | null
    servicio: string | null
    monto: number | null
    monto_letra: string | null
    anticipo: number | null
    gastos_adm: number | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    estcivil_sol: string | null
    fecha_nac_sol: Date | null
    dom_sol: string | null
    domnum_sol: number | null
    piso_sol: string | null
    barrio_sol: string | null
    localidad_sol: string | null
    codpostal_sol: number | null
    telefono_sol: string | null
    movil_sol: string | null
    apellido_ben: string | null
    nombre_ben: string | null
    dni_ben: number | null
    estcivil_ben: string | null
    fecha_nac_ben: Date | null
    dom_ben: string | null
    domnum_ben: number | null
    piso_ben: string | null
    barrio_ben: string | null
    localidad_ben: string | null
    codpostal_ben: number | null
    telefono_ben: string | null
    movil_ben: string | null
    operador: string | null
    cuotas: number | null
    nacionalidad_sol: string | null
    nacionalidad_ben: string | null
    anticipo_letra: string | null
    cuotasaldo: number | null
    cuotasaldo_letra: string | null
    cuota_mantenimiento: number | null
  }, ExtArgs["result"]["alta_novell"]>
  composites: {}
}

/**
 * Model alta_novell
 * 
 */
export type alta_novell = runtime.Types.DefaultSelection<alta_novellPayload>
export type caja_sucursalesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    fecha_carga: Date | null
    sucursal: string | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
    operador_carga: string | null
    empresa: string | null
  }, ExtArgs["result"]["caja_sucursales"]>
  composites: {}
}

/**
 * Model caja_sucursales
 * 
 */
export type caja_sucursales = runtime.Types.DefaultSelection<caja_sucursalesPayload>
export type campanacasosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaso: number
    idcampana: number | null
    fechacampana: Date | null
    mes: number | null
    ano: number | null
    sucursal: string | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: string | null
    movil: string | null
    calle: string | null
    nro_calle: number | null
    barrio: string | null
    localidad: string | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    estadocaso: boolean | null
    accion: number | null
    edad: number | null
    adherentes: number | null
    alta: Date | null
    vigencia: Date | null
  }, ExtArgs["result"]["campanacasos"]>
  composites: {}
}

/**
 * Model campanacasos
 * 
 */
export type campanacasos = runtime.Types.DefaultSelection<campanacasosPayload>
export type campanasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcampana: number
    descripcion: string | null
    operador: string | null
    fecha: Date | null
    empresa: string | null
    sucursal: string | null
  }, ExtArgs["result"]["campanas"]>
  composites: {}
}

/**
 * Model campanas
 * 
 */
export type campanas = runtime.Types.DefaultSelection<campanasPayload>
export type campanatemporalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    SUCURSAL: string | null
    CONTRATO: number
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    ALTA: Date | null
    VIGENCIA: Date | null
    CALLE: string | null
    NRO_CALLE: number | null
    BARRIO: string | null
    LOCALIDAD: string | null
    GRUPO: number | null
    ZONA: number | null
    TELEFONO: string | null
    MOVIL: string | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    operador: string | null
    estado: boolean | null
    idcaso: number
    observacion: string | null
    fecha: string | null
    fecha_observacion: string | null
    accion: string | null
  }, ExtArgs["result"]["campanatemporal"]>
  composites: {}
}

/**
 * Model campanatemporal
 * 
 */
export type campanatemporal = runtime.Types.DefaultSelection<campanatemporalPayload>
export type capital_prestamoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcapital: number
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }, ExtArgs["result"]["capital_prestamo"]>
  composites: {}
}

/**
 * Model capital_prestamo
 * 
 */
export type capital_prestamo = runtime.Types.DefaultSelection<capital_prestamoPayload>
export type capital_prestamo_empleadosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcapital: number
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }, ExtArgs["result"]["capital_prestamo_empleados"]>
  composites: {}
}

/**
 * Model capital_prestamo_empleados
 * 
 */
export type capital_prestamo_empleados = runtime.Types.DefaultSelection<capital_prestamo_empleadosPayload>
export type categoria_obsequioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcategoria: number
    categoria: string | null
    observacion: string | null
  }, ExtArgs["result"]["categoria_obsequio"]>
  composites: {}
}

/**
 * Model categoria_obsequio
 * 
 */
export type categoria_obsequio = runtime.Types.DefaultSelection<categoria_obsequioPayload>
export type contratosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcontrato: number
    locatario1: string | null
    dni1: number | null
    domicilio1: string | null
    locatario2: string | null
    dni2: number | null
    domicilio2: string | null
    monto: number | null
    fecha_inicio: Date | null
    duracion: number | null
    locador: number | null
    operador: string | null
    local: string | null
    uf: string | null
  }, ExtArgs["result"]["contratos"]>
  composites: {}
}

/**
 * Model contratos
 * 
 */
export type contratos = runtime.Types.DefaultSelection<contratosPayload>
export type convenio_deudaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idconvdeuda: number
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
    vencimiento1: Date | null
    importe1: number | null
    vencimiento2: Date | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
  }, ExtArgs["result"]["convenio_deuda"]>
  composites: {}
}

/**
 * Model convenio_deuda
 * 
 */
export type convenio_deuda = runtime.Types.DefaultSelection<convenio_deudaPayload>
export type datosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    iddato: number
    apellido: string | null
    nombre: string | null
    edad: number | null
    telefono: bigint | null
    celular: number | null
    cobertura: string | null
    grupo_familiar: string | null
    observacion: string | null
    operador: string | null
    domicilio: string | null
    fecha: Date | null
  }, ExtArgs["result"]["datos"]>
  composites: {}
}

/**
 * Model datos
 * 
 */
export type datos = runtime.Types.DefaultSelection<datosPayload>
export type datos_atencionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    iddatos: number
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    motivo: string | null
    operador: string | null
    operadoratencion: string | null
    fecha: Date | null
  }, ExtArgs["result"]["datos_atencion"]>
  composites: {}
}

/**
 * Model datos_atencion
 * 
 */
export type datos_atencion = runtime.Types.DefaultSelection<datos_atencionPayload>
export type detalle_orden_pagoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    iddetallepago: number
    norden: string | null
    nconsulta: string | null
    sucursal: string | null
    prestador: string | null
    importe: string | null
    operador_carga: string | null
    fecha: Date | null
  }, ExtArgs["result"]["detalle_orden_pago"]>
  composites: {}
}

/**
 * Model detalle_orden_pago
 * 
 */
export type detalle_orden_pago = runtime.Types.DefaultSelection<detalle_orden_pagoPayload>
export type empresasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idempresa: number
    empresa: string | null
    cuit: string | null
  }, ExtArgs["result"]["empresas"]>
  composites: {}
}

/**
 * Model empresas
 * 
 */
export type empresas = runtime.Types.DefaultSelection<empresasPayload>
export type eventosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idevents: number
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
  }, ExtArgs["result"]["eventos"]>
  composites: {}
}

/**
 * Model eventos
 * 
 */
export type eventos = runtime.Types.DefaultSelection<eventosPayload>
export type fabricante_ataudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idfabricante: number
    fabricante: string | null
  }, ExtArgs["result"]["fabricante_ataud"]>
  composites: {}
}

/**
 * Model fabricante_ataud
 * 
 */
export type fabricante_ataud = runtime.Types.DefaultSelection<fabricante_ataudPayload>
export type gestioncasoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgestion: number
    idcaso: number | null
    contrato: number | null
    operador: string | null
    accion: string | null
    observacion: string | null
    fechaaccion: string | null
    nuevaaccion: string | null
    fechanuevaaccion: string | null
    realizado: boolean | null
    observacion_nuevaaccion: string | null
  }, ExtArgs["result"]["gestioncaso"]>
  composites: {}
}

/**
 * Model gestioncaso
 * 
 */
export type gestioncaso = runtime.Types.DefaultSelection<gestioncasoPayload>
export type historial_accionesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhistorial: number
    operador: string | null
    fecha: Date | null
    accion: string | null
  }, ExtArgs["result"]["historial_acciones"]>
  composites: {}
}

/**
 * Model historial_acciones
 * 
 */
export type historial_acciones = runtime.Types.DefaultSelection<historial_accionesPayload>
export type historial_aprobacion_prestamosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idaprobacion: number
    operador: string | null
    idprestamo: number | null
    fecha: Date | null
    contrato: number | null
    afiliado: string | null
    productor: number | null
  }, ExtArgs["result"]["historial_aprobacion_prestamos"]>
  composites: {}
}

/**
 * Model historial_aprobacion_prestamos
 * 
 */
export type historial_aprobacion_prestamos = runtime.Types.DefaultSelection<historial_aprobacion_prestamosPayload>
export type historial_liquidacionesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idliquidacion: number
    operador: string | null
    fecha: string | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
    entidad: string | null
  }, ExtArgs["result"]["historial_liquidaciones"]>
  composites: {}
}

/**
 * Model historial_liquidaciones
 * 
 */
export type historial_liquidaciones = runtime.Types.DefaultSelection<historial_liquidacionesPayload>
export type intereses_tarjetasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idplan: number
    plan_cuota: number | null
    interes: number | null
    tarjeta: string | null
    fecha: Date | null
    estado: boolean | null
  }, ExtArgs["result"]["intereses_tarjetas"]>
  composites: {}
}

/**
 * Model intereses_tarjetas
 * 
 */
export type intereses_tarjetas = runtime.Types.DefaultSelection<intereses_tarjetasPayload>
export type legajo_virtualPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    tipoarchivo: string | null
  }, ExtArgs["result"]["legajo_virtual"]>
  composites: {}
}

/**
 * Model legajo_virtual
 * 
 */
export type legajo_virtual = runtime.Types.DefaultSelection<legajo_virtualPayload>
export type legajo_virtual_cajasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    idcaja: number | null
    archivo: string | null
    fecha_subida: Date | null
  }, ExtArgs["result"]["legajo_virtual_cajas"]>
  composites: {}
}

/**
 * Model legajo_virtual_cajas
 * 
 */
export type legajo_virtual_cajas = runtime.Types.DefaultSelection<legajo_virtual_cajasPayload>
export type legajo_virtual_ordenesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    idorden: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }, ExtArgs["result"]["legajo_virtual_ordenes"]>
  composites: {}
}

/**
 * Model legajo_virtual_ordenes
 * 
 */
export type legajo_virtual_ordenes = runtime.Types.DefaultSelection<legajo_virtual_ordenesPayload>
export type legajo_virtual_personalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    idpersonal: number | null
    archivo: string | null
    fecha_subida: Date | null
  }, ExtArgs["result"]["legajo_virtual_personal"]>
  composites: {}
}

/**
 * Model legajo_virtual_personal
 * 
 */
export type legajo_virtual_personal = runtime.Types.DefaultSelection<legajo_virtual_personalPayload>
export type legajo_virtual_prestamosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    cod_ptm_leg: string | null
  }, ExtArgs["result"]["legajo_virtual_prestamos"]>
  composites: {}
}

/**
 * Model legajo_virtual_prestamos
 * 
 */
export type legajo_virtual_prestamos = runtime.Types.DefaultSelection<legajo_virtual_prestamosPayload>
export type locadorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    dni: number
    apellido: string
    nombre: string
    domicilio: string
    barrio: string | null
    localidad: string
    provincia: string
  }, ExtArgs["result"]["locador"]>
  composites: {}
}

/**
 * Model locador
 * 
 */
export type locador = runtime.Types.DefaultSelection<locadorPayload>
export type mailsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idmail: number
    fecha: Date | null
    envia: string | null
    recibe: string | null
    descrip: string | null
    codmail: string | null
    asunto: string | null
    leido: boolean | null
    fecha_leido: Date | null
    url_caja: string | null
  }, ExtArgs["result"]["mails"]>
  composites: {}
}

/**
 * Model mails
 * 
 */
export type mails = runtime.Types.DefaultSelection<mailsPayload>
export type mails_adjuntosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idadjunto: number
    codmail: string | null
    adjunto: string | null
    tipo: string | null
  }, ExtArgs["result"]["mails_adjuntos"]>
  composites: {}
}

/**
 * Model mails_adjuntos
 * 
 */
export type mails_adjuntos = runtime.Types.DefaultSelection<mails_adjuntosPayload>
export type mbanconvPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id_mora: number
    tipo: string | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
  }, ExtArgs["result"]["mbanconv"]>
  composites: {}
}

/**
 * Model mbanconv
 * 
 */
export type mbanconv = runtime.Types.DefaultSelection<mbanconvPayload>
export type movimiento_caja_sucursalesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idmovimiento: number
    fecha_carga: Date | null
    fecha_movimiento: Date | null
    sucursal: string | null
    concepto: string | null
    movimiento: string | null
    importe: number | null
    operador_carga: string | null
    idcaja: number | null
    empresa: string | null
  }, ExtArgs["result"]["movimiento_caja_sucursales"]>
  composites: {}
}

/**
 * Model movimiento_caja_sucursales
 * 
 */
export type movimiento_caja_sucursales = runtime.Types.DefaultSelection<movimiento_caja_sucursalesPayload>
export type noticiaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnoticia: number
    fecha: Date | null
    noticia: string | null
    operador: string | null
    perfil: number | null
  }, ExtArgs["result"]["noticia"]>
  composites: {}
}

/**
 * Model noticia
 * 
 */
export type noticia = runtime.Types.DefaultSelection<noticiaPayload>
export type novedadesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovedades: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }, ExtArgs["result"]["novedades"]>
  composites: {}
}

/**
 * Model novedades
 * 
 */
export type novedades = runtime.Types.DefaultSelection<novedadesPayload>
export type obsequiosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idobsequio: number
    producto: string | null
    marca: string | null
    categoria: string | null
    precio: number | null
    stock: number | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    fecha_reposicion: string | null
    operador_rep: string | null
  }, ExtArgs["result"]["obsequios"]>
  composites: {}
}

/**
 * Model obsequios
 * 
 */
export type obsequios = runtime.Types.DefaultSelection<obsequiosPayload>
export type openia_keysPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idkey: number
    key: string | null
    fecha: Date | null
    estado: boolean | null
  }, ExtArgs["result"]["openia_keys"]>
  composites: {}
}

/**
 * Model openia_keys
 * 
 */
export type openia_keys = runtime.Types.DefaultSelection<openia_keysPayload>
export type operadorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    nombre: string
    apellido: string
    usuario: string
    contrasena: string
    createdAt: Date
    updatedAt: Date
    puestom: number | null
    perfil: number | null
    estado: boolean | null
    puestow: number | null
    codigo: number | null
    medicos: boolean | null
    sucursal: string | null
    prestamos: boolean | null
    ordenpago: boolean | null
    clubwerchow: boolean | null
    ventas: boolean | null
    administracion: boolean | null
    campanas: boolean | null
    socios: boolean | null
    sepelio: boolean | null
  }, ExtArgs["result"]["operador"]>
  composites: {}
}

/**
 * Model operador
 * 
 */
export type operador = runtime.Types.DefaultSelection<operadorPayload>
export type ordenes_pagoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idorden: number
    fecha: Date | null
    proveedor: string | null
    cuit_cuil: string | null
    total: number | null
    operador_carga: string | null
    autorizado: boolean | null
    operador_autorizacion: string | null
    fecha_autorizacion: Date | null
    norden: string | null
    observacion: string | null
    nombre: string | null
    tipo_orden: string | null
    nfactura: string | null
    tipo_factura: string | null
    fecha_pago: Date | null
    pagado: boolean | null
    estado: boolean | null
  }, ExtArgs["result"]["ordenes_pago"]>
  composites: {}
}

/**
 * Model ordenes_pago
 * 
 */
export type ordenes_pago = runtime.Types.DefaultSelection<ordenes_pagoPayload>
export type personalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idpersonal: number
    apellido: string | null
    nombre: string | null
    dni: number | null
    alta: Date | null
    rol: string | null
    legajo: string | null
    baja: Date | null
  }, ExtArgs["result"]["personal"]>
  composites: {}
}

/**
 * Model personal
 * 
 */
export type personal = runtime.Types.DefaultSelection<personalPayload>
export type plan_cuentasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcuenta: number
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }, ExtArgs["result"]["plan_cuentas"]>
  composites: {}
}

/**
 * Model plan_cuentas
 * 
 */
export type plan_cuentas = runtime.Types.DefaultSelection<plan_cuentasPayload>
export type plan_cuentas_xPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcuenta: number
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }, ExtArgs["result"]["plan_cuentas_x"]>
  composites: {}
}

/**
 * Model plan_cuentas_x
 * 
 */
export type plan_cuentas_x = runtime.Types.DefaultSelection<plan_cuentas_xPayload>
export type plan_detallePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id_plandetalle: number
    detalle: string | null
    cuota: number | null
    sub_ext: boolean | null
    vigencia: string | null
    id_plan: number | null
  }, ExtArgs["result"]["plan_detalle"]>
  composites: {}
}

/**
 * Model plan_detalle
 * 
 */
export type plan_detalle = runtime.Types.DefaultSelection<plan_detallePayload>
export type plan_precioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id_plan: number
    plan: string | null
    tipo_plan: string | null
    codigo: string | null
  }, ExtArgs["result"]["plan_precio"]>
  composites: {}
}

/**
 * Model plan_precio
 * 
 */
export type plan_precio = runtime.Types.DefaultSelection<plan_precioPayload>
export type porcentaje_liqPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    porcliq_id: number
    porcliq_nombre: string | null
    porcliq_descrip: string | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
  }, ExtArgs["result"]["porcentaje_liq"]>
  composites: {}
}

/**
 * Model porcentaje_liq
 * 
 */
export type porcentaje_liq = runtime.Types.DefaultSelection<porcentaje_liqPayload>
export type prestamos_empleadosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idprestamo: number
    empleado: string | null
    fecha_solicitud: Date | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
    inicia: string | null
    termina: string | null
    estado: string | null
    capinoaut: boolean | null
  }, ExtArgs["result"]["prestamos_empleados"]>
  composites: {}
}

/**
 * Model prestamos_empleados
 * 
 */
export type prestamos_empleados = runtime.Types.DefaultSelection<prestamos_empleadosPayload>
export type prestamos_empleados_cobroPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idpago: number
    idprestamo: number | null
    cuota: number | null
    importe: number | null
    fecha_cobro: Date | null
    estado: boolean | null
    fecha_pago: Date | null
    operador: string | null
  }, ExtArgs["result"]["prestamos_empleados_cobro"]>
  composites: {}
}

/**
 * Model prestamos_empleados_cobro
 * 
 */
export type prestamos_empleados_cobro = runtime.Types.DefaultSelection<prestamos_empleados_cobroPayload>
export type produccionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    prod_ide: number
    prod_fechacarga: Date | null
    prod_fechaafi: Date | null
    prod_asesor: number | null
    prod_empre: string | null
    prod_mes: string | null
    prod_anio: number | null
    prod_apeafi: string | null
    prod_nomafi: string | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_plan: string | null
    prod_pago: string | null
    prod_cta_tar: bigint | null
    prod_obs: string | null
    prod_semana: number | null
    prod_estado: string | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_rendido: string | null
    prod_recibosis: number | null
    prod_fechren: Date | null
    prod_tel: string | null
  }, ExtArgs["result"]["produccion"]>
  composites: {}
}

/**
 * Model produccion
 * 
 */
export type produccion = runtime.Types.DefaultSelection<produccionPayload>
export type registro_constancia_afiliacionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idconstancia: number
    apellido_extinto: string | null
    nombre_extinto: string | null
    dni_extinto: number | null
    apellido_soli: string | null
    nombre_soli: string | null
    dni_soli: string | null
    lugar_presentacion: string | null
    fecha: Date | null
    operador: string | null
    idservicio: number | null
  }, ExtArgs["result"]["registro_constancia_afiliacion"]>
  composites: {}
}

/**
 * Model registro_constancia_afiliacion
 * 
 */
export type registro_constancia_afiliacion = runtime.Types.DefaultSelection<registro_constancia_afiliacionPayload>
export type rehabilitacionesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idrehab: number
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
  }, ExtArgs["result"]["rehabilitaciones"]>
  composites: {}
}

/**
 * Model rehabilitaciones
 * 
 */
export type rehabilitaciones = runtime.Types.DefaultSelection<rehabilitacionesPayload>
export type rol_personalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idrol: number
    rol: string | null
  }, ExtArgs["result"]["rol_personal"]>
  composites: {}
}

/**
 * Model rol_personal
 * 
 */
export type rol_personal = runtime.Types.DefaultSelection<rol_personalPayload>
export type sucursalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idsucursal: number
    sucursal: string | null
    codigo: string | null
  }, ExtArgs["result"]["sucursal"]>
  composites: {}
}

/**
 * Model sucursal
 * 
 */
export type sucursal = runtime.Types.DefaultSelection<sucursalPayload>
export type sueldosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    sld_id: number
    sld_perfil: string | null
    sld_basico: number | null
    sld_basicoant: number | null
  }, ExtArgs["result"]["sueldos"]>
  composites: {}
}

/**
 * Model sueldos
 * 
 */
export type sueldos = runtime.Types.DefaultSelection<sueldosPayload>
export type tab_efPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    start: Date | null
    end: Date | null
    allDay: number | null
    holiday: number | null
    title: string | null
    user: string | null
    detail: string | null
  }, ExtArgs["result"]["tab_ef"]>
  composites: {}
}

/**
 * Model tab_ef
 * 
 */
export type tab_ef = runtime.Types.DefaultSelection<tab_efPayload>
export type tablero_efectividadPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idregistro: number
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    aumento: boolean | null
    por_aumento: number | null
    feriado: boolean | null
  }, ExtArgs["result"]["tablero_efectividad"]>
  composites: {}
}

/**
 * Model tablero_efectividad
 * 
 */
export type tablero_efectividad = runtime.Types.DefaultSelection<tablero_efectividadPayload>
export type tareas_sucursalesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idevents: number
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
    priority: number | null
    sucursal: string | null
    operador: string | null
    leido: boolean | null
  }, ExtArgs["result"]["tareas_sucursales"]>
  composites: {}
}

/**
 * Model tareas_sucursales
 * 
 */
export type tareas_sucursales = runtime.Types.DefaultSelection<tareas_sucursalesPayload>
export type tipo_contratosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtipocontrato: number
    tipo_contrato: string | null
    url: string | null
  }, ExtArgs["result"]["tipo_contratos"]>
  composites: {}
}

/**
 * Model tipo_contratos
 * 
 */
export type tipo_contratos = runtime.Types.DefaultSelection<tipo_contratosPayload>
export type tipo_facturasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idfactura: number
    tipo_factura: string | null
    fecha: Date | null
    estado: boolean | null
  }, ExtArgs["result"]["tipo_facturas"]>
  composites: {}
}

/**
 * Model tipo_facturas
 * 
 */
export type tipo_facturas = runtime.Types.DefaultSelection<tipo_facturasPayload>
export type turno_bajasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idturno: number
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    fecha_pedido: Date | null
    fecha_turno: Date | null
    motivo: string | null
    operador: string | null
    telefono: string | null
    movil: string | null
    fecha_atencion: Date | null
    estado: number | null
    empresa: string | null
    respuesta: string | null
    operador_atencion: string | null
    detalle: string | null
  }, ExtArgs["result"]["turno_bajas"]>
  composites: {}
}

/**
 * Model turno_bajas
 * 
 */
export type turno_bajas = runtime.Types.DefaultSelection<turno_bajasPayload>
export type vacacionesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    start: Date | null
    end: Date | null
    allDay: number | null
    priority: number | null
    title: string | null
    user: string | null
    detail: string | null
  }, ExtArgs["result"]["vacaciones"]>
  composites: {}
}

/**
 * Model vacaciones
 * 
 */
export type vacaciones = runtime.Types.DefaultSelection<vacacionesPayload>
export type motivos_atencionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idmotivo: number
    motivo: string | null
    estado: boolean | null
  }, ExtArgs["result"]["motivos_atencion"]>
  composites: {}
}

/**
 * Model motivos_atencion
 * 
 */
export type motivos_atencion = runtime.Types.DefaultSelection<motivos_atencionPayload>
export type prestamos_plan_cuotasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idplan: number
    plan_cuotas: number | null
    detalle: string | null
    estado: boolean | null
  }, ExtArgs["result"]["prestamos_plan_cuotas"]>
  composites: {}
}

/**
 * Model prestamos_plan_cuotas
 * 
 */
export type prestamos_plan_cuotas = runtime.Types.DefaultSelection<prestamos_plan_cuotasPayload>
export type prestamos_tasasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtasa: number
    tasa: number | null
    plan: string | null
    tipo: string | null
    estado: boolean | null
  }, ExtArgs["result"]["prestamos_tasas"]>
  composites: {}
}

/**
 * Model prestamos_tasas
 * 
 */
export type prestamos_tasas = runtime.Types.DefaultSelection<prestamos_tasasPayload>
export type certificado_estudiantesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcertificado: number
    contrato: number | null
    socio: string | null
    fecha: Date | null
    operador: string | null
    ncert: string | null
  }, ExtArgs["result"]["certificado_estudiantes"]>
  composites: {}
}

/**
 * Model certificado_estudiantes
 * 
 */
export type certificado_estudiantes = runtime.Types.DefaultSelection<certificado_estudiantesPayload>
export type carteraPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    contrato: number | null
    socio: string | null
    alta: Date | null
    grupo: number | null
    adhs: number | null
    plan: string | null
    sub_plan: string | null
    zona: number | null
    cuota: number | null
    empresa: string | null
    sucursal: string | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number
  }, ExtArgs["result"]["cartera"]>
  composites: {}
}

/**
 * Model cartera
 * 
 */
export type cartera = runtime.Types.DefaultSelection<carteraPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alta_novells
 * const alta_novells = await prisma.alta_novell.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alta_novells
   * const alta_novells = await prisma.alta_novell.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.alta_novell`: Exposes CRUD operations for the **alta_novell** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alta_novells
    * const alta_novells = await prisma.alta_novell.findMany()
    * ```
    */
  get alta_novell(): Prisma.alta_novellDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_sucursales`: Exposes CRUD operations for the **caja_sucursales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sucursales
    * const caja_sucursales = await prisma.caja_sucursales.findMany()
    * ```
    */
  get caja_sucursales(): Prisma.caja_sucursalesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.campanacasos`: Exposes CRUD operations for the **campanacasos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanacasos
    * const campanacasos = await prisma.campanacasos.findMany()
    * ```
    */
  get campanacasos(): Prisma.campanacasosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.campanas`: Exposes CRUD operations for the **campanas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanas
    * const campanas = await prisma.campanas.findMany()
    * ```
    */
  get campanas(): Prisma.campanasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.campanatemporal`: Exposes CRUD operations for the **campanatemporal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanatemporals
    * const campanatemporals = await prisma.campanatemporal.findMany()
    * ```
    */
  get campanatemporal(): Prisma.campanatemporalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.capital_prestamo`: Exposes CRUD operations for the **capital_prestamo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capital_prestamos
    * const capital_prestamos = await prisma.capital_prestamo.findMany()
    * ```
    */
  get capital_prestamo(): Prisma.capital_prestamoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.capital_prestamo_empleados`: Exposes CRUD operations for the **capital_prestamo_empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capital_prestamo_empleados
    * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findMany()
    * ```
    */
  get capital_prestamo_empleados(): Prisma.capital_prestamo_empleadosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.categoria_obsequio`: Exposes CRUD operations for the **categoria_obsequio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoria_obsequios
    * const categoria_obsequios = await prisma.categoria_obsequio.findMany()
    * ```
    */
  get categoria_obsequio(): Prisma.categoria_obsequioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.contratos`: Exposes CRUD operations for the **contratos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contratos
    * const contratos = await prisma.contratos.findMany()
    * ```
    */
  get contratos(): Prisma.contratosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.convenio_deuda`: Exposes CRUD operations for the **convenio_deuda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Convenio_deudas
    * const convenio_deudas = await prisma.convenio_deuda.findMany()
    * ```
    */
  get convenio_deuda(): Prisma.convenio_deudaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.datos`: Exposes CRUD operations for the **datos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datos
    * const datos = await prisma.datos.findMany()
    * ```
    */
  get datos(): Prisma.datosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.datos_atencion`: Exposes CRUD operations for the **datos_atencion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datos_atencions
    * const datos_atencions = await prisma.datos_atencion.findMany()
    * ```
    */
  get datos_atencion(): Prisma.datos_atencionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.detalle_orden_pago`: Exposes CRUD operations for the **detalle_orden_pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_orden_pagos
    * const detalle_orden_pagos = await prisma.detalle_orden_pago.findMany()
    * ```
    */
  get detalle_orden_pago(): Prisma.detalle_orden_pagoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.empresas`: Exposes CRUD operations for the **empresas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresas.findMany()
    * ```
    */
  get empresas(): Prisma.empresasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.eventos`: Exposes CRUD operations for the **eventos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.eventos.findMany()
    * ```
    */
  get eventos(): Prisma.eventosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fabricante_ataud`: Exposes CRUD operations for the **fabricante_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fabricante_atauds
    * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
    * ```
    */
  get fabricante_ataud(): Prisma.fabricante_ataudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gestioncaso`: Exposes CRUD operations for the **gestioncaso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gestioncasos
    * const gestioncasos = await prisma.gestioncaso.findMany()
    * ```
    */
  get gestioncaso(): Prisma.gestioncasoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_acciones`: Exposes CRUD operations for the **historial_acciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_acciones
    * const historial_acciones = await prisma.historial_acciones.findMany()
    * ```
    */
  get historial_acciones(): Prisma.historial_accionesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_aprobacion_prestamos`: Exposes CRUD operations for the **historial_aprobacion_prestamos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_aprobacion_prestamos
    * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findMany()
    * ```
    */
  get historial_aprobacion_prestamos(): Prisma.historial_aprobacion_prestamosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_liquidaciones`: Exposes CRUD operations for the **historial_liquidaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_liquidaciones
    * const historial_liquidaciones = await prisma.historial_liquidaciones.findMany()
    * ```
    */
  get historial_liquidaciones(): Prisma.historial_liquidacionesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.intereses_tarjetas`: Exposes CRUD operations for the **intereses_tarjetas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intereses_tarjetas
    * const intereses_tarjetas = await prisma.intereses_tarjetas.findMany()
    * ```
    */
  get intereses_tarjetas(): Prisma.intereses_tarjetasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual`: Exposes CRUD operations for the **legajo_virtual** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtuals
    * const legajo_virtuals = await prisma.legajo_virtual.findMany()
    * ```
    */
  get legajo_virtual(): Prisma.legajo_virtualDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_cajas`: Exposes CRUD operations for the **legajo_virtual_cajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_cajas
    * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findMany()
    * ```
    */
  get legajo_virtual_cajas(): Prisma.legajo_virtual_cajasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_ordenes`: Exposes CRUD operations for the **legajo_virtual_ordenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_ordenes
    * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findMany()
    * ```
    */
  get legajo_virtual_ordenes(): Prisma.legajo_virtual_ordenesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_personal`: Exposes CRUD operations for the **legajo_virtual_personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_personals
    * const legajo_virtual_personals = await prisma.legajo_virtual_personal.findMany()
    * ```
    */
  get legajo_virtual_personal(): Prisma.legajo_virtual_personalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_prestamos`: Exposes CRUD operations for the **legajo_virtual_prestamos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_prestamos
    * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findMany()
    * ```
    */
  get legajo_virtual_prestamos(): Prisma.legajo_virtual_prestamosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.locador`: Exposes CRUD operations for the **locador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locadors
    * const locadors = await prisma.locador.findMany()
    * ```
    */
  get locador(): Prisma.locadorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.mails`: Exposes CRUD operations for the **mails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mails
    * const mails = await prisma.mails.findMany()
    * ```
    */
  get mails(): Prisma.mailsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.mails_adjuntos`: Exposes CRUD operations for the **mails_adjuntos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mails_adjuntos
    * const mails_adjuntos = await prisma.mails_adjuntos.findMany()
    * ```
    */
  get mails_adjuntos(): Prisma.mails_adjuntosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.mbanconv`: Exposes CRUD operations for the **mbanconv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mbanconvs
    * const mbanconvs = await prisma.mbanconv.findMany()
    * ```
    */
  get mbanconv(): Prisma.mbanconvDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.movimiento_caja_sucursales`: Exposes CRUD operations for the **movimiento_caja_sucursales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movimiento_caja_sucursales
    * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findMany()
    * ```
    */
  get movimiento_caja_sucursales(): Prisma.movimiento_caja_sucursalesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.noticia`: Exposes CRUD operations for the **noticia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Noticias
    * const noticias = await prisma.noticia.findMany()
    * ```
    */
  get noticia(): Prisma.noticiaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.novedades`: Exposes CRUD operations for the **novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Novedades
    * const novedades = await prisma.novedades.findMany()
    * ```
    */
  get novedades(): Prisma.novedadesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.obsequios`: Exposes CRUD operations for the **obsequios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obsequios
    * const obsequios = await prisma.obsequios.findMany()
    * ```
    */
  get obsequios(): Prisma.obsequiosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.openia_keys`: Exposes CRUD operations for the **openia_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Openia_keys
    * const openia_keys = await prisma.openia_keys.findMany()
    * ```
    */
  get openia_keys(): Prisma.openia_keysDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.operador`: Exposes CRUD operations for the **operador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operadors
    * const operadors = await prisma.operador.findMany()
    * ```
    */
  get operador(): Prisma.operadorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ordenes_pago`: Exposes CRUD operations for the **ordenes_pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ordenes_pagos
    * const ordenes_pagos = await prisma.ordenes_pago.findMany()
    * ```
    */
  get ordenes_pago(): Prisma.ordenes_pagoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.personal`: Exposes CRUD operations for the **personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personals
    * const personals = await prisma.personal.findMany()
    * ```
    */
  get personal(): Prisma.personalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.plan_cuentas`: Exposes CRUD operations for the **plan_cuentas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_cuentas
    * const plan_cuentas = await prisma.plan_cuentas.findMany()
    * ```
    */
  get plan_cuentas(): Prisma.plan_cuentasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.plan_cuentas_x`: Exposes CRUD operations for the **plan_cuentas_x** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_cuentas_xes
    * const plan_cuentas_xes = await prisma.plan_cuentas_x.findMany()
    * ```
    */
  get plan_cuentas_x(): Prisma.plan_cuentas_xDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.plan_detalle`: Exposes CRUD operations for the **plan_detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_detalles
    * const plan_detalles = await prisma.plan_detalle.findMany()
    * ```
    */
  get plan_detalle(): Prisma.plan_detalleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.plan_precio`: Exposes CRUD operations for the **plan_precio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_precios
    * const plan_precios = await prisma.plan_precio.findMany()
    * ```
    */
  get plan_precio(): Prisma.plan_precioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.porcentaje_liq`: Exposes CRUD operations for the **porcentaje_liq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Porcentaje_liqs
    * const porcentaje_liqs = await prisma.porcentaje_liq.findMany()
    * ```
    */
  get porcentaje_liq(): Prisma.porcentaje_liqDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.prestamos_empleados`: Exposes CRUD operations for the **prestamos_empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestamos_empleados
    * const prestamos_empleados = await prisma.prestamos_empleados.findMany()
    * ```
    */
  get prestamos_empleados(): Prisma.prestamos_empleadosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.prestamos_empleados_cobro`: Exposes CRUD operations for the **prestamos_empleados_cobro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestamos_empleados_cobros
    * const prestamos_empleados_cobros = await prisma.prestamos_empleados_cobro.findMany()
    * ```
    */
  get prestamos_empleados_cobro(): Prisma.prestamos_empleados_cobroDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.produccion`: Exposes CRUD operations for the **produccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produccions
    * const produccions = await prisma.produccion.findMany()
    * ```
    */
  get produccion(): Prisma.produccionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.registro_constancia_afiliacion`: Exposes CRUD operations for the **registro_constancia_afiliacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Registro_constancia_afiliacions
    * const registro_constancia_afiliacions = await prisma.registro_constancia_afiliacion.findMany()
    * ```
    */
  get registro_constancia_afiliacion(): Prisma.registro_constancia_afiliacionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rehabilitaciones`: Exposes CRUD operations for the **rehabilitaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rehabilitaciones
    * const rehabilitaciones = await prisma.rehabilitaciones.findMany()
    * ```
    */
  get rehabilitaciones(): Prisma.rehabilitacionesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rol_personal`: Exposes CRUD operations for the **rol_personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rol_personals
    * const rol_personals = await prisma.rol_personal.findMany()
    * ```
    */
  get rol_personal(): Prisma.rol_personalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.sucursal`: Exposes CRUD operations for the **sucursal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sucursals
    * const sucursals = await prisma.sucursal.findMany()
    * ```
    */
  get sucursal(): Prisma.sucursalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.sueldos`: Exposes CRUD operations for the **sueldos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sueldos
    * const sueldos = await prisma.sueldos.findMany()
    * ```
    */
  get sueldos(): Prisma.sueldosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tab_ef`: Exposes CRUD operations for the **tab_ef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tab_efs
    * const tab_efs = await prisma.tab_ef.findMany()
    * ```
    */
  get tab_ef(): Prisma.tab_efDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tablero_efectividad`: Exposes CRUD operations for the **tablero_efectividad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tablero_efectividads
    * const tablero_efectividads = await prisma.tablero_efectividad.findMany()
    * ```
    */
  get tablero_efectividad(): Prisma.tablero_efectividadDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tareas_sucursales`: Exposes CRUD operations for the **tareas_sucursales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas_sucursales
    * const tareas_sucursales = await prisma.tareas_sucursales.findMany()
    * ```
    */
  get tareas_sucursales(): Prisma.tareas_sucursalesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tipo_contratos`: Exposes CRUD operations for the **tipo_contratos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_contratos
    * const tipo_contratos = await prisma.tipo_contratos.findMany()
    * ```
    */
  get tipo_contratos(): Prisma.tipo_contratosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tipo_facturas`: Exposes CRUD operations for the **tipo_facturas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_facturas
    * const tipo_facturas = await prisma.tipo_facturas.findMany()
    * ```
    */
  get tipo_facturas(): Prisma.tipo_facturasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.turno_bajas`: Exposes CRUD operations for the **turno_bajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turno_bajas
    * const turno_bajas = await prisma.turno_bajas.findMany()
    * ```
    */
  get turno_bajas(): Prisma.turno_bajasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.vacaciones`: Exposes CRUD operations for the **vacaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vacaciones
    * const vacaciones = await prisma.vacaciones.findMany()
    * ```
    */
  get vacaciones(): Prisma.vacacionesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.motivos_atencion`: Exposes CRUD operations for the **motivos_atencion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motivos_atencions
    * const motivos_atencions = await prisma.motivos_atencion.findMany()
    * ```
    */
  get motivos_atencion(): Prisma.motivos_atencionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.prestamos_plan_cuotas`: Exposes CRUD operations for the **prestamos_plan_cuotas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestamos_plan_cuotas
    * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findMany()
    * ```
    */
  get prestamos_plan_cuotas(): Prisma.prestamos_plan_cuotasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.prestamos_tasas`: Exposes CRUD operations for the **prestamos_tasas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestamos_tasas
    * const prestamos_tasas = await prisma.prestamos_tasas.findMany()
    * ```
    */
  get prestamos_tasas(): Prisma.prestamos_tasasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.certificado_estudiantes`: Exposes CRUD operations for the **certificado_estudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificado_estudiantes
    * const certificado_estudiantes = await prisma.certificado_estudiantes.findMany()
    * ```
    */
  get certificado_estudiantes(): Prisma.certificado_estudiantesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.cartera`: Exposes CRUD operations for the **cartera** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteras
    * const carteras = await prisma.cartera.findMany()
    * ```
    */
  get cartera(): Prisma.carteraDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.17.0-dev.38
   * Query Engine version: e6267db1c1bc827b8eb87f644288c3cb0800ec89
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    alta_novell: 'alta_novell',
    caja_sucursales: 'caja_sucursales',
    campanacasos: 'campanacasos',
    campanas: 'campanas',
    campanatemporal: 'campanatemporal',
    capital_prestamo: 'capital_prestamo',
    capital_prestamo_empleados: 'capital_prestamo_empleados',
    categoria_obsequio: 'categoria_obsequio',
    contratos: 'contratos',
    convenio_deuda: 'convenio_deuda',
    datos: 'datos',
    datos_atencion: 'datos_atencion',
    detalle_orden_pago: 'detalle_orden_pago',
    empresas: 'empresas',
    eventos: 'eventos',
    fabricante_ataud: 'fabricante_ataud',
    gestioncaso: 'gestioncaso',
    historial_acciones: 'historial_acciones',
    historial_aprobacion_prestamos: 'historial_aprobacion_prestamos',
    historial_liquidaciones: 'historial_liquidaciones',
    intereses_tarjetas: 'intereses_tarjetas',
    legajo_virtual: 'legajo_virtual',
    legajo_virtual_cajas: 'legajo_virtual_cajas',
    legajo_virtual_ordenes: 'legajo_virtual_ordenes',
    legajo_virtual_personal: 'legajo_virtual_personal',
    legajo_virtual_prestamos: 'legajo_virtual_prestamos',
    locador: 'locador',
    mails: 'mails',
    mails_adjuntos: 'mails_adjuntos',
    mbanconv: 'mbanconv',
    movimiento_caja_sucursales: 'movimiento_caja_sucursales',
    noticia: 'noticia',
    novedades: 'novedades',
    obsequios: 'obsequios',
    openia_keys: 'openia_keys',
    operador: 'operador',
    ordenes_pago: 'ordenes_pago',
    personal: 'personal',
    plan_cuentas: 'plan_cuentas',
    plan_cuentas_x: 'plan_cuentas_x',
    plan_detalle: 'plan_detalle',
    plan_precio: 'plan_precio',
    porcentaje_liq: 'porcentaje_liq',
    prestamos_empleados: 'prestamos_empleados',
    prestamos_empleados_cobro: 'prestamos_empleados_cobro',
    produccion: 'produccion',
    registro_constancia_afiliacion: 'registro_constancia_afiliacion',
    rehabilitaciones: 'rehabilitaciones',
    rol_personal: 'rol_personal',
    sucursal: 'sucursal',
    sueldos: 'sueldos',
    tab_ef: 'tab_ef',
    tablero_efectividad: 'tablero_efectividad',
    tareas_sucursales: 'tareas_sucursales',
    tipo_contratos: 'tipo_contratos',
    tipo_facturas: 'tipo_facturas',
    turno_bajas: 'turno_bajas',
    vacaciones: 'vacaciones',
    motivos_atencion: 'motivos_atencion',
    prestamos_plan_cuotas: 'prestamos_plan_cuotas',
    prestamos_tasas: 'prestamos_tasas',
    certificado_estudiantes: 'certificado_estudiantes',
    cartera: 'cartera'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'alta_novell' | 'caja_sucursales' | 'campanacasos' | 'campanas' | 'campanatemporal' | 'capital_prestamo' | 'capital_prestamo_empleados' | 'categoria_obsequio' | 'contratos' | 'convenio_deuda' | 'datos' | 'datos_atencion' | 'detalle_orden_pago' | 'empresas' | 'eventos' | 'fabricante_ataud' | 'gestioncaso' | 'historial_acciones' | 'historial_aprobacion_prestamos' | 'historial_liquidaciones' | 'intereses_tarjetas' | 'legajo_virtual' | 'legajo_virtual_cajas' | 'legajo_virtual_ordenes' | 'legajo_virtual_personal' | 'legajo_virtual_prestamos' | 'locador' | 'mails' | 'mails_adjuntos' | 'mbanconv' | 'movimiento_caja_sucursales' | 'noticia' | 'novedades' | 'obsequios' | 'openia_keys' | 'operador' | 'ordenes_pago' | 'personal' | 'plan_cuentas' | 'plan_cuentas_x' | 'plan_detalle' | 'plan_precio' | 'porcentaje_liq' | 'prestamos_empleados' | 'prestamos_empleados_cobro' | 'produccion' | 'registro_constancia_afiliacion' | 'rehabilitaciones' | 'rol_personal' | 'sucursal' | 'sueldos' | 'tab_ef' | 'tablero_efectividad' | 'tareas_sucursales' | 'tipo_contratos' | 'tipo_facturas' | 'turno_bajas' | 'vacaciones' | 'motivos_atencion' | 'prestamos_plan_cuotas' | 'prestamos_tasas' | 'certificado_estudiantes' | 'cartera'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      alta_novell: {
        operations: {
          findUnique: {
            args: Prisma.alta_novellFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload> | null
            payload: alta_novellPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.alta_novellFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.alta_novellFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload> | null
            payload: alta_novellPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.alta_novellFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.alta_novellFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>[]
            payload: alta_novellPayload<ExtArgs>
          }
          create: {
            args: Prisma.alta_novellCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.alta_novellCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: alta_novellPayload<ExtArgs>
          }
          delete: {
            args: Prisma.alta_novellDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          update: {
            args: Prisma.alta_novellUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.alta_novellDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: alta_novellPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.alta_novellUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: alta_novellPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.alta_novellUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<alta_novellPayload>
            payload: alta_novellPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Alta_novellAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlta_novell>
            payload: alta_novellPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.alta_novellGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Alta_novellGroupByOutputType>[]
            payload: alta_novellPayload<ExtArgs>
          }
          count: {
            args: Prisma.alta_novellCountArgs<ExtArgs>,
            result: $Utils.Optional<Alta_novellCountAggregateOutputType> | number
            payload: alta_novellPayload<ExtArgs>
          }
        }
      }
      caja_sucursales: {
        operations: {
          findUnique: {
            args: Prisma.caja_sucursalesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload> | null
            payload: caja_sucursalesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_sucursalesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload> | null
            payload: caja_sucursalesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_sucursalesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_sucursalesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>[]
            payload: caja_sucursalesPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_sucursalesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_sucursalesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sucursalesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_sucursalesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_sucursalesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_sucursalesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sucursalesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_sucursalesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sucursalesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_sucursalesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sucursalesPayload>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_sucursalesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_sucursales>
            payload: caja_sucursalesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_sucursalesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sucursalesGroupByOutputType>[]
            payload: caja_sucursalesPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_sucursalesCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sucursalesCountAggregateOutputType> | number
            payload: caja_sucursalesPayload<ExtArgs>
          }
        }
      }
      campanacasos: {
        operations: {
          findUnique: {
            args: Prisma.campanacasosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload> | null
            payload: campanacasosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.campanacasosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.campanacasosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload> | null
            payload: campanacasosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.campanacasosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.campanacasosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>[]
            payload: campanacasosPayload<ExtArgs>
          }
          create: {
            args: Prisma.campanacasosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.campanacasosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanacasosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.campanacasosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          update: {
            args: Prisma.campanacasosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.campanacasosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanacasosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.campanacasosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanacasosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.campanacasosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanacasosPayload>
            payload: campanacasosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CampanacasosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampanacasos>
            payload: campanacasosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.campanacasosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampanacasosGroupByOutputType>[]
            payload: campanacasosPayload<ExtArgs>
          }
          count: {
            args: Prisma.campanacasosCountArgs<ExtArgs>,
            result: $Utils.Optional<CampanacasosCountAggregateOutputType> | number
            payload: campanacasosPayload<ExtArgs>
          }
        }
      }
      campanas: {
        operations: {
          findUnique: {
            args: Prisma.campanasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload> | null
            payload: campanasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.campanasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.campanasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload> | null
            payload: campanasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.campanasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.campanasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>[]
            payload: campanasPayload<ExtArgs>
          }
          create: {
            args: Prisma.campanasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.campanasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.campanasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          update: {
            args: Prisma.campanasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.campanasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.campanasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.campanasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanasPayload>
            payload: campanasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CampanasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampanas>
            payload: campanasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.campanasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampanasGroupByOutputType>[]
            payload: campanasPayload<ExtArgs>
          }
          count: {
            args: Prisma.campanasCountArgs<ExtArgs>,
            result: $Utils.Optional<CampanasCountAggregateOutputType> | number
            payload: campanasPayload<ExtArgs>
          }
        }
      }
      campanatemporal: {
        operations: {
          findUnique: {
            args: Prisma.campanatemporalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload> | null
            payload: campanatemporalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.campanatemporalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.campanatemporalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload> | null
            payload: campanatemporalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.campanatemporalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.campanatemporalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>[]
            payload: campanatemporalPayload<ExtArgs>
          }
          create: {
            args: Prisma.campanatemporalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.campanatemporalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanatemporalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.campanatemporalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          update: {
            args: Prisma.campanatemporalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.campanatemporalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanatemporalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.campanatemporalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: campanatemporalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.campanatemporalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<campanatemporalPayload>
            payload: campanatemporalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CampanatemporalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampanatemporal>
            payload: campanatemporalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.campanatemporalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampanatemporalGroupByOutputType>[]
            payload: campanatemporalPayload<ExtArgs>
          }
          count: {
            args: Prisma.campanatemporalCountArgs<ExtArgs>,
            result: $Utils.Optional<CampanatemporalCountAggregateOutputType> | number
            payload: campanatemporalPayload<ExtArgs>
          }
        }
      }
      capital_prestamo: {
        operations: {
          findUnique: {
            args: Prisma.capital_prestamoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload> | null
            payload: capital_prestamoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.capital_prestamoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.capital_prestamoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload> | null
            payload: capital_prestamoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.capital_prestamoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.capital_prestamoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>[]
            payload: capital_prestamoPayload<ExtArgs>
          }
          create: {
            args: Prisma.capital_prestamoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.capital_prestamoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.capital_prestamoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          update: {
            args: Prisma.capital_prestamoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.capital_prestamoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.capital_prestamoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.capital_prestamoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamoPayload>
            payload: capital_prestamoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Capital_prestamoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCapital_prestamo>
            payload: capital_prestamoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.capital_prestamoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Capital_prestamoGroupByOutputType>[]
            payload: capital_prestamoPayload<ExtArgs>
          }
          count: {
            args: Prisma.capital_prestamoCountArgs<ExtArgs>,
            result: $Utils.Optional<Capital_prestamoCountAggregateOutputType> | number
            payload: capital_prestamoPayload<ExtArgs>
          }
        }
      }
      capital_prestamo_empleados: {
        operations: {
          findUnique: {
            args: Prisma.capital_prestamo_empleadosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload> | null
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.capital_prestamo_empleadosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.capital_prestamo_empleadosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload> | null
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.capital_prestamo_empleadosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.capital_prestamo_empleadosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>[]
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          create: {
            args: Prisma.capital_prestamo_empleadosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.capital_prestamo_empleadosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.capital_prestamo_empleadosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          update: {
            args: Prisma.capital_prestamo_empleadosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.capital_prestamo_empleadosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.capital_prestamo_empleadosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.capital_prestamo_empleadosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<capital_prestamo_empleadosPayload>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Capital_prestamo_empleadosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCapital_prestamo_empleados>
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.capital_prestamo_empleadosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Capital_prestamo_empleadosGroupByOutputType>[]
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
          count: {
            args: Prisma.capital_prestamo_empleadosCountArgs<ExtArgs>,
            result: $Utils.Optional<Capital_prestamo_empleadosCountAggregateOutputType> | number
            payload: capital_prestamo_empleadosPayload<ExtArgs>
          }
        }
      }
      categoria_obsequio: {
        operations: {
          findUnique: {
            args: Prisma.categoria_obsequioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload> | null
            payload: categoria_obsequioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.categoria_obsequioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.categoria_obsequioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload> | null
            payload: categoria_obsequioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.categoria_obsequioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.categoria_obsequioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>[]
            payload: categoria_obsequioPayload<ExtArgs>
          }
          create: {
            args: Prisma.categoria_obsequioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.categoria_obsequioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoria_obsequioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.categoria_obsequioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          update: {
            args: Prisma.categoria_obsequioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.categoria_obsequioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoria_obsequioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.categoria_obsequioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoria_obsequioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.categoria_obsequioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoria_obsequioPayload>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Categoria_obsequioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoria_obsequio>
            payload: categoria_obsequioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.categoria_obsequioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Categoria_obsequioGroupByOutputType>[]
            payload: categoria_obsequioPayload<ExtArgs>
          }
          count: {
            args: Prisma.categoria_obsequioCountArgs<ExtArgs>,
            result: $Utils.Optional<Categoria_obsequioCountAggregateOutputType> | number
            payload: categoria_obsequioPayload<ExtArgs>
          }
        }
      }
      contratos: {
        operations: {
          findUnique: {
            args: Prisma.contratosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload> | null
            payload: contratosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.contratosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.contratosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload> | null
            payload: contratosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.contratosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.contratosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>[]
            payload: contratosPayload<ExtArgs>
          }
          create: {
            args: Prisma.contratosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.contratosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: contratosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.contratosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          update: {
            args: Prisma.contratosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.contratosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: contratosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.contratosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: contratosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.contratosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contratosPayload>
            payload: contratosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ContratosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContratos>
            payload: contratosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.contratosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContratosGroupByOutputType>[]
            payload: contratosPayload<ExtArgs>
          }
          count: {
            args: Prisma.contratosCountArgs<ExtArgs>,
            result: $Utils.Optional<ContratosCountAggregateOutputType> | number
            payload: contratosPayload<ExtArgs>
          }
        }
      }
      convenio_deuda: {
        operations: {
          findUnique: {
            args: Prisma.convenio_deudaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload> | null
            payload: convenio_deudaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.convenio_deudaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.convenio_deudaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload> | null
            payload: convenio_deudaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.convenio_deudaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.convenio_deudaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>[]
            payload: convenio_deudaPayload<ExtArgs>
          }
          create: {
            args: Prisma.convenio_deudaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.convenio_deudaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: convenio_deudaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.convenio_deudaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          update: {
            args: Prisma.convenio_deudaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.convenio_deudaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: convenio_deudaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.convenio_deudaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: convenio_deudaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.convenio_deudaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<convenio_deudaPayload>
            payload: convenio_deudaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Convenio_deudaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConvenio_deuda>
            payload: convenio_deudaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.convenio_deudaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Convenio_deudaGroupByOutputType>[]
            payload: convenio_deudaPayload<ExtArgs>
          }
          count: {
            args: Prisma.convenio_deudaCountArgs<ExtArgs>,
            result: $Utils.Optional<Convenio_deudaCountAggregateOutputType> | number
            payload: convenio_deudaPayload<ExtArgs>
          }
        }
      }
      datos: {
        operations: {
          findUnique: {
            args: Prisma.datosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload> | null
            payload: datosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.datosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.datosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload> | null
            payload: datosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.datosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.datosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>[]
            payload: datosPayload<ExtArgs>
          }
          create: {
            args: Prisma.datosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.datosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.datosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          update: {
            args: Prisma.datosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.datosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.datosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.datosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datosPayload>
            payload: datosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.DatosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDatos>
            payload: datosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.datosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DatosGroupByOutputType>[]
            payload: datosPayload<ExtArgs>
          }
          count: {
            args: Prisma.datosCountArgs<ExtArgs>,
            result: $Utils.Optional<DatosCountAggregateOutputType> | number
            payload: datosPayload<ExtArgs>
          }
        }
      }
      datos_atencion: {
        operations: {
          findUnique: {
            args: Prisma.datos_atencionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload> | null
            payload: datos_atencionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.datos_atencionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.datos_atencionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload> | null
            payload: datos_atencionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.datos_atencionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.datos_atencionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>[]
            payload: datos_atencionPayload<ExtArgs>
          }
          create: {
            args: Prisma.datos_atencionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.datos_atencionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datos_atencionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.datos_atencionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          update: {
            args: Prisma.datos_atencionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.datos_atencionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datos_atencionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.datos_atencionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: datos_atencionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.datos_atencionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<datos_atencionPayload>
            payload: datos_atencionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Datos_atencionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDatos_atencion>
            payload: datos_atencionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.datos_atencionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Datos_atencionGroupByOutputType>[]
            payload: datos_atencionPayload<ExtArgs>
          }
          count: {
            args: Prisma.datos_atencionCountArgs<ExtArgs>,
            result: $Utils.Optional<Datos_atencionCountAggregateOutputType> | number
            payload: datos_atencionPayload<ExtArgs>
          }
        }
      }
      detalle_orden_pago: {
        operations: {
          findUnique: {
            args: Prisma.detalle_orden_pagoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload> | null
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_orden_pagoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.detalle_orden_pagoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload> | null
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.detalle_orden_pagoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.detalle_orden_pagoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>[]
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          create: {
            args: Prisma.detalle_orden_pagoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.detalle_orden_pagoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.detalle_orden_pagoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          update: {
            args: Prisma.detalle_orden_pagoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.detalle_orden_pagoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.detalle_orden_pagoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.detalle_orden_pagoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<detalle_orden_pagoPayload>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Detalle_orden_pagoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetalle_orden_pago>
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.detalle_orden_pagoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detalle_orden_pagoGroupByOutputType>[]
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
          count: {
            args: Prisma.detalle_orden_pagoCountArgs<ExtArgs>,
            result: $Utils.Optional<Detalle_orden_pagoCountAggregateOutputType> | number
            payload: detalle_orden_pagoPayload<ExtArgs>
          }
        }
      }
      empresas: {
        operations: {
          findUnique: {
            args: Prisma.empresasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload> | null
            payload: empresasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.empresasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.empresasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload> | null
            payload: empresasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.empresasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.empresasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>[]
            payload: empresasPayload<ExtArgs>
          }
          create: {
            args: Prisma.empresasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.empresasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: empresasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.empresasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          update: {
            args: Prisma.empresasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.empresasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: empresasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.empresasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: empresasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.empresasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<empresasPayload>
            payload: empresasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.EmpresasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmpresas>
            payload: empresasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.empresasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmpresasGroupByOutputType>[]
            payload: empresasPayload<ExtArgs>
          }
          count: {
            args: Prisma.empresasCountArgs<ExtArgs>,
            result: $Utils.Optional<EmpresasCountAggregateOutputType> | number
            payload: empresasPayload<ExtArgs>
          }
        }
      }
      eventos: {
        operations: {
          findUnique: {
            args: Prisma.eventosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload> | null
            payload: eventosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.eventosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.eventosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload> | null
            payload: eventosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.eventosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.eventosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>[]
            payload: eventosPayload<ExtArgs>
          }
          create: {
            args: Prisma.eventosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.eventosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: eventosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.eventosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          update: {
            args: Prisma.eventosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.eventosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: eventosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.eventosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: eventosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.eventosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<eventosPayload>
            payload: eventosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.EventosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventos>
            payload: eventosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.eventosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventosGroupByOutputType>[]
            payload: eventosPayload<ExtArgs>
          }
          count: {
            args: Prisma.eventosCountArgs<ExtArgs>,
            result: $Utils.Optional<EventosCountAggregateOutputType> | number
            payload: eventosPayload<ExtArgs>
          }
        }
      }
      fabricante_ataud: {
        operations: {
          findUnique: {
            args: Prisma.fabricante_ataudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.fabricante_ataudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.fabricante_ataudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.fabricante_ataudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          create: {
            args: Prisma.fabricante_ataudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.fabricante_ataudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          delete: {
            args: Prisma.fabricante_ataudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          update: {
            args: Prisma.fabricante_ataudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.fabricante_ataudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.fabricante_ataudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.fabricante_ataudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Fabricante_ataudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFabricante_ataud>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.fabricante_ataudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudGroupByOutputType>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          count: {
            args: Prisma.fabricante_ataudCountArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudCountAggregateOutputType> | number
            payload: fabricante_ataudPayload<ExtArgs>
          }
        }
      }
      gestioncaso: {
        operations: {
          findUnique: {
            args: Prisma.gestioncasoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload> | null
            payload: gestioncasoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gestioncasoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gestioncasoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload> | null
            payload: gestioncasoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gestioncasoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gestioncasoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>[]
            payload: gestioncasoPayload<ExtArgs>
          }
          create: {
            args: Prisma.gestioncasoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gestioncasoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gestioncasoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gestioncasoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          update: {
            args: Prisma.gestioncasoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gestioncasoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gestioncasoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gestioncasoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gestioncasoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gestioncasoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gestioncasoPayload>
            payload: gestioncasoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.GestioncasoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGestioncaso>
            payload: gestioncasoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gestioncasoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GestioncasoGroupByOutputType>[]
            payload: gestioncasoPayload<ExtArgs>
          }
          count: {
            args: Prisma.gestioncasoCountArgs<ExtArgs>,
            result: $Utils.Optional<GestioncasoCountAggregateOutputType> | number
            payload: gestioncasoPayload<ExtArgs>
          }
        }
      }
      historial_acciones: {
        operations: {
          findUnique: {
            args: Prisma.historial_accionesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload> | null
            payload: historial_accionesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_accionesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_accionesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload> | null
            payload: historial_accionesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_accionesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_accionesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>[]
            payload: historial_accionesPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_accionesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_accionesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_accionesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_accionesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_accionesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_accionesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_accionesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_accionesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_accionesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_accionesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_accionesPayload>
            payload: historial_accionesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_accionesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_acciones>
            payload: historial_accionesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_accionesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_accionesGroupByOutputType>[]
            payload: historial_accionesPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_accionesCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_accionesCountAggregateOutputType> | number
            payload: historial_accionesPayload<ExtArgs>
          }
        }
      }
      historial_aprobacion_prestamos: {
        operations: {
          findUnique: {
            args: Prisma.historial_aprobacion_prestamosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload> | null
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_aprobacion_prestamosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_aprobacion_prestamosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload> | null
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_aprobacion_prestamosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_aprobacion_prestamosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>[]
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_aprobacion_prestamosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_aprobacion_prestamosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_aprobacion_prestamosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_aprobacion_prestamosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_aprobacion_prestamosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_aprobacion_prestamosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_aprobacion_prestamosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_aprobacion_prestamosPayload>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_aprobacion_prestamosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_aprobacion_prestamos>
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_aprobacion_prestamosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_aprobacion_prestamosGroupByOutputType>[]
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_aprobacion_prestamosCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_aprobacion_prestamosCountAggregateOutputType> | number
            payload: historial_aprobacion_prestamosPayload<ExtArgs>
          }
        }
      }
      historial_liquidaciones: {
        operations: {
          findUnique: {
            args: Prisma.historial_liquidacionesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload> | null
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_liquidacionesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_liquidacionesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload> | null
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_liquidacionesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_liquidacionesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>[]
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_liquidacionesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_liquidacionesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_liquidacionesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_liquidacionesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_liquidacionesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_liquidacionesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_liquidacionesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_liquidacionesPayload>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_liquidacionesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_liquidaciones>
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_liquidacionesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_liquidacionesGroupByOutputType>[]
            payload: historial_liquidacionesPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_liquidacionesCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_liquidacionesCountAggregateOutputType> | number
            payload: historial_liquidacionesPayload<ExtArgs>
          }
        }
      }
      intereses_tarjetas: {
        operations: {
          findUnique: {
            args: Prisma.intereses_tarjetasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload> | null
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.intereses_tarjetasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.intereses_tarjetasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload> | null
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.intereses_tarjetasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.intereses_tarjetasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>[]
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          create: {
            args: Prisma.intereses_tarjetasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.intereses_tarjetasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.intereses_tarjetasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          update: {
            args: Prisma.intereses_tarjetasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.intereses_tarjetasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.intereses_tarjetasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.intereses_tarjetasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<intereses_tarjetasPayload>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Intereses_tarjetasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIntereses_tarjetas>
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.intereses_tarjetasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Intereses_tarjetasGroupByOutputType>[]
            payload: intereses_tarjetasPayload<ExtArgs>
          }
          count: {
            args: Prisma.intereses_tarjetasCountArgs<ExtArgs>,
            result: $Utils.Optional<Intereses_tarjetasCountAggregateOutputType> | number
            payload: intereses_tarjetasPayload<ExtArgs>
          }
        }
      }
      legajo_virtual: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtualFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload> | null
            payload: legajo_virtualPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtualFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtualFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload> | null
            payload: legajo_virtualPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtualFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtualFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>[]
            payload: legajo_virtualPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtualCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtualCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtualPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtualDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtualUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtualDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtualPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtualUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtualPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtualUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtualPayload>
            payload: legajo_virtualPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtualAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual>
            payload: legajo_virtualPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtualGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtualGroupByOutputType>[]
            payload: legajo_virtualPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtualCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtualCountAggregateOutputType> | number
            payload: legajo_virtualPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_cajas: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_cajasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload> | null
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_cajasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_cajasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload> | null
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_cajasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_cajasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>[]
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_cajasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_cajasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_cajasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_cajasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_cajasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_cajasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_cajasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_cajasPayload>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_cajasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_cajas>
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_cajasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_cajasGroupByOutputType>[]
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_cajasCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_cajasCountAggregateOutputType> | number
            payload: legajo_virtual_cajasPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_ordenes: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_ordenesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload> | null
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_ordenesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_ordenesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload> | null
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_ordenesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_ordenesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>[]
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_ordenesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_ordenesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_ordenesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_ordenesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_ordenesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_ordenesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_ordenesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_ordenesPayload>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_ordenesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_ordenes>
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_ordenesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_ordenesGroupByOutputType>[]
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_ordenesCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_ordenesCountAggregateOutputType> | number
            payload: legajo_virtual_ordenesPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_personal: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_personalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload> | null
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_personalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_personalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload> | null
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_personalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_personalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>[]
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_personalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_personalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_personalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_personalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_personalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_personalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_personalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_personalPayload>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_personalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_personal>
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_personalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_personalGroupByOutputType>[]
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_personalCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_personalCountAggregateOutputType> | number
            payload: legajo_virtual_personalPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_prestamos: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_prestamosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload> | null
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_prestamosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_prestamosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload> | null
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_prestamosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_prestamosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>[]
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_prestamosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_prestamosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_prestamosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_prestamosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_prestamosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_prestamosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_prestamosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_prestamosPayload>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_prestamosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_prestamos>
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_prestamosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_prestamosGroupByOutputType>[]
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_prestamosCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_prestamosCountAggregateOutputType> | number
            payload: legajo_virtual_prestamosPayload<ExtArgs>
          }
        }
      }
      locador: {
        operations: {
          findUnique: {
            args: Prisma.locadorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload> | null
            payload: locadorPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.locadorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.locadorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload> | null
            payload: locadorPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.locadorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.locadorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>[]
            payload: locadorPayload<ExtArgs>
          }
          create: {
            args: Prisma.locadorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.locadorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: locadorPayload<ExtArgs>
          }
          delete: {
            args: Prisma.locadorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          update: {
            args: Prisma.locadorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.locadorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: locadorPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.locadorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: locadorPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.locadorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<locadorPayload>
            payload: locadorPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.LocadorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLocador>
            payload: locadorPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.locadorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LocadorGroupByOutputType>[]
            payload: locadorPayload<ExtArgs>
          }
          count: {
            args: Prisma.locadorCountArgs<ExtArgs>,
            result: $Utils.Optional<LocadorCountAggregateOutputType> | number
            payload: locadorPayload<ExtArgs>
          }
        }
      }
      mails: {
        operations: {
          findUnique: {
            args: Prisma.mailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload> | null
            payload: mailsPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.mailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.mailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload> | null
            payload: mailsPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.mailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.mailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>[]
            payload: mailsPayload<ExtArgs>
          }
          create: {
            args: Prisma.mailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.mailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mailsPayload<ExtArgs>
          }
          delete: {
            args: Prisma.mailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          update: {
            args: Prisma.mailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.mailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mailsPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.mailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mailsPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.mailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mailsPayload>
            payload: mailsPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.MailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMails>
            payload: mailsPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.mailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MailsGroupByOutputType>[]
            payload: mailsPayload<ExtArgs>
          }
          count: {
            args: Prisma.mailsCountArgs<ExtArgs>,
            result: $Utils.Optional<MailsCountAggregateOutputType> | number
            payload: mailsPayload<ExtArgs>
          }
        }
      }
      mails_adjuntos: {
        operations: {
          findUnique: {
            args: Prisma.mails_adjuntosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload> | null
            payload: mails_adjuntosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.mails_adjuntosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.mails_adjuntosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload> | null
            payload: mails_adjuntosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.mails_adjuntosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.mails_adjuntosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>[]
            payload: mails_adjuntosPayload<ExtArgs>
          }
          create: {
            args: Prisma.mails_adjuntosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.mails_adjuntosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mails_adjuntosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.mails_adjuntosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          update: {
            args: Prisma.mails_adjuntosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.mails_adjuntosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mails_adjuntosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.mails_adjuntosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mails_adjuntosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.mails_adjuntosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mails_adjuntosPayload>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Mails_adjuntosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMails_adjuntos>
            payload: mails_adjuntosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.mails_adjuntosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Mails_adjuntosGroupByOutputType>[]
            payload: mails_adjuntosPayload<ExtArgs>
          }
          count: {
            args: Prisma.mails_adjuntosCountArgs<ExtArgs>,
            result: $Utils.Optional<Mails_adjuntosCountAggregateOutputType> | number
            payload: mails_adjuntosPayload<ExtArgs>
          }
        }
      }
      mbanconv: {
        operations: {
          findUnique: {
            args: Prisma.mbanconvFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload> | null
            payload: mbanconvPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.mbanconvFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.mbanconvFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload> | null
            payload: mbanconvPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.mbanconvFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.mbanconvFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>[]
            payload: mbanconvPayload<ExtArgs>
          }
          create: {
            args: Prisma.mbanconvCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.mbanconvCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mbanconvPayload<ExtArgs>
          }
          delete: {
            args: Prisma.mbanconvDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          update: {
            args: Prisma.mbanconvUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.mbanconvDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mbanconvPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.mbanconvUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mbanconvPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.mbanconvUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mbanconvPayload>
            payload: mbanconvPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.MbanconvAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMbanconv>
            payload: mbanconvPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.mbanconvGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MbanconvGroupByOutputType>[]
            payload: mbanconvPayload<ExtArgs>
          }
          count: {
            args: Prisma.mbanconvCountArgs<ExtArgs>,
            result: $Utils.Optional<MbanconvCountAggregateOutputType> | number
            payload: mbanconvPayload<ExtArgs>
          }
        }
      }
      movimiento_caja_sucursales: {
        operations: {
          findUnique: {
            args: Prisma.movimiento_caja_sucursalesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload> | null
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.movimiento_caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.movimiento_caja_sucursalesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload> | null
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.movimiento_caja_sucursalesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.movimiento_caja_sucursalesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>[]
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          create: {
            args: Prisma.movimiento_caja_sucursalesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.movimiento_caja_sucursalesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.movimiento_caja_sucursalesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          update: {
            args: Prisma.movimiento_caja_sucursalesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.movimiento_caja_sucursalesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.movimiento_caja_sucursalesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.movimiento_caja_sucursalesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<movimiento_caja_sucursalesPayload>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Movimiento_caja_sucursalesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMovimiento_caja_sucursales>
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.movimiento_caja_sucursalesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Movimiento_caja_sucursalesGroupByOutputType>[]
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
          count: {
            args: Prisma.movimiento_caja_sucursalesCountArgs<ExtArgs>,
            result: $Utils.Optional<Movimiento_caja_sucursalesCountAggregateOutputType> | number
            payload: movimiento_caja_sucursalesPayload<ExtArgs>
          }
        }
      }
      noticia: {
        operations: {
          findUnique: {
            args: Prisma.noticiaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload> | null
            payload: noticiaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.noticiaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.noticiaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload> | null
            payload: noticiaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.noticiaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.noticiaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>[]
            payload: noticiaPayload<ExtArgs>
          }
          create: {
            args: Prisma.noticiaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.noticiaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: noticiaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.noticiaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          update: {
            args: Prisma.noticiaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.noticiaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: noticiaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.noticiaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: noticiaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.noticiaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<noticiaPayload>
            payload: noticiaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NoticiaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNoticia>
            payload: noticiaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.noticiaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NoticiaGroupByOutputType>[]
            payload: noticiaPayload<ExtArgs>
          }
          count: {
            args: Prisma.noticiaCountArgs<ExtArgs>,
            result: $Utils.Optional<NoticiaCountAggregateOutputType> | number
            payload: noticiaPayload<ExtArgs>
          }
        }
      }
      novedades: {
        operations: {
          findUnique: {
            args: Prisma.novedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.novedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.novedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.novedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.novedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>[]
            payload: novedadesPayload<ExtArgs>
          }
          create: {
            args: Prisma.novedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.novedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.novedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          update: {
            args: Prisma.novedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.novedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.novedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.novedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NovedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNovedades>
            payload: novedadesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.novedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesGroupByOutputType>[]
            payload: novedadesPayload<ExtArgs>
          }
          count: {
            args: Prisma.novedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesCountAggregateOutputType> | number
            payload: novedadesPayload<ExtArgs>
          }
        }
      }
      obsequios: {
        operations: {
          findUnique: {
            args: Prisma.obsequiosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload> | null
            payload: obsequiosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.obsequiosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.obsequiosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload> | null
            payload: obsequiosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.obsequiosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.obsequiosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>[]
            payload: obsequiosPayload<ExtArgs>
          }
          create: {
            args: Prisma.obsequiosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.obsequiosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: obsequiosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.obsequiosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          update: {
            args: Prisma.obsequiosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.obsequiosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: obsequiosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.obsequiosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: obsequiosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.obsequiosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<obsequiosPayload>
            payload: obsequiosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ObsequiosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObsequios>
            payload: obsequiosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.obsequiosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObsequiosGroupByOutputType>[]
            payload: obsequiosPayload<ExtArgs>
          }
          count: {
            args: Prisma.obsequiosCountArgs<ExtArgs>,
            result: $Utils.Optional<ObsequiosCountAggregateOutputType> | number
            payload: obsequiosPayload<ExtArgs>
          }
        }
      }
      openia_keys: {
        operations: {
          findUnique: {
            args: Prisma.openia_keysFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload> | null
            payload: openia_keysPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.openia_keysFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.openia_keysFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload> | null
            payload: openia_keysPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.openia_keysFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.openia_keysFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>[]
            payload: openia_keysPayload<ExtArgs>
          }
          create: {
            args: Prisma.openia_keysCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.openia_keysCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: openia_keysPayload<ExtArgs>
          }
          delete: {
            args: Prisma.openia_keysDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          update: {
            args: Prisma.openia_keysUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.openia_keysDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: openia_keysPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.openia_keysUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: openia_keysPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.openia_keysUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<openia_keysPayload>
            payload: openia_keysPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Openia_keysAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOpenia_keys>
            payload: openia_keysPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.openia_keysGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Openia_keysGroupByOutputType>[]
            payload: openia_keysPayload<ExtArgs>
          }
          count: {
            args: Prisma.openia_keysCountArgs<ExtArgs>,
            result: $Utils.Optional<Openia_keysCountAggregateOutputType> | number
            payload: openia_keysPayload<ExtArgs>
          }
        }
      }
      operador: {
        operations: {
          findUnique: {
            args: Prisma.operadorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload> | null
            payload: operadorPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.operadorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.operadorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload> | null
            payload: operadorPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.operadorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.operadorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>[]
            payload: operadorPayload<ExtArgs>
          }
          create: {
            args: Prisma.operadorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.operadorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorPayload<ExtArgs>
          }
          delete: {
            args: Prisma.operadorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          update: {
            args: Prisma.operadorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.operadorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.operadorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.operadorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorPayload>
            payload: operadorPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.OperadorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperador>
            payload: operadorPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.operadorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperadorGroupByOutputType>[]
            payload: operadorPayload<ExtArgs>
          }
          count: {
            args: Prisma.operadorCountArgs<ExtArgs>,
            result: $Utils.Optional<OperadorCountAggregateOutputType> | number
            payload: operadorPayload<ExtArgs>
          }
        }
      }
      ordenes_pago: {
        operations: {
          findUnique: {
            args: Prisma.ordenes_pagoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload> | null
            payload: ordenes_pagoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ordenes_pagoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ordenes_pagoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload> | null
            payload: ordenes_pagoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ordenes_pagoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ordenes_pagoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>[]
            payload: ordenes_pagoPayload<ExtArgs>
          }
          create: {
            args: Prisma.ordenes_pagoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ordenes_pagoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ordenes_pagoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ordenes_pagoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          update: {
            args: Prisma.ordenes_pagoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ordenes_pagoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ordenes_pagoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ordenes_pagoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ordenes_pagoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ordenes_pagoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ordenes_pagoPayload>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ordenes_pagoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrdenes_pago>
            payload: ordenes_pagoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ordenes_pagoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ordenes_pagoGroupByOutputType>[]
            payload: ordenes_pagoPayload<ExtArgs>
          }
          count: {
            args: Prisma.ordenes_pagoCountArgs<ExtArgs>,
            result: $Utils.Optional<Ordenes_pagoCountAggregateOutputType> | number
            payload: ordenes_pagoPayload<ExtArgs>
          }
        }
      }
      personal: {
        operations: {
          findUnique: {
            args: Prisma.personalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload> | null
            payload: personalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.personalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.personalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload> | null
            payload: personalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.personalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.personalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>[]
            payload: personalPayload<ExtArgs>
          }
          create: {
            args: Prisma.personalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.personalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: personalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.personalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          update: {
            args: Prisma.personalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.personalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: personalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.personalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: personalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.personalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<personalPayload>
            payload: personalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.PersonalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersonal>
            payload: personalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.personalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonalGroupByOutputType>[]
            payload: personalPayload<ExtArgs>
          }
          count: {
            args: Prisma.personalCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonalCountAggregateOutputType> | number
            payload: personalPayload<ExtArgs>
          }
        }
      }
      plan_cuentas: {
        operations: {
          findUnique: {
            args: Prisma.plan_cuentasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload> | null
            payload: plan_cuentasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.plan_cuentasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.plan_cuentasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload> | null
            payload: plan_cuentasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.plan_cuentasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.plan_cuentasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>[]
            payload: plan_cuentasPayload<ExtArgs>
          }
          create: {
            args: Prisma.plan_cuentasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.plan_cuentasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.plan_cuentasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          update: {
            args: Prisma.plan_cuentasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.plan_cuentasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.plan_cuentasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.plan_cuentasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentasPayload>
            payload: plan_cuentasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Plan_cuentasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan_cuentas>
            payload: plan_cuentasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.plan_cuentasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Plan_cuentasGroupByOutputType>[]
            payload: plan_cuentasPayload<ExtArgs>
          }
          count: {
            args: Prisma.plan_cuentasCountArgs<ExtArgs>,
            result: $Utils.Optional<Plan_cuentasCountAggregateOutputType> | number
            payload: plan_cuentasPayload<ExtArgs>
          }
        }
      }
      plan_cuentas_x: {
        operations: {
          findUnique: {
            args: Prisma.plan_cuentas_xFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload> | null
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.plan_cuentas_xFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.plan_cuentas_xFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload> | null
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.plan_cuentas_xFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.plan_cuentas_xFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>[]
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          create: {
            args: Prisma.plan_cuentas_xCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.plan_cuentas_xCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          delete: {
            args: Prisma.plan_cuentas_xDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          update: {
            args: Prisma.plan_cuentas_xUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.plan_cuentas_xDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.plan_cuentas_xUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.plan_cuentas_xUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_cuentas_xPayload>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Plan_cuentas_xAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan_cuentas_x>
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.plan_cuentas_xGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Plan_cuentas_xGroupByOutputType>[]
            payload: plan_cuentas_xPayload<ExtArgs>
          }
          count: {
            args: Prisma.plan_cuentas_xCountArgs<ExtArgs>,
            result: $Utils.Optional<Plan_cuentas_xCountAggregateOutputType> | number
            payload: plan_cuentas_xPayload<ExtArgs>
          }
        }
      }
      plan_detalle: {
        operations: {
          findUnique: {
            args: Prisma.plan_detalleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload> | null
            payload: plan_detallePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.plan_detalleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.plan_detalleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload> | null
            payload: plan_detallePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.plan_detalleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.plan_detalleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>[]
            payload: plan_detallePayload<ExtArgs>
          }
          create: {
            args: Prisma.plan_detalleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.plan_detalleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_detallePayload<ExtArgs>
          }
          delete: {
            args: Prisma.plan_detalleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          update: {
            args: Prisma.plan_detalleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.plan_detalleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_detallePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.plan_detalleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_detallePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.plan_detalleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_detallePayload>
            payload: plan_detallePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Plan_detalleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan_detalle>
            payload: plan_detallePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.plan_detalleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Plan_detalleGroupByOutputType>[]
            payload: plan_detallePayload<ExtArgs>
          }
          count: {
            args: Prisma.plan_detalleCountArgs<ExtArgs>,
            result: $Utils.Optional<Plan_detalleCountAggregateOutputType> | number
            payload: plan_detallePayload<ExtArgs>
          }
        }
      }
      plan_precio: {
        operations: {
          findUnique: {
            args: Prisma.plan_precioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload> | null
            payload: plan_precioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.plan_precioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.plan_precioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload> | null
            payload: plan_precioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.plan_precioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.plan_precioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>[]
            payload: plan_precioPayload<ExtArgs>
          }
          create: {
            args: Prisma.plan_precioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.plan_precioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_precioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.plan_precioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          update: {
            args: Prisma.plan_precioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.plan_precioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_precioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.plan_precioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: plan_precioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.plan_precioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<plan_precioPayload>
            payload: plan_precioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Plan_precioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan_precio>
            payload: plan_precioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.plan_precioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Plan_precioGroupByOutputType>[]
            payload: plan_precioPayload<ExtArgs>
          }
          count: {
            args: Prisma.plan_precioCountArgs<ExtArgs>,
            result: $Utils.Optional<Plan_precioCountAggregateOutputType> | number
            payload: plan_precioPayload<ExtArgs>
          }
        }
      }
      porcentaje_liq: {
        operations: {
          findUnique: {
            args: Prisma.porcentaje_liqFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload> | null
            payload: porcentaje_liqPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.porcentaje_liqFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.porcentaje_liqFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload> | null
            payload: porcentaje_liqPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.porcentaje_liqFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.porcentaje_liqFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>[]
            payload: porcentaje_liqPayload<ExtArgs>
          }
          create: {
            args: Prisma.porcentaje_liqCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.porcentaje_liqCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: porcentaje_liqPayload<ExtArgs>
          }
          delete: {
            args: Prisma.porcentaje_liqDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          update: {
            args: Prisma.porcentaje_liqUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.porcentaje_liqDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: porcentaje_liqPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.porcentaje_liqUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: porcentaje_liqPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.porcentaje_liqUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<porcentaje_liqPayload>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Porcentaje_liqAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePorcentaje_liq>
            payload: porcentaje_liqPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.porcentaje_liqGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Porcentaje_liqGroupByOutputType>[]
            payload: porcentaje_liqPayload<ExtArgs>
          }
          count: {
            args: Prisma.porcentaje_liqCountArgs<ExtArgs>,
            result: $Utils.Optional<Porcentaje_liqCountAggregateOutputType> | number
            payload: porcentaje_liqPayload<ExtArgs>
          }
        }
      }
      prestamos_empleados: {
        operations: {
          findUnique: {
            args: Prisma.prestamos_empleadosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload> | null
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.prestamos_empleadosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.prestamos_empleadosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload> | null
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.prestamos_empleadosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.prestamos_empleadosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>[]
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          create: {
            args: Prisma.prestamos_empleadosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.prestamos_empleadosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.prestamos_empleadosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          update: {
            args: Prisma.prestamos_empleadosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.prestamos_empleadosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.prestamos_empleadosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.prestamos_empleadosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleadosPayload>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Prestamos_empleadosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrestamos_empleados>
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.prestamos_empleadosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_empleadosGroupByOutputType>[]
            payload: prestamos_empleadosPayload<ExtArgs>
          }
          count: {
            args: Prisma.prestamos_empleadosCountArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_empleadosCountAggregateOutputType> | number
            payload: prestamos_empleadosPayload<ExtArgs>
          }
        }
      }
      prestamos_empleados_cobro: {
        operations: {
          findUnique: {
            args: Prisma.prestamos_empleados_cobroFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload> | null
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.prestamos_empleados_cobroFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.prestamos_empleados_cobroFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload> | null
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.prestamos_empleados_cobroFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.prestamos_empleados_cobroFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>[]
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          create: {
            args: Prisma.prestamos_empleados_cobroCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.prestamos_empleados_cobroCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          delete: {
            args: Prisma.prestamos_empleados_cobroDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          update: {
            args: Prisma.prestamos_empleados_cobroUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.prestamos_empleados_cobroDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.prestamos_empleados_cobroUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.prestamos_empleados_cobroUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_empleados_cobroPayload>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Prestamos_empleados_cobroAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrestamos_empleados_cobro>
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.prestamos_empleados_cobroGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_empleados_cobroGroupByOutputType>[]
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
          count: {
            args: Prisma.prestamos_empleados_cobroCountArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_empleados_cobroCountAggregateOutputType> | number
            payload: prestamos_empleados_cobroPayload<ExtArgs>
          }
        }
      }
      produccion: {
        operations: {
          findUnique: {
            args: Prisma.produccionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload> | null
            payload: produccionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.produccionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.produccionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload> | null
            payload: produccionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.produccionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.produccionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>[]
            payload: produccionPayload<ExtArgs>
          }
          create: {
            args: Prisma.produccionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.produccionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: produccionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.produccionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          update: {
            args: Prisma.produccionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.produccionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: produccionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.produccionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: produccionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.produccionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<produccionPayload>
            payload: produccionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ProduccionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduccion>
            payload: produccionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.produccionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProduccionGroupByOutputType>[]
            payload: produccionPayload<ExtArgs>
          }
          count: {
            args: Prisma.produccionCountArgs<ExtArgs>,
            result: $Utils.Optional<ProduccionCountAggregateOutputType> | number
            payload: produccionPayload<ExtArgs>
          }
        }
      }
      registro_constancia_afiliacion: {
        operations: {
          findUnique: {
            args: Prisma.registro_constancia_afiliacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload> | null
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.registro_constancia_afiliacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.registro_constancia_afiliacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload> | null
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.registro_constancia_afiliacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.registro_constancia_afiliacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>[]
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          create: {
            args: Prisma.registro_constancia_afiliacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.registro_constancia_afiliacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.registro_constancia_afiliacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          update: {
            args: Prisma.registro_constancia_afiliacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.registro_constancia_afiliacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.registro_constancia_afiliacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.registro_constancia_afiliacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<registro_constancia_afiliacionPayload>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Registro_constancia_afiliacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegistro_constancia_afiliacion>
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.registro_constancia_afiliacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Registro_constancia_afiliacionGroupByOutputType>[]
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
          count: {
            args: Prisma.registro_constancia_afiliacionCountArgs<ExtArgs>,
            result: $Utils.Optional<Registro_constancia_afiliacionCountAggregateOutputType> | number
            payload: registro_constancia_afiliacionPayload<ExtArgs>
          }
        }
      }
      rehabilitaciones: {
        operations: {
          findUnique: {
            args: Prisma.rehabilitacionesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload> | null
            payload: rehabilitacionesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.rehabilitacionesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.rehabilitacionesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload> | null
            payload: rehabilitacionesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.rehabilitacionesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.rehabilitacionesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>[]
            payload: rehabilitacionesPayload<ExtArgs>
          }
          create: {
            args: Prisma.rehabilitacionesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.rehabilitacionesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rehabilitacionesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.rehabilitacionesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          update: {
            args: Prisma.rehabilitacionesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.rehabilitacionesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rehabilitacionesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.rehabilitacionesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rehabilitacionesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.rehabilitacionesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rehabilitacionesPayload>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.RehabilitacionesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRehabilitaciones>
            payload: rehabilitacionesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.rehabilitacionesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RehabilitacionesGroupByOutputType>[]
            payload: rehabilitacionesPayload<ExtArgs>
          }
          count: {
            args: Prisma.rehabilitacionesCountArgs<ExtArgs>,
            result: $Utils.Optional<RehabilitacionesCountAggregateOutputType> | number
            payload: rehabilitacionesPayload<ExtArgs>
          }
        }
      }
      rol_personal: {
        operations: {
          findUnique: {
            args: Prisma.rol_personalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload> | null
            payload: rol_personalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.rol_personalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.rol_personalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload> | null
            payload: rol_personalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.rol_personalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.rol_personalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>[]
            payload: rol_personalPayload<ExtArgs>
          }
          create: {
            args: Prisma.rol_personalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.rol_personalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rol_personalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.rol_personalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          update: {
            args: Prisma.rol_personalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.rol_personalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rol_personalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.rol_personalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rol_personalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.rol_personalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rol_personalPayload>
            payload: rol_personalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Rol_personalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRol_personal>
            payload: rol_personalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.rol_personalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Rol_personalGroupByOutputType>[]
            payload: rol_personalPayload<ExtArgs>
          }
          count: {
            args: Prisma.rol_personalCountArgs<ExtArgs>,
            result: $Utils.Optional<Rol_personalCountAggregateOutputType> | number
            payload: rol_personalPayload<ExtArgs>
          }
        }
      }
      sucursal: {
        operations: {
          findUnique: {
            args: Prisma.sucursalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload> | null
            payload: sucursalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.sucursalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.sucursalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload> | null
            payload: sucursalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.sucursalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.sucursalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>[]
            payload: sucursalPayload<ExtArgs>
          }
          create: {
            args: Prisma.sucursalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.sucursalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sucursalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.sucursalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          update: {
            args: Prisma.sucursalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.sucursalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sucursalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.sucursalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sucursalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.sucursalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sucursalPayload>
            payload: sucursalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SucursalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSucursal>
            payload: sucursalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.sucursalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SucursalGroupByOutputType>[]
            payload: sucursalPayload<ExtArgs>
          }
          count: {
            args: Prisma.sucursalCountArgs<ExtArgs>,
            result: $Utils.Optional<SucursalCountAggregateOutputType> | number
            payload: sucursalPayload<ExtArgs>
          }
        }
      }
      sueldos: {
        operations: {
          findUnique: {
            args: Prisma.sueldosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload> | null
            payload: sueldosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.sueldosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.sueldosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload> | null
            payload: sueldosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.sueldosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.sueldosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>[]
            payload: sueldosPayload<ExtArgs>
          }
          create: {
            args: Prisma.sueldosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.sueldosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sueldosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.sueldosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          update: {
            args: Prisma.sueldosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.sueldosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sueldosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.sueldosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sueldosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.sueldosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sueldosPayload>
            payload: sueldosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SueldosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSueldos>
            payload: sueldosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.sueldosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SueldosGroupByOutputType>[]
            payload: sueldosPayload<ExtArgs>
          }
          count: {
            args: Prisma.sueldosCountArgs<ExtArgs>,
            result: $Utils.Optional<SueldosCountAggregateOutputType> | number
            payload: sueldosPayload<ExtArgs>
          }
        }
      }
      tab_ef: {
        operations: {
          findUnique: {
            args: Prisma.tab_efFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload> | null
            payload: tab_efPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tab_efFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tab_efFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload> | null
            payload: tab_efPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tab_efFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tab_efFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>[]
            payload: tab_efPayload<ExtArgs>
          }
          create: {
            args: Prisma.tab_efCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tab_efCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tab_efPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tab_efDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          update: {
            args: Prisma.tab_efUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tab_efDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tab_efPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tab_efUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tab_efPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tab_efUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tab_efPayload>
            payload: tab_efPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tab_efAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTab_ef>
            payload: tab_efPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tab_efGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tab_efGroupByOutputType>[]
            payload: tab_efPayload<ExtArgs>
          }
          count: {
            args: Prisma.tab_efCountArgs<ExtArgs>,
            result: $Utils.Optional<Tab_efCountAggregateOutputType> | number
            payload: tab_efPayload<ExtArgs>
          }
        }
      }
      tablero_efectividad: {
        operations: {
          findUnique: {
            args: Prisma.tablero_efectividadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload> | null
            payload: tablero_efectividadPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tablero_efectividadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tablero_efectividadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload> | null
            payload: tablero_efectividadPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tablero_efectividadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tablero_efectividadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>[]
            payload: tablero_efectividadPayload<ExtArgs>
          }
          create: {
            args: Prisma.tablero_efectividadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tablero_efectividadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tablero_efectividadPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tablero_efectividadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          update: {
            args: Prisma.tablero_efectividadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tablero_efectividadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tablero_efectividadPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tablero_efectividadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tablero_efectividadPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tablero_efectividadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tablero_efectividadPayload>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tablero_efectividadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTablero_efectividad>
            payload: tablero_efectividadPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tablero_efectividadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tablero_efectividadGroupByOutputType>[]
            payload: tablero_efectividadPayload<ExtArgs>
          }
          count: {
            args: Prisma.tablero_efectividadCountArgs<ExtArgs>,
            result: $Utils.Optional<Tablero_efectividadCountAggregateOutputType> | number
            payload: tablero_efectividadPayload<ExtArgs>
          }
        }
      }
      tareas_sucursales: {
        operations: {
          findUnique: {
            args: Prisma.tareas_sucursalesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload> | null
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tareas_sucursalesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tareas_sucursalesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload> | null
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tareas_sucursalesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tareas_sucursalesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>[]
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          create: {
            args: Prisma.tareas_sucursalesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tareas_sucursalesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tareas_sucursalesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          update: {
            args: Prisma.tareas_sucursalesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tareas_sucursalesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tareas_sucursalesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tareas_sucursalesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_sucursalesPayload>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tareas_sucursalesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTareas_sucursales>
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tareas_sucursalesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tareas_sucursalesGroupByOutputType>[]
            payload: tareas_sucursalesPayload<ExtArgs>
          }
          count: {
            args: Prisma.tareas_sucursalesCountArgs<ExtArgs>,
            result: $Utils.Optional<Tareas_sucursalesCountAggregateOutputType> | number
            payload: tareas_sucursalesPayload<ExtArgs>
          }
        }
      }
      tipo_contratos: {
        operations: {
          findUnique: {
            args: Prisma.tipo_contratosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload> | null
            payload: tipo_contratosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tipo_contratosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tipo_contratosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload> | null
            payload: tipo_contratosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tipo_contratosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tipo_contratosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>[]
            payload: tipo_contratosPayload<ExtArgs>
          }
          create: {
            args: Prisma.tipo_contratosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tipo_contratosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_contratosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tipo_contratosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          update: {
            args: Prisma.tipo_contratosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tipo_contratosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_contratosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tipo_contratosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_contratosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tipo_contratosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_contratosPayload>
            payload: tipo_contratosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tipo_contratosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipo_contratos>
            payload: tipo_contratosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tipo_contratosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_contratosGroupByOutputType>[]
            payload: tipo_contratosPayload<ExtArgs>
          }
          count: {
            args: Prisma.tipo_contratosCountArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_contratosCountAggregateOutputType> | number
            payload: tipo_contratosPayload<ExtArgs>
          }
        }
      }
      tipo_facturas: {
        operations: {
          findUnique: {
            args: Prisma.tipo_facturasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload> | null
            payload: tipo_facturasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tipo_facturasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tipo_facturasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload> | null
            payload: tipo_facturasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tipo_facturasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tipo_facturasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>[]
            payload: tipo_facturasPayload<ExtArgs>
          }
          create: {
            args: Prisma.tipo_facturasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tipo_facturasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_facturasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tipo_facturasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          update: {
            args: Prisma.tipo_facturasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tipo_facturasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_facturasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tipo_facturasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_facturasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tipo_facturasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_facturasPayload>
            payload: tipo_facturasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tipo_facturasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipo_facturas>
            payload: tipo_facturasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tipo_facturasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_facturasGroupByOutputType>[]
            payload: tipo_facturasPayload<ExtArgs>
          }
          count: {
            args: Prisma.tipo_facturasCountArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_facturasCountAggregateOutputType> | number
            payload: tipo_facturasPayload<ExtArgs>
          }
        }
      }
      turno_bajas: {
        operations: {
          findUnique: {
            args: Prisma.turno_bajasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload> | null
            payload: turno_bajasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.turno_bajasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.turno_bajasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload> | null
            payload: turno_bajasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.turno_bajasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.turno_bajasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>[]
            payload: turno_bajasPayload<ExtArgs>
          }
          create: {
            args: Prisma.turno_bajasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.turno_bajasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: turno_bajasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.turno_bajasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          update: {
            args: Prisma.turno_bajasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.turno_bajasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: turno_bajasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.turno_bajasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: turno_bajasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.turno_bajasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<turno_bajasPayload>
            payload: turno_bajasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Turno_bajasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTurno_bajas>
            payload: turno_bajasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.turno_bajasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Turno_bajasGroupByOutputType>[]
            payload: turno_bajasPayload<ExtArgs>
          }
          count: {
            args: Prisma.turno_bajasCountArgs<ExtArgs>,
            result: $Utils.Optional<Turno_bajasCountAggregateOutputType> | number
            payload: turno_bajasPayload<ExtArgs>
          }
        }
      }
      vacaciones: {
        operations: {
          findUnique: {
            args: Prisma.vacacionesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload> | null
            payload: vacacionesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.vacacionesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.vacacionesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload> | null
            payload: vacacionesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.vacacionesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.vacacionesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>[]
            payload: vacacionesPayload<ExtArgs>
          }
          create: {
            args: Prisma.vacacionesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.vacacionesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: vacacionesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.vacacionesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          update: {
            args: Prisma.vacacionesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.vacacionesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: vacacionesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.vacacionesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: vacacionesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.vacacionesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<vacacionesPayload>
            payload: vacacionesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.VacacionesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVacaciones>
            payload: vacacionesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.vacacionesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VacacionesGroupByOutputType>[]
            payload: vacacionesPayload<ExtArgs>
          }
          count: {
            args: Prisma.vacacionesCountArgs<ExtArgs>,
            result: $Utils.Optional<VacacionesCountAggregateOutputType> | number
            payload: vacacionesPayload<ExtArgs>
          }
        }
      }
      motivos_atencion: {
        operations: {
          findUnique: {
            args: Prisma.motivos_atencionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload> | null
            payload: motivos_atencionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.motivos_atencionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.motivos_atencionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload> | null
            payload: motivos_atencionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.motivos_atencionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.motivos_atencionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>[]
            payload: motivos_atencionPayload<ExtArgs>
          }
          create: {
            args: Prisma.motivos_atencionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.motivos_atencionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: motivos_atencionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.motivos_atencionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          update: {
            args: Prisma.motivos_atencionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.motivos_atencionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: motivos_atencionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.motivos_atencionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: motivos_atencionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.motivos_atencionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<motivos_atencionPayload>
            payload: motivos_atencionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Motivos_atencionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMotivos_atencion>
            payload: motivos_atencionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.motivos_atencionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Motivos_atencionGroupByOutputType>[]
            payload: motivos_atencionPayload<ExtArgs>
          }
          count: {
            args: Prisma.motivos_atencionCountArgs<ExtArgs>,
            result: $Utils.Optional<Motivos_atencionCountAggregateOutputType> | number
            payload: motivos_atencionPayload<ExtArgs>
          }
        }
      }
      prestamos_plan_cuotas: {
        operations: {
          findUnique: {
            args: Prisma.prestamos_plan_cuotasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload> | null
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.prestamos_plan_cuotasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.prestamos_plan_cuotasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload> | null
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.prestamos_plan_cuotasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.prestamos_plan_cuotasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>[]
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          create: {
            args: Prisma.prestamos_plan_cuotasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.prestamos_plan_cuotasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.prestamos_plan_cuotasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          update: {
            args: Prisma.prestamos_plan_cuotasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.prestamos_plan_cuotasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.prestamos_plan_cuotasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.prestamos_plan_cuotasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_plan_cuotasPayload>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Prestamos_plan_cuotasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrestamos_plan_cuotas>
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.prestamos_plan_cuotasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_plan_cuotasGroupByOutputType>[]
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
          count: {
            args: Prisma.prestamos_plan_cuotasCountArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_plan_cuotasCountAggregateOutputType> | number
            payload: prestamos_plan_cuotasPayload<ExtArgs>
          }
        }
      }
      prestamos_tasas: {
        operations: {
          findUnique: {
            args: Prisma.prestamos_tasasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload> | null
            payload: prestamos_tasasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.prestamos_tasasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.prestamos_tasasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload> | null
            payload: prestamos_tasasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.prestamos_tasasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.prestamos_tasasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>[]
            payload: prestamos_tasasPayload<ExtArgs>
          }
          create: {
            args: Prisma.prestamos_tasasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.prestamos_tasasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_tasasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.prestamos_tasasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          update: {
            args: Prisma.prestamos_tasasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.prestamos_tasasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_tasasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.prestamos_tasasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: prestamos_tasasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.prestamos_tasasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<prestamos_tasasPayload>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Prestamos_tasasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrestamos_tasas>
            payload: prestamos_tasasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.prestamos_tasasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_tasasGroupByOutputType>[]
            payload: prestamos_tasasPayload<ExtArgs>
          }
          count: {
            args: Prisma.prestamos_tasasCountArgs<ExtArgs>,
            result: $Utils.Optional<Prestamos_tasasCountAggregateOutputType> | number
            payload: prestamos_tasasPayload<ExtArgs>
          }
        }
      }
      certificado_estudiantes: {
        operations: {
          findUnique: {
            args: Prisma.certificado_estudiantesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload> | null
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.certificado_estudiantesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.certificado_estudiantesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload> | null
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.certificado_estudiantesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.certificado_estudiantesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>[]
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          create: {
            args: Prisma.certificado_estudiantesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.certificado_estudiantesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.certificado_estudiantesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          update: {
            args: Prisma.certificado_estudiantesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.certificado_estudiantesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.certificado_estudiantesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.certificado_estudiantesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<certificado_estudiantesPayload>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Certificado_estudiantesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCertificado_estudiantes>
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.certificado_estudiantesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Certificado_estudiantesGroupByOutputType>[]
            payload: certificado_estudiantesPayload<ExtArgs>
          }
          count: {
            args: Prisma.certificado_estudiantesCountArgs<ExtArgs>,
            result: $Utils.Optional<Certificado_estudiantesCountAggregateOutputType> | number
            payload: certificado_estudiantesPayload<ExtArgs>
          }
        }
      }
      cartera: {
        operations: {
          findUnique: {
            args: Prisma.carteraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload> | null
            payload: carteraPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.carteraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.carteraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload> | null
            payload: carteraPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.carteraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.carteraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>[]
            payload: carteraPayload<ExtArgs>
          }
          create: {
            args: Prisma.carteraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.carteraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: carteraPayload<ExtArgs>
          }
          delete: {
            args: Prisma.carteraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          update: {
            args: Prisma.carteraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.carteraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: carteraPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.carteraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: carteraPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.carteraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<carteraPayload>
            payload: carteraPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CarteraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCartera>
            payload: carteraPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.carteraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CarteraGroupByOutputType>[]
            payload: carteraPayload<ExtArgs>
          }
          count: {
            args: Prisma.carteraCountArgs<ExtArgs>,
            result: $Utils.Optional<CarteraCountAggregateOutputType> | number
            payload: carteraPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model alta_novell
   */


  export type AggregateAlta_novell = {
    _count: Alta_novellCountAggregateOutputType | null
    _avg: Alta_novellAvgAggregateOutputType | null
    _sum: Alta_novellSumAggregateOutputType | null
    _min: Alta_novellMinAggregateOutputType | null
    _max: Alta_novellMaxAggregateOutputType | null
  }

  export type Alta_novellAvgAggregateOutputType = {
    idnovell: number | null
    monto: number | null
    anticipo: number | null
    gastos_adm: number | null
    dni_sol: number | null
    domnum_sol: number | null
    codpostal_sol: number | null
    dni_ben: number | null
    domnum_ben: number | null
    codpostal_ben: number | null
    cuotas: number | null
    cuotasaldo: number | null
    cuota_mantenimiento: number | null
  }

  export type Alta_novellSumAggregateOutputType = {
    idnovell: number | null
    monto: number | null
    anticipo: number | null
    gastos_adm: number | null
    dni_sol: number | null
    domnum_sol: number | null
    codpostal_sol: number | null
    dni_ben: number | null
    domnum_ben: number | null
    codpostal_ben: number | null
    cuotas: number | null
    cuotasaldo: number | null
    cuota_mantenimiento: number | null
  }

  export type Alta_novellMinAggregateOutputType = {
    idnovell: number | null
    fecha_recepcion: Date | null
    servicio: string | null
    monto: number | null
    monto_letra: string | null
    anticipo: number | null
    gastos_adm: number | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    estcivil_sol: string | null
    fecha_nac_sol: Date | null
    dom_sol: string | null
    domnum_sol: number | null
    piso_sol: string | null
    barrio_sol: string | null
    localidad_sol: string | null
    codpostal_sol: number | null
    telefono_sol: string | null
    movil_sol: string | null
    apellido_ben: string | null
    nombre_ben: string | null
    dni_ben: number | null
    estcivil_ben: string | null
    fecha_nac_ben: Date | null
    dom_ben: string | null
    domnum_ben: number | null
    piso_ben: string | null
    barrio_ben: string | null
    localidad_ben: string | null
    codpostal_ben: number | null
    telefono_ben: string | null
    movil_ben: string | null
    operador: string | null
    cuotas: number | null
    nacionalidad_sol: string | null
    nacionalidad_ben: string | null
    anticipo_letra: string | null
    cuotasaldo: number | null
    cuotasaldo_letra: string | null
    cuota_mantenimiento: number | null
  }

  export type Alta_novellMaxAggregateOutputType = {
    idnovell: number | null
    fecha_recepcion: Date | null
    servicio: string | null
    monto: number | null
    monto_letra: string | null
    anticipo: number | null
    gastos_adm: number | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    estcivil_sol: string | null
    fecha_nac_sol: Date | null
    dom_sol: string | null
    domnum_sol: number | null
    piso_sol: string | null
    barrio_sol: string | null
    localidad_sol: string | null
    codpostal_sol: number | null
    telefono_sol: string | null
    movil_sol: string | null
    apellido_ben: string | null
    nombre_ben: string | null
    dni_ben: number | null
    estcivil_ben: string | null
    fecha_nac_ben: Date | null
    dom_ben: string | null
    domnum_ben: number | null
    piso_ben: string | null
    barrio_ben: string | null
    localidad_ben: string | null
    codpostal_ben: number | null
    telefono_ben: string | null
    movil_ben: string | null
    operador: string | null
    cuotas: number | null
    nacionalidad_sol: string | null
    nacionalidad_ben: string | null
    anticipo_letra: string | null
    cuotasaldo: number | null
    cuotasaldo_letra: string | null
    cuota_mantenimiento: number | null
  }

  export type Alta_novellCountAggregateOutputType = {
    idnovell: number
    fecha_recepcion: number
    servicio: number
    monto: number
    monto_letra: number
    anticipo: number
    gastos_adm: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    estcivil_sol: number
    fecha_nac_sol: number
    dom_sol: number
    domnum_sol: number
    piso_sol: number
    barrio_sol: number
    localidad_sol: number
    codpostal_sol: number
    telefono_sol: number
    movil_sol: number
    apellido_ben: number
    nombre_ben: number
    dni_ben: number
    estcivil_ben: number
    fecha_nac_ben: number
    dom_ben: number
    domnum_ben: number
    piso_ben: number
    barrio_ben: number
    localidad_ben: number
    codpostal_ben: number
    telefono_ben: number
    movil_ben: number
    operador: number
    cuotas: number
    nacionalidad_sol: number
    nacionalidad_ben: number
    anticipo_letra: number
    cuotasaldo: number
    cuotasaldo_letra: number
    cuota_mantenimiento: number
    _all: number
  }


  export type Alta_novellAvgAggregateInputType = {
    idnovell?: true
    monto?: true
    anticipo?: true
    gastos_adm?: true
    dni_sol?: true
    domnum_sol?: true
    codpostal_sol?: true
    dni_ben?: true
    domnum_ben?: true
    codpostal_ben?: true
    cuotas?: true
    cuotasaldo?: true
    cuota_mantenimiento?: true
  }

  export type Alta_novellSumAggregateInputType = {
    idnovell?: true
    monto?: true
    anticipo?: true
    gastos_adm?: true
    dni_sol?: true
    domnum_sol?: true
    codpostal_sol?: true
    dni_ben?: true
    domnum_ben?: true
    codpostal_ben?: true
    cuotas?: true
    cuotasaldo?: true
    cuota_mantenimiento?: true
  }

  export type Alta_novellMinAggregateInputType = {
    idnovell?: true
    fecha_recepcion?: true
    servicio?: true
    monto?: true
    monto_letra?: true
    anticipo?: true
    gastos_adm?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    estcivil_sol?: true
    fecha_nac_sol?: true
    dom_sol?: true
    domnum_sol?: true
    piso_sol?: true
    barrio_sol?: true
    localidad_sol?: true
    codpostal_sol?: true
    telefono_sol?: true
    movil_sol?: true
    apellido_ben?: true
    nombre_ben?: true
    dni_ben?: true
    estcivil_ben?: true
    fecha_nac_ben?: true
    dom_ben?: true
    domnum_ben?: true
    piso_ben?: true
    barrio_ben?: true
    localidad_ben?: true
    codpostal_ben?: true
    telefono_ben?: true
    movil_ben?: true
    operador?: true
    cuotas?: true
    nacionalidad_sol?: true
    nacionalidad_ben?: true
    anticipo_letra?: true
    cuotasaldo?: true
    cuotasaldo_letra?: true
    cuota_mantenimiento?: true
  }

  export type Alta_novellMaxAggregateInputType = {
    idnovell?: true
    fecha_recepcion?: true
    servicio?: true
    monto?: true
    monto_letra?: true
    anticipo?: true
    gastos_adm?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    estcivil_sol?: true
    fecha_nac_sol?: true
    dom_sol?: true
    domnum_sol?: true
    piso_sol?: true
    barrio_sol?: true
    localidad_sol?: true
    codpostal_sol?: true
    telefono_sol?: true
    movil_sol?: true
    apellido_ben?: true
    nombre_ben?: true
    dni_ben?: true
    estcivil_ben?: true
    fecha_nac_ben?: true
    dom_ben?: true
    domnum_ben?: true
    piso_ben?: true
    barrio_ben?: true
    localidad_ben?: true
    codpostal_ben?: true
    telefono_ben?: true
    movil_ben?: true
    operador?: true
    cuotas?: true
    nacionalidad_sol?: true
    nacionalidad_ben?: true
    anticipo_letra?: true
    cuotasaldo?: true
    cuotasaldo_letra?: true
    cuota_mantenimiento?: true
  }

  export type Alta_novellCountAggregateInputType = {
    idnovell?: true
    fecha_recepcion?: true
    servicio?: true
    monto?: true
    monto_letra?: true
    anticipo?: true
    gastos_adm?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    estcivil_sol?: true
    fecha_nac_sol?: true
    dom_sol?: true
    domnum_sol?: true
    piso_sol?: true
    barrio_sol?: true
    localidad_sol?: true
    codpostal_sol?: true
    telefono_sol?: true
    movil_sol?: true
    apellido_ben?: true
    nombre_ben?: true
    dni_ben?: true
    estcivil_ben?: true
    fecha_nac_ben?: true
    dom_ben?: true
    domnum_ben?: true
    piso_ben?: true
    barrio_ben?: true
    localidad_ben?: true
    codpostal_ben?: true
    telefono_ben?: true
    movil_ben?: true
    operador?: true
    cuotas?: true
    nacionalidad_sol?: true
    nacionalidad_ben?: true
    anticipo_letra?: true
    cuotasaldo?: true
    cuotasaldo_letra?: true
    cuota_mantenimiento?: true
    _all?: true
  }

  export type Alta_novellAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which alta_novell to aggregate.
     */
    where?: alta_novellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alta_novells to fetch.
     */
    orderBy?: alta_novellOrderByWithRelationInput | alta_novellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alta_novellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alta_novells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alta_novells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alta_novells
    **/
    _count?: true | Alta_novellCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alta_novellAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alta_novellSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alta_novellMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alta_novellMaxAggregateInputType
  }

  export type GetAlta_novellAggregateType<T extends Alta_novellAggregateArgs> = {
        [P in keyof T & keyof AggregateAlta_novell]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlta_novell[P]>
      : GetScalarType<T[P], AggregateAlta_novell[P]>
  }




  export type alta_novellGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: alta_novellWhereInput
    orderBy?: alta_novellOrderByWithAggregationInput | alta_novellOrderByWithAggregationInput[]
    by: Alta_novellScalarFieldEnum[] | Alta_novellScalarFieldEnum
    having?: alta_novellScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alta_novellCountAggregateInputType | true
    _avg?: Alta_novellAvgAggregateInputType
    _sum?: Alta_novellSumAggregateInputType
    _min?: Alta_novellMinAggregateInputType
    _max?: Alta_novellMaxAggregateInputType
  }


  export type Alta_novellGroupByOutputType = {
    idnovell: number
    fecha_recepcion: Date | null
    servicio: string | null
    monto: number | null
    monto_letra: string | null
    anticipo: number | null
    gastos_adm: number | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    estcivil_sol: string | null
    fecha_nac_sol: Date | null
    dom_sol: string | null
    domnum_sol: number | null
    piso_sol: string | null
    barrio_sol: string | null
    localidad_sol: string | null
    codpostal_sol: number | null
    telefono_sol: string | null
    movil_sol: string | null
    apellido_ben: string | null
    nombre_ben: string | null
    dni_ben: number | null
    estcivil_ben: string | null
    fecha_nac_ben: Date | null
    dom_ben: string | null
    domnum_ben: number | null
    piso_ben: string | null
    barrio_ben: string | null
    localidad_ben: string | null
    codpostal_ben: number | null
    telefono_ben: string | null
    movil_ben: string | null
    operador: string | null
    cuotas: number | null
    nacionalidad_sol: string | null
    nacionalidad_ben: string | null
    anticipo_letra: string | null
    cuotasaldo: number | null
    cuotasaldo_letra: string | null
    cuota_mantenimiento: number | null
    _count: Alta_novellCountAggregateOutputType | null
    _avg: Alta_novellAvgAggregateOutputType | null
    _sum: Alta_novellSumAggregateOutputType | null
    _min: Alta_novellMinAggregateOutputType | null
    _max: Alta_novellMaxAggregateOutputType | null
  }

  type GetAlta_novellGroupByPayload<T extends alta_novellGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Alta_novellGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alta_novellGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alta_novellGroupByOutputType[P]>
            : GetScalarType<T[P], Alta_novellGroupByOutputType[P]>
        }
      >
    >


  export type alta_novellSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovell?: boolean
    fecha_recepcion?: boolean
    servicio?: boolean
    monto?: boolean
    monto_letra?: boolean
    anticipo?: boolean
    gastos_adm?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    estcivil_sol?: boolean
    fecha_nac_sol?: boolean
    dom_sol?: boolean
    domnum_sol?: boolean
    piso_sol?: boolean
    barrio_sol?: boolean
    localidad_sol?: boolean
    codpostal_sol?: boolean
    telefono_sol?: boolean
    movil_sol?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    dni_ben?: boolean
    estcivil_ben?: boolean
    fecha_nac_ben?: boolean
    dom_ben?: boolean
    domnum_ben?: boolean
    piso_ben?: boolean
    barrio_ben?: boolean
    localidad_ben?: boolean
    codpostal_ben?: boolean
    telefono_ben?: boolean
    movil_ben?: boolean
    operador?: boolean
    cuotas?: boolean
    nacionalidad_sol?: boolean
    nacionalidad_ben?: boolean
    anticipo_letra?: boolean
    cuotasaldo?: boolean
    cuotasaldo_letra?: boolean
    cuota_mantenimiento?: boolean
  }, ExtArgs["result"]["alta_novell"]>

  export type alta_novellSelectScalar = {
    idnovell?: boolean
    fecha_recepcion?: boolean
    servicio?: boolean
    monto?: boolean
    monto_letra?: boolean
    anticipo?: boolean
    gastos_adm?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    estcivil_sol?: boolean
    fecha_nac_sol?: boolean
    dom_sol?: boolean
    domnum_sol?: boolean
    piso_sol?: boolean
    barrio_sol?: boolean
    localidad_sol?: boolean
    codpostal_sol?: boolean
    telefono_sol?: boolean
    movil_sol?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    dni_ben?: boolean
    estcivil_ben?: boolean
    fecha_nac_ben?: boolean
    dom_ben?: boolean
    domnum_ben?: boolean
    piso_ben?: boolean
    barrio_ben?: boolean
    localidad_ben?: boolean
    codpostal_ben?: boolean
    telefono_ben?: boolean
    movil_ben?: boolean
    operador?: boolean
    cuotas?: boolean
    nacionalidad_sol?: boolean
    nacionalidad_ben?: boolean
    anticipo_letra?: boolean
    cuotasaldo?: boolean
    cuotasaldo_letra?: boolean
    cuota_mantenimiento?: boolean
  }


  type alta_novellGetPayload<S extends boolean | null | undefined | alta_novellArgs> = $Types.GetResult<alta_novellPayload, S>

  type alta_novellCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<alta_novellFindManyArgs, 'select' | 'include'> & {
      select?: Alta_novellCountAggregateInputType | true
    }

  export interface alta_novellDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alta_novell'], meta: { name: 'alta_novell' } }
    /**
     * Find zero or one Alta_novell that matches the filter.
     * @param {alta_novellFindUniqueArgs} args - Arguments to find a Alta_novell
     * @example
     * // Get one Alta_novell
     * const alta_novell = await prisma.alta_novell.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends alta_novellFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, alta_novellFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'alta_novell'> extends True ? Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Alta_novell that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {alta_novellFindUniqueOrThrowArgs} args - Arguments to find a Alta_novell
     * @example
     * // Get one Alta_novell
     * const alta_novell = await prisma.alta_novell.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends alta_novellFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, alta_novellFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Alta_novell that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellFindFirstArgs} args - Arguments to find a Alta_novell
     * @example
     * // Get one Alta_novell
     * const alta_novell = await prisma.alta_novell.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends alta_novellFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, alta_novellFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'alta_novell'> extends True ? Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Alta_novell that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellFindFirstOrThrowArgs} args - Arguments to find a Alta_novell
     * @example
     * // Get one Alta_novell
     * const alta_novell = await prisma.alta_novell.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends alta_novellFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, alta_novellFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Alta_novells that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alta_novells
     * const alta_novells = await prisma.alta_novell.findMany()
     * 
     * // Get first 10 Alta_novells
     * const alta_novells = await prisma.alta_novell.findMany({ take: 10 })
     * 
     * // Only select the `idnovell`
     * const alta_novellWithIdnovellOnly = await prisma.alta_novell.findMany({ select: { idnovell: true } })
     * 
    **/
    findMany<T extends alta_novellFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, alta_novellFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Alta_novell.
     * @param {alta_novellCreateArgs} args - Arguments to create a Alta_novell.
     * @example
     * // Create one Alta_novell
     * const Alta_novell = await prisma.alta_novell.create({
     *   data: {
     *     // ... data to create a Alta_novell
     *   }
     * })
     * 
    **/
    create<T extends alta_novellCreateArgs<ExtArgs>>(
      args: SelectSubset<T, alta_novellCreateArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Alta_novells.
     *     @param {alta_novellCreateManyArgs} args - Arguments to create many Alta_novells.
     *     @example
     *     // Create many Alta_novells
     *     const alta_novell = await prisma.alta_novell.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends alta_novellCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, alta_novellCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alta_novell.
     * @param {alta_novellDeleteArgs} args - Arguments to delete one Alta_novell.
     * @example
     * // Delete one Alta_novell
     * const Alta_novell = await prisma.alta_novell.delete({
     *   where: {
     *     // ... filter to delete one Alta_novell
     *   }
     * })
     * 
    **/
    delete<T extends alta_novellDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, alta_novellDeleteArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Alta_novell.
     * @param {alta_novellUpdateArgs} args - Arguments to update one Alta_novell.
     * @example
     * // Update one Alta_novell
     * const alta_novell = await prisma.alta_novell.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends alta_novellUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, alta_novellUpdateArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Alta_novells.
     * @param {alta_novellDeleteManyArgs} args - Arguments to filter Alta_novells to delete.
     * @example
     * // Delete a few Alta_novells
     * const { count } = await prisma.alta_novell.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends alta_novellDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, alta_novellDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alta_novells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alta_novells
     * const alta_novell = await prisma.alta_novell.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends alta_novellUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, alta_novellUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alta_novell.
     * @param {alta_novellUpsertArgs} args - Arguments to update or create a Alta_novell.
     * @example
     * // Update or create a Alta_novell
     * const alta_novell = await prisma.alta_novell.upsert({
     *   create: {
     *     // ... data to create a Alta_novell
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alta_novell we want to update
     *   }
     * })
    **/
    upsert<T extends alta_novellUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, alta_novellUpsertArgs<ExtArgs>>
    ): Prisma__alta_novellClient<$Types.GetResult<alta_novellPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Alta_novells.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellCountArgs} args - Arguments to filter Alta_novells to count.
     * @example
     * // Count the number of Alta_novells
     * const count = await prisma.alta_novell.count({
     *   where: {
     *     // ... the filter for the Alta_novells we want to count
     *   }
     * })
    **/
    count<T extends alta_novellCountArgs>(
      args?: Subset<T, alta_novellCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alta_novellCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alta_novell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alta_novellAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alta_novellAggregateArgs>(args: Subset<T, Alta_novellAggregateArgs>): Prisma.PrismaPromise<GetAlta_novellAggregateType<T>>

    /**
     * Group by Alta_novell.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alta_novellGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alta_novellGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alta_novellGroupByArgs['orderBy'] }
        : { orderBy?: alta_novellGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alta_novellGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlta_novellGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for alta_novell.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__alta_novellClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * alta_novell base type for findUnique actions
   */
  export type alta_novellFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter, which alta_novell to fetch.
     */
    where: alta_novellWhereUniqueInput
  }

  /**
   * alta_novell findUnique
   */
  export interface alta_novellFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends alta_novellFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alta_novell findUniqueOrThrow
   */
  export type alta_novellFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter, which alta_novell to fetch.
     */
    where: alta_novellWhereUniqueInput
  }


  /**
   * alta_novell base type for findFirst actions
   */
  export type alta_novellFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter, which alta_novell to fetch.
     */
    where?: alta_novellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alta_novells to fetch.
     */
    orderBy?: alta_novellOrderByWithRelationInput | alta_novellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alta_novells.
     */
    cursor?: alta_novellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alta_novells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alta_novells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alta_novells.
     */
    distinct?: Alta_novellScalarFieldEnum | Alta_novellScalarFieldEnum[]
  }

  /**
   * alta_novell findFirst
   */
  export interface alta_novellFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends alta_novellFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * alta_novell findFirstOrThrow
   */
  export type alta_novellFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter, which alta_novell to fetch.
     */
    where?: alta_novellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alta_novells to fetch.
     */
    orderBy?: alta_novellOrderByWithRelationInput | alta_novellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alta_novells.
     */
    cursor?: alta_novellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alta_novells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alta_novells.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alta_novells.
     */
    distinct?: Alta_novellScalarFieldEnum | Alta_novellScalarFieldEnum[]
  }


  /**
   * alta_novell findMany
   */
  export type alta_novellFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter, which alta_novells to fetch.
     */
    where?: alta_novellWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alta_novells to fetch.
     */
    orderBy?: alta_novellOrderByWithRelationInput | alta_novellOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alta_novells.
     */
    cursor?: alta_novellWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alta_novells from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alta_novells.
     */
    skip?: number
    distinct?: Alta_novellScalarFieldEnum | Alta_novellScalarFieldEnum[]
  }


  /**
   * alta_novell create
   */
  export type alta_novellCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * The data needed to create a alta_novell.
     */
    data?: XOR<alta_novellCreateInput, alta_novellUncheckedCreateInput>
  }


  /**
   * alta_novell createMany
   */
  export type alta_novellCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alta_novells.
     */
    data: alta_novellCreateManyInput | alta_novellCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * alta_novell update
   */
  export type alta_novellUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * The data needed to update a alta_novell.
     */
    data: XOR<alta_novellUpdateInput, alta_novellUncheckedUpdateInput>
    /**
     * Choose, which alta_novell to update.
     */
    where: alta_novellWhereUniqueInput
  }


  /**
   * alta_novell updateMany
   */
  export type alta_novellUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alta_novells.
     */
    data: XOR<alta_novellUpdateManyMutationInput, alta_novellUncheckedUpdateManyInput>
    /**
     * Filter which alta_novells to update
     */
    where?: alta_novellWhereInput
  }


  /**
   * alta_novell upsert
   */
  export type alta_novellUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * The filter to search for the alta_novell to update in case it exists.
     */
    where: alta_novellWhereUniqueInput
    /**
     * In case the alta_novell found by the `where` argument doesn't exist, create a new alta_novell with this data.
     */
    create: XOR<alta_novellCreateInput, alta_novellUncheckedCreateInput>
    /**
     * In case the alta_novell was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alta_novellUpdateInput, alta_novellUncheckedUpdateInput>
  }


  /**
   * alta_novell delete
   */
  export type alta_novellDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
    /**
     * Filter which alta_novell to delete.
     */
    where: alta_novellWhereUniqueInput
  }


  /**
   * alta_novell deleteMany
   */
  export type alta_novellDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which alta_novells to delete
     */
    where?: alta_novellWhereInput
  }


  /**
   * alta_novell without action
   */
  export type alta_novellArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alta_novell
     */
    select?: alta_novellSelect<ExtArgs> | null
  }



  /**
   * Model caja_sucursales
   */


  export type AggregateCaja_sucursales = {
    _count: Caja_sucursalesCountAggregateOutputType | null
    _avg: Caja_sucursalesAvgAggregateOutputType | null
    _sum: Caja_sucursalesSumAggregateOutputType | null
    _min: Caja_sucursalesMinAggregateOutputType | null
    _max: Caja_sucursalesMaxAggregateOutputType | null
  }

  export type Caja_sucursalesAvgAggregateOutputType = {
    idcaja: number | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
  }

  export type Caja_sucursalesSumAggregateOutputType = {
    idcaja: number | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
  }

  export type Caja_sucursalesMinAggregateOutputType = {
    idcaja: number | null
    fecha_carga: Date | null
    sucursal: string | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
    operador_carga: string | null
    empresa: string | null
  }

  export type Caja_sucursalesMaxAggregateOutputType = {
    idcaja: number | null
    fecha_carga: Date | null
    sucursal: string | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
    operador_carga: string | null
    empresa: string | null
  }

  export type Caja_sucursalesCountAggregateOutputType = {
    idcaja: number
    fecha_carga: number
    sucursal: number
    ingresos: number
    egresos: number
    saldo: number
    operador_carga: number
    empresa: number
    _all: number
  }


  export type Caja_sucursalesAvgAggregateInputType = {
    idcaja?: true
    ingresos?: true
    egresos?: true
    saldo?: true
  }

  export type Caja_sucursalesSumAggregateInputType = {
    idcaja?: true
    ingresos?: true
    egresos?: true
    saldo?: true
  }

  export type Caja_sucursalesMinAggregateInputType = {
    idcaja?: true
    fecha_carga?: true
    sucursal?: true
    ingresos?: true
    egresos?: true
    saldo?: true
    operador_carga?: true
    empresa?: true
  }

  export type Caja_sucursalesMaxAggregateInputType = {
    idcaja?: true
    fecha_carga?: true
    sucursal?: true
    ingresos?: true
    egresos?: true
    saldo?: true
    operador_carga?: true
    empresa?: true
  }

  export type Caja_sucursalesCountAggregateInputType = {
    idcaja?: true
    fecha_carga?: true
    sucursal?: true
    ingresos?: true
    egresos?: true
    saldo?: true
    operador_carga?: true
    empresa?: true
    _all?: true
  }

  export type Caja_sucursalesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sucursales to aggregate.
     */
    where?: caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sucursales to fetch.
     */
    orderBy?: caja_sucursalesOrderByWithRelationInput | caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sucursales
    **/
    _count?: true | Caja_sucursalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_sucursalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_sucursalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_sucursalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_sucursalesMaxAggregateInputType
  }

  export type GetCaja_sucursalesAggregateType<T extends Caja_sucursalesAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sucursales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sucursales[P]>
      : GetScalarType<T[P], AggregateCaja_sucursales[P]>
  }




  export type caja_sucursalesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_sucursalesWhereInput
    orderBy?: caja_sucursalesOrderByWithAggregationInput | caja_sucursalesOrderByWithAggregationInput[]
    by: Caja_sucursalesScalarFieldEnum[] | Caja_sucursalesScalarFieldEnum
    having?: caja_sucursalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_sucursalesCountAggregateInputType | true
    _avg?: Caja_sucursalesAvgAggregateInputType
    _sum?: Caja_sucursalesSumAggregateInputType
    _min?: Caja_sucursalesMinAggregateInputType
    _max?: Caja_sucursalesMaxAggregateInputType
  }


  export type Caja_sucursalesGroupByOutputType = {
    idcaja: number
    fecha_carga: Date | null
    sucursal: string | null
    ingresos: number | null
    egresos: number | null
    saldo: number | null
    operador_carga: string | null
    empresa: string | null
    _count: Caja_sucursalesCountAggregateOutputType | null
    _avg: Caja_sucursalesAvgAggregateOutputType | null
    _sum: Caja_sucursalesSumAggregateOutputType | null
    _min: Caja_sucursalesMinAggregateOutputType | null
    _max: Caja_sucursalesMaxAggregateOutputType | null
  }

  type GetCaja_sucursalesGroupByPayload<T extends caja_sucursalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_sucursalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_sucursalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_sucursalesGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_sucursalesGroupByOutputType[P]>
        }
      >
    >


  export type caja_sucursalesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    fecha_carga?: boolean
    sucursal?: boolean
    ingresos?: boolean
    egresos?: boolean
    saldo?: boolean
    operador_carga?: boolean
    empresa?: boolean
  }, ExtArgs["result"]["caja_sucursales"]>

  export type caja_sucursalesSelectScalar = {
    idcaja?: boolean
    fecha_carga?: boolean
    sucursal?: boolean
    ingresos?: boolean
    egresos?: boolean
    saldo?: boolean
    operador_carga?: boolean
    empresa?: boolean
  }


  type caja_sucursalesGetPayload<S extends boolean | null | undefined | caja_sucursalesArgs> = $Types.GetResult<caja_sucursalesPayload, S>

  type caja_sucursalesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_sucursalesFindManyArgs, 'select' | 'include'> & {
      select?: Caja_sucursalesCountAggregateInputType | true
    }

  export interface caja_sucursalesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_sucursales'], meta: { name: 'caja_sucursales' } }
    /**
     * Find zero or one Caja_sucursales that matches the filter.
     * @param {caja_sucursalesFindUniqueArgs} args - Arguments to find a Caja_sucursales
     * @example
     * // Get one Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_sucursalesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_sucursalesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sucursales'> extends True ? Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_sucursales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_sucursalesFindUniqueOrThrowArgs} args - Arguments to find a Caja_sucursales
     * @example
     * // Get one Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesFindFirstArgs} args - Arguments to find a Caja_sucursales
     * @example
     * // Get one Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_sucursalesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_sucursalesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sucursales'> extends True ? Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_sucursales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesFindFirstOrThrowArgs} args - Arguments to find a Caja_sucursales
     * @example
     * // Get one Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_sucursalesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sucursalesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findMany()
     * 
     * // Get first 10 Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_sucursalesWithIdcajaOnly = await prisma.caja_sucursales.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_sucursalesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sucursalesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_sucursales.
     * @param {caja_sucursalesCreateArgs} args - Arguments to create a Caja_sucursales.
     * @example
     * // Create one Caja_sucursales
     * const Caja_sucursales = await prisma.caja_sucursales.create({
     *   data: {
     *     // ... data to create a Caja_sucursales
     *   }
     * })
     * 
    **/
    create<T extends caja_sucursalesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sucursalesCreateArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_sucursales.
     *     @param {caja_sucursalesCreateManyArgs} args - Arguments to create many Caja_sucursales.
     *     @example
     *     // Create many Caja_sucursales
     *     const caja_sucursales = await prisma.caja_sucursales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_sucursalesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sucursalesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sucursales.
     * @param {caja_sucursalesDeleteArgs} args - Arguments to delete one Caja_sucursales.
     * @example
     * // Delete one Caja_sucursales
     * const Caja_sucursales = await prisma.caja_sucursales.delete({
     *   where: {
     *     // ... filter to delete one Caja_sucursales
     *   }
     * })
     * 
    **/
    delete<T extends caja_sucursalesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sucursalesDeleteArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_sucursales.
     * @param {caja_sucursalesUpdateArgs} args - Arguments to update one Caja_sucursales.
     * @example
     * // Update one Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_sucursalesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sucursalesUpdateArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_sucursales.
     * @param {caja_sucursalesDeleteManyArgs} args - Arguments to filter Caja_sucursales to delete.
     * @example
     * // Delete a few Caja_sucursales
     * const { count } = await prisma.caja_sucursales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_sucursalesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sucursalesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_sucursalesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sucursalesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sucursales.
     * @param {caja_sucursalesUpsertArgs} args - Arguments to update or create a Caja_sucursales.
     * @example
     * // Update or create a Caja_sucursales
     * const caja_sucursales = await prisma.caja_sucursales.upsert({
     *   create: {
     *     // ... data to create a Caja_sucursales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sucursales we want to update
     *   }
     * })
    **/
    upsert<T extends caja_sucursalesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sucursalesUpsertArgs<ExtArgs>>
    ): Prisma__caja_sucursalesClient<$Types.GetResult<caja_sucursalesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesCountArgs} args - Arguments to filter Caja_sucursales to count.
     * @example
     * // Count the number of Caja_sucursales
     * const count = await prisma.caja_sucursales.count({
     *   where: {
     *     // ... the filter for the Caja_sucursales we want to count
     *   }
     * })
    **/
    count<T extends caja_sucursalesCountArgs>(
      args?: Subset<T, caja_sucursalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_sucursalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_sucursalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_sucursalesAggregateArgs>(args: Subset<T, Caja_sucursalesAggregateArgs>): Prisma.PrismaPromise<GetCaja_sucursalesAggregateType<T>>

    /**
     * Group by Caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sucursalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_sucursalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_sucursalesGroupByArgs['orderBy'] }
        : { orderBy?: caja_sucursalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_sucursalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_sucursalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sucursales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_sucursalesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sucursales base type for findUnique actions
   */
  export type caja_sucursalesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which caja_sucursales to fetch.
     */
    where: caja_sucursalesWhereUniqueInput
  }

  /**
   * caja_sucursales findUnique
   */
  export interface caja_sucursalesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sucursalesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sucursales findUniqueOrThrow
   */
  export type caja_sucursalesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which caja_sucursales to fetch.
     */
    where: caja_sucursalesWhereUniqueInput
  }


  /**
   * caja_sucursales base type for findFirst actions
   */
  export type caja_sucursalesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which caja_sucursales to fetch.
     */
    where?: caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sucursales to fetch.
     */
    orderBy?: caja_sucursalesOrderByWithRelationInput | caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sucursales.
     */
    cursor?: caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sucursales.
     */
    distinct?: Caja_sucursalesScalarFieldEnum | Caja_sucursalesScalarFieldEnum[]
  }

  /**
   * caja_sucursales findFirst
   */
  export interface caja_sucursalesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sucursalesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sucursales findFirstOrThrow
   */
  export type caja_sucursalesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which caja_sucursales to fetch.
     */
    where?: caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sucursales to fetch.
     */
    orderBy?: caja_sucursalesOrderByWithRelationInput | caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sucursales.
     */
    cursor?: caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sucursales.
     */
    distinct?: Caja_sucursalesScalarFieldEnum | Caja_sucursalesScalarFieldEnum[]
  }


  /**
   * caja_sucursales findMany
   */
  export type caja_sucursalesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which caja_sucursales to fetch.
     */
    where?: caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sucursales to fetch.
     */
    orderBy?: caja_sucursalesOrderByWithRelationInput | caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sucursales.
     */
    cursor?: caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sucursales.
     */
    skip?: number
    distinct?: Caja_sucursalesScalarFieldEnum | Caja_sucursalesScalarFieldEnum[]
  }


  /**
   * caja_sucursales create
   */
  export type caja_sucursalesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_sucursales.
     */
    data?: XOR<caja_sucursalesCreateInput, caja_sucursalesUncheckedCreateInput>
  }


  /**
   * caja_sucursales createMany
   */
  export type caja_sucursalesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_sucursales.
     */
    data: caja_sucursalesCreateManyInput | caja_sucursalesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_sucursales update
   */
  export type caja_sucursalesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_sucursales.
     */
    data: XOR<caja_sucursalesUpdateInput, caja_sucursalesUncheckedUpdateInput>
    /**
     * Choose, which caja_sucursales to update.
     */
    where: caja_sucursalesWhereUniqueInput
  }


  /**
   * caja_sucursales updateMany
   */
  export type caja_sucursalesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_sucursales.
     */
    data: XOR<caja_sucursalesUpdateManyMutationInput, caja_sucursalesUncheckedUpdateManyInput>
    /**
     * Filter which caja_sucursales to update
     */
    where?: caja_sucursalesWhereInput
  }


  /**
   * caja_sucursales upsert
   */
  export type caja_sucursalesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_sucursales to update in case it exists.
     */
    where: caja_sucursalesWhereUniqueInput
    /**
     * In case the caja_sucursales found by the `where` argument doesn't exist, create a new caja_sucursales with this data.
     */
    create: XOR<caja_sucursalesCreateInput, caja_sucursalesUncheckedCreateInput>
    /**
     * In case the caja_sucursales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_sucursalesUpdateInput, caja_sucursalesUncheckedUpdateInput>
  }


  /**
   * caja_sucursales delete
   */
  export type caja_sucursalesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter which caja_sucursales to delete.
     */
    where: caja_sucursalesWhereUniqueInput
  }


  /**
   * caja_sucursales deleteMany
   */
  export type caja_sucursalesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sucursales to delete
     */
    where?: caja_sucursalesWhereInput
  }


  /**
   * caja_sucursales without action
   */
  export type caja_sucursalesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sucursales
     */
    select?: caja_sucursalesSelect<ExtArgs> | null
  }



  /**
   * Model campanacasos
   */


  export type AggregateCampanacasos = {
    _count: CampanacasosCountAggregateOutputType | null
    _avg: CampanacasosAvgAggregateOutputType | null
    _sum: CampanacasosSumAggregateOutputType | null
    _min: CampanacasosMinAggregateOutputType | null
    _max: CampanacasosMaxAggregateOutputType | null
  }

  export type CampanacasosAvgAggregateOutputType = {
    idcaso: number | null
    idcampana: number | null
    mes: number | null
    ano: number | null
    contrato: number | null
    dni: number | null
    nro_calle: number | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    accion: number | null
    edad: number | null
    adherentes: number | null
  }

  export type CampanacasosSumAggregateOutputType = {
    idcaso: number | null
    idcampana: number | null
    mes: number | null
    ano: number | null
    contrato: number | null
    dni: number | null
    nro_calle: number | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    accion: number | null
    edad: number | null
    adherentes: number | null
  }

  export type CampanacasosMinAggregateOutputType = {
    idcaso: number | null
    idcampana: number | null
    fechacampana: Date | null
    mes: number | null
    ano: number | null
    sucursal: string | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: string | null
    movil: string | null
    calle: string | null
    nro_calle: number | null
    barrio: string | null
    localidad: string | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    estadocaso: boolean | null
    accion: number | null
    edad: number | null
    adherentes: number | null
    alta: Date | null
    vigencia: Date | null
  }

  export type CampanacasosMaxAggregateOutputType = {
    idcaso: number | null
    idcampana: number | null
    fechacampana: Date | null
    mes: number | null
    ano: number | null
    sucursal: string | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: string | null
    movil: string | null
    calle: string | null
    nro_calle: number | null
    barrio: string | null
    localidad: string | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    estadocaso: boolean | null
    accion: number | null
    edad: number | null
    adherentes: number | null
    alta: Date | null
    vigencia: Date | null
  }

  export type CampanacasosCountAggregateOutputType = {
    idcaso: number
    idcampana: number
    fechacampana: number
    mes: number
    ano: number
    sucursal: number
    contrato: number
    apellido: number
    nombre: number
    dni: number
    telefono: number
    movil: number
    calle: number
    nro_calle: number
    barrio: number
    localidad: number
    cuota: number
    cuotasadeudadas: number
    montoadeudado: number
    estadocaso: number
    accion: number
    edad: number
    adherentes: number
    alta: number
    vigencia: number
    _all: number
  }


  export type CampanacasosAvgAggregateInputType = {
    idcaso?: true
    idcampana?: true
    mes?: true
    ano?: true
    contrato?: true
    dni?: true
    nro_calle?: true
    cuota?: true
    cuotasadeudadas?: true
    montoadeudado?: true
    accion?: true
    edad?: true
    adherentes?: true
  }

  export type CampanacasosSumAggregateInputType = {
    idcaso?: true
    idcampana?: true
    mes?: true
    ano?: true
    contrato?: true
    dni?: true
    nro_calle?: true
    cuota?: true
    cuotasadeudadas?: true
    montoadeudado?: true
    accion?: true
    edad?: true
    adherentes?: true
  }

  export type CampanacasosMinAggregateInputType = {
    idcaso?: true
    idcampana?: true
    fechacampana?: true
    mes?: true
    ano?: true
    sucursal?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    movil?: true
    calle?: true
    nro_calle?: true
    barrio?: true
    localidad?: true
    cuota?: true
    cuotasadeudadas?: true
    montoadeudado?: true
    estadocaso?: true
    accion?: true
    edad?: true
    adherentes?: true
    alta?: true
    vigencia?: true
  }

  export type CampanacasosMaxAggregateInputType = {
    idcaso?: true
    idcampana?: true
    fechacampana?: true
    mes?: true
    ano?: true
    sucursal?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    movil?: true
    calle?: true
    nro_calle?: true
    barrio?: true
    localidad?: true
    cuota?: true
    cuotasadeudadas?: true
    montoadeudado?: true
    estadocaso?: true
    accion?: true
    edad?: true
    adherentes?: true
    alta?: true
    vigencia?: true
  }

  export type CampanacasosCountAggregateInputType = {
    idcaso?: true
    idcampana?: true
    fechacampana?: true
    mes?: true
    ano?: true
    sucursal?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    movil?: true
    calle?: true
    nro_calle?: true
    barrio?: true
    localidad?: true
    cuota?: true
    cuotasadeudadas?: true
    montoadeudado?: true
    estadocaso?: true
    accion?: true
    edad?: true
    adherentes?: true
    alta?: true
    vigencia?: true
    _all?: true
  }

  export type CampanacasosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanacasos to aggregate.
     */
    where?: campanacasosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanacasos to fetch.
     */
    orderBy?: campanacasosOrderByWithRelationInput | campanacasosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanacasosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanacasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanacasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanacasos
    **/
    _count?: true | CampanacasosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampanacasosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampanacasosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampanacasosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampanacasosMaxAggregateInputType
  }

  export type GetCampanacasosAggregateType<T extends CampanacasosAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanacasos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanacasos[P]>
      : GetScalarType<T[P], AggregateCampanacasos[P]>
  }




  export type campanacasosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: campanacasosWhereInput
    orderBy?: campanacasosOrderByWithAggregationInput | campanacasosOrderByWithAggregationInput[]
    by: CampanacasosScalarFieldEnum[] | CampanacasosScalarFieldEnum
    having?: campanacasosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampanacasosCountAggregateInputType | true
    _avg?: CampanacasosAvgAggregateInputType
    _sum?: CampanacasosSumAggregateInputType
    _min?: CampanacasosMinAggregateInputType
    _max?: CampanacasosMaxAggregateInputType
  }


  export type CampanacasosGroupByOutputType = {
    idcaso: number
    idcampana: number | null
    fechacampana: Date | null
    mes: number | null
    ano: number | null
    sucursal: string | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: string | null
    movil: string | null
    calle: string | null
    nro_calle: number | null
    barrio: string | null
    localidad: string | null
    cuota: number | null
    cuotasadeudadas: number | null
    montoadeudado: number | null
    estadocaso: boolean | null
    accion: number | null
    edad: number | null
    adherentes: number | null
    alta: Date | null
    vigencia: Date | null
    _count: CampanacasosCountAggregateOutputType | null
    _avg: CampanacasosAvgAggregateOutputType | null
    _sum: CampanacasosSumAggregateOutputType | null
    _min: CampanacasosMinAggregateOutputType | null
    _max: CampanacasosMaxAggregateOutputType | null
  }

  type GetCampanacasosGroupByPayload<T extends campanacasosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampanacasosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampanacasosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampanacasosGroupByOutputType[P]>
            : GetScalarType<T[P], CampanacasosGroupByOutputType[P]>
        }
      >
    >


  export type campanacasosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaso?: boolean
    idcampana?: boolean
    fechacampana?: boolean
    mes?: boolean
    ano?: boolean
    sucursal?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    telefono?: boolean
    movil?: boolean
    calle?: boolean
    nro_calle?: boolean
    barrio?: boolean
    localidad?: boolean
    cuota?: boolean
    cuotasadeudadas?: boolean
    montoadeudado?: boolean
    estadocaso?: boolean
    accion?: boolean
    edad?: boolean
    adherentes?: boolean
    alta?: boolean
    vigencia?: boolean
  }, ExtArgs["result"]["campanacasos"]>

  export type campanacasosSelectScalar = {
    idcaso?: boolean
    idcampana?: boolean
    fechacampana?: boolean
    mes?: boolean
    ano?: boolean
    sucursal?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    telefono?: boolean
    movil?: boolean
    calle?: boolean
    nro_calle?: boolean
    barrio?: boolean
    localidad?: boolean
    cuota?: boolean
    cuotasadeudadas?: boolean
    montoadeudado?: boolean
    estadocaso?: boolean
    accion?: boolean
    edad?: boolean
    adherentes?: boolean
    alta?: boolean
    vigencia?: boolean
  }


  type campanacasosGetPayload<S extends boolean | null | undefined | campanacasosArgs> = $Types.GetResult<campanacasosPayload, S>

  type campanacasosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<campanacasosFindManyArgs, 'select' | 'include'> & {
      select?: CampanacasosCountAggregateInputType | true
    }

  export interface campanacasosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanacasos'], meta: { name: 'campanacasos' } }
    /**
     * Find zero or one Campanacasos that matches the filter.
     * @param {campanacasosFindUniqueArgs} args - Arguments to find a Campanacasos
     * @example
     * // Get one Campanacasos
     * const campanacasos = await prisma.campanacasos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends campanacasosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, campanacasosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'campanacasos'> extends True ? Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Campanacasos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {campanacasosFindUniqueOrThrowArgs} args - Arguments to find a Campanacasos
     * @example
     * // Get one Campanacasos
     * const campanacasos = await prisma.campanacasos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends campanacasosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanacasosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Campanacasos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosFindFirstArgs} args - Arguments to find a Campanacasos
     * @example
     * // Get one Campanacasos
     * const campanacasos = await prisma.campanacasos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends campanacasosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, campanacasosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'campanacasos'> extends True ? Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Campanacasos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosFindFirstOrThrowArgs} args - Arguments to find a Campanacasos
     * @example
     * // Get one Campanacasos
     * const campanacasos = await prisma.campanacasos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends campanacasosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanacasosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Campanacasos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanacasos
     * const campanacasos = await prisma.campanacasos.findMany()
     * 
     * // Get first 10 Campanacasos
     * const campanacasos = await prisma.campanacasos.findMany({ take: 10 })
     * 
     * // Only select the `idcaso`
     * const campanacasosWithIdcasoOnly = await prisma.campanacasos.findMany({ select: { idcaso: true } })
     * 
    **/
    findMany<T extends campanacasosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanacasosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Campanacasos.
     * @param {campanacasosCreateArgs} args - Arguments to create a Campanacasos.
     * @example
     * // Create one Campanacasos
     * const Campanacasos = await prisma.campanacasos.create({
     *   data: {
     *     // ... data to create a Campanacasos
     *   }
     * })
     * 
    **/
    create<T extends campanacasosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, campanacasosCreateArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Campanacasos.
     *     @param {campanacasosCreateManyArgs} args - Arguments to create many Campanacasos.
     *     @example
     *     // Create many Campanacasos
     *     const campanacasos = await prisma.campanacasos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends campanacasosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanacasosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campanacasos.
     * @param {campanacasosDeleteArgs} args - Arguments to delete one Campanacasos.
     * @example
     * // Delete one Campanacasos
     * const Campanacasos = await prisma.campanacasos.delete({
     *   where: {
     *     // ... filter to delete one Campanacasos
     *   }
     * })
     * 
    **/
    delete<T extends campanacasosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, campanacasosDeleteArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Campanacasos.
     * @param {campanacasosUpdateArgs} args - Arguments to update one Campanacasos.
     * @example
     * // Update one Campanacasos
     * const campanacasos = await prisma.campanacasos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends campanacasosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, campanacasosUpdateArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Campanacasos.
     * @param {campanacasosDeleteManyArgs} args - Arguments to filter Campanacasos to delete.
     * @example
     * // Delete a few Campanacasos
     * const { count } = await prisma.campanacasos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends campanacasosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanacasosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanacasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanacasos
     * const campanacasos = await prisma.campanacasos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends campanacasosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, campanacasosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campanacasos.
     * @param {campanacasosUpsertArgs} args - Arguments to update or create a Campanacasos.
     * @example
     * // Update or create a Campanacasos
     * const campanacasos = await prisma.campanacasos.upsert({
     *   create: {
     *     // ... data to create a Campanacasos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanacasos we want to update
     *   }
     * })
    **/
    upsert<T extends campanacasosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, campanacasosUpsertArgs<ExtArgs>>
    ): Prisma__campanacasosClient<$Types.GetResult<campanacasosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Campanacasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosCountArgs} args - Arguments to filter Campanacasos to count.
     * @example
     * // Count the number of Campanacasos
     * const count = await prisma.campanacasos.count({
     *   where: {
     *     // ... the filter for the Campanacasos we want to count
     *   }
     * })
    **/
    count<T extends campanacasosCountArgs>(
      args?: Subset<T, campanacasosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampanacasosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanacasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampanacasosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampanacasosAggregateArgs>(args: Subset<T, CampanacasosAggregateArgs>): Prisma.PrismaPromise<GetCampanacasosAggregateType<T>>

    /**
     * Group by Campanacasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanacasosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanacasosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanacasosGroupByArgs['orderBy'] }
        : { orderBy?: campanacasosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanacasosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanacasosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for campanacasos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__campanacasosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * campanacasos base type for findUnique actions
   */
  export type campanacasosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter, which campanacasos to fetch.
     */
    where: campanacasosWhereUniqueInput
  }

  /**
   * campanacasos findUnique
   */
  export interface campanacasosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanacasosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanacasos findUniqueOrThrow
   */
  export type campanacasosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter, which campanacasos to fetch.
     */
    where: campanacasosWhereUniqueInput
  }


  /**
   * campanacasos base type for findFirst actions
   */
  export type campanacasosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter, which campanacasos to fetch.
     */
    where?: campanacasosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanacasos to fetch.
     */
    orderBy?: campanacasosOrderByWithRelationInput | campanacasosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanacasos.
     */
    cursor?: campanacasosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanacasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanacasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanacasos.
     */
    distinct?: CampanacasosScalarFieldEnum | CampanacasosScalarFieldEnum[]
  }

  /**
   * campanacasos findFirst
   */
  export interface campanacasosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanacasosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanacasos findFirstOrThrow
   */
  export type campanacasosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter, which campanacasos to fetch.
     */
    where?: campanacasosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanacasos to fetch.
     */
    orderBy?: campanacasosOrderByWithRelationInput | campanacasosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanacasos.
     */
    cursor?: campanacasosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanacasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanacasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanacasos.
     */
    distinct?: CampanacasosScalarFieldEnum | CampanacasosScalarFieldEnum[]
  }


  /**
   * campanacasos findMany
   */
  export type campanacasosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter, which campanacasos to fetch.
     */
    where?: campanacasosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanacasos to fetch.
     */
    orderBy?: campanacasosOrderByWithRelationInput | campanacasosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanacasos.
     */
    cursor?: campanacasosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanacasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanacasos.
     */
    skip?: number
    distinct?: CampanacasosScalarFieldEnum | CampanacasosScalarFieldEnum[]
  }


  /**
   * campanacasos create
   */
  export type campanacasosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * The data needed to create a campanacasos.
     */
    data?: XOR<campanacasosCreateInput, campanacasosUncheckedCreateInput>
  }


  /**
   * campanacasos createMany
   */
  export type campanacasosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanacasos.
     */
    data: campanacasosCreateManyInput | campanacasosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * campanacasos update
   */
  export type campanacasosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * The data needed to update a campanacasos.
     */
    data: XOR<campanacasosUpdateInput, campanacasosUncheckedUpdateInput>
    /**
     * Choose, which campanacasos to update.
     */
    where: campanacasosWhereUniqueInput
  }


  /**
   * campanacasos updateMany
   */
  export type campanacasosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanacasos.
     */
    data: XOR<campanacasosUpdateManyMutationInput, campanacasosUncheckedUpdateManyInput>
    /**
     * Filter which campanacasos to update
     */
    where?: campanacasosWhereInput
  }


  /**
   * campanacasos upsert
   */
  export type campanacasosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * The filter to search for the campanacasos to update in case it exists.
     */
    where: campanacasosWhereUniqueInput
    /**
     * In case the campanacasos found by the `where` argument doesn't exist, create a new campanacasos with this data.
     */
    create: XOR<campanacasosCreateInput, campanacasosUncheckedCreateInput>
    /**
     * In case the campanacasos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanacasosUpdateInput, campanacasosUncheckedUpdateInput>
  }


  /**
   * campanacasos delete
   */
  export type campanacasosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
    /**
     * Filter which campanacasos to delete.
     */
    where: campanacasosWhereUniqueInput
  }


  /**
   * campanacasos deleteMany
   */
  export type campanacasosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanacasos to delete
     */
    where?: campanacasosWhereInput
  }


  /**
   * campanacasos without action
   */
  export type campanacasosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanacasos
     */
    select?: campanacasosSelect<ExtArgs> | null
  }



  /**
   * Model campanas
   */


  export type AggregateCampanas = {
    _count: CampanasCountAggregateOutputType | null
    _avg: CampanasAvgAggregateOutputType | null
    _sum: CampanasSumAggregateOutputType | null
    _min: CampanasMinAggregateOutputType | null
    _max: CampanasMaxAggregateOutputType | null
  }

  export type CampanasAvgAggregateOutputType = {
    idcampana: number | null
  }

  export type CampanasSumAggregateOutputType = {
    idcampana: number | null
  }

  export type CampanasMinAggregateOutputType = {
    idcampana: number | null
    descripcion: string | null
    operador: string | null
    fecha: Date | null
    empresa: string | null
    sucursal: string | null
  }

  export type CampanasMaxAggregateOutputType = {
    idcampana: number | null
    descripcion: string | null
    operador: string | null
    fecha: Date | null
    empresa: string | null
    sucursal: string | null
  }

  export type CampanasCountAggregateOutputType = {
    idcampana: number
    descripcion: number
    operador: number
    fecha: number
    empresa: number
    sucursal: number
    _all: number
  }


  export type CampanasAvgAggregateInputType = {
    idcampana?: true
  }

  export type CampanasSumAggregateInputType = {
    idcampana?: true
  }

  export type CampanasMinAggregateInputType = {
    idcampana?: true
    descripcion?: true
    operador?: true
    fecha?: true
    empresa?: true
    sucursal?: true
  }

  export type CampanasMaxAggregateInputType = {
    idcampana?: true
    descripcion?: true
    operador?: true
    fecha?: true
    empresa?: true
    sucursal?: true
  }

  export type CampanasCountAggregateInputType = {
    idcampana?: true
    descripcion?: true
    operador?: true
    fecha?: true
    empresa?: true
    sucursal?: true
    _all?: true
  }

  export type CampanasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanas to aggregate.
     */
    where?: campanasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanas to fetch.
     */
    orderBy?: campanasOrderByWithRelationInput | campanasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanas
    **/
    _count?: true | CampanasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampanasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampanasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampanasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampanasMaxAggregateInputType
  }

  export type GetCampanasAggregateType<T extends CampanasAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanas[P]>
      : GetScalarType<T[P], AggregateCampanas[P]>
  }




  export type campanasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: campanasWhereInput
    orderBy?: campanasOrderByWithAggregationInput | campanasOrderByWithAggregationInput[]
    by: CampanasScalarFieldEnum[] | CampanasScalarFieldEnum
    having?: campanasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampanasCountAggregateInputType | true
    _avg?: CampanasAvgAggregateInputType
    _sum?: CampanasSumAggregateInputType
    _min?: CampanasMinAggregateInputType
    _max?: CampanasMaxAggregateInputType
  }


  export type CampanasGroupByOutputType = {
    idcampana: number
    descripcion: string | null
    operador: string | null
    fecha: Date | null
    empresa: string | null
    sucursal: string | null
    _count: CampanasCountAggregateOutputType | null
    _avg: CampanasAvgAggregateOutputType | null
    _sum: CampanasSumAggregateOutputType | null
    _min: CampanasMinAggregateOutputType | null
    _max: CampanasMaxAggregateOutputType | null
  }

  type GetCampanasGroupByPayload<T extends campanasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampanasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampanasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampanasGroupByOutputType[P]>
            : GetScalarType<T[P], CampanasGroupByOutputType[P]>
        }
      >
    >


  export type campanasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcampana?: boolean
    descripcion?: boolean
    operador?: boolean
    fecha?: boolean
    empresa?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["campanas"]>

  export type campanasSelectScalar = {
    idcampana?: boolean
    descripcion?: boolean
    operador?: boolean
    fecha?: boolean
    empresa?: boolean
    sucursal?: boolean
  }


  type campanasGetPayload<S extends boolean | null | undefined | campanasArgs> = $Types.GetResult<campanasPayload, S>

  type campanasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<campanasFindManyArgs, 'select' | 'include'> & {
      select?: CampanasCountAggregateInputType | true
    }

  export interface campanasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanas'], meta: { name: 'campanas' } }
    /**
     * Find zero or one Campanas that matches the filter.
     * @param {campanasFindUniqueArgs} args - Arguments to find a Campanas
     * @example
     * // Get one Campanas
     * const campanas = await prisma.campanas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends campanasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, campanasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'campanas'> extends True ? Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Campanas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {campanasFindUniqueOrThrowArgs} args - Arguments to find a Campanas
     * @example
     * // Get one Campanas
     * const campanas = await prisma.campanas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends campanasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Campanas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasFindFirstArgs} args - Arguments to find a Campanas
     * @example
     * // Get one Campanas
     * const campanas = await prisma.campanas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends campanasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, campanasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'campanas'> extends True ? Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Campanas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasFindFirstOrThrowArgs} args - Arguments to find a Campanas
     * @example
     * // Get one Campanas
     * const campanas = await prisma.campanas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends campanasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Campanas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanas
     * const campanas = await prisma.campanas.findMany()
     * 
     * // Get first 10 Campanas
     * const campanas = await prisma.campanas.findMany({ take: 10 })
     * 
     * // Only select the `idcampana`
     * const campanasWithIdcampanaOnly = await prisma.campanas.findMany({ select: { idcampana: true } })
     * 
    **/
    findMany<T extends campanasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<campanasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Campanas.
     * @param {campanasCreateArgs} args - Arguments to create a Campanas.
     * @example
     * // Create one Campanas
     * const Campanas = await prisma.campanas.create({
     *   data: {
     *     // ... data to create a Campanas
     *   }
     * })
     * 
    **/
    create<T extends campanasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, campanasCreateArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Campanas.
     *     @param {campanasCreateManyArgs} args - Arguments to create many Campanas.
     *     @example
     *     // Create many Campanas
     *     const campanas = await prisma.campanas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends campanasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campanas.
     * @param {campanasDeleteArgs} args - Arguments to delete one Campanas.
     * @example
     * // Delete one Campanas
     * const Campanas = await prisma.campanas.delete({
     *   where: {
     *     // ... filter to delete one Campanas
     *   }
     * })
     * 
    **/
    delete<T extends campanasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, campanasDeleteArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Campanas.
     * @param {campanasUpdateArgs} args - Arguments to update one Campanas.
     * @example
     * // Update one Campanas
     * const campanas = await prisma.campanas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends campanasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, campanasUpdateArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Campanas.
     * @param {campanasDeleteManyArgs} args - Arguments to filter Campanas to delete.
     * @example
     * // Delete a few Campanas
     * const { count } = await prisma.campanas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends campanasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanas
     * const campanas = await prisma.campanas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends campanasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, campanasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campanas.
     * @param {campanasUpsertArgs} args - Arguments to update or create a Campanas.
     * @example
     * // Update or create a Campanas
     * const campanas = await prisma.campanas.upsert({
     *   create: {
     *     // ... data to create a Campanas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanas we want to update
     *   }
     * })
    **/
    upsert<T extends campanasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, campanasUpsertArgs<ExtArgs>>
    ): Prisma__campanasClient<$Types.GetResult<campanasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Campanas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasCountArgs} args - Arguments to filter Campanas to count.
     * @example
     * // Count the number of Campanas
     * const count = await prisma.campanas.count({
     *   where: {
     *     // ... the filter for the Campanas we want to count
     *   }
     * })
    **/
    count<T extends campanasCountArgs>(
      args?: Subset<T, campanasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampanasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampanasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampanasAggregateArgs>(args: Subset<T, CampanasAggregateArgs>): Prisma.PrismaPromise<GetCampanasAggregateType<T>>

    /**
     * Group by Campanas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanasGroupByArgs['orderBy'] }
        : { orderBy?: campanasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for campanas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__campanasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * campanas base type for findUnique actions
   */
  export type campanasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter, which campanas to fetch.
     */
    where: campanasWhereUniqueInput
  }

  /**
   * campanas findUnique
   */
  export interface campanasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanas findUniqueOrThrow
   */
  export type campanasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter, which campanas to fetch.
     */
    where: campanasWhereUniqueInput
  }


  /**
   * campanas base type for findFirst actions
   */
  export type campanasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter, which campanas to fetch.
     */
    where?: campanasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanas to fetch.
     */
    orderBy?: campanasOrderByWithRelationInput | campanasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanas.
     */
    cursor?: campanasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanas.
     */
    distinct?: CampanasScalarFieldEnum | CampanasScalarFieldEnum[]
  }

  /**
   * campanas findFirst
   */
  export interface campanasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanas findFirstOrThrow
   */
  export type campanasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter, which campanas to fetch.
     */
    where?: campanasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanas to fetch.
     */
    orderBy?: campanasOrderByWithRelationInput | campanasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanas.
     */
    cursor?: campanasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanas.
     */
    distinct?: CampanasScalarFieldEnum | CampanasScalarFieldEnum[]
  }


  /**
   * campanas findMany
   */
  export type campanasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter, which campanas to fetch.
     */
    where?: campanasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanas to fetch.
     */
    orderBy?: campanasOrderByWithRelationInput | campanasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanas.
     */
    cursor?: campanasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanas.
     */
    skip?: number
    distinct?: CampanasScalarFieldEnum | CampanasScalarFieldEnum[]
  }


  /**
   * campanas create
   */
  export type campanasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * The data needed to create a campanas.
     */
    data?: XOR<campanasCreateInput, campanasUncheckedCreateInput>
  }


  /**
   * campanas createMany
   */
  export type campanasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanas.
     */
    data: campanasCreateManyInput | campanasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * campanas update
   */
  export type campanasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * The data needed to update a campanas.
     */
    data: XOR<campanasUpdateInput, campanasUncheckedUpdateInput>
    /**
     * Choose, which campanas to update.
     */
    where: campanasWhereUniqueInput
  }


  /**
   * campanas updateMany
   */
  export type campanasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanas.
     */
    data: XOR<campanasUpdateManyMutationInput, campanasUncheckedUpdateManyInput>
    /**
     * Filter which campanas to update
     */
    where?: campanasWhereInput
  }


  /**
   * campanas upsert
   */
  export type campanasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * The filter to search for the campanas to update in case it exists.
     */
    where: campanasWhereUniqueInput
    /**
     * In case the campanas found by the `where` argument doesn't exist, create a new campanas with this data.
     */
    create: XOR<campanasCreateInput, campanasUncheckedCreateInput>
    /**
     * In case the campanas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanasUpdateInput, campanasUncheckedUpdateInput>
  }


  /**
   * campanas delete
   */
  export type campanasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
    /**
     * Filter which campanas to delete.
     */
    where: campanasWhereUniqueInput
  }


  /**
   * campanas deleteMany
   */
  export type campanasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanas to delete
     */
    where?: campanasWhereInput
  }


  /**
   * campanas without action
   */
  export type campanasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanas
     */
    select?: campanasSelect<ExtArgs> | null
  }



  /**
   * Model campanatemporal
   */


  export type AggregateCampanatemporal = {
    _count: CampanatemporalCountAggregateOutputType | null
    _avg: CampanatemporalAvgAggregateOutputType | null
    _sum: CampanatemporalSumAggregateOutputType | null
    _min: CampanatemporalMinAggregateOutputType | null
    _max: CampanatemporalMaxAggregateOutputType | null
  }

  export type CampanatemporalAvgAggregateOutputType = {
    CONTRATO: number | null
    NRO_DOC: number | null
    NRO_CALLE: number | null
    GRUPO: number | null
    ZONA: number | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    idcaso: number | null
  }

  export type CampanatemporalSumAggregateOutputType = {
    CONTRATO: number | null
    NRO_DOC: number | null
    NRO_CALLE: number | null
    GRUPO: number | null
    ZONA: number | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    idcaso: number | null
  }

  export type CampanatemporalMinAggregateOutputType = {
    SUCURSAL: string | null
    CONTRATO: number | null
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    ALTA: Date | null
    VIGENCIA: Date | null
    CALLE: string | null
    NRO_CALLE: number | null
    BARRIO: string | null
    LOCALIDAD: string | null
    GRUPO: number | null
    ZONA: number | null
    TELEFONO: string | null
    MOVIL: string | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    operador: string | null
    estado: boolean | null
    idcaso: number | null
    observacion: string | null
    fecha: string | null
    fecha_observacion: string | null
    accion: string | null
  }

  export type CampanatemporalMaxAggregateOutputType = {
    SUCURSAL: string | null
    CONTRATO: number | null
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    ALTA: Date | null
    VIGENCIA: Date | null
    CALLE: string | null
    NRO_CALLE: number | null
    BARRIO: string | null
    LOCALIDAD: string | null
    GRUPO: number | null
    ZONA: number | null
    TELEFONO: string | null
    MOVIL: string | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    operador: string | null
    estado: boolean | null
    idcaso: number | null
    observacion: string | null
    fecha: string | null
    fecha_observacion: string | null
    accion: string | null
  }

  export type CampanatemporalCountAggregateOutputType = {
    SUCURSAL: number
    CONTRATO: number
    NRO_DOC: number
    APELLIDOS: number
    NOMBRES: number
    ALTA: number
    VIGENCIA: number
    CALLE: number
    NRO_CALLE: number
    BARRIO: number
    LOCALIDAD: number
    GRUPO: number
    ZONA: number
    TELEFONO: number
    MOVIL: number
    EDAD: number
    MES: number
    ANO: number
    IMPORTE: number
    operador: number
    estado: number
    idcaso: number
    observacion: number
    fecha: number
    fecha_observacion: number
    accion: number
    _all: number
  }


  export type CampanatemporalAvgAggregateInputType = {
    CONTRATO?: true
    NRO_DOC?: true
    NRO_CALLE?: true
    GRUPO?: true
    ZONA?: true
    EDAD?: true
    MES?: true
    ANO?: true
    IMPORTE?: true
    idcaso?: true
  }

  export type CampanatemporalSumAggregateInputType = {
    CONTRATO?: true
    NRO_DOC?: true
    NRO_CALLE?: true
    GRUPO?: true
    ZONA?: true
    EDAD?: true
    MES?: true
    ANO?: true
    IMPORTE?: true
    idcaso?: true
  }

  export type CampanatemporalMinAggregateInputType = {
    SUCURSAL?: true
    CONTRATO?: true
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    ALTA?: true
    VIGENCIA?: true
    CALLE?: true
    NRO_CALLE?: true
    BARRIO?: true
    LOCALIDAD?: true
    GRUPO?: true
    ZONA?: true
    TELEFONO?: true
    MOVIL?: true
    EDAD?: true
    MES?: true
    ANO?: true
    IMPORTE?: true
    operador?: true
    estado?: true
    idcaso?: true
    observacion?: true
    fecha?: true
    fecha_observacion?: true
    accion?: true
  }

  export type CampanatemporalMaxAggregateInputType = {
    SUCURSAL?: true
    CONTRATO?: true
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    ALTA?: true
    VIGENCIA?: true
    CALLE?: true
    NRO_CALLE?: true
    BARRIO?: true
    LOCALIDAD?: true
    GRUPO?: true
    ZONA?: true
    TELEFONO?: true
    MOVIL?: true
    EDAD?: true
    MES?: true
    ANO?: true
    IMPORTE?: true
    operador?: true
    estado?: true
    idcaso?: true
    observacion?: true
    fecha?: true
    fecha_observacion?: true
    accion?: true
  }

  export type CampanatemporalCountAggregateInputType = {
    SUCURSAL?: true
    CONTRATO?: true
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    ALTA?: true
    VIGENCIA?: true
    CALLE?: true
    NRO_CALLE?: true
    BARRIO?: true
    LOCALIDAD?: true
    GRUPO?: true
    ZONA?: true
    TELEFONO?: true
    MOVIL?: true
    EDAD?: true
    MES?: true
    ANO?: true
    IMPORTE?: true
    operador?: true
    estado?: true
    idcaso?: true
    observacion?: true
    fecha?: true
    fecha_observacion?: true
    accion?: true
    _all?: true
  }

  export type CampanatemporalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanatemporal to aggregate.
     */
    where?: campanatemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanatemporals to fetch.
     */
    orderBy?: campanatemporalOrderByWithRelationInput | campanatemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campanatemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanatemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanatemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campanatemporals
    **/
    _count?: true | CampanatemporalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampanatemporalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampanatemporalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampanatemporalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampanatemporalMaxAggregateInputType
  }

  export type GetCampanatemporalAggregateType<T extends CampanatemporalAggregateArgs> = {
        [P in keyof T & keyof AggregateCampanatemporal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampanatemporal[P]>
      : GetScalarType<T[P], AggregateCampanatemporal[P]>
  }




  export type campanatemporalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: campanatemporalWhereInput
    orderBy?: campanatemporalOrderByWithAggregationInput | campanatemporalOrderByWithAggregationInput[]
    by: CampanatemporalScalarFieldEnum[] | CampanatemporalScalarFieldEnum
    having?: campanatemporalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampanatemporalCountAggregateInputType | true
    _avg?: CampanatemporalAvgAggregateInputType
    _sum?: CampanatemporalSumAggregateInputType
    _min?: CampanatemporalMinAggregateInputType
    _max?: CampanatemporalMaxAggregateInputType
  }


  export type CampanatemporalGroupByOutputType = {
    SUCURSAL: string | null
    CONTRATO: number
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    ALTA: Date | null
    VIGENCIA: Date | null
    CALLE: string | null
    NRO_CALLE: number | null
    BARRIO: string | null
    LOCALIDAD: string | null
    GRUPO: number | null
    ZONA: number | null
    TELEFONO: string | null
    MOVIL: string | null
    EDAD: number | null
    MES: number | null
    ANO: number | null
    IMPORTE: number | null
    operador: string | null
    estado: boolean | null
    idcaso: number
    observacion: string | null
    fecha: string | null
    fecha_observacion: string | null
    accion: string | null
    _count: CampanatemporalCountAggregateOutputType | null
    _avg: CampanatemporalAvgAggregateOutputType | null
    _sum: CampanatemporalSumAggregateOutputType | null
    _min: CampanatemporalMinAggregateOutputType | null
    _max: CampanatemporalMaxAggregateOutputType | null
  }

  type GetCampanatemporalGroupByPayload<T extends campanatemporalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampanatemporalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampanatemporalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampanatemporalGroupByOutputType[P]>
            : GetScalarType<T[P], CampanatemporalGroupByOutputType[P]>
        }
      >
    >


  export type campanatemporalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SUCURSAL?: boolean
    CONTRATO?: boolean
    NRO_DOC?: boolean
    APELLIDOS?: boolean
    NOMBRES?: boolean
    ALTA?: boolean
    VIGENCIA?: boolean
    CALLE?: boolean
    NRO_CALLE?: boolean
    BARRIO?: boolean
    LOCALIDAD?: boolean
    GRUPO?: boolean
    ZONA?: boolean
    TELEFONO?: boolean
    MOVIL?: boolean
    EDAD?: boolean
    MES?: boolean
    ANO?: boolean
    IMPORTE?: boolean
    operador?: boolean
    estado?: boolean
    idcaso?: boolean
    observacion?: boolean
    fecha?: boolean
    fecha_observacion?: boolean
    accion?: boolean
  }, ExtArgs["result"]["campanatemporal"]>

  export type campanatemporalSelectScalar = {
    SUCURSAL?: boolean
    CONTRATO?: boolean
    NRO_DOC?: boolean
    APELLIDOS?: boolean
    NOMBRES?: boolean
    ALTA?: boolean
    VIGENCIA?: boolean
    CALLE?: boolean
    NRO_CALLE?: boolean
    BARRIO?: boolean
    LOCALIDAD?: boolean
    GRUPO?: boolean
    ZONA?: boolean
    TELEFONO?: boolean
    MOVIL?: boolean
    EDAD?: boolean
    MES?: boolean
    ANO?: boolean
    IMPORTE?: boolean
    operador?: boolean
    estado?: boolean
    idcaso?: boolean
    observacion?: boolean
    fecha?: boolean
    fecha_observacion?: boolean
    accion?: boolean
  }


  type campanatemporalGetPayload<S extends boolean | null | undefined | campanatemporalArgs> = $Types.GetResult<campanatemporalPayload, S>

  type campanatemporalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<campanatemporalFindManyArgs, 'select' | 'include'> & {
      select?: CampanatemporalCountAggregateInputType | true
    }

  export interface campanatemporalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campanatemporal'], meta: { name: 'campanatemporal' } }
    /**
     * Find zero or one Campanatemporal that matches the filter.
     * @param {campanatemporalFindUniqueArgs} args - Arguments to find a Campanatemporal
     * @example
     * // Get one Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends campanatemporalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, campanatemporalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'campanatemporal'> extends True ? Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Campanatemporal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {campanatemporalFindUniqueOrThrowArgs} args - Arguments to find a Campanatemporal
     * @example
     * // Get one Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends campanatemporalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanatemporalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Campanatemporal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalFindFirstArgs} args - Arguments to find a Campanatemporal
     * @example
     * // Get one Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends campanatemporalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, campanatemporalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'campanatemporal'> extends True ? Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Campanatemporal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalFindFirstOrThrowArgs} args - Arguments to find a Campanatemporal
     * @example
     * // Get one Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends campanatemporalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, campanatemporalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Campanatemporals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanatemporals
     * const campanatemporals = await prisma.campanatemporal.findMany()
     * 
     * // Get first 10 Campanatemporals
     * const campanatemporals = await prisma.campanatemporal.findMany({ take: 10 })
     * 
     * // Only select the `SUCURSAL`
     * const campanatemporalWithSUCURSALOnly = await prisma.campanatemporal.findMany({ select: { SUCURSAL: true } })
     * 
    **/
    findMany<T extends campanatemporalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanatemporalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Campanatemporal.
     * @param {campanatemporalCreateArgs} args - Arguments to create a Campanatemporal.
     * @example
     * // Create one Campanatemporal
     * const Campanatemporal = await prisma.campanatemporal.create({
     *   data: {
     *     // ... data to create a Campanatemporal
     *   }
     * })
     * 
    **/
    create<T extends campanatemporalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, campanatemporalCreateArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Campanatemporals.
     *     @param {campanatemporalCreateManyArgs} args - Arguments to create many Campanatemporals.
     *     @example
     *     // Create many Campanatemporals
     *     const campanatemporal = await prisma.campanatemporal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends campanatemporalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanatemporalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campanatemporal.
     * @param {campanatemporalDeleteArgs} args - Arguments to delete one Campanatemporal.
     * @example
     * // Delete one Campanatemporal
     * const Campanatemporal = await prisma.campanatemporal.delete({
     *   where: {
     *     // ... filter to delete one Campanatemporal
     *   }
     * })
     * 
    **/
    delete<T extends campanatemporalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, campanatemporalDeleteArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Campanatemporal.
     * @param {campanatemporalUpdateArgs} args - Arguments to update one Campanatemporal.
     * @example
     * // Update one Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends campanatemporalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, campanatemporalUpdateArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Campanatemporals.
     * @param {campanatemporalDeleteManyArgs} args - Arguments to filter Campanatemporals to delete.
     * @example
     * // Delete a few Campanatemporals
     * const { count } = await prisma.campanatemporal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends campanatemporalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, campanatemporalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanatemporals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanatemporals
     * const campanatemporal = await prisma.campanatemporal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends campanatemporalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, campanatemporalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campanatemporal.
     * @param {campanatemporalUpsertArgs} args - Arguments to update or create a Campanatemporal.
     * @example
     * // Update or create a Campanatemporal
     * const campanatemporal = await prisma.campanatemporal.upsert({
     *   create: {
     *     // ... data to create a Campanatemporal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campanatemporal we want to update
     *   }
     * })
    **/
    upsert<T extends campanatemporalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, campanatemporalUpsertArgs<ExtArgs>>
    ): Prisma__campanatemporalClient<$Types.GetResult<campanatemporalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Campanatemporals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalCountArgs} args - Arguments to filter Campanatemporals to count.
     * @example
     * // Count the number of Campanatemporals
     * const count = await prisma.campanatemporal.count({
     *   where: {
     *     // ... the filter for the Campanatemporals we want to count
     *   }
     * })
    **/
    count<T extends campanatemporalCountArgs>(
      args?: Subset<T, campanatemporalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampanatemporalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campanatemporal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampanatemporalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampanatemporalAggregateArgs>(args: Subset<T, CampanatemporalAggregateArgs>): Prisma.PrismaPromise<GetCampanatemporalAggregateType<T>>

    /**
     * Group by Campanatemporal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campanatemporalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campanatemporalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campanatemporalGroupByArgs['orderBy'] }
        : { orderBy?: campanatemporalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campanatemporalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampanatemporalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for campanatemporal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__campanatemporalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * campanatemporal base type for findUnique actions
   */
  export type campanatemporalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter, which campanatemporal to fetch.
     */
    where: campanatemporalWhereUniqueInput
  }

  /**
   * campanatemporal findUnique
   */
  export interface campanatemporalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanatemporalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanatemporal findUniqueOrThrow
   */
  export type campanatemporalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter, which campanatemporal to fetch.
     */
    where: campanatemporalWhereUniqueInput
  }


  /**
   * campanatemporal base type for findFirst actions
   */
  export type campanatemporalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter, which campanatemporal to fetch.
     */
    where?: campanatemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanatemporals to fetch.
     */
    orderBy?: campanatemporalOrderByWithRelationInput | campanatemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanatemporals.
     */
    cursor?: campanatemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanatemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanatemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanatemporals.
     */
    distinct?: CampanatemporalScalarFieldEnum | CampanatemporalScalarFieldEnum[]
  }

  /**
   * campanatemporal findFirst
   */
  export interface campanatemporalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends campanatemporalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * campanatemporal findFirstOrThrow
   */
  export type campanatemporalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter, which campanatemporal to fetch.
     */
    where?: campanatemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanatemporals to fetch.
     */
    orderBy?: campanatemporalOrderByWithRelationInput | campanatemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campanatemporals.
     */
    cursor?: campanatemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanatemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanatemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campanatemporals.
     */
    distinct?: CampanatemporalScalarFieldEnum | CampanatemporalScalarFieldEnum[]
  }


  /**
   * campanatemporal findMany
   */
  export type campanatemporalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter, which campanatemporals to fetch.
     */
    where?: campanatemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campanatemporals to fetch.
     */
    orderBy?: campanatemporalOrderByWithRelationInput | campanatemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campanatemporals.
     */
    cursor?: campanatemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campanatemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campanatemporals.
     */
    skip?: number
    distinct?: CampanatemporalScalarFieldEnum | CampanatemporalScalarFieldEnum[]
  }


  /**
   * campanatemporal create
   */
  export type campanatemporalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * The data needed to create a campanatemporal.
     */
    data: XOR<campanatemporalCreateInput, campanatemporalUncheckedCreateInput>
  }


  /**
   * campanatemporal createMany
   */
  export type campanatemporalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campanatemporals.
     */
    data: campanatemporalCreateManyInput | campanatemporalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * campanatemporal update
   */
  export type campanatemporalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * The data needed to update a campanatemporal.
     */
    data: XOR<campanatemporalUpdateInput, campanatemporalUncheckedUpdateInput>
    /**
     * Choose, which campanatemporal to update.
     */
    where: campanatemporalWhereUniqueInput
  }


  /**
   * campanatemporal updateMany
   */
  export type campanatemporalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campanatemporals.
     */
    data: XOR<campanatemporalUpdateManyMutationInput, campanatemporalUncheckedUpdateManyInput>
    /**
     * Filter which campanatemporals to update
     */
    where?: campanatemporalWhereInput
  }


  /**
   * campanatemporal upsert
   */
  export type campanatemporalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * The filter to search for the campanatemporal to update in case it exists.
     */
    where: campanatemporalWhereUniqueInput
    /**
     * In case the campanatemporal found by the `where` argument doesn't exist, create a new campanatemporal with this data.
     */
    create: XOR<campanatemporalCreateInput, campanatemporalUncheckedCreateInput>
    /**
     * In case the campanatemporal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campanatemporalUpdateInput, campanatemporalUncheckedUpdateInput>
  }


  /**
   * campanatemporal delete
   */
  export type campanatemporalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
    /**
     * Filter which campanatemporal to delete.
     */
    where: campanatemporalWhereUniqueInput
  }


  /**
   * campanatemporal deleteMany
   */
  export type campanatemporalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which campanatemporals to delete
     */
    where?: campanatemporalWhereInput
  }


  /**
   * campanatemporal without action
   */
  export type campanatemporalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campanatemporal
     */
    select?: campanatemporalSelect<ExtArgs> | null
  }



  /**
   * Model capital_prestamo
   */


  export type AggregateCapital_prestamo = {
    _count: Capital_prestamoCountAggregateOutputType | null
    _avg: Capital_prestamoAvgAggregateOutputType | null
    _sum: Capital_prestamoSumAggregateOutputType | null
    _min: Capital_prestamoMinAggregateOutputType | null
    _max: Capital_prestamoMaxAggregateOutputType | null
  }

  export type Capital_prestamoAvgAggregateOutputType = {
    idcapital: number | null
    capital: number | null
  }

  export type Capital_prestamoSumAggregateOutputType = {
    idcapital: number | null
    capital: number | null
  }

  export type Capital_prestamoMinAggregateOutputType = {
    idcapital: number | null
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }

  export type Capital_prestamoMaxAggregateOutputType = {
    idcapital: number | null
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }

  export type Capital_prestamoCountAggregateOutputType = {
    idcapital: number
    capital: number
    fecha: number
    estado: number
    autorizacion: number
    _all: number
  }


  export type Capital_prestamoAvgAggregateInputType = {
    idcapital?: true
    capital?: true
  }

  export type Capital_prestamoSumAggregateInputType = {
    idcapital?: true
    capital?: true
  }

  export type Capital_prestamoMinAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
  }

  export type Capital_prestamoMaxAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
  }

  export type Capital_prestamoCountAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
    _all?: true
  }

  export type Capital_prestamoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which capital_prestamo to aggregate.
     */
    where?: capital_prestamoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamos to fetch.
     */
    orderBy?: capital_prestamoOrderByWithRelationInput | capital_prestamoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capital_prestamoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capital_prestamos
    **/
    _count?: true | Capital_prestamoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capital_prestamoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capital_prestamoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capital_prestamoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capital_prestamoMaxAggregateInputType
  }

  export type GetCapital_prestamoAggregateType<T extends Capital_prestamoAggregateArgs> = {
        [P in keyof T & keyof AggregateCapital_prestamo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapital_prestamo[P]>
      : GetScalarType<T[P], AggregateCapital_prestamo[P]>
  }




  export type capital_prestamoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: capital_prestamoWhereInput
    orderBy?: capital_prestamoOrderByWithAggregationInput | capital_prestamoOrderByWithAggregationInput[]
    by: Capital_prestamoScalarFieldEnum[] | Capital_prestamoScalarFieldEnum
    having?: capital_prestamoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capital_prestamoCountAggregateInputType | true
    _avg?: Capital_prestamoAvgAggregateInputType
    _sum?: Capital_prestamoSumAggregateInputType
    _min?: Capital_prestamoMinAggregateInputType
    _max?: Capital_prestamoMaxAggregateInputType
  }


  export type Capital_prestamoGroupByOutputType = {
    idcapital: number
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
    _count: Capital_prestamoCountAggregateOutputType | null
    _avg: Capital_prestamoAvgAggregateOutputType | null
    _sum: Capital_prestamoSumAggregateOutputType | null
    _min: Capital_prestamoMinAggregateOutputType | null
    _max: Capital_prestamoMaxAggregateOutputType | null
  }

  type GetCapital_prestamoGroupByPayload<T extends capital_prestamoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capital_prestamoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capital_prestamoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capital_prestamoGroupByOutputType[P]>
            : GetScalarType<T[P], Capital_prestamoGroupByOutputType[P]>
        }
      >
    >


  export type capital_prestamoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcapital?: boolean
    capital?: boolean
    fecha?: boolean
    estado?: boolean
    autorizacion?: boolean
  }, ExtArgs["result"]["capital_prestamo"]>

  export type capital_prestamoSelectScalar = {
    idcapital?: boolean
    capital?: boolean
    fecha?: boolean
    estado?: boolean
    autorizacion?: boolean
  }


  type capital_prestamoGetPayload<S extends boolean | null | undefined | capital_prestamoArgs> = $Types.GetResult<capital_prestamoPayload, S>

  type capital_prestamoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<capital_prestamoFindManyArgs, 'select' | 'include'> & {
      select?: Capital_prestamoCountAggregateInputType | true
    }

  export interface capital_prestamoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capital_prestamo'], meta: { name: 'capital_prestamo' } }
    /**
     * Find zero or one Capital_prestamo that matches the filter.
     * @param {capital_prestamoFindUniqueArgs} args - Arguments to find a Capital_prestamo
     * @example
     * // Get one Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends capital_prestamoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, capital_prestamoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'capital_prestamo'> extends True ? Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Capital_prestamo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {capital_prestamoFindUniqueOrThrowArgs} args - Arguments to find a Capital_prestamo
     * @example
     * // Get one Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends capital_prestamoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Capital_prestamo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoFindFirstArgs} args - Arguments to find a Capital_prestamo
     * @example
     * // Get one Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends capital_prestamoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, capital_prestamoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'capital_prestamo'> extends True ? Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Capital_prestamo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoFindFirstOrThrowArgs} args - Arguments to find a Capital_prestamo
     * @example
     * // Get one Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends capital_prestamoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Capital_prestamos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capital_prestamos
     * const capital_prestamos = await prisma.capital_prestamo.findMany()
     * 
     * // Get first 10 Capital_prestamos
     * const capital_prestamos = await prisma.capital_prestamo.findMany({ take: 10 })
     * 
     * // Only select the `idcapital`
     * const capital_prestamoWithIdcapitalOnly = await prisma.capital_prestamo.findMany({ select: { idcapital: true } })
     * 
    **/
    findMany<T extends capital_prestamoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Capital_prestamo.
     * @param {capital_prestamoCreateArgs} args - Arguments to create a Capital_prestamo.
     * @example
     * // Create one Capital_prestamo
     * const Capital_prestamo = await prisma.capital_prestamo.create({
     *   data: {
     *     // ... data to create a Capital_prestamo
     *   }
     * })
     * 
    **/
    create<T extends capital_prestamoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamoCreateArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Capital_prestamos.
     *     @param {capital_prestamoCreateManyArgs} args - Arguments to create many Capital_prestamos.
     *     @example
     *     // Create many Capital_prestamos
     *     const capital_prestamo = await prisma.capital_prestamo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends capital_prestamoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capital_prestamo.
     * @param {capital_prestamoDeleteArgs} args - Arguments to delete one Capital_prestamo.
     * @example
     * // Delete one Capital_prestamo
     * const Capital_prestamo = await prisma.capital_prestamo.delete({
     *   where: {
     *     // ... filter to delete one Capital_prestamo
     *   }
     * })
     * 
    **/
    delete<T extends capital_prestamoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamoDeleteArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Capital_prestamo.
     * @param {capital_prestamoUpdateArgs} args - Arguments to update one Capital_prestamo.
     * @example
     * // Update one Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends capital_prestamoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamoUpdateArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Capital_prestamos.
     * @param {capital_prestamoDeleteManyArgs} args - Arguments to filter Capital_prestamos to delete.
     * @example
     * // Delete a few Capital_prestamos
     * const { count } = await prisma.capital_prestamo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends capital_prestamoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capital_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capital_prestamos
     * const capital_prestamo = await prisma.capital_prestamo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends capital_prestamoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capital_prestamo.
     * @param {capital_prestamoUpsertArgs} args - Arguments to update or create a Capital_prestamo.
     * @example
     * // Update or create a Capital_prestamo
     * const capital_prestamo = await prisma.capital_prestamo.upsert({
     *   create: {
     *     // ... data to create a Capital_prestamo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capital_prestamo we want to update
     *   }
     * })
    **/
    upsert<T extends capital_prestamoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamoUpsertArgs<ExtArgs>>
    ): Prisma__capital_prestamoClient<$Types.GetResult<capital_prestamoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Capital_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoCountArgs} args - Arguments to filter Capital_prestamos to count.
     * @example
     * // Count the number of Capital_prestamos
     * const count = await prisma.capital_prestamo.count({
     *   where: {
     *     // ... the filter for the Capital_prestamos we want to count
     *   }
     * })
    **/
    count<T extends capital_prestamoCountArgs>(
      args?: Subset<T, capital_prestamoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capital_prestamoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capital_prestamo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capital_prestamoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capital_prestamoAggregateArgs>(args: Subset<T, Capital_prestamoAggregateArgs>): Prisma.PrismaPromise<GetCapital_prestamoAggregateType<T>>

    /**
     * Group by Capital_prestamo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capital_prestamoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capital_prestamoGroupByArgs['orderBy'] }
        : { orderBy?: capital_prestamoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capital_prestamoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapital_prestamoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for capital_prestamo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__capital_prestamoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * capital_prestamo base type for findUnique actions
   */
  export type capital_prestamoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo to fetch.
     */
    where: capital_prestamoWhereUniqueInput
  }

  /**
   * capital_prestamo findUnique
   */
  export interface capital_prestamoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends capital_prestamoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * capital_prestamo findUniqueOrThrow
   */
  export type capital_prestamoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo to fetch.
     */
    where: capital_prestamoWhereUniqueInput
  }


  /**
   * capital_prestamo base type for findFirst actions
   */
  export type capital_prestamoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo to fetch.
     */
    where?: capital_prestamoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamos to fetch.
     */
    orderBy?: capital_prestamoOrderByWithRelationInput | capital_prestamoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capital_prestamos.
     */
    cursor?: capital_prestamoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capital_prestamos.
     */
    distinct?: Capital_prestamoScalarFieldEnum | Capital_prestamoScalarFieldEnum[]
  }

  /**
   * capital_prestamo findFirst
   */
  export interface capital_prestamoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends capital_prestamoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * capital_prestamo findFirstOrThrow
   */
  export type capital_prestamoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo to fetch.
     */
    where?: capital_prestamoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamos to fetch.
     */
    orderBy?: capital_prestamoOrderByWithRelationInput | capital_prestamoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capital_prestamos.
     */
    cursor?: capital_prestamoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capital_prestamos.
     */
    distinct?: Capital_prestamoScalarFieldEnum | Capital_prestamoScalarFieldEnum[]
  }


  /**
   * capital_prestamo findMany
   */
  export type capital_prestamoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamos to fetch.
     */
    where?: capital_prestamoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamos to fetch.
     */
    orderBy?: capital_prestamoOrderByWithRelationInput | capital_prestamoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capital_prestamos.
     */
    cursor?: capital_prestamoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamos.
     */
    skip?: number
    distinct?: Capital_prestamoScalarFieldEnum | Capital_prestamoScalarFieldEnum[]
  }


  /**
   * capital_prestamo create
   */
  export type capital_prestamoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * The data needed to create a capital_prestamo.
     */
    data?: XOR<capital_prestamoCreateInput, capital_prestamoUncheckedCreateInput>
  }


  /**
   * capital_prestamo createMany
   */
  export type capital_prestamoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capital_prestamos.
     */
    data: capital_prestamoCreateManyInput | capital_prestamoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * capital_prestamo update
   */
  export type capital_prestamoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * The data needed to update a capital_prestamo.
     */
    data: XOR<capital_prestamoUpdateInput, capital_prestamoUncheckedUpdateInput>
    /**
     * Choose, which capital_prestamo to update.
     */
    where: capital_prestamoWhereUniqueInput
  }


  /**
   * capital_prestamo updateMany
   */
  export type capital_prestamoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capital_prestamos.
     */
    data: XOR<capital_prestamoUpdateManyMutationInput, capital_prestamoUncheckedUpdateManyInput>
    /**
     * Filter which capital_prestamos to update
     */
    where?: capital_prestamoWhereInput
  }


  /**
   * capital_prestamo upsert
   */
  export type capital_prestamoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * The filter to search for the capital_prestamo to update in case it exists.
     */
    where: capital_prestamoWhereUniqueInput
    /**
     * In case the capital_prestamo found by the `where` argument doesn't exist, create a new capital_prestamo with this data.
     */
    create: XOR<capital_prestamoCreateInput, capital_prestamoUncheckedCreateInput>
    /**
     * In case the capital_prestamo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capital_prestamoUpdateInput, capital_prestamoUncheckedUpdateInput>
  }


  /**
   * capital_prestamo delete
   */
  export type capital_prestamoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
    /**
     * Filter which capital_prestamo to delete.
     */
    where: capital_prestamoWhereUniqueInput
  }


  /**
   * capital_prestamo deleteMany
   */
  export type capital_prestamoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which capital_prestamos to delete
     */
    where?: capital_prestamoWhereInput
  }


  /**
   * capital_prestamo without action
   */
  export type capital_prestamoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo
     */
    select?: capital_prestamoSelect<ExtArgs> | null
  }



  /**
   * Model capital_prestamo_empleados
   */


  export type AggregateCapital_prestamo_empleados = {
    _count: Capital_prestamo_empleadosCountAggregateOutputType | null
    _avg: Capital_prestamo_empleadosAvgAggregateOutputType | null
    _sum: Capital_prestamo_empleadosSumAggregateOutputType | null
    _min: Capital_prestamo_empleadosMinAggregateOutputType | null
    _max: Capital_prestamo_empleadosMaxAggregateOutputType | null
  }

  export type Capital_prestamo_empleadosAvgAggregateOutputType = {
    idcapital: number | null
    capital: number | null
  }

  export type Capital_prestamo_empleadosSumAggregateOutputType = {
    idcapital: number | null
    capital: number | null
  }

  export type Capital_prestamo_empleadosMinAggregateOutputType = {
    idcapital: number | null
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }

  export type Capital_prestamo_empleadosMaxAggregateOutputType = {
    idcapital: number | null
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
  }

  export type Capital_prestamo_empleadosCountAggregateOutputType = {
    idcapital: number
    capital: number
    fecha: number
    estado: number
    autorizacion: number
    _all: number
  }


  export type Capital_prestamo_empleadosAvgAggregateInputType = {
    idcapital?: true
    capital?: true
  }

  export type Capital_prestamo_empleadosSumAggregateInputType = {
    idcapital?: true
    capital?: true
  }

  export type Capital_prestamo_empleadosMinAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
  }

  export type Capital_prestamo_empleadosMaxAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
  }

  export type Capital_prestamo_empleadosCountAggregateInputType = {
    idcapital?: true
    capital?: true
    fecha?: true
    estado?: true
    autorizacion?: true
    _all?: true
  }

  export type Capital_prestamo_empleadosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which capital_prestamo_empleados to aggregate.
     */
    where?: capital_prestamo_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamo_empleados to fetch.
     */
    orderBy?: capital_prestamo_empleadosOrderByWithRelationInput | capital_prestamo_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capital_prestamo_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamo_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamo_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capital_prestamo_empleados
    **/
    _count?: true | Capital_prestamo_empleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Capital_prestamo_empleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Capital_prestamo_empleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Capital_prestamo_empleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Capital_prestamo_empleadosMaxAggregateInputType
  }

  export type GetCapital_prestamo_empleadosAggregateType<T extends Capital_prestamo_empleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateCapital_prestamo_empleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapital_prestamo_empleados[P]>
      : GetScalarType<T[P], AggregateCapital_prestamo_empleados[P]>
  }




  export type capital_prestamo_empleadosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: capital_prestamo_empleadosWhereInput
    orderBy?: capital_prestamo_empleadosOrderByWithAggregationInput | capital_prestamo_empleadosOrderByWithAggregationInput[]
    by: Capital_prestamo_empleadosScalarFieldEnum[] | Capital_prestamo_empleadosScalarFieldEnum
    having?: capital_prestamo_empleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Capital_prestamo_empleadosCountAggregateInputType | true
    _avg?: Capital_prestamo_empleadosAvgAggregateInputType
    _sum?: Capital_prestamo_empleadosSumAggregateInputType
    _min?: Capital_prestamo_empleadosMinAggregateInputType
    _max?: Capital_prestamo_empleadosMaxAggregateInputType
  }


  export type Capital_prestamo_empleadosGroupByOutputType = {
    idcapital: number
    capital: number | null
    fecha: Date | null
    estado: boolean | null
    autorizacion: boolean | null
    _count: Capital_prestamo_empleadosCountAggregateOutputType | null
    _avg: Capital_prestamo_empleadosAvgAggregateOutputType | null
    _sum: Capital_prestamo_empleadosSumAggregateOutputType | null
    _min: Capital_prestamo_empleadosMinAggregateOutputType | null
    _max: Capital_prestamo_empleadosMaxAggregateOutputType | null
  }

  type GetCapital_prestamo_empleadosGroupByPayload<T extends capital_prestamo_empleadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Capital_prestamo_empleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Capital_prestamo_empleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Capital_prestamo_empleadosGroupByOutputType[P]>
            : GetScalarType<T[P], Capital_prestamo_empleadosGroupByOutputType[P]>
        }
      >
    >


  export type capital_prestamo_empleadosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcapital?: boolean
    capital?: boolean
    fecha?: boolean
    estado?: boolean
    autorizacion?: boolean
  }, ExtArgs["result"]["capital_prestamo_empleados"]>

  export type capital_prestamo_empleadosSelectScalar = {
    idcapital?: boolean
    capital?: boolean
    fecha?: boolean
    estado?: boolean
    autorizacion?: boolean
  }


  type capital_prestamo_empleadosGetPayload<S extends boolean | null | undefined | capital_prestamo_empleadosArgs> = $Types.GetResult<capital_prestamo_empleadosPayload, S>

  type capital_prestamo_empleadosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<capital_prestamo_empleadosFindManyArgs, 'select' | 'include'> & {
      select?: Capital_prestamo_empleadosCountAggregateInputType | true
    }

  export interface capital_prestamo_empleadosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capital_prestamo_empleados'], meta: { name: 'capital_prestamo_empleados' } }
    /**
     * Find zero or one Capital_prestamo_empleados that matches the filter.
     * @param {capital_prestamo_empleadosFindUniqueArgs} args - Arguments to find a Capital_prestamo_empleados
     * @example
     * // Get one Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends capital_prestamo_empleadosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, capital_prestamo_empleadosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'capital_prestamo_empleados'> extends True ? Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Capital_prestamo_empleados that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {capital_prestamo_empleadosFindUniqueOrThrowArgs} args - Arguments to find a Capital_prestamo_empleados
     * @example
     * // Get one Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends capital_prestamo_empleadosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamo_empleadosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Capital_prestamo_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosFindFirstArgs} args - Arguments to find a Capital_prestamo_empleados
     * @example
     * // Get one Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends capital_prestamo_empleadosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, capital_prestamo_empleadosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'capital_prestamo_empleados'> extends True ? Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Capital_prestamo_empleados that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosFindFirstOrThrowArgs} args - Arguments to find a Capital_prestamo_empleados
     * @example
     * // Get one Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends capital_prestamo_empleadosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamo_empleadosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Capital_prestamo_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findMany()
     * 
     * // Get first 10 Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.findMany({ take: 10 })
     * 
     * // Only select the `idcapital`
     * const capital_prestamo_empleadosWithIdcapitalOnly = await prisma.capital_prestamo_empleados.findMany({ select: { idcapital: true } })
     * 
    **/
    findMany<T extends capital_prestamo_empleadosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamo_empleadosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Capital_prestamo_empleados.
     * @param {capital_prestamo_empleadosCreateArgs} args - Arguments to create a Capital_prestamo_empleados.
     * @example
     * // Create one Capital_prestamo_empleados
     * const Capital_prestamo_empleados = await prisma.capital_prestamo_empleados.create({
     *   data: {
     *     // ... data to create a Capital_prestamo_empleados
     *   }
     * })
     * 
    **/
    create<T extends capital_prestamo_empleadosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamo_empleadosCreateArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Capital_prestamo_empleados.
     *     @param {capital_prestamo_empleadosCreateManyArgs} args - Arguments to create many Capital_prestamo_empleados.
     *     @example
     *     // Create many Capital_prestamo_empleados
     *     const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends capital_prestamo_empleadosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamo_empleadosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Capital_prestamo_empleados.
     * @param {capital_prestamo_empleadosDeleteArgs} args - Arguments to delete one Capital_prestamo_empleados.
     * @example
     * // Delete one Capital_prestamo_empleados
     * const Capital_prestamo_empleados = await prisma.capital_prestamo_empleados.delete({
     *   where: {
     *     // ... filter to delete one Capital_prestamo_empleados
     *   }
     * })
     * 
    **/
    delete<T extends capital_prestamo_empleadosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamo_empleadosDeleteArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Capital_prestamo_empleados.
     * @param {capital_prestamo_empleadosUpdateArgs} args - Arguments to update one Capital_prestamo_empleados.
     * @example
     * // Update one Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends capital_prestamo_empleadosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamo_empleadosUpdateArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Capital_prestamo_empleados.
     * @param {capital_prestamo_empleadosDeleteManyArgs} args - Arguments to filter Capital_prestamo_empleados to delete.
     * @example
     * // Delete a few Capital_prestamo_empleados
     * const { count } = await prisma.capital_prestamo_empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends capital_prestamo_empleadosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, capital_prestamo_empleadosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capital_prestamo_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends capital_prestamo_empleadosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamo_empleadosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Capital_prestamo_empleados.
     * @param {capital_prestamo_empleadosUpsertArgs} args - Arguments to update or create a Capital_prestamo_empleados.
     * @example
     * // Update or create a Capital_prestamo_empleados
     * const capital_prestamo_empleados = await prisma.capital_prestamo_empleados.upsert({
     *   create: {
     *     // ... data to create a Capital_prestamo_empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capital_prestamo_empleados we want to update
     *   }
     * })
    **/
    upsert<T extends capital_prestamo_empleadosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, capital_prestamo_empleadosUpsertArgs<ExtArgs>>
    ): Prisma__capital_prestamo_empleadosClient<$Types.GetResult<capital_prestamo_empleadosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Capital_prestamo_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosCountArgs} args - Arguments to filter Capital_prestamo_empleados to count.
     * @example
     * // Count the number of Capital_prestamo_empleados
     * const count = await prisma.capital_prestamo_empleados.count({
     *   where: {
     *     // ... the filter for the Capital_prestamo_empleados we want to count
     *   }
     * })
    **/
    count<T extends capital_prestamo_empleadosCountArgs>(
      args?: Subset<T, capital_prestamo_empleadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Capital_prestamo_empleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capital_prestamo_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Capital_prestamo_empleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Capital_prestamo_empleadosAggregateArgs>(args: Subset<T, Capital_prestamo_empleadosAggregateArgs>): Prisma.PrismaPromise<GetCapital_prestamo_empleadosAggregateType<T>>

    /**
     * Group by Capital_prestamo_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capital_prestamo_empleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capital_prestamo_empleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capital_prestamo_empleadosGroupByArgs['orderBy'] }
        : { orderBy?: capital_prestamo_empleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capital_prestamo_empleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapital_prestamo_empleadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for capital_prestamo_empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__capital_prestamo_empleadosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * capital_prestamo_empleados base type for findUnique actions
   */
  export type capital_prestamo_empleadosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo_empleados to fetch.
     */
    where: capital_prestamo_empleadosWhereUniqueInput
  }

  /**
   * capital_prestamo_empleados findUnique
   */
  export interface capital_prestamo_empleadosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends capital_prestamo_empleadosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * capital_prestamo_empleados findUniqueOrThrow
   */
  export type capital_prestamo_empleadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo_empleados to fetch.
     */
    where: capital_prestamo_empleadosWhereUniqueInput
  }


  /**
   * capital_prestamo_empleados base type for findFirst actions
   */
  export type capital_prestamo_empleadosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo_empleados to fetch.
     */
    where?: capital_prestamo_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamo_empleados to fetch.
     */
    orderBy?: capital_prestamo_empleadosOrderByWithRelationInput | capital_prestamo_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capital_prestamo_empleados.
     */
    cursor?: capital_prestamo_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamo_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamo_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capital_prestamo_empleados.
     */
    distinct?: Capital_prestamo_empleadosScalarFieldEnum | Capital_prestamo_empleadosScalarFieldEnum[]
  }

  /**
   * capital_prestamo_empleados findFirst
   */
  export interface capital_prestamo_empleadosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends capital_prestamo_empleadosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * capital_prestamo_empleados findFirstOrThrow
   */
  export type capital_prestamo_empleadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo_empleados to fetch.
     */
    where?: capital_prestamo_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamo_empleados to fetch.
     */
    orderBy?: capital_prestamo_empleadosOrderByWithRelationInput | capital_prestamo_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capital_prestamo_empleados.
     */
    cursor?: capital_prestamo_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamo_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamo_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capital_prestamo_empleados.
     */
    distinct?: Capital_prestamo_empleadosScalarFieldEnum | Capital_prestamo_empleadosScalarFieldEnum[]
  }


  /**
   * capital_prestamo_empleados findMany
   */
  export type capital_prestamo_empleadosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which capital_prestamo_empleados to fetch.
     */
    where?: capital_prestamo_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capital_prestamo_empleados to fetch.
     */
    orderBy?: capital_prestamo_empleadosOrderByWithRelationInput | capital_prestamo_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capital_prestamo_empleados.
     */
    cursor?: capital_prestamo_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capital_prestamo_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capital_prestamo_empleados.
     */
    skip?: number
    distinct?: Capital_prestamo_empleadosScalarFieldEnum | Capital_prestamo_empleadosScalarFieldEnum[]
  }


  /**
   * capital_prestamo_empleados create
   */
  export type capital_prestamo_empleadosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * The data needed to create a capital_prestamo_empleados.
     */
    data?: XOR<capital_prestamo_empleadosCreateInput, capital_prestamo_empleadosUncheckedCreateInput>
  }


  /**
   * capital_prestamo_empleados createMany
   */
  export type capital_prestamo_empleadosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capital_prestamo_empleados.
     */
    data: capital_prestamo_empleadosCreateManyInput | capital_prestamo_empleadosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * capital_prestamo_empleados update
   */
  export type capital_prestamo_empleadosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * The data needed to update a capital_prestamo_empleados.
     */
    data: XOR<capital_prestamo_empleadosUpdateInput, capital_prestamo_empleadosUncheckedUpdateInput>
    /**
     * Choose, which capital_prestamo_empleados to update.
     */
    where: capital_prestamo_empleadosWhereUniqueInput
  }


  /**
   * capital_prestamo_empleados updateMany
   */
  export type capital_prestamo_empleadosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capital_prestamo_empleados.
     */
    data: XOR<capital_prestamo_empleadosUpdateManyMutationInput, capital_prestamo_empleadosUncheckedUpdateManyInput>
    /**
     * Filter which capital_prestamo_empleados to update
     */
    where?: capital_prestamo_empleadosWhereInput
  }


  /**
   * capital_prestamo_empleados upsert
   */
  export type capital_prestamo_empleadosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * The filter to search for the capital_prestamo_empleados to update in case it exists.
     */
    where: capital_prestamo_empleadosWhereUniqueInput
    /**
     * In case the capital_prestamo_empleados found by the `where` argument doesn't exist, create a new capital_prestamo_empleados with this data.
     */
    create: XOR<capital_prestamo_empleadosCreateInput, capital_prestamo_empleadosUncheckedCreateInput>
    /**
     * In case the capital_prestamo_empleados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capital_prestamo_empleadosUpdateInput, capital_prestamo_empleadosUncheckedUpdateInput>
  }


  /**
   * capital_prestamo_empleados delete
   */
  export type capital_prestamo_empleadosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
    /**
     * Filter which capital_prestamo_empleados to delete.
     */
    where: capital_prestamo_empleadosWhereUniqueInput
  }


  /**
   * capital_prestamo_empleados deleteMany
   */
  export type capital_prestamo_empleadosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which capital_prestamo_empleados to delete
     */
    where?: capital_prestamo_empleadosWhereInput
  }


  /**
   * capital_prestamo_empleados without action
   */
  export type capital_prestamo_empleadosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capital_prestamo_empleados
     */
    select?: capital_prestamo_empleadosSelect<ExtArgs> | null
  }



  /**
   * Model categoria_obsequio
   */


  export type AggregateCategoria_obsequio = {
    _count: Categoria_obsequioCountAggregateOutputType | null
    _avg: Categoria_obsequioAvgAggregateOutputType | null
    _sum: Categoria_obsequioSumAggregateOutputType | null
    _min: Categoria_obsequioMinAggregateOutputType | null
    _max: Categoria_obsequioMaxAggregateOutputType | null
  }

  export type Categoria_obsequioAvgAggregateOutputType = {
    idcategoria: number | null
  }

  export type Categoria_obsequioSumAggregateOutputType = {
    idcategoria: number | null
  }

  export type Categoria_obsequioMinAggregateOutputType = {
    idcategoria: number | null
    categoria: string | null
    observacion: string | null
  }

  export type Categoria_obsequioMaxAggregateOutputType = {
    idcategoria: number | null
    categoria: string | null
    observacion: string | null
  }

  export type Categoria_obsequioCountAggregateOutputType = {
    idcategoria: number
    categoria: number
    observacion: number
    _all: number
  }


  export type Categoria_obsequioAvgAggregateInputType = {
    idcategoria?: true
  }

  export type Categoria_obsequioSumAggregateInputType = {
    idcategoria?: true
  }

  export type Categoria_obsequioMinAggregateInputType = {
    idcategoria?: true
    categoria?: true
    observacion?: true
  }

  export type Categoria_obsequioMaxAggregateInputType = {
    idcategoria?: true
    categoria?: true
    observacion?: true
  }

  export type Categoria_obsequioCountAggregateInputType = {
    idcategoria?: true
    categoria?: true
    observacion?: true
    _all?: true
  }

  export type Categoria_obsequioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoria_obsequio to aggregate.
     */
    where?: categoria_obsequioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoria_obsequios to fetch.
     */
    orderBy?: categoria_obsequioOrderByWithRelationInput | categoria_obsequioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoria_obsequioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoria_obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoria_obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoria_obsequios
    **/
    _count?: true | Categoria_obsequioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Categoria_obsequioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Categoria_obsequioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Categoria_obsequioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Categoria_obsequioMaxAggregateInputType
  }

  export type GetCategoria_obsequioAggregateType<T extends Categoria_obsequioAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria_obsequio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria_obsequio[P]>
      : GetScalarType<T[P], AggregateCategoria_obsequio[P]>
  }




  export type categoria_obsequioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: categoria_obsequioWhereInput
    orderBy?: categoria_obsequioOrderByWithAggregationInput | categoria_obsequioOrderByWithAggregationInput[]
    by: Categoria_obsequioScalarFieldEnum[] | Categoria_obsequioScalarFieldEnum
    having?: categoria_obsequioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Categoria_obsequioCountAggregateInputType | true
    _avg?: Categoria_obsequioAvgAggregateInputType
    _sum?: Categoria_obsequioSumAggregateInputType
    _min?: Categoria_obsequioMinAggregateInputType
    _max?: Categoria_obsequioMaxAggregateInputType
  }


  export type Categoria_obsequioGroupByOutputType = {
    idcategoria: number
    categoria: string | null
    observacion: string | null
    _count: Categoria_obsequioCountAggregateOutputType | null
    _avg: Categoria_obsequioAvgAggregateOutputType | null
    _sum: Categoria_obsequioSumAggregateOutputType | null
    _min: Categoria_obsequioMinAggregateOutputType | null
    _max: Categoria_obsequioMaxAggregateOutputType | null
  }

  type GetCategoria_obsequioGroupByPayload<T extends categoria_obsequioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Categoria_obsequioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Categoria_obsequioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Categoria_obsequioGroupByOutputType[P]>
            : GetScalarType<T[P], Categoria_obsequioGroupByOutputType[P]>
        }
      >
    >


  export type categoria_obsequioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcategoria?: boolean
    categoria?: boolean
    observacion?: boolean
  }, ExtArgs["result"]["categoria_obsequio"]>

  export type categoria_obsequioSelectScalar = {
    idcategoria?: boolean
    categoria?: boolean
    observacion?: boolean
  }


  type categoria_obsequioGetPayload<S extends boolean | null | undefined | categoria_obsequioArgs> = $Types.GetResult<categoria_obsequioPayload, S>

  type categoria_obsequioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<categoria_obsequioFindManyArgs, 'select' | 'include'> & {
      select?: Categoria_obsequioCountAggregateInputType | true
    }

  export interface categoria_obsequioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoria_obsequio'], meta: { name: 'categoria_obsequio' } }
    /**
     * Find zero or one Categoria_obsequio that matches the filter.
     * @param {categoria_obsequioFindUniqueArgs} args - Arguments to find a Categoria_obsequio
     * @example
     * // Get one Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoria_obsequioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoria_obsequioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categoria_obsequio'> extends True ? Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Categoria_obsequio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoria_obsequioFindUniqueOrThrowArgs} args - Arguments to find a Categoria_obsequio
     * @example
     * // Get one Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoria_obsequioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoria_obsequioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Categoria_obsequio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioFindFirstArgs} args - Arguments to find a Categoria_obsequio
     * @example
     * // Get one Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoria_obsequioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoria_obsequioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categoria_obsequio'> extends True ? Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Categoria_obsequio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioFindFirstOrThrowArgs} args - Arguments to find a Categoria_obsequio
     * @example
     * // Get one Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoria_obsequioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoria_obsequioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Categoria_obsequios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoria_obsequios
     * const categoria_obsequios = await prisma.categoria_obsequio.findMany()
     * 
     * // Get first 10 Categoria_obsequios
     * const categoria_obsequios = await prisma.categoria_obsequio.findMany({ take: 10 })
     * 
     * // Only select the `idcategoria`
     * const categoria_obsequioWithIdcategoriaOnly = await prisma.categoria_obsequio.findMany({ select: { idcategoria: true } })
     * 
    **/
    findMany<T extends categoria_obsequioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoria_obsequioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Categoria_obsequio.
     * @param {categoria_obsequioCreateArgs} args - Arguments to create a Categoria_obsequio.
     * @example
     * // Create one Categoria_obsequio
     * const Categoria_obsequio = await prisma.categoria_obsequio.create({
     *   data: {
     *     // ... data to create a Categoria_obsequio
     *   }
     * })
     * 
    **/
    create<T extends categoria_obsequioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoria_obsequioCreateArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Categoria_obsequios.
     *     @param {categoria_obsequioCreateManyArgs} args - Arguments to create many Categoria_obsequios.
     *     @example
     *     // Create many Categoria_obsequios
     *     const categoria_obsequio = await prisma.categoria_obsequio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoria_obsequioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoria_obsequioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria_obsequio.
     * @param {categoria_obsequioDeleteArgs} args - Arguments to delete one Categoria_obsequio.
     * @example
     * // Delete one Categoria_obsequio
     * const Categoria_obsequio = await prisma.categoria_obsequio.delete({
     *   where: {
     *     // ... filter to delete one Categoria_obsequio
     *   }
     * })
     * 
    **/
    delete<T extends categoria_obsequioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoria_obsequioDeleteArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Categoria_obsequio.
     * @param {categoria_obsequioUpdateArgs} args - Arguments to update one Categoria_obsequio.
     * @example
     * // Update one Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoria_obsequioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoria_obsequioUpdateArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Categoria_obsequios.
     * @param {categoria_obsequioDeleteManyArgs} args - Arguments to filter Categoria_obsequios to delete.
     * @example
     * // Delete a few Categoria_obsequios
     * const { count } = await prisma.categoria_obsequio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoria_obsequioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoria_obsequioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoria_obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoria_obsequios
     * const categoria_obsequio = await prisma.categoria_obsequio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoria_obsequioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoria_obsequioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria_obsequio.
     * @param {categoria_obsequioUpsertArgs} args - Arguments to update or create a Categoria_obsequio.
     * @example
     * // Update or create a Categoria_obsequio
     * const categoria_obsequio = await prisma.categoria_obsequio.upsert({
     *   create: {
     *     // ... data to create a Categoria_obsequio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria_obsequio we want to update
     *   }
     * })
    **/
    upsert<T extends categoria_obsequioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoria_obsequioUpsertArgs<ExtArgs>>
    ): Prisma__categoria_obsequioClient<$Types.GetResult<categoria_obsequioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Categoria_obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioCountArgs} args - Arguments to filter Categoria_obsequios to count.
     * @example
     * // Count the number of Categoria_obsequios
     * const count = await prisma.categoria_obsequio.count({
     *   where: {
     *     // ... the filter for the Categoria_obsequios we want to count
     *   }
     * })
    **/
    count<T extends categoria_obsequioCountArgs>(
      args?: Subset<T, categoria_obsequioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Categoria_obsequioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria_obsequio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Categoria_obsequioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Categoria_obsequioAggregateArgs>(args: Subset<T, Categoria_obsequioAggregateArgs>): Prisma.PrismaPromise<GetCategoria_obsequioAggregateType<T>>

    /**
     * Group by Categoria_obsequio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoria_obsequioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoria_obsequioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoria_obsequioGroupByArgs['orderBy'] }
        : { orderBy?: categoria_obsequioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoria_obsequioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoria_obsequioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categoria_obsequio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoria_obsequioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categoria_obsequio base type for findUnique actions
   */
  export type categoria_obsequioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter, which categoria_obsequio to fetch.
     */
    where: categoria_obsequioWhereUniqueInput
  }

  /**
   * categoria_obsequio findUnique
   */
  export interface categoria_obsequioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends categoria_obsequioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoria_obsequio findUniqueOrThrow
   */
  export type categoria_obsequioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter, which categoria_obsequio to fetch.
     */
    where: categoria_obsequioWhereUniqueInput
  }


  /**
   * categoria_obsequio base type for findFirst actions
   */
  export type categoria_obsequioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter, which categoria_obsequio to fetch.
     */
    where?: categoria_obsequioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoria_obsequios to fetch.
     */
    orderBy?: categoria_obsequioOrderByWithRelationInput | categoria_obsequioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoria_obsequios.
     */
    cursor?: categoria_obsequioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoria_obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoria_obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoria_obsequios.
     */
    distinct?: Categoria_obsequioScalarFieldEnum | Categoria_obsequioScalarFieldEnum[]
  }

  /**
   * categoria_obsequio findFirst
   */
  export interface categoria_obsequioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends categoria_obsequioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoria_obsequio findFirstOrThrow
   */
  export type categoria_obsequioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter, which categoria_obsequio to fetch.
     */
    where?: categoria_obsequioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoria_obsequios to fetch.
     */
    orderBy?: categoria_obsequioOrderByWithRelationInput | categoria_obsequioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoria_obsequios.
     */
    cursor?: categoria_obsequioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoria_obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoria_obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoria_obsequios.
     */
    distinct?: Categoria_obsequioScalarFieldEnum | Categoria_obsequioScalarFieldEnum[]
  }


  /**
   * categoria_obsequio findMany
   */
  export type categoria_obsequioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter, which categoria_obsequios to fetch.
     */
    where?: categoria_obsequioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoria_obsequios to fetch.
     */
    orderBy?: categoria_obsequioOrderByWithRelationInput | categoria_obsequioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoria_obsequios.
     */
    cursor?: categoria_obsequioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoria_obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoria_obsequios.
     */
    skip?: number
    distinct?: Categoria_obsequioScalarFieldEnum | Categoria_obsequioScalarFieldEnum[]
  }


  /**
   * categoria_obsequio create
   */
  export type categoria_obsequioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * The data needed to create a categoria_obsequio.
     */
    data?: XOR<categoria_obsequioCreateInput, categoria_obsequioUncheckedCreateInput>
  }


  /**
   * categoria_obsequio createMany
   */
  export type categoria_obsequioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categoria_obsequios.
     */
    data: categoria_obsequioCreateManyInput | categoria_obsequioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * categoria_obsequio update
   */
  export type categoria_obsequioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * The data needed to update a categoria_obsequio.
     */
    data: XOR<categoria_obsequioUpdateInput, categoria_obsequioUncheckedUpdateInput>
    /**
     * Choose, which categoria_obsequio to update.
     */
    where: categoria_obsequioWhereUniqueInput
  }


  /**
   * categoria_obsequio updateMany
   */
  export type categoria_obsequioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categoria_obsequios.
     */
    data: XOR<categoria_obsequioUpdateManyMutationInput, categoria_obsequioUncheckedUpdateManyInput>
    /**
     * Filter which categoria_obsequios to update
     */
    where?: categoria_obsequioWhereInput
  }


  /**
   * categoria_obsequio upsert
   */
  export type categoria_obsequioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * The filter to search for the categoria_obsequio to update in case it exists.
     */
    where: categoria_obsequioWhereUniqueInput
    /**
     * In case the categoria_obsequio found by the `where` argument doesn't exist, create a new categoria_obsequio with this data.
     */
    create: XOR<categoria_obsequioCreateInput, categoria_obsequioUncheckedCreateInput>
    /**
     * In case the categoria_obsequio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoria_obsequioUpdateInput, categoria_obsequioUncheckedUpdateInput>
  }


  /**
   * categoria_obsequio delete
   */
  export type categoria_obsequioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
    /**
     * Filter which categoria_obsequio to delete.
     */
    where: categoria_obsequioWhereUniqueInput
  }


  /**
   * categoria_obsequio deleteMany
   */
  export type categoria_obsequioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoria_obsequios to delete
     */
    where?: categoria_obsequioWhereInput
  }


  /**
   * categoria_obsequio without action
   */
  export type categoria_obsequioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria_obsequio
     */
    select?: categoria_obsequioSelect<ExtArgs> | null
  }



  /**
   * Model contratos
   */


  export type AggregateContratos = {
    _count: ContratosCountAggregateOutputType | null
    _avg: ContratosAvgAggregateOutputType | null
    _sum: ContratosSumAggregateOutputType | null
    _min: ContratosMinAggregateOutputType | null
    _max: ContratosMaxAggregateOutputType | null
  }

  export type ContratosAvgAggregateOutputType = {
    idcontrato: number | null
    dni1: number | null
    dni2: number | null
    monto: number | null
    duracion: number | null
    locador: number | null
  }

  export type ContratosSumAggregateOutputType = {
    idcontrato: number | null
    dni1: number | null
    dni2: number | null
    monto: number | null
    duracion: number | null
    locador: number | null
  }

  export type ContratosMinAggregateOutputType = {
    idcontrato: number | null
    locatario1: string | null
    dni1: number | null
    domicilio1: string | null
    locatario2: string | null
    dni2: number | null
    domicilio2: string | null
    monto: number | null
    fecha_inicio: Date | null
    duracion: number | null
    locador: number | null
    operador: string | null
    local: string | null
    uf: string | null
  }

  export type ContratosMaxAggregateOutputType = {
    idcontrato: number | null
    locatario1: string | null
    dni1: number | null
    domicilio1: string | null
    locatario2: string | null
    dni2: number | null
    domicilio2: string | null
    monto: number | null
    fecha_inicio: Date | null
    duracion: number | null
    locador: number | null
    operador: string | null
    local: string | null
    uf: string | null
  }

  export type ContratosCountAggregateOutputType = {
    idcontrato: number
    locatario1: number
    dni1: number
    domicilio1: number
    locatario2: number
    dni2: number
    domicilio2: number
    monto: number
    fecha_inicio: number
    duracion: number
    locador: number
    operador: number
    local: number
    uf: number
    _all: number
  }


  export type ContratosAvgAggregateInputType = {
    idcontrato?: true
    dni1?: true
    dni2?: true
    monto?: true
    duracion?: true
    locador?: true
  }

  export type ContratosSumAggregateInputType = {
    idcontrato?: true
    dni1?: true
    dni2?: true
    monto?: true
    duracion?: true
    locador?: true
  }

  export type ContratosMinAggregateInputType = {
    idcontrato?: true
    locatario1?: true
    dni1?: true
    domicilio1?: true
    locatario2?: true
    dni2?: true
    domicilio2?: true
    monto?: true
    fecha_inicio?: true
    duracion?: true
    locador?: true
    operador?: true
    local?: true
    uf?: true
  }

  export type ContratosMaxAggregateInputType = {
    idcontrato?: true
    locatario1?: true
    dni1?: true
    domicilio1?: true
    locatario2?: true
    dni2?: true
    domicilio2?: true
    monto?: true
    fecha_inicio?: true
    duracion?: true
    locador?: true
    operador?: true
    local?: true
    uf?: true
  }

  export type ContratosCountAggregateInputType = {
    idcontrato?: true
    locatario1?: true
    dni1?: true
    domicilio1?: true
    locatario2?: true
    dni2?: true
    domicilio2?: true
    monto?: true
    fecha_inicio?: true
    duracion?: true
    locador?: true
    operador?: true
    local?: true
    uf?: true
    _all?: true
  }

  export type ContratosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which contratos to aggregate.
     */
    where?: contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contratos to fetch.
     */
    orderBy?: contratosOrderByWithRelationInput | contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contratos
    **/
    _count?: true | ContratosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContratosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContratosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratosMaxAggregateInputType
  }

  export type GetContratosAggregateType<T extends ContratosAggregateArgs> = {
        [P in keyof T & keyof AggregateContratos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContratos[P]>
      : GetScalarType<T[P], AggregateContratos[P]>
  }




  export type contratosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: contratosWhereInput
    orderBy?: contratosOrderByWithAggregationInput | contratosOrderByWithAggregationInput[]
    by: ContratosScalarFieldEnum[] | ContratosScalarFieldEnum
    having?: contratosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratosCountAggregateInputType | true
    _avg?: ContratosAvgAggregateInputType
    _sum?: ContratosSumAggregateInputType
    _min?: ContratosMinAggregateInputType
    _max?: ContratosMaxAggregateInputType
  }


  export type ContratosGroupByOutputType = {
    idcontrato: number
    locatario1: string | null
    dni1: number | null
    domicilio1: string | null
    locatario2: string | null
    dni2: number | null
    domicilio2: string | null
    monto: number | null
    fecha_inicio: Date | null
    duracion: number | null
    locador: number | null
    operador: string | null
    local: string | null
    uf: string | null
    _count: ContratosCountAggregateOutputType | null
    _avg: ContratosAvgAggregateOutputType | null
    _sum: ContratosSumAggregateOutputType | null
    _min: ContratosMinAggregateOutputType | null
    _max: ContratosMaxAggregateOutputType | null
  }

  type GetContratosGroupByPayload<T extends contratosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratosGroupByOutputType[P]>
            : GetScalarType<T[P], ContratosGroupByOutputType[P]>
        }
      >
    >


  export type contratosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcontrato?: boolean
    locatario1?: boolean
    dni1?: boolean
    domicilio1?: boolean
    locatario2?: boolean
    dni2?: boolean
    domicilio2?: boolean
    monto?: boolean
    fecha_inicio?: boolean
    duracion?: boolean
    locador?: boolean
    operador?: boolean
    local?: boolean
    uf?: boolean
  }, ExtArgs["result"]["contratos"]>

  export type contratosSelectScalar = {
    idcontrato?: boolean
    locatario1?: boolean
    dni1?: boolean
    domicilio1?: boolean
    locatario2?: boolean
    dni2?: boolean
    domicilio2?: boolean
    monto?: boolean
    fecha_inicio?: boolean
    duracion?: boolean
    locador?: boolean
    operador?: boolean
    local?: boolean
    uf?: boolean
  }


  type contratosGetPayload<S extends boolean | null | undefined | contratosArgs> = $Types.GetResult<contratosPayload, S>

  type contratosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<contratosFindManyArgs, 'select' | 'include'> & {
      select?: ContratosCountAggregateInputType | true
    }

  export interface contratosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contratos'], meta: { name: 'contratos' } }
    /**
     * Find zero or one Contratos that matches the filter.
     * @param {contratosFindUniqueArgs} args - Arguments to find a Contratos
     * @example
     * // Get one Contratos
     * const contratos = await prisma.contratos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contratosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, contratosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'contratos'> extends True ? Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Contratos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contratosFindUniqueOrThrowArgs} args - Arguments to find a Contratos
     * @example
     * // Get one Contratos
     * const contratos = await prisma.contratos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contratosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contratosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Contratos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosFindFirstArgs} args - Arguments to find a Contratos
     * @example
     * // Get one Contratos
     * const contratos = await prisma.contratos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contratosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, contratosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'contratos'> extends True ? Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Contratos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosFindFirstOrThrowArgs} args - Arguments to find a Contratos
     * @example
     * // Get one Contratos
     * const contratos = await prisma.contratos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contratosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contratosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Contratos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contratos
     * const contratos = await prisma.contratos.findMany()
     * 
     * // Get first 10 Contratos
     * const contratos = await prisma.contratos.findMany({ take: 10 })
     * 
     * // Only select the `idcontrato`
     * const contratosWithIdcontratoOnly = await prisma.contratos.findMany({ select: { idcontrato: true } })
     * 
    **/
    findMany<T extends contratosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contratosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<contratosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Contratos.
     * @param {contratosCreateArgs} args - Arguments to create a Contratos.
     * @example
     * // Create one Contratos
     * const Contratos = await prisma.contratos.create({
     *   data: {
     *     // ... data to create a Contratos
     *   }
     * })
     * 
    **/
    create<T extends contratosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contratosCreateArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Contratos.
     *     @param {contratosCreateManyArgs} args - Arguments to create many Contratos.
     *     @example
     *     // Create many Contratos
     *     const contratos = await prisma.contratos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contratosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contratosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contratos.
     * @param {contratosDeleteArgs} args - Arguments to delete one Contratos.
     * @example
     * // Delete one Contratos
     * const Contratos = await prisma.contratos.delete({
     *   where: {
     *     // ... filter to delete one Contratos
     *   }
     * })
     * 
    **/
    delete<T extends contratosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contratosDeleteArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Contratos.
     * @param {contratosUpdateArgs} args - Arguments to update one Contratos.
     * @example
     * // Update one Contratos
     * const contratos = await prisma.contratos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contratosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contratosUpdateArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Contratos.
     * @param {contratosDeleteManyArgs} args - Arguments to filter Contratos to delete.
     * @example
     * // Delete a few Contratos
     * const { count } = await prisma.contratos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contratosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contratosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contratos
     * const contratos = await prisma.contratos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contratosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contratosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contratos.
     * @param {contratosUpsertArgs} args - Arguments to update or create a Contratos.
     * @example
     * // Update or create a Contratos
     * const contratos = await prisma.contratos.upsert({
     *   create: {
     *     // ... data to create a Contratos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contratos we want to update
     *   }
     * })
    **/
    upsert<T extends contratosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contratosUpsertArgs<ExtArgs>>
    ): Prisma__contratosClient<$Types.GetResult<contratosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosCountArgs} args - Arguments to filter Contratos to count.
     * @example
     * // Count the number of Contratos
     * const count = await prisma.contratos.count({
     *   where: {
     *     // ... the filter for the Contratos we want to count
     *   }
     * })
    **/
    count<T extends contratosCountArgs>(
      args?: Subset<T, contratosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratosAggregateArgs>(args: Subset<T, ContratosAggregateArgs>): Prisma.PrismaPromise<GetContratosAggregateType<T>>

    /**
     * Group by Contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contratosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contratosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contratosGroupByArgs['orderBy'] }
        : { orderBy?: contratosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contratosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for contratos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contratosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * contratos base type for findUnique actions
   */
  export type contratosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter, which contratos to fetch.
     */
    where: contratosWhereUniqueInput
  }

  /**
   * contratos findUnique
   */
  export interface contratosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends contratosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contratos findUniqueOrThrow
   */
  export type contratosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter, which contratos to fetch.
     */
    where: contratosWhereUniqueInput
  }


  /**
   * contratos base type for findFirst actions
   */
  export type contratosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter, which contratos to fetch.
     */
    where?: contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contratos to fetch.
     */
    orderBy?: contratosOrderByWithRelationInput | contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contratos.
     */
    cursor?: contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contratos.
     */
    distinct?: ContratosScalarFieldEnum | ContratosScalarFieldEnum[]
  }

  /**
   * contratos findFirst
   */
  export interface contratosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends contratosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * contratos findFirstOrThrow
   */
  export type contratosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter, which contratos to fetch.
     */
    where?: contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contratos to fetch.
     */
    orderBy?: contratosOrderByWithRelationInput | contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contratos.
     */
    cursor?: contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contratos.
     */
    distinct?: ContratosScalarFieldEnum | ContratosScalarFieldEnum[]
  }


  /**
   * contratos findMany
   */
  export type contratosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter, which contratos to fetch.
     */
    where?: contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contratos to fetch.
     */
    orderBy?: contratosOrderByWithRelationInput | contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contratos.
     */
    cursor?: contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contratos.
     */
    skip?: number
    distinct?: ContratosScalarFieldEnum | ContratosScalarFieldEnum[]
  }


  /**
   * contratos create
   */
  export type contratosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * The data needed to create a contratos.
     */
    data?: XOR<contratosCreateInput, contratosUncheckedCreateInput>
  }


  /**
   * contratos createMany
   */
  export type contratosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contratos.
     */
    data: contratosCreateManyInput | contratosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contratos update
   */
  export type contratosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * The data needed to update a contratos.
     */
    data: XOR<contratosUpdateInput, contratosUncheckedUpdateInput>
    /**
     * Choose, which contratos to update.
     */
    where: contratosWhereUniqueInput
  }


  /**
   * contratos updateMany
   */
  export type contratosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contratos.
     */
    data: XOR<contratosUpdateManyMutationInput, contratosUncheckedUpdateManyInput>
    /**
     * Filter which contratos to update
     */
    where?: contratosWhereInput
  }


  /**
   * contratos upsert
   */
  export type contratosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * The filter to search for the contratos to update in case it exists.
     */
    where: contratosWhereUniqueInput
    /**
     * In case the contratos found by the `where` argument doesn't exist, create a new contratos with this data.
     */
    create: XOR<contratosCreateInput, contratosUncheckedCreateInput>
    /**
     * In case the contratos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contratosUpdateInput, contratosUncheckedUpdateInput>
  }


  /**
   * contratos delete
   */
  export type contratosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
    /**
     * Filter which contratos to delete.
     */
    where: contratosWhereUniqueInput
  }


  /**
   * contratos deleteMany
   */
  export type contratosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which contratos to delete
     */
    where?: contratosWhereInput
  }


  /**
   * contratos without action
   */
  export type contratosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contratos
     */
    select?: contratosSelect<ExtArgs> | null
  }



  /**
   * Model convenio_deuda
   */


  export type AggregateConvenio_deuda = {
    _count: Convenio_deudaCountAggregateOutputType | null
    _avg: Convenio_deudaAvgAggregateOutputType | null
    _sum: Convenio_deudaSumAggregateOutputType | null
    _min: Convenio_deudaMinAggregateOutputType | null
    _max: Convenio_deudaMaxAggregateOutputType | null
  }

  export type Convenio_deudaAvgAggregateOutputType = {
    idconvdeuda: number | null
    cuotas: number | null
    dni: number | null
    idoperador: number | null
    importe1: number | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
  }

  export type Convenio_deudaSumAggregateOutputType = {
    idconvdeuda: number | null
    cuotas: number | null
    dni: number | null
    idoperador: number | null
    importe1: number | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
  }

  export type Convenio_deudaMinAggregateOutputType = {
    idconvdeuda: number | null
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
    vencimiento1: Date | null
    importe1: number | null
    vencimiento2: Date | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
  }

  export type Convenio_deudaMaxAggregateOutputType = {
    idconvdeuda: number | null
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
    vencimiento1: Date | null
    importe1: number | null
    vencimiento2: Date | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
  }

  export type Convenio_deudaCountAggregateOutputType = {
    idconvdeuda: number
    contrato: number
    apellido: number
    nombre: number
    operador: number
    vigencia: number
    fecha: number
    cuotas: number
    dni: number
    empresa: number
    idoperador: number
    vencimiento1: number
    importe1: number
    vencimiento2: number
    importe2: number
    deuda: number
    bonificacion: number
    saldo: number
    _all: number
  }


  export type Convenio_deudaAvgAggregateInputType = {
    idconvdeuda?: true
    cuotas?: true
    dni?: true
    idoperador?: true
    importe1?: true
    importe2?: true
    deuda?: true
    bonificacion?: true
    saldo?: true
  }

  export type Convenio_deudaSumAggregateInputType = {
    idconvdeuda?: true
    cuotas?: true
    dni?: true
    idoperador?: true
    importe1?: true
    importe2?: true
    deuda?: true
    bonificacion?: true
    saldo?: true
  }

  export type Convenio_deudaMinAggregateInputType = {
    idconvdeuda?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
    vencimiento1?: true
    importe1?: true
    vencimiento2?: true
    importe2?: true
    deuda?: true
    bonificacion?: true
    saldo?: true
  }

  export type Convenio_deudaMaxAggregateInputType = {
    idconvdeuda?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
    vencimiento1?: true
    importe1?: true
    vencimiento2?: true
    importe2?: true
    deuda?: true
    bonificacion?: true
    saldo?: true
  }

  export type Convenio_deudaCountAggregateInputType = {
    idconvdeuda?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
    vencimiento1?: true
    importe1?: true
    vencimiento2?: true
    importe2?: true
    deuda?: true
    bonificacion?: true
    saldo?: true
    _all?: true
  }

  export type Convenio_deudaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which convenio_deuda to aggregate.
     */
    where?: convenio_deudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convenio_deudas to fetch.
     */
    orderBy?: convenio_deudaOrderByWithRelationInput | convenio_deudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: convenio_deudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convenio_deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convenio_deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned convenio_deudas
    **/
    _count?: true | Convenio_deudaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Convenio_deudaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Convenio_deudaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Convenio_deudaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Convenio_deudaMaxAggregateInputType
  }

  export type GetConvenio_deudaAggregateType<T extends Convenio_deudaAggregateArgs> = {
        [P in keyof T & keyof AggregateConvenio_deuda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvenio_deuda[P]>
      : GetScalarType<T[P], AggregateConvenio_deuda[P]>
  }




  export type convenio_deudaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: convenio_deudaWhereInput
    orderBy?: convenio_deudaOrderByWithAggregationInput | convenio_deudaOrderByWithAggregationInput[]
    by: Convenio_deudaScalarFieldEnum[] | Convenio_deudaScalarFieldEnum
    having?: convenio_deudaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Convenio_deudaCountAggregateInputType | true
    _avg?: Convenio_deudaAvgAggregateInputType
    _sum?: Convenio_deudaSumAggregateInputType
    _min?: Convenio_deudaMinAggregateInputType
    _max?: Convenio_deudaMaxAggregateInputType
  }


  export type Convenio_deudaGroupByOutputType = {
    idconvdeuda: number
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
    vencimiento1: Date | null
    importe1: number | null
    vencimiento2: Date | null
    importe2: number | null
    deuda: number | null
    bonificacion: number | null
    saldo: number | null
    _count: Convenio_deudaCountAggregateOutputType | null
    _avg: Convenio_deudaAvgAggregateOutputType | null
    _sum: Convenio_deudaSumAggregateOutputType | null
    _min: Convenio_deudaMinAggregateOutputType | null
    _max: Convenio_deudaMaxAggregateOutputType | null
  }

  type GetConvenio_deudaGroupByPayload<T extends convenio_deudaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Convenio_deudaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Convenio_deudaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Convenio_deudaGroupByOutputType[P]>
            : GetScalarType<T[P], Convenio_deudaGroupByOutputType[P]>
        }
      >
    >


  export type convenio_deudaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconvdeuda?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    operador?: boolean
    vigencia?: boolean
    fecha?: boolean
    cuotas?: boolean
    dni?: boolean
    empresa?: boolean
    idoperador?: boolean
    vencimiento1?: boolean
    importe1?: boolean
    vencimiento2?: boolean
    importe2?: boolean
    deuda?: boolean
    bonificacion?: boolean
    saldo?: boolean
  }, ExtArgs["result"]["convenio_deuda"]>

  export type convenio_deudaSelectScalar = {
    idconvdeuda?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    operador?: boolean
    vigencia?: boolean
    fecha?: boolean
    cuotas?: boolean
    dni?: boolean
    empresa?: boolean
    idoperador?: boolean
    vencimiento1?: boolean
    importe1?: boolean
    vencimiento2?: boolean
    importe2?: boolean
    deuda?: boolean
    bonificacion?: boolean
    saldo?: boolean
  }


  type convenio_deudaGetPayload<S extends boolean | null | undefined | convenio_deudaArgs> = $Types.GetResult<convenio_deudaPayload, S>

  type convenio_deudaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<convenio_deudaFindManyArgs, 'select' | 'include'> & {
      select?: Convenio_deudaCountAggregateInputType | true
    }

  export interface convenio_deudaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['convenio_deuda'], meta: { name: 'convenio_deuda' } }
    /**
     * Find zero or one Convenio_deuda that matches the filter.
     * @param {convenio_deudaFindUniqueArgs} args - Arguments to find a Convenio_deuda
     * @example
     * // Get one Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends convenio_deudaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, convenio_deudaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'convenio_deuda'> extends True ? Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Convenio_deuda that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {convenio_deudaFindUniqueOrThrowArgs} args - Arguments to find a Convenio_deuda
     * @example
     * // Get one Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends convenio_deudaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, convenio_deudaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Convenio_deuda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaFindFirstArgs} args - Arguments to find a Convenio_deuda
     * @example
     * // Get one Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends convenio_deudaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, convenio_deudaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'convenio_deuda'> extends True ? Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Convenio_deuda that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaFindFirstOrThrowArgs} args - Arguments to find a Convenio_deuda
     * @example
     * // Get one Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends convenio_deudaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, convenio_deudaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Convenio_deudas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Convenio_deudas
     * const convenio_deudas = await prisma.convenio_deuda.findMany()
     * 
     * // Get first 10 Convenio_deudas
     * const convenio_deudas = await prisma.convenio_deuda.findMany({ take: 10 })
     * 
     * // Only select the `idconvdeuda`
     * const convenio_deudaWithIdconvdeudaOnly = await prisma.convenio_deuda.findMany({ select: { idconvdeuda: true } })
     * 
    **/
    findMany<T extends convenio_deudaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, convenio_deudaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Convenio_deuda.
     * @param {convenio_deudaCreateArgs} args - Arguments to create a Convenio_deuda.
     * @example
     * // Create one Convenio_deuda
     * const Convenio_deuda = await prisma.convenio_deuda.create({
     *   data: {
     *     // ... data to create a Convenio_deuda
     *   }
     * })
     * 
    **/
    create<T extends convenio_deudaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, convenio_deudaCreateArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Convenio_deudas.
     *     @param {convenio_deudaCreateManyArgs} args - Arguments to create many Convenio_deudas.
     *     @example
     *     // Create many Convenio_deudas
     *     const convenio_deuda = await prisma.convenio_deuda.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends convenio_deudaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, convenio_deudaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Convenio_deuda.
     * @param {convenio_deudaDeleteArgs} args - Arguments to delete one Convenio_deuda.
     * @example
     * // Delete one Convenio_deuda
     * const Convenio_deuda = await prisma.convenio_deuda.delete({
     *   where: {
     *     // ... filter to delete one Convenio_deuda
     *   }
     * })
     * 
    **/
    delete<T extends convenio_deudaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, convenio_deudaDeleteArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Convenio_deuda.
     * @param {convenio_deudaUpdateArgs} args - Arguments to update one Convenio_deuda.
     * @example
     * // Update one Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends convenio_deudaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, convenio_deudaUpdateArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Convenio_deudas.
     * @param {convenio_deudaDeleteManyArgs} args - Arguments to filter Convenio_deudas to delete.
     * @example
     * // Delete a few Convenio_deudas
     * const { count } = await prisma.convenio_deuda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends convenio_deudaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, convenio_deudaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convenio_deudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Convenio_deudas
     * const convenio_deuda = await prisma.convenio_deuda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends convenio_deudaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, convenio_deudaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Convenio_deuda.
     * @param {convenio_deudaUpsertArgs} args - Arguments to update or create a Convenio_deuda.
     * @example
     * // Update or create a Convenio_deuda
     * const convenio_deuda = await prisma.convenio_deuda.upsert({
     *   create: {
     *     // ... data to create a Convenio_deuda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Convenio_deuda we want to update
     *   }
     * })
    **/
    upsert<T extends convenio_deudaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, convenio_deudaUpsertArgs<ExtArgs>>
    ): Prisma__convenio_deudaClient<$Types.GetResult<convenio_deudaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Convenio_deudas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaCountArgs} args - Arguments to filter Convenio_deudas to count.
     * @example
     * // Count the number of Convenio_deudas
     * const count = await prisma.convenio_deuda.count({
     *   where: {
     *     // ... the filter for the Convenio_deudas we want to count
     *   }
     * })
    **/
    count<T extends convenio_deudaCountArgs>(
      args?: Subset<T, convenio_deudaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Convenio_deudaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Convenio_deuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Convenio_deudaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Convenio_deudaAggregateArgs>(args: Subset<T, Convenio_deudaAggregateArgs>): Prisma.PrismaPromise<GetConvenio_deudaAggregateType<T>>

    /**
     * Group by Convenio_deuda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convenio_deudaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends convenio_deudaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: convenio_deudaGroupByArgs['orderBy'] }
        : { orderBy?: convenio_deudaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, convenio_deudaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvenio_deudaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for convenio_deuda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__convenio_deudaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * convenio_deuda base type for findUnique actions
   */
  export type convenio_deudaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter, which convenio_deuda to fetch.
     */
    where: convenio_deudaWhereUniqueInput
  }

  /**
   * convenio_deuda findUnique
   */
  export interface convenio_deudaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends convenio_deudaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * convenio_deuda findUniqueOrThrow
   */
  export type convenio_deudaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter, which convenio_deuda to fetch.
     */
    where: convenio_deudaWhereUniqueInput
  }


  /**
   * convenio_deuda base type for findFirst actions
   */
  export type convenio_deudaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter, which convenio_deuda to fetch.
     */
    where?: convenio_deudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convenio_deudas to fetch.
     */
    orderBy?: convenio_deudaOrderByWithRelationInput | convenio_deudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for convenio_deudas.
     */
    cursor?: convenio_deudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convenio_deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convenio_deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of convenio_deudas.
     */
    distinct?: Convenio_deudaScalarFieldEnum | Convenio_deudaScalarFieldEnum[]
  }

  /**
   * convenio_deuda findFirst
   */
  export interface convenio_deudaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends convenio_deudaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * convenio_deuda findFirstOrThrow
   */
  export type convenio_deudaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter, which convenio_deuda to fetch.
     */
    where?: convenio_deudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convenio_deudas to fetch.
     */
    orderBy?: convenio_deudaOrderByWithRelationInput | convenio_deudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for convenio_deudas.
     */
    cursor?: convenio_deudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convenio_deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convenio_deudas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of convenio_deudas.
     */
    distinct?: Convenio_deudaScalarFieldEnum | Convenio_deudaScalarFieldEnum[]
  }


  /**
   * convenio_deuda findMany
   */
  export type convenio_deudaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter, which convenio_deudas to fetch.
     */
    where?: convenio_deudaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convenio_deudas to fetch.
     */
    orderBy?: convenio_deudaOrderByWithRelationInput | convenio_deudaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing convenio_deudas.
     */
    cursor?: convenio_deudaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convenio_deudas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convenio_deudas.
     */
    skip?: number
    distinct?: Convenio_deudaScalarFieldEnum | Convenio_deudaScalarFieldEnum[]
  }


  /**
   * convenio_deuda create
   */
  export type convenio_deudaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * The data needed to create a convenio_deuda.
     */
    data?: XOR<convenio_deudaCreateInput, convenio_deudaUncheckedCreateInput>
  }


  /**
   * convenio_deuda createMany
   */
  export type convenio_deudaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many convenio_deudas.
     */
    data: convenio_deudaCreateManyInput | convenio_deudaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * convenio_deuda update
   */
  export type convenio_deudaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * The data needed to update a convenio_deuda.
     */
    data: XOR<convenio_deudaUpdateInput, convenio_deudaUncheckedUpdateInput>
    /**
     * Choose, which convenio_deuda to update.
     */
    where: convenio_deudaWhereUniqueInput
  }


  /**
   * convenio_deuda updateMany
   */
  export type convenio_deudaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update convenio_deudas.
     */
    data: XOR<convenio_deudaUpdateManyMutationInput, convenio_deudaUncheckedUpdateManyInput>
    /**
     * Filter which convenio_deudas to update
     */
    where?: convenio_deudaWhereInput
  }


  /**
   * convenio_deuda upsert
   */
  export type convenio_deudaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * The filter to search for the convenio_deuda to update in case it exists.
     */
    where: convenio_deudaWhereUniqueInput
    /**
     * In case the convenio_deuda found by the `where` argument doesn't exist, create a new convenio_deuda with this data.
     */
    create: XOR<convenio_deudaCreateInput, convenio_deudaUncheckedCreateInput>
    /**
     * In case the convenio_deuda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<convenio_deudaUpdateInput, convenio_deudaUncheckedUpdateInput>
  }


  /**
   * convenio_deuda delete
   */
  export type convenio_deudaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
    /**
     * Filter which convenio_deuda to delete.
     */
    where: convenio_deudaWhereUniqueInput
  }


  /**
   * convenio_deuda deleteMany
   */
  export type convenio_deudaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which convenio_deudas to delete
     */
    where?: convenio_deudaWhereInput
  }


  /**
   * convenio_deuda without action
   */
  export type convenio_deudaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convenio_deuda
     */
    select?: convenio_deudaSelect<ExtArgs> | null
  }



  /**
   * Model datos
   */


  export type AggregateDatos = {
    _count: DatosCountAggregateOutputType | null
    _avg: DatosAvgAggregateOutputType | null
    _sum: DatosSumAggregateOutputType | null
    _min: DatosMinAggregateOutputType | null
    _max: DatosMaxAggregateOutputType | null
  }

  export type DatosAvgAggregateOutputType = {
    iddato: number | null
    edad: number | null
    telefono: number | null
    celular: number | null
  }

  export type DatosSumAggregateOutputType = {
    iddato: number | null
    edad: number | null
    telefono: bigint | null
    celular: number | null
  }

  export type DatosMinAggregateOutputType = {
    iddato: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    telefono: bigint | null
    celular: number | null
    cobertura: string | null
    grupo_familiar: string | null
    observacion: string | null
    operador: string | null
    domicilio: string | null
    fecha: Date | null
  }

  export type DatosMaxAggregateOutputType = {
    iddato: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    telefono: bigint | null
    celular: number | null
    cobertura: string | null
    grupo_familiar: string | null
    observacion: string | null
    operador: string | null
    domicilio: string | null
    fecha: Date | null
  }

  export type DatosCountAggregateOutputType = {
    iddato: number
    apellido: number
    nombre: number
    edad: number
    telefono: number
    celular: number
    cobertura: number
    grupo_familiar: number
    observacion: number
    operador: number
    domicilio: number
    fecha: number
    _all: number
  }


  export type DatosAvgAggregateInputType = {
    iddato?: true
    edad?: true
    telefono?: true
    celular?: true
  }

  export type DatosSumAggregateInputType = {
    iddato?: true
    edad?: true
    telefono?: true
    celular?: true
  }

  export type DatosMinAggregateInputType = {
    iddato?: true
    apellido?: true
    nombre?: true
    edad?: true
    telefono?: true
    celular?: true
    cobertura?: true
    grupo_familiar?: true
    observacion?: true
    operador?: true
    domicilio?: true
    fecha?: true
  }

  export type DatosMaxAggregateInputType = {
    iddato?: true
    apellido?: true
    nombre?: true
    edad?: true
    telefono?: true
    celular?: true
    cobertura?: true
    grupo_familiar?: true
    observacion?: true
    operador?: true
    domicilio?: true
    fecha?: true
  }

  export type DatosCountAggregateInputType = {
    iddato?: true
    apellido?: true
    nombre?: true
    edad?: true
    telefono?: true
    celular?: true
    cobertura?: true
    grupo_familiar?: true
    observacion?: true
    operador?: true
    domicilio?: true
    fecha?: true
    _all?: true
  }

  export type DatosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos to aggregate.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datos
    **/
    _count?: true | DatosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatosMaxAggregateInputType
  }

  export type GetDatosAggregateType<T extends DatosAggregateArgs> = {
        [P in keyof T & keyof AggregateDatos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatos[P]>
      : GetScalarType<T[P], AggregateDatos[P]>
  }




  export type datosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: datosWhereInput
    orderBy?: datosOrderByWithAggregationInput | datosOrderByWithAggregationInput[]
    by: DatosScalarFieldEnum[] | DatosScalarFieldEnum
    having?: datosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatosCountAggregateInputType | true
    _avg?: DatosAvgAggregateInputType
    _sum?: DatosSumAggregateInputType
    _min?: DatosMinAggregateInputType
    _max?: DatosMaxAggregateInputType
  }


  export type DatosGroupByOutputType = {
    iddato: number
    apellido: string | null
    nombre: string | null
    edad: number | null
    telefono: bigint | null
    celular: number | null
    cobertura: string | null
    grupo_familiar: string | null
    observacion: string | null
    operador: string | null
    domicilio: string | null
    fecha: Date | null
    _count: DatosCountAggregateOutputType | null
    _avg: DatosAvgAggregateOutputType | null
    _sum: DatosSumAggregateOutputType | null
    _min: DatosMinAggregateOutputType | null
    _max: DatosMaxAggregateOutputType | null
  }

  type GetDatosGroupByPayload<T extends datosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatosGroupByOutputType[P]>
            : GetScalarType<T[P], DatosGroupByOutputType[P]>
        }
      >
    >


  export type datosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddato?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    telefono?: boolean
    celular?: boolean
    cobertura?: boolean
    grupo_familiar?: boolean
    observacion?: boolean
    operador?: boolean
    domicilio?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["datos"]>

  export type datosSelectScalar = {
    iddato?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    telefono?: boolean
    celular?: boolean
    cobertura?: boolean
    grupo_familiar?: boolean
    observacion?: boolean
    operador?: boolean
    domicilio?: boolean
    fecha?: boolean
  }


  type datosGetPayload<S extends boolean | null | undefined | datosArgs> = $Types.GetResult<datosPayload, S>

  type datosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<datosFindManyArgs, 'select' | 'include'> & {
      select?: DatosCountAggregateInputType | true
    }

  export interface datosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datos'], meta: { name: 'datos' } }
    /**
     * Find zero or one Datos that matches the filter.
     * @param {datosFindUniqueArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, datosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'datos'> extends True ? Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Datos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datosFindUniqueOrThrowArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Datos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindFirstArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, datosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'datos'> extends True ? Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Datos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindFirstOrThrowArgs} args - Arguments to find a Datos
     * @example
     * // Get one Datos
     * const datos = await prisma.datos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Datos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datos
     * const datos = await prisma.datos.findMany()
     * 
     * // Get first 10 Datos
     * const datos = await prisma.datos.findMany({ take: 10 })
     * 
     * // Only select the `iddato`
     * const datosWithIddatoOnly = await prisma.datos.findMany({ select: { iddato: true } })
     * 
    **/
    findMany<T extends datosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<datosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Datos.
     * @param {datosCreateArgs} args - Arguments to create a Datos.
     * @example
     * // Create one Datos
     * const Datos = await prisma.datos.create({
     *   data: {
     *     // ... data to create a Datos
     *   }
     * })
     * 
    **/
    create<T extends datosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, datosCreateArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Datos.
     *     @param {datosCreateManyArgs} args - Arguments to create many Datos.
     *     @example
     *     // Create many Datos
     *     const datos = await prisma.datos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datos.
     * @param {datosDeleteArgs} args - Arguments to delete one Datos.
     * @example
     * // Delete one Datos
     * const Datos = await prisma.datos.delete({
     *   where: {
     *     // ... filter to delete one Datos
     *   }
     * })
     * 
    **/
    delete<T extends datosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, datosDeleteArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Datos.
     * @param {datosUpdateArgs} args - Arguments to update one Datos.
     * @example
     * // Update one Datos
     * const datos = await prisma.datos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpdateArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Datos.
     * @param {datosDeleteManyArgs} args - Arguments to filter Datos to delete.
     * @example
     * // Delete a few Datos
     * const { count } = await prisma.datos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datos
     * const datos = await prisma.datos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datos.
     * @param {datosUpsertArgs} args - Arguments to update or create a Datos.
     * @example
     * // Update or create a Datos
     * const datos = await prisma.datos.upsert({
     *   create: {
     *     // ... data to create a Datos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datos we want to update
     *   }
     * })
    **/
    upsert<T extends datosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, datosUpsertArgs<ExtArgs>>
    ): Prisma__datosClient<$Types.GetResult<datosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosCountArgs} args - Arguments to filter Datos to count.
     * @example
     * // Count the number of Datos
     * const count = await prisma.datos.count({
     *   where: {
     *     // ... the filter for the Datos we want to count
     *   }
     * })
    **/
    count<T extends datosCountArgs>(
      args?: Subset<T, datosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatosAggregateArgs>(args: Subset<T, DatosAggregateArgs>): Prisma.PrismaPromise<GetDatosAggregateType<T>>

    /**
     * Group by Datos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datosGroupByArgs['orderBy'] }
        : { orderBy?: datosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for datos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__datosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * datos base type for findUnique actions
   */
  export type datosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where: datosWhereUniqueInput
  }

  /**
   * datos findUnique
   */
  export interface datosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends datosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datos findUniqueOrThrow
   */
  export type datosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos base type for findFirst actions
   */
  export type datosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos.
     */
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }

  /**
   * datos findFirst
   */
  export interface datosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends datosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datos findFirstOrThrow
   */
  export type datosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos.
     */
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * datos findMany
   */
  export type datosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter, which datos to fetch.
     */
    where?: datosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos to fetch.
     */
    orderBy?: datosOrderByWithRelationInput | datosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datos.
     */
    cursor?: datosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos.
     */
    skip?: number
    distinct?: DatosScalarFieldEnum | DatosScalarFieldEnum[]
  }


  /**
   * datos create
   */
  export type datosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * The data needed to create a datos.
     */
    data?: XOR<datosCreateInput, datosUncheckedCreateInput>
  }


  /**
   * datos createMany
   */
  export type datosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many datos.
     */
    data: datosCreateManyInput | datosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * datos update
   */
  export type datosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * The data needed to update a datos.
     */
    data: XOR<datosUpdateInput, datosUncheckedUpdateInput>
    /**
     * Choose, which datos to update.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos updateMany
   */
  export type datosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update datos.
     */
    data: XOR<datosUpdateManyMutationInput, datosUncheckedUpdateManyInput>
    /**
     * Filter which datos to update
     */
    where?: datosWhereInput
  }


  /**
   * datos upsert
   */
  export type datosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * The filter to search for the datos to update in case it exists.
     */
    where: datosWhereUniqueInput
    /**
     * In case the datos found by the `where` argument doesn't exist, create a new datos with this data.
     */
    create: XOR<datosCreateInput, datosUncheckedCreateInput>
    /**
     * In case the datos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datosUpdateInput, datosUncheckedUpdateInput>
  }


  /**
   * datos delete
   */
  export type datosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
    /**
     * Filter which datos to delete.
     */
    where: datosWhereUniqueInput
  }


  /**
   * datos deleteMany
   */
  export type datosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos to delete
     */
    where?: datosWhereInput
  }


  /**
   * datos without action
   */
  export type datosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos
     */
    select?: datosSelect<ExtArgs> | null
  }



  /**
   * Model datos_atencion
   */


  export type AggregateDatos_atencion = {
    _count: Datos_atencionCountAggregateOutputType | null
    _avg: Datos_atencionAvgAggregateOutputType | null
    _sum: Datos_atencionSumAggregateOutputType | null
    _min: Datos_atencionMinAggregateOutputType | null
    _max: Datos_atencionMaxAggregateOutputType | null
  }

  export type Datos_atencionAvgAggregateOutputType = {
    iddatos: number | null
    dni: number | null
    telefono: number | null
  }

  export type Datos_atencionSumAggregateOutputType = {
    iddatos: number | null
    dni: number | null
    telefono: number | null
  }

  export type Datos_atencionMinAggregateOutputType = {
    iddatos: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    motivo: string | null
    operador: string | null
    operadoratencion: string | null
    fecha: Date | null
  }

  export type Datos_atencionMaxAggregateOutputType = {
    iddatos: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    motivo: string | null
    operador: string | null
    operadoratencion: string | null
    fecha: Date | null
  }

  export type Datos_atencionCountAggregateOutputType = {
    iddatos: number
    apellido: number
    nombre: number
    dni: number
    telefono: number
    parentezco: number
    motivo: number
    operador: number
    operadoratencion: number
    fecha: number
    _all: number
  }


  export type Datos_atencionAvgAggregateInputType = {
    iddatos?: true
    dni?: true
    telefono?: true
  }

  export type Datos_atencionSumAggregateInputType = {
    iddatos?: true
    dni?: true
    telefono?: true
  }

  export type Datos_atencionMinAggregateInputType = {
    iddatos?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    parentezco?: true
    motivo?: true
    operador?: true
    operadoratencion?: true
    fecha?: true
  }

  export type Datos_atencionMaxAggregateInputType = {
    iddatos?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    parentezco?: true
    motivo?: true
    operador?: true
    operadoratencion?: true
    fecha?: true
  }

  export type Datos_atencionCountAggregateInputType = {
    iddatos?: true
    apellido?: true
    nombre?: true
    dni?: true
    telefono?: true
    parentezco?: true
    motivo?: true
    operador?: true
    operadoratencion?: true
    fecha?: true
    _all?: true
  }

  export type Datos_atencionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos_atencion to aggregate.
     */
    where?: datos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos_atencions to fetch.
     */
    orderBy?: datos_atencionOrderByWithRelationInput | datos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datos_atencions
    **/
    _count?: true | Datos_atencionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Datos_atencionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Datos_atencionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Datos_atencionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Datos_atencionMaxAggregateInputType
  }

  export type GetDatos_atencionAggregateType<T extends Datos_atencionAggregateArgs> = {
        [P in keyof T & keyof AggregateDatos_atencion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatos_atencion[P]>
      : GetScalarType<T[P], AggregateDatos_atencion[P]>
  }




  export type datos_atencionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: datos_atencionWhereInput
    orderBy?: datos_atencionOrderByWithAggregationInput | datos_atencionOrderByWithAggregationInput[]
    by: Datos_atencionScalarFieldEnum[] | Datos_atencionScalarFieldEnum
    having?: datos_atencionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Datos_atencionCountAggregateInputType | true
    _avg?: Datos_atencionAvgAggregateInputType
    _sum?: Datos_atencionSumAggregateInputType
    _min?: Datos_atencionMinAggregateInputType
    _max?: Datos_atencionMaxAggregateInputType
  }


  export type Datos_atencionGroupByOutputType = {
    iddatos: number
    apellido: string | null
    nombre: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    motivo: string | null
    operador: string | null
    operadoratencion: string | null
    fecha: Date | null
    _count: Datos_atencionCountAggregateOutputType | null
    _avg: Datos_atencionAvgAggregateOutputType | null
    _sum: Datos_atencionSumAggregateOutputType | null
    _min: Datos_atencionMinAggregateOutputType | null
    _max: Datos_atencionMaxAggregateOutputType | null
  }

  type GetDatos_atencionGroupByPayload<T extends datos_atencionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Datos_atencionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Datos_atencionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Datos_atencionGroupByOutputType[P]>
            : GetScalarType<T[P], Datos_atencionGroupByOutputType[P]>
        }
      >
    >


  export type datos_atencionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddatos?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    motivo?: boolean
    operador?: boolean
    operadoratencion?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["datos_atencion"]>

  export type datos_atencionSelectScalar = {
    iddatos?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    motivo?: boolean
    operador?: boolean
    operadoratencion?: boolean
    fecha?: boolean
  }


  type datos_atencionGetPayload<S extends boolean | null | undefined | datos_atencionArgs> = $Types.GetResult<datos_atencionPayload, S>

  type datos_atencionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<datos_atencionFindManyArgs, 'select' | 'include'> & {
      select?: Datos_atencionCountAggregateInputType | true
    }

  export interface datos_atencionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datos_atencion'], meta: { name: 'datos_atencion' } }
    /**
     * Find zero or one Datos_atencion that matches the filter.
     * @param {datos_atencionFindUniqueArgs} args - Arguments to find a Datos_atencion
     * @example
     * // Get one Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datos_atencionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, datos_atencionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'datos_atencion'> extends True ? Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Datos_atencion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datos_atencionFindUniqueOrThrowArgs} args - Arguments to find a Datos_atencion
     * @example
     * // Get one Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datos_atencionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datos_atencionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Datos_atencion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionFindFirstArgs} args - Arguments to find a Datos_atencion
     * @example
     * // Get one Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datos_atencionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, datos_atencionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'datos_atencion'> extends True ? Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Datos_atencion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionFindFirstOrThrowArgs} args - Arguments to find a Datos_atencion
     * @example
     * // Get one Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datos_atencionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datos_atencionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Datos_atencions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datos_atencions
     * const datos_atencions = await prisma.datos_atencion.findMany()
     * 
     * // Get first 10 Datos_atencions
     * const datos_atencions = await prisma.datos_atencion.findMany({ take: 10 })
     * 
     * // Only select the `iddatos`
     * const datos_atencionWithIddatosOnly = await prisma.datos_atencion.findMany({ select: { iddatos: true } })
     * 
    **/
    findMany<T extends datos_atencionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datos_atencionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Datos_atencion.
     * @param {datos_atencionCreateArgs} args - Arguments to create a Datos_atencion.
     * @example
     * // Create one Datos_atencion
     * const Datos_atencion = await prisma.datos_atencion.create({
     *   data: {
     *     // ... data to create a Datos_atencion
     *   }
     * })
     * 
    **/
    create<T extends datos_atencionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, datos_atencionCreateArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Datos_atencions.
     *     @param {datos_atencionCreateManyArgs} args - Arguments to create many Datos_atencions.
     *     @example
     *     // Create many Datos_atencions
     *     const datos_atencion = await prisma.datos_atencion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datos_atencionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datos_atencionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datos_atencion.
     * @param {datos_atencionDeleteArgs} args - Arguments to delete one Datos_atencion.
     * @example
     * // Delete one Datos_atencion
     * const Datos_atencion = await prisma.datos_atencion.delete({
     *   where: {
     *     // ... filter to delete one Datos_atencion
     *   }
     * })
     * 
    **/
    delete<T extends datos_atencionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, datos_atencionDeleteArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Datos_atencion.
     * @param {datos_atencionUpdateArgs} args - Arguments to update one Datos_atencion.
     * @example
     * // Update one Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datos_atencionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, datos_atencionUpdateArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Datos_atencions.
     * @param {datos_atencionDeleteManyArgs} args - Arguments to filter Datos_atencions to delete.
     * @example
     * // Delete a few Datos_atencions
     * const { count } = await prisma.datos_atencion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datos_atencionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datos_atencionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datos_atencions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datos_atencions
     * const datos_atencion = await prisma.datos_atencion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datos_atencionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, datos_atencionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datos_atencion.
     * @param {datos_atencionUpsertArgs} args - Arguments to update or create a Datos_atencion.
     * @example
     * // Update or create a Datos_atencion
     * const datos_atencion = await prisma.datos_atencion.upsert({
     *   create: {
     *     // ... data to create a Datos_atencion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datos_atencion we want to update
     *   }
     * })
    **/
    upsert<T extends datos_atencionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, datos_atencionUpsertArgs<ExtArgs>>
    ): Prisma__datos_atencionClient<$Types.GetResult<datos_atencionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Datos_atencions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionCountArgs} args - Arguments to filter Datos_atencions to count.
     * @example
     * // Count the number of Datos_atencions
     * const count = await prisma.datos_atencion.count({
     *   where: {
     *     // ... the filter for the Datos_atencions we want to count
     *   }
     * })
    **/
    count<T extends datos_atencionCountArgs>(
      args?: Subset<T, datos_atencionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Datos_atencionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datos_atencion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Datos_atencionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Datos_atencionAggregateArgs>(args: Subset<T, Datos_atencionAggregateArgs>): Prisma.PrismaPromise<GetDatos_atencionAggregateType<T>>

    /**
     * Group by Datos_atencion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datos_atencionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datos_atencionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datos_atencionGroupByArgs['orderBy'] }
        : { orderBy?: datos_atencionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datos_atencionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatos_atencionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for datos_atencion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__datos_atencionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * datos_atencion base type for findUnique actions
   */
  export type datos_atencionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which datos_atencion to fetch.
     */
    where: datos_atencionWhereUniqueInput
  }

  /**
   * datos_atencion findUnique
   */
  export interface datos_atencionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends datos_atencionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datos_atencion findUniqueOrThrow
   */
  export type datos_atencionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which datos_atencion to fetch.
     */
    where: datos_atencionWhereUniqueInput
  }


  /**
   * datos_atencion base type for findFirst actions
   */
  export type datos_atencionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which datos_atencion to fetch.
     */
    where?: datos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos_atencions to fetch.
     */
    orderBy?: datos_atencionOrderByWithRelationInput | datos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos_atencions.
     */
    cursor?: datos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos_atencions.
     */
    distinct?: Datos_atencionScalarFieldEnum | Datos_atencionScalarFieldEnum[]
  }

  /**
   * datos_atencion findFirst
   */
  export interface datos_atencionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends datos_atencionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * datos_atencion findFirstOrThrow
   */
  export type datos_atencionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which datos_atencion to fetch.
     */
    where?: datos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos_atencions to fetch.
     */
    orderBy?: datos_atencionOrderByWithRelationInput | datos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datos_atencions.
     */
    cursor?: datos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datos_atencions.
     */
    distinct?: Datos_atencionScalarFieldEnum | Datos_atencionScalarFieldEnum[]
  }


  /**
   * datos_atencion findMany
   */
  export type datos_atencionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which datos_atencions to fetch.
     */
    where?: datos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datos_atencions to fetch.
     */
    orderBy?: datos_atencionOrderByWithRelationInput | datos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datos_atencions.
     */
    cursor?: datos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datos_atencions.
     */
    skip?: number
    distinct?: Datos_atencionScalarFieldEnum | Datos_atencionScalarFieldEnum[]
  }


  /**
   * datos_atencion create
   */
  export type datos_atencionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * The data needed to create a datos_atencion.
     */
    data?: XOR<datos_atencionCreateInput, datos_atencionUncheckedCreateInput>
  }


  /**
   * datos_atencion createMany
   */
  export type datos_atencionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many datos_atencions.
     */
    data: datos_atencionCreateManyInput | datos_atencionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * datos_atencion update
   */
  export type datos_atencionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * The data needed to update a datos_atencion.
     */
    data: XOR<datos_atencionUpdateInput, datos_atencionUncheckedUpdateInput>
    /**
     * Choose, which datos_atencion to update.
     */
    where: datos_atencionWhereUniqueInput
  }


  /**
   * datos_atencion updateMany
   */
  export type datos_atencionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update datos_atencions.
     */
    data: XOR<datos_atencionUpdateManyMutationInput, datos_atencionUncheckedUpdateManyInput>
    /**
     * Filter which datos_atencions to update
     */
    where?: datos_atencionWhereInput
  }


  /**
   * datos_atencion upsert
   */
  export type datos_atencionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * The filter to search for the datos_atencion to update in case it exists.
     */
    where: datos_atencionWhereUniqueInput
    /**
     * In case the datos_atencion found by the `where` argument doesn't exist, create a new datos_atencion with this data.
     */
    create: XOR<datos_atencionCreateInput, datos_atencionUncheckedCreateInput>
    /**
     * In case the datos_atencion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datos_atencionUpdateInput, datos_atencionUncheckedUpdateInput>
  }


  /**
   * datos_atencion delete
   */
  export type datos_atencionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
    /**
     * Filter which datos_atencion to delete.
     */
    where: datos_atencionWhereUniqueInput
  }


  /**
   * datos_atencion deleteMany
   */
  export type datos_atencionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datos_atencions to delete
     */
    where?: datos_atencionWhereInput
  }


  /**
   * datos_atencion without action
   */
  export type datos_atencionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datos_atencion
     */
    select?: datos_atencionSelect<ExtArgs> | null
  }



  /**
   * Model detalle_orden_pago
   */


  export type AggregateDetalle_orden_pago = {
    _count: Detalle_orden_pagoCountAggregateOutputType | null
    _avg: Detalle_orden_pagoAvgAggregateOutputType | null
    _sum: Detalle_orden_pagoSumAggregateOutputType | null
    _min: Detalle_orden_pagoMinAggregateOutputType | null
    _max: Detalle_orden_pagoMaxAggregateOutputType | null
  }

  export type Detalle_orden_pagoAvgAggregateOutputType = {
    iddetallepago: number | null
  }

  export type Detalle_orden_pagoSumAggregateOutputType = {
    iddetallepago: number | null
  }

  export type Detalle_orden_pagoMinAggregateOutputType = {
    iddetallepago: number | null
    norden: string | null
    nconsulta: string | null
    sucursal: string | null
    prestador: string | null
    importe: string | null
    operador_carga: string | null
    fecha: Date | null
  }

  export type Detalle_orden_pagoMaxAggregateOutputType = {
    iddetallepago: number | null
    norden: string | null
    nconsulta: string | null
    sucursal: string | null
    prestador: string | null
    importe: string | null
    operador_carga: string | null
    fecha: Date | null
  }

  export type Detalle_orden_pagoCountAggregateOutputType = {
    iddetallepago: number
    norden: number
    nconsulta: number
    sucursal: number
    prestador: number
    importe: number
    operador_carga: number
    fecha: number
    _all: number
  }


  export type Detalle_orden_pagoAvgAggregateInputType = {
    iddetallepago?: true
  }

  export type Detalle_orden_pagoSumAggregateInputType = {
    iddetallepago?: true
  }

  export type Detalle_orden_pagoMinAggregateInputType = {
    iddetallepago?: true
    norden?: true
    nconsulta?: true
    sucursal?: true
    prestador?: true
    importe?: true
    operador_carga?: true
    fecha?: true
  }

  export type Detalle_orden_pagoMaxAggregateInputType = {
    iddetallepago?: true
    norden?: true
    nconsulta?: true
    sucursal?: true
    prestador?: true
    importe?: true
    operador_carga?: true
    fecha?: true
  }

  export type Detalle_orden_pagoCountAggregateInputType = {
    iddetallepago?: true
    norden?: true
    nconsulta?: true
    sucursal?: true
    prestador?: true
    importe?: true
    operador_carga?: true
    fecha?: true
    _all?: true
  }

  export type Detalle_orden_pagoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_orden_pago to aggregate.
     */
    where?: detalle_orden_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_orden_pagos to fetch.
     */
    orderBy?: detalle_orden_pagoOrderByWithRelationInput | detalle_orden_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_orden_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_orden_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_orden_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_orden_pagos
    **/
    _count?: true | Detalle_orden_pagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_orden_pagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_orden_pagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_orden_pagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_orden_pagoMaxAggregateInputType
  }

  export type GetDetalle_orden_pagoAggregateType<T extends Detalle_orden_pagoAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_orden_pago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_orden_pago[P]>
      : GetScalarType<T[P], AggregateDetalle_orden_pago[P]>
  }




  export type detalle_orden_pagoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: detalle_orden_pagoWhereInput
    orderBy?: detalle_orden_pagoOrderByWithAggregationInput | detalle_orden_pagoOrderByWithAggregationInput[]
    by: Detalle_orden_pagoScalarFieldEnum[] | Detalle_orden_pagoScalarFieldEnum
    having?: detalle_orden_pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_orden_pagoCountAggregateInputType | true
    _avg?: Detalle_orden_pagoAvgAggregateInputType
    _sum?: Detalle_orden_pagoSumAggregateInputType
    _min?: Detalle_orden_pagoMinAggregateInputType
    _max?: Detalle_orden_pagoMaxAggregateInputType
  }


  export type Detalle_orden_pagoGroupByOutputType = {
    iddetallepago: number
    norden: string | null
    nconsulta: string | null
    sucursal: string | null
    prestador: string | null
    importe: string | null
    operador_carga: string | null
    fecha: Date | null
    _count: Detalle_orden_pagoCountAggregateOutputType | null
    _avg: Detalle_orden_pagoAvgAggregateOutputType | null
    _sum: Detalle_orden_pagoSumAggregateOutputType | null
    _min: Detalle_orden_pagoMinAggregateOutputType | null
    _max: Detalle_orden_pagoMaxAggregateOutputType | null
  }

  type GetDetalle_orden_pagoGroupByPayload<T extends detalle_orden_pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_orden_pagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_orden_pagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_orden_pagoGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_orden_pagoGroupByOutputType[P]>
        }
      >
    >


  export type detalle_orden_pagoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddetallepago?: boolean
    norden?: boolean
    nconsulta?: boolean
    sucursal?: boolean
    prestador?: boolean
    importe?: boolean
    operador_carga?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["detalle_orden_pago"]>

  export type detalle_orden_pagoSelectScalar = {
    iddetallepago?: boolean
    norden?: boolean
    nconsulta?: boolean
    sucursal?: boolean
    prestador?: boolean
    importe?: boolean
    operador_carga?: boolean
    fecha?: boolean
  }


  type detalle_orden_pagoGetPayload<S extends boolean | null | undefined | detalle_orden_pagoArgs> = $Types.GetResult<detalle_orden_pagoPayload, S>

  type detalle_orden_pagoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<detalle_orden_pagoFindManyArgs, 'select' | 'include'> & {
      select?: Detalle_orden_pagoCountAggregateInputType | true
    }

  export interface detalle_orden_pagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_orden_pago'], meta: { name: 'detalle_orden_pago' } }
    /**
     * Find zero or one Detalle_orden_pago that matches the filter.
     * @param {detalle_orden_pagoFindUniqueArgs} args - Arguments to find a Detalle_orden_pago
     * @example
     * // Get one Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detalle_orden_pagoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, detalle_orden_pagoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'detalle_orden_pago'> extends True ? Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Detalle_orden_pago that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detalle_orden_pagoFindUniqueOrThrowArgs} args - Arguments to find a Detalle_orden_pago
     * @example
     * // Get one Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detalle_orden_pagoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_orden_pagoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Detalle_orden_pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoFindFirstArgs} args - Arguments to find a Detalle_orden_pago
     * @example
     * // Get one Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detalle_orden_pagoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, detalle_orden_pagoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'detalle_orden_pago'> extends True ? Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Detalle_orden_pago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoFindFirstOrThrowArgs} args - Arguments to find a Detalle_orden_pago
     * @example
     * // Get one Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detalle_orden_pagoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_orden_pagoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Detalle_orden_pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_orden_pagos
     * const detalle_orden_pagos = await prisma.detalle_orden_pago.findMany()
     * 
     * // Get first 10 Detalle_orden_pagos
     * const detalle_orden_pagos = await prisma.detalle_orden_pago.findMany({ take: 10 })
     * 
     * // Only select the `iddetallepago`
     * const detalle_orden_pagoWithIddetallepagoOnly = await prisma.detalle_orden_pago.findMany({ select: { iddetallepago: true } })
     * 
    **/
    findMany<T extends detalle_orden_pagoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_orden_pagoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Detalle_orden_pago.
     * @param {detalle_orden_pagoCreateArgs} args - Arguments to create a Detalle_orden_pago.
     * @example
     * // Create one Detalle_orden_pago
     * const Detalle_orden_pago = await prisma.detalle_orden_pago.create({
     *   data: {
     *     // ... data to create a Detalle_orden_pago
     *   }
     * })
     * 
    **/
    create<T extends detalle_orden_pagoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_orden_pagoCreateArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Detalle_orden_pagos.
     *     @param {detalle_orden_pagoCreateManyArgs} args - Arguments to create many Detalle_orden_pagos.
     *     @example
     *     // Create many Detalle_orden_pagos
     *     const detalle_orden_pago = await prisma.detalle_orden_pago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detalle_orden_pagoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_orden_pagoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detalle_orden_pago.
     * @param {detalle_orden_pagoDeleteArgs} args - Arguments to delete one Detalle_orden_pago.
     * @example
     * // Delete one Detalle_orden_pago
     * const Detalle_orden_pago = await prisma.detalle_orden_pago.delete({
     *   where: {
     *     // ... filter to delete one Detalle_orden_pago
     *   }
     * })
     * 
    **/
    delete<T extends detalle_orden_pagoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_orden_pagoDeleteArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Detalle_orden_pago.
     * @param {detalle_orden_pagoUpdateArgs} args - Arguments to update one Detalle_orden_pago.
     * @example
     * // Update one Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detalle_orden_pagoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_orden_pagoUpdateArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Detalle_orden_pagos.
     * @param {detalle_orden_pagoDeleteManyArgs} args - Arguments to filter Detalle_orden_pagos to delete.
     * @example
     * // Delete a few Detalle_orden_pagos
     * const { count } = await prisma.detalle_orden_pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detalle_orden_pagoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_orden_pagoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_orden_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_orden_pagos
     * const detalle_orden_pago = await prisma.detalle_orden_pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detalle_orden_pagoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_orden_pagoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detalle_orden_pago.
     * @param {detalle_orden_pagoUpsertArgs} args - Arguments to update or create a Detalle_orden_pago.
     * @example
     * // Update or create a Detalle_orden_pago
     * const detalle_orden_pago = await prisma.detalle_orden_pago.upsert({
     *   create: {
     *     // ... data to create a Detalle_orden_pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_orden_pago we want to update
     *   }
     * })
    **/
    upsert<T extends detalle_orden_pagoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_orden_pagoUpsertArgs<ExtArgs>>
    ): Prisma__detalle_orden_pagoClient<$Types.GetResult<detalle_orden_pagoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Detalle_orden_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoCountArgs} args - Arguments to filter Detalle_orden_pagos to count.
     * @example
     * // Count the number of Detalle_orden_pagos
     * const count = await prisma.detalle_orden_pago.count({
     *   where: {
     *     // ... the filter for the Detalle_orden_pagos we want to count
     *   }
     * })
    **/
    count<T extends detalle_orden_pagoCountArgs>(
      args?: Subset<T, detalle_orden_pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_orden_pagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_orden_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_orden_pagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_orden_pagoAggregateArgs>(args: Subset<T, Detalle_orden_pagoAggregateArgs>): Prisma.PrismaPromise<GetDetalle_orden_pagoAggregateType<T>>

    /**
     * Group by Detalle_orden_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_orden_pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_orden_pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_orden_pagoGroupByArgs['orderBy'] }
        : { orderBy?: detalle_orden_pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_orden_pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_orden_pagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_orden_pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__detalle_orden_pagoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * detalle_orden_pago base type for findUnique actions
   */
  export type detalle_orden_pagoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter, which detalle_orden_pago to fetch.
     */
    where: detalle_orden_pagoWhereUniqueInput
  }

  /**
   * detalle_orden_pago findUnique
   */
  export interface detalle_orden_pagoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends detalle_orden_pagoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * detalle_orden_pago findUniqueOrThrow
   */
  export type detalle_orden_pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter, which detalle_orden_pago to fetch.
     */
    where: detalle_orden_pagoWhereUniqueInput
  }


  /**
   * detalle_orden_pago base type for findFirst actions
   */
  export type detalle_orden_pagoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter, which detalle_orden_pago to fetch.
     */
    where?: detalle_orden_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_orden_pagos to fetch.
     */
    orderBy?: detalle_orden_pagoOrderByWithRelationInput | detalle_orden_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_orden_pagos.
     */
    cursor?: detalle_orden_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_orden_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_orden_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_orden_pagos.
     */
    distinct?: Detalle_orden_pagoScalarFieldEnum | Detalle_orden_pagoScalarFieldEnum[]
  }

  /**
   * detalle_orden_pago findFirst
   */
  export interface detalle_orden_pagoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends detalle_orden_pagoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * detalle_orden_pago findFirstOrThrow
   */
  export type detalle_orden_pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter, which detalle_orden_pago to fetch.
     */
    where?: detalle_orden_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_orden_pagos to fetch.
     */
    orderBy?: detalle_orden_pagoOrderByWithRelationInput | detalle_orden_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_orden_pagos.
     */
    cursor?: detalle_orden_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_orden_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_orden_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_orden_pagos.
     */
    distinct?: Detalle_orden_pagoScalarFieldEnum | Detalle_orden_pagoScalarFieldEnum[]
  }


  /**
   * detalle_orden_pago findMany
   */
  export type detalle_orden_pagoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter, which detalle_orden_pagos to fetch.
     */
    where?: detalle_orden_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_orden_pagos to fetch.
     */
    orderBy?: detalle_orden_pagoOrderByWithRelationInput | detalle_orden_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_orden_pagos.
     */
    cursor?: detalle_orden_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_orden_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_orden_pagos.
     */
    skip?: number
    distinct?: Detalle_orden_pagoScalarFieldEnum | Detalle_orden_pagoScalarFieldEnum[]
  }


  /**
   * detalle_orden_pago create
   */
  export type detalle_orden_pagoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * The data needed to create a detalle_orden_pago.
     */
    data?: XOR<detalle_orden_pagoCreateInput, detalle_orden_pagoUncheckedCreateInput>
  }


  /**
   * detalle_orden_pago createMany
   */
  export type detalle_orden_pagoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_orden_pagos.
     */
    data: detalle_orden_pagoCreateManyInput | detalle_orden_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detalle_orden_pago update
   */
  export type detalle_orden_pagoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * The data needed to update a detalle_orden_pago.
     */
    data: XOR<detalle_orden_pagoUpdateInput, detalle_orden_pagoUncheckedUpdateInput>
    /**
     * Choose, which detalle_orden_pago to update.
     */
    where: detalle_orden_pagoWhereUniqueInput
  }


  /**
   * detalle_orden_pago updateMany
   */
  export type detalle_orden_pagoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_orden_pagos.
     */
    data: XOR<detalle_orden_pagoUpdateManyMutationInput, detalle_orden_pagoUncheckedUpdateManyInput>
    /**
     * Filter which detalle_orden_pagos to update
     */
    where?: detalle_orden_pagoWhereInput
  }


  /**
   * detalle_orden_pago upsert
   */
  export type detalle_orden_pagoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * The filter to search for the detalle_orden_pago to update in case it exists.
     */
    where: detalle_orden_pagoWhereUniqueInput
    /**
     * In case the detalle_orden_pago found by the `where` argument doesn't exist, create a new detalle_orden_pago with this data.
     */
    create: XOR<detalle_orden_pagoCreateInput, detalle_orden_pagoUncheckedCreateInput>
    /**
     * In case the detalle_orden_pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_orden_pagoUpdateInput, detalle_orden_pagoUncheckedUpdateInput>
  }


  /**
   * detalle_orden_pago delete
   */
  export type detalle_orden_pagoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
    /**
     * Filter which detalle_orden_pago to delete.
     */
    where: detalle_orden_pagoWhereUniqueInput
  }


  /**
   * detalle_orden_pago deleteMany
   */
  export type detalle_orden_pagoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_orden_pagos to delete
     */
    where?: detalle_orden_pagoWhereInput
  }


  /**
   * detalle_orden_pago without action
   */
  export type detalle_orden_pagoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_orden_pago
     */
    select?: detalle_orden_pagoSelect<ExtArgs> | null
  }



  /**
   * Model empresas
   */


  export type AggregateEmpresas = {
    _count: EmpresasCountAggregateOutputType | null
    _avg: EmpresasAvgAggregateOutputType | null
    _sum: EmpresasSumAggregateOutputType | null
    _min: EmpresasMinAggregateOutputType | null
    _max: EmpresasMaxAggregateOutputType | null
  }

  export type EmpresasAvgAggregateOutputType = {
    idempresa: number | null
  }

  export type EmpresasSumAggregateOutputType = {
    idempresa: number | null
  }

  export type EmpresasMinAggregateOutputType = {
    idempresa: number | null
    empresa: string | null
    cuit: string | null
  }

  export type EmpresasMaxAggregateOutputType = {
    idempresa: number | null
    empresa: string | null
    cuit: string | null
  }

  export type EmpresasCountAggregateOutputType = {
    idempresa: number
    empresa: number
    cuit: number
    _all: number
  }


  export type EmpresasAvgAggregateInputType = {
    idempresa?: true
  }

  export type EmpresasSumAggregateInputType = {
    idempresa?: true
  }

  export type EmpresasMinAggregateInputType = {
    idempresa?: true
    empresa?: true
    cuit?: true
  }

  export type EmpresasMaxAggregateInputType = {
    idempresa?: true
    empresa?: true
    cuit?: true
  }

  export type EmpresasCountAggregateInputType = {
    idempresa?: true
    empresa?: true
    cuit?: true
    _all?: true
  }

  export type EmpresasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresas to aggregate.
     */
    where?: empresasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresasOrderByWithRelationInput | empresasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empresasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empresas
    **/
    _count?: true | EmpresasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresasMaxAggregateInputType
  }

  export type GetEmpresasAggregateType<T extends EmpresasAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresas[P]>
      : GetScalarType<T[P], AggregateEmpresas[P]>
  }




  export type empresasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: empresasWhereInput
    orderBy?: empresasOrderByWithAggregationInput | empresasOrderByWithAggregationInput[]
    by: EmpresasScalarFieldEnum[] | EmpresasScalarFieldEnum
    having?: empresasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresasCountAggregateInputType | true
    _avg?: EmpresasAvgAggregateInputType
    _sum?: EmpresasSumAggregateInputType
    _min?: EmpresasMinAggregateInputType
    _max?: EmpresasMaxAggregateInputType
  }


  export type EmpresasGroupByOutputType = {
    idempresa: number
    empresa: string | null
    cuit: string | null
    _count: EmpresasCountAggregateOutputType | null
    _avg: EmpresasAvgAggregateOutputType | null
    _sum: EmpresasSumAggregateOutputType | null
    _min: EmpresasMinAggregateOutputType | null
    _max: EmpresasMaxAggregateOutputType | null
  }

  type GetEmpresasGroupByPayload<T extends empresasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresasGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresasGroupByOutputType[P]>
        }
      >
    >


  export type empresasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idempresa?: boolean
    empresa?: boolean
    cuit?: boolean
  }, ExtArgs["result"]["empresas"]>

  export type empresasSelectScalar = {
    idempresa?: boolean
    empresa?: boolean
    cuit?: boolean
  }


  type empresasGetPayload<S extends boolean | null | undefined | empresasArgs> = $Types.GetResult<empresasPayload, S>

  type empresasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<empresasFindManyArgs, 'select' | 'include'> & {
      select?: EmpresasCountAggregateInputType | true
    }

  export interface empresasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empresas'], meta: { name: 'empresas' } }
    /**
     * Find zero or one Empresas that matches the filter.
     * @param {empresasFindUniqueArgs} args - Arguments to find a Empresas
     * @example
     * // Get one Empresas
     * const empresas = await prisma.empresas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empresasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, empresasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'empresas'> extends True ? Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Empresas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {empresasFindUniqueOrThrowArgs} args - Arguments to find a Empresas
     * @example
     * // Get one Empresas
     * const empresas = await prisma.empresas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends empresasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empresasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasFindFirstArgs} args - Arguments to find a Empresas
     * @example
     * // Get one Empresas
     * const empresas = await prisma.empresas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empresasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, empresasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'empresas'> extends True ? Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Empresas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasFindFirstOrThrowArgs} args - Arguments to find a Empresas
     * @example
     * // Get one Empresas
     * const empresas = await prisma.empresas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends empresasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empresasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresas.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresas.findMany({ take: 10 })
     * 
     * // Only select the `idempresa`
     * const empresasWithIdempresaOnly = await prisma.empresas.findMany({ select: { idempresa: true } })
     * 
    **/
    findMany<T extends empresasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<empresasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Empresas.
     * @param {empresasCreateArgs} args - Arguments to create a Empresas.
     * @example
     * // Create one Empresas
     * const Empresas = await prisma.empresas.create({
     *   data: {
     *     // ... data to create a Empresas
     *   }
     * })
     * 
    **/
    create<T extends empresasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, empresasCreateArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Empresas.
     *     @param {empresasCreateManyArgs} args - Arguments to create many Empresas.
     *     @example
     *     // Create many Empresas
     *     const empresas = await prisma.empresas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empresasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empresas.
     * @param {empresasDeleteArgs} args - Arguments to delete one Empresas.
     * @example
     * // Delete one Empresas
     * const Empresas = await prisma.empresas.delete({
     *   where: {
     *     // ... filter to delete one Empresas
     *   }
     * })
     * 
    **/
    delete<T extends empresasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, empresasDeleteArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Empresas.
     * @param {empresasUpdateArgs} args - Arguments to update one Empresas.
     * @example
     * // Update one Empresas
     * const empresas = await prisma.empresas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empresasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, empresasUpdateArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {empresasDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empresasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empresasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresas = await prisma.empresas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empresasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, empresasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresas.
     * @param {empresasUpsertArgs} args - Arguments to update or create a Empresas.
     * @example
     * // Update or create a Empresas
     * const empresas = await prisma.empresas.upsert({
     *   create: {
     *     // ... data to create a Empresas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresas we want to update
     *   }
     * })
    **/
    upsert<T extends empresasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, empresasUpsertArgs<ExtArgs>>
    ): Prisma__empresasClient<$Types.GetResult<empresasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresas.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends empresasCountArgs>(
      args?: Subset<T, empresasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresasAggregateArgs>(args: Subset<T, EmpresasAggregateArgs>): Prisma.PrismaPromise<GetEmpresasAggregateType<T>>

    /**
     * Group by Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empresasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empresasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empresasGroupByArgs['orderBy'] }
        : { orderBy?: empresasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empresasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for empresas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__empresasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * empresas base type for findUnique actions
   */
  export type empresasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where: empresasWhereUniqueInput
  }

  /**
   * empresas findUnique
   */
  export interface empresasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends empresasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * empresas findUniqueOrThrow
   */
  export type empresasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where: empresasWhereUniqueInput
  }


  /**
   * empresas base type for findFirst actions
   */
  export type empresasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresasOrderByWithRelationInput | empresasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresasScalarFieldEnum | EmpresasScalarFieldEnum[]
  }

  /**
   * empresas findFirst
   */
  export interface empresasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends empresasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * empresas findFirstOrThrow
   */
  export type empresasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresasOrderByWithRelationInput | empresasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empresas.
     */
    cursor?: empresasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empresas.
     */
    distinct?: EmpresasScalarFieldEnum | EmpresasScalarFieldEnum[]
  }


  /**
   * empresas findMany
   */
  export type empresasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter, which empresas to fetch.
     */
    where?: empresasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empresas to fetch.
     */
    orderBy?: empresasOrderByWithRelationInput | empresasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empresas.
     */
    cursor?: empresasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empresas.
     */
    skip?: number
    distinct?: EmpresasScalarFieldEnum | EmpresasScalarFieldEnum[]
  }


  /**
   * empresas create
   */
  export type empresasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * The data needed to create a empresas.
     */
    data?: XOR<empresasCreateInput, empresasUncheckedCreateInput>
  }


  /**
   * empresas createMany
   */
  export type empresasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empresas.
     */
    data: empresasCreateManyInput | empresasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * empresas update
   */
  export type empresasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * The data needed to update a empresas.
     */
    data: XOR<empresasUpdateInput, empresasUncheckedUpdateInput>
    /**
     * Choose, which empresas to update.
     */
    where: empresasWhereUniqueInput
  }


  /**
   * empresas updateMany
   */
  export type empresasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empresas.
     */
    data: XOR<empresasUpdateManyMutationInput, empresasUncheckedUpdateManyInput>
    /**
     * Filter which empresas to update
     */
    where?: empresasWhereInput
  }


  /**
   * empresas upsert
   */
  export type empresasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * The filter to search for the empresas to update in case it exists.
     */
    where: empresasWhereUniqueInput
    /**
     * In case the empresas found by the `where` argument doesn't exist, create a new empresas with this data.
     */
    create: XOR<empresasCreateInput, empresasUncheckedCreateInput>
    /**
     * In case the empresas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empresasUpdateInput, empresasUncheckedUpdateInput>
  }


  /**
   * empresas delete
   */
  export type empresasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
    /**
     * Filter which empresas to delete.
     */
    where: empresasWhereUniqueInput
  }


  /**
   * empresas deleteMany
   */
  export type empresasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which empresas to delete
     */
    where?: empresasWhereInput
  }


  /**
   * empresas without action
   */
  export type empresasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empresas
     */
    select?: empresasSelect<ExtArgs> | null
  }



  /**
   * Model eventos
   */


  export type AggregateEventos = {
    _count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
  }

  export type EventosAvgAggregateOutputType = {
    idevents: number | null
    allDay: number | null
  }

  export type EventosSumAggregateOutputType = {
    idevents: number | null
    allDay: number | null
  }

  export type EventosMinAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
  }

  export type EventosMaxAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
  }

  export type EventosCountAggregateOutputType = {
    idevents: number
    title: number
    allDay: number
    start: number
    end: number
    _all: number
  }


  export type EventosAvgAggregateInputType = {
    idevents?: true
    allDay?: true
  }

  export type EventosSumAggregateInputType = {
    idevents?: true
    allDay?: true
  }

  export type EventosMinAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
  }

  export type EventosMaxAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
  }

  export type EventosCountAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    _all?: true
  }

  export type EventosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventos to aggregate.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventos
    **/
    _count?: true | EventosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventosMaxAggregateInputType
  }

  export type GetEventosAggregateType<T extends EventosAggregateArgs> = {
        [P in keyof T & keyof AggregateEventos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventos[P]>
      : GetScalarType<T[P], AggregateEventos[P]>
  }




  export type eventosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: eventosWhereInput
    orderBy?: eventosOrderByWithAggregationInput | eventosOrderByWithAggregationInput[]
    by: EventosScalarFieldEnum[] | EventosScalarFieldEnum
    having?: eventosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventosCountAggregateInputType | true
    _avg?: EventosAvgAggregateInputType
    _sum?: EventosSumAggregateInputType
    _min?: EventosMinAggregateInputType
    _max?: EventosMaxAggregateInputType
  }


  export type EventosGroupByOutputType = {
    idevents: number
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
    _count: EventosCountAggregateOutputType | null
    _avg: EventosAvgAggregateOutputType | null
    _sum: EventosSumAggregateOutputType | null
    _min: EventosMinAggregateOutputType | null
    _max: EventosMaxAggregateOutputType | null
  }

  type GetEventosGroupByPayload<T extends eventosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventosGroupByOutputType[P]>
            : GetScalarType<T[P], EventosGroupByOutputType[P]>
        }
      >
    >


  export type eventosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
  }, ExtArgs["result"]["eventos"]>

  export type eventosSelectScalar = {
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
  }


  type eventosGetPayload<S extends boolean | null | undefined | eventosArgs> = $Types.GetResult<eventosPayload, S>

  type eventosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<eventosFindManyArgs, 'select' | 'include'> & {
      select?: EventosCountAggregateInputType | true
    }

  export interface eventosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eventos'], meta: { name: 'eventos' } }
    /**
     * Find zero or one Eventos that matches the filter.
     * @param {eventosFindUniqueArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eventosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'eventos'> extends True ? Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Eventos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventosFindUniqueOrThrowArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindFirstArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eventosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'eventos'> extends True ? Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Eventos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindFirstOrThrowArgs} args - Arguments to find a Eventos
     * @example
     * // Get one Eventos
     * const eventos = await prisma.eventos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.eventos.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.eventos.findMany({ take: 10 })
     * 
     * // Only select the `idevents`
     * const eventosWithIdeventsOnly = await prisma.eventos.findMany({ select: { idevents: true } })
     * 
    **/
    findMany<T extends eventosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<eventosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Eventos.
     * @param {eventosCreateArgs} args - Arguments to create a Eventos.
     * @example
     * // Create one Eventos
     * const Eventos = await prisma.eventos.create({
     *   data: {
     *     // ... data to create a Eventos
     *   }
     * })
     * 
    **/
    create<T extends eventosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, eventosCreateArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Eventos.
     *     @param {eventosCreateManyArgs} args - Arguments to create many Eventos.
     *     @example
     *     // Create many Eventos
     *     const eventos = await prisma.eventos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eventos.
     * @param {eventosDeleteArgs} args - Arguments to delete one Eventos.
     * @example
     * // Delete one Eventos
     * const Eventos = await prisma.eventos.delete({
     *   where: {
     *     // ... filter to delete one Eventos
     *   }
     * })
     * 
    **/
    delete<T extends eventosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, eventosDeleteArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Eventos.
     * @param {eventosUpdateArgs} args - Arguments to update one Eventos.
     * @example
     * // Update one Eventos
     * const eventos = await prisma.eventos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpdateArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Eventos.
     * @param {eventosDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.eventos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, eventosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const eventos = await prisma.eventos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventos.
     * @param {eventosUpsertArgs} args - Arguments to update or create a Eventos.
     * @example
     * // Update or create a Eventos
     * const eventos = await prisma.eventos.upsert({
     *   create: {
     *     // ... data to create a Eventos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventos we want to update
     *   }
     * })
    **/
    upsert<T extends eventosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, eventosUpsertArgs<ExtArgs>>
    ): Prisma__eventosClient<$Types.GetResult<eventosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.eventos.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends eventosCountArgs>(
      args?: Subset<T, eventosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventosAggregateArgs>(args: Subset<T, EventosAggregateArgs>): Prisma.PrismaPromise<GetEventosAggregateType<T>>

    /**
     * Group by Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventosGroupByArgs['orderBy'] }
        : { orderBy?: eventosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for eventos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eventosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * eventos base type for findUnique actions
   */
  export type eventosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where: eventosWhereUniqueInput
  }

  /**
   * eventos findUnique
   */
  export interface eventosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends eventosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eventos findUniqueOrThrow
   */
  export type eventosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos base type for findFirst actions
   */
  export type eventosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventos.
     */
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }

  /**
   * eventos findFirst
   */
  export interface eventosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends eventosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * eventos findFirstOrThrow
   */
  export type eventosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventos.
     */
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }


  /**
   * eventos findMany
   */
  export type eventosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter, which eventos to fetch.
     */
    where?: eventosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventos to fetch.
     */
    orderBy?: eventosOrderByWithRelationInput | eventosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventos.
     */
    cursor?: eventosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventos.
     */
    skip?: number
    distinct?: EventosScalarFieldEnum | EventosScalarFieldEnum[]
  }


  /**
   * eventos create
   */
  export type eventosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The data needed to create a eventos.
     */
    data?: XOR<eventosCreateInput, eventosUncheckedCreateInput>
  }


  /**
   * eventos createMany
   */
  export type eventosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eventos.
     */
    data: eventosCreateManyInput | eventosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * eventos update
   */
  export type eventosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The data needed to update a eventos.
     */
    data: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
    /**
     * Choose, which eventos to update.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos updateMany
   */
  export type eventosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eventos.
     */
    data: XOR<eventosUpdateManyMutationInput, eventosUncheckedUpdateManyInput>
    /**
     * Filter which eventos to update
     */
    where?: eventosWhereInput
  }


  /**
   * eventos upsert
   */
  export type eventosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * The filter to search for the eventos to update in case it exists.
     */
    where: eventosWhereUniqueInput
    /**
     * In case the eventos found by the `where` argument doesn't exist, create a new eventos with this data.
     */
    create: XOR<eventosCreateInput, eventosUncheckedCreateInput>
    /**
     * In case the eventos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventosUpdateInput, eventosUncheckedUpdateInput>
  }


  /**
   * eventos delete
   */
  export type eventosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
    /**
     * Filter which eventos to delete.
     */
    where: eventosWhereUniqueInput
  }


  /**
   * eventos deleteMany
   */
  export type eventosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventos to delete
     */
    where?: eventosWhereInput
  }


  /**
   * eventos without action
   */
  export type eventosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventos
     */
    select?: eventosSelect<ExtArgs> | null
  }



  /**
   * Model fabricante_ataud
   */


  export type AggregateFabricante_ataud = {
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  export type Fabricante_ataudAvgAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudSumAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudMinAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudMaxAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudCountAggregateOutputType = {
    idfabricante: number
    fabricante: number
    _all: number
  }


  export type Fabricante_ataudAvgAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudSumAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudMinAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudMaxAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudCountAggregateInputType = {
    idfabricante?: true
    fabricante?: true
    _all?: true
  }

  export type Fabricante_ataudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_ataud to aggregate.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fabricante_atauds
    **/
    _count?: true | Fabricante_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fabricante_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fabricante_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fabricante_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fabricante_ataudMaxAggregateInputType
  }

  export type GetFabricante_ataudAggregateType<T extends Fabricante_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateFabricante_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabricante_ataud[P]>
      : GetScalarType<T[P], AggregateFabricante_ataud[P]>
  }




  export type fabricante_ataudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fabricante_ataudWhereInput
    orderBy?: fabricante_ataudOrderByWithAggregationInput | fabricante_ataudOrderByWithAggregationInput[]
    by: Fabricante_ataudScalarFieldEnum[] | Fabricante_ataudScalarFieldEnum
    having?: fabricante_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fabricante_ataudCountAggregateInputType | true
    _avg?: Fabricante_ataudAvgAggregateInputType
    _sum?: Fabricante_ataudSumAggregateInputType
    _min?: Fabricante_ataudMinAggregateInputType
    _max?: Fabricante_ataudMaxAggregateInputType
  }


  export type Fabricante_ataudGroupByOutputType = {
    idfabricante: number
    fabricante: string | null
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  type GetFabricante_ataudGroupByPayload<T extends fabricante_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fabricante_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fabricante_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
        }
      >
    >


  export type fabricante_ataudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idfabricante?: boolean
    fabricante?: boolean
  }, ExtArgs["result"]["fabricante_ataud"]>

  export type fabricante_ataudSelectScalar = {
    idfabricante?: boolean
    fabricante?: boolean
  }


  type fabricante_ataudGetPayload<S extends boolean | null | undefined | fabricante_ataudArgs> = $Types.GetResult<fabricante_ataudPayload, S>

  type fabricante_ataudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fabricante_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Fabricante_ataudCountAggregateInputType | true
    }

  export interface fabricante_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fabricante_ataud'], meta: { name: 'fabricante_ataud' } }
    /**
     * Find zero or one Fabricante_ataud that matches the filter.
     * @param {fabricante_ataudFindUniqueArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fabricante_ataudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fabricante_ataudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fabricante_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fabricante_ataudFindUniqueOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fabricante_ataudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fabricante_ataudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fabricante_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
     * 
     * // Get first 10 Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idfabricante`
     * const fabricante_ataudWithIdfabricanteOnly = await prisma.fabricante_ataud.findMany({ select: { idfabricante: true } })
     * 
    **/
    findMany<T extends fabricante_ataudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fabricante_ataud.
     * @param {fabricante_ataudCreateArgs} args - Arguments to create a Fabricante_ataud.
     * @example
     * // Create one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.create({
     *   data: {
     *     // ... data to create a Fabricante_ataud
     *   }
     * })
     * 
    **/
    create<T extends fabricante_ataudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudCreateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fabricante_atauds.
     *     @param {fabricante_ataudCreateManyArgs} args - Arguments to create many Fabricante_atauds.
     *     @example
     *     // Create many Fabricante_atauds
     *     const fabricante_ataud = await prisma.fabricante_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fabricante_ataudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fabricante_ataud.
     * @param {fabricante_ataudDeleteArgs} args - Arguments to delete one Fabricante_ataud.
     * @example
     * // Delete one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.delete({
     *   where: {
     *     // ... filter to delete one Fabricante_ataud
     *   }
     * })
     * 
    **/
    delete<T extends fabricante_ataudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudDeleteArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fabricante_ataud.
     * @param {fabricante_ataudUpdateArgs} args - Arguments to update one Fabricante_ataud.
     * @example
     * // Update one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fabricante_ataudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fabricante_atauds.
     * @param {fabricante_ataudDeleteManyArgs} args - Arguments to filter Fabricante_atauds to delete.
     * @example
     * // Delete a few Fabricante_atauds
     * const { count } = await prisma.fabricante_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fabricante_ataudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fabricante_atauds
     * const fabricante_ataud = await prisma.fabricante_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fabricante_ataudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fabricante_ataud.
     * @param {fabricante_ataudUpsertArgs} args - Arguments to update or create a Fabricante_ataud.
     * @example
     * // Update or create a Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.upsert({
     *   create: {
     *     // ... data to create a Fabricante_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fabricante_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends fabricante_ataudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpsertArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudCountArgs} args - Arguments to filter Fabricante_atauds to count.
     * @example
     * // Count the number of Fabricante_atauds
     * const count = await prisma.fabricante_ataud.count({
     *   where: {
     *     // ... the filter for the Fabricante_atauds we want to count
     *   }
     * })
    **/
    count<T extends fabricante_ataudCountArgs>(
      args?: Subset<T, fabricante_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fabricante_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fabricante_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fabricante_ataudAggregateArgs>(args: Subset<T, Fabricante_ataudAggregateArgs>): Prisma.PrismaPromise<GetFabricante_ataudAggregateType<T>>

    /**
     * Group by Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fabricante_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fabricante_ataudGroupByArgs['orderBy'] }
        : { orderBy?: fabricante_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fabricante_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricante_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fabricante_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fabricante_ataudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fabricante_ataud base type for findUnique actions
   */
  export type fabricante_ataudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }

  /**
   * fabricante_ataud findUnique
   */
  export interface fabricante_ataudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findUniqueOrThrow
   */
  export type fabricante_ataudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud base type for findFirst actions
   */
  export type fabricante_ataudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }

  /**
   * fabricante_ataud findFirst
   */
  export interface fabricante_ataudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findFirstOrThrow
   */
  export type fabricante_ataudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud findMany
   */
  export type fabricante_ataudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_atauds to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud create
   */
  export type fabricante_ataudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to create a fabricante_ataud.
     */
    data?: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
  }


  /**
   * fabricante_ataud createMany
   */
  export type fabricante_ataudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fabricante_atauds.
     */
    data: fabricante_ataudCreateManyInput | fabricante_ataudCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fabricante_ataud update
   */
  export type fabricante_ataudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to update a fabricante_ataud.
     */
    data: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
    /**
     * Choose, which fabricante_ataud to update.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud updateMany
   */
  export type fabricante_ataudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fabricante_atauds.
     */
    data: XOR<fabricante_ataudUpdateManyMutationInput, fabricante_ataudUncheckedUpdateManyInput>
    /**
     * Filter which fabricante_atauds to update
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud upsert
   */
  export type fabricante_ataudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The filter to search for the fabricante_ataud to update in case it exists.
     */
    where: fabricante_ataudWhereUniqueInput
    /**
     * In case the fabricante_ataud found by the `where` argument doesn't exist, create a new fabricante_ataud with this data.
     */
    create: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
    /**
     * In case the fabricante_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
  }


  /**
   * fabricante_ataud delete
   */
  export type fabricante_ataudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter which fabricante_ataud to delete.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud deleteMany
   */
  export type fabricante_ataudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_atauds to delete
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud without action
   */
  export type fabricante_ataudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
  }



  /**
   * Model gestioncaso
   */


  export type AggregateGestioncaso = {
    _count: GestioncasoCountAggregateOutputType | null
    _avg: GestioncasoAvgAggregateOutputType | null
    _sum: GestioncasoSumAggregateOutputType | null
    _min: GestioncasoMinAggregateOutputType | null
    _max: GestioncasoMaxAggregateOutputType | null
  }

  export type GestioncasoAvgAggregateOutputType = {
    idgestion: number | null
    idcaso: number | null
    contrato: number | null
  }

  export type GestioncasoSumAggregateOutputType = {
    idgestion: number | null
    idcaso: number | null
    contrato: number | null
  }

  export type GestioncasoMinAggregateOutputType = {
    idgestion: number | null
    idcaso: number | null
    contrato: number | null
    operador: string | null
    accion: string | null
    observacion: string | null
    fechaaccion: string | null
    nuevaaccion: string | null
    fechanuevaaccion: string | null
    realizado: boolean | null
    observacion_nuevaaccion: string | null
  }

  export type GestioncasoMaxAggregateOutputType = {
    idgestion: number | null
    idcaso: number | null
    contrato: number | null
    operador: string | null
    accion: string | null
    observacion: string | null
    fechaaccion: string | null
    nuevaaccion: string | null
    fechanuevaaccion: string | null
    realizado: boolean | null
    observacion_nuevaaccion: string | null
  }

  export type GestioncasoCountAggregateOutputType = {
    idgestion: number
    idcaso: number
    contrato: number
    operador: number
    accion: number
    observacion: number
    fechaaccion: number
    nuevaaccion: number
    fechanuevaaccion: number
    realizado: number
    observacion_nuevaaccion: number
    _all: number
  }


  export type GestioncasoAvgAggregateInputType = {
    idgestion?: true
    idcaso?: true
    contrato?: true
  }

  export type GestioncasoSumAggregateInputType = {
    idgestion?: true
    idcaso?: true
    contrato?: true
  }

  export type GestioncasoMinAggregateInputType = {
    idgestion?: true
    idcaso?: true
    contrato?: true
    operador?: true
    accion?: true
    observacion?: true
    fechaaccion?: true
    nuevaaccion?: true
    fechanuevaaccion?: true
    realizado?: true
    observacion_nuevaaccion?: true
  }

  export type GestioncasoMaxAggregateInputType = {
    idgestion?: true
    idcaso?: true
    contrato?: true
    operador?: true
    accion?: true
    observacion?: true
    fechaaccion?: true
    nuevaaccion?: true
    fechanuevaaccion?: true
    realizado?: true
    observacion_nuevaaccion?: true
  }

  export type GestioncasoCountAggregateInputType = {
    idgestion?: true
    idcaso?: true
    contrato?: true
    operador?: true
    accion?: true
    observacion?: true
    fechaaccion?: true
    nuevaaccion?: true
    fechanuevaaccion?: true
    realizado?: true
    observacion_nuevaaccion?: true
    _all?: true
  }

  export type GestioncasoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gestioncaso to aggregate.
     */
    where?: gestioncasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gestioncasos to fetch.
     */
    orderBy?: gestioncasoOrderByWithRelationInput | gestioncasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gestioncasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gestioncasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gestioncasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gestioncasos
    **/
    _count?: true | GestioncasoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GestioncasoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GestioncasoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GestioncasoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GestioncasoMaxAggregateInputType
  }

  export type GetGestioncasoAggregateType<T extends GestioncasoAggregateArgs> = {
        [P in keyof T & keyof AggregateGestioncaso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGestioncaso[P]>
      : GetScalarType<T[P], AggregateGestioncaso[P]>
  }




  export type gestioncasoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gestioncasoWhereInput
    orderBy?: gestioncasoOrderByWithAggregationInput | gestioncasoOrderByWithAggregationInput[]
    by: GestioncasoScalarFieldEnum[] | GestioncasoScalarFieldEnum
    having?: gestioncasoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GestioncasoCountAggregateInputType | true
    _avg?: GestioncasoAvgAggregateInputType
    _sum?: GestioncasoSumAggregateInputType
    _min?: GestioncasoMinAggregateInputType
    _max?: GestioncasoMaxAggregateInputType
  }


  export type GestioncasoGroupByOutputType = {
    idgestion: number
    idcaso: number | null
    contrato: number | null
    operador: string | null
    accion: string | null
    observacion: string | null
    fechaaccion: string | null
    nuevaaccion: string | null
    fechanuevaaccion: string | null
    realizado: boolean | null
    observacion_nuevaaccion: string | null
    _count: GestioncasoCountAggregateOutputType | null
    _avg: GestioncasoAvgAggregateOutputType | null
    _sum: GestioncasoSumAggregateOutputType | null
    _min: GestioncasoMinAggregateOutputType | null
    _max: GestioncasoMaxAggregateOutputType | null
  }

  type GetGestioncasoGroupByPayload<T extends gestioncasoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GestioncasoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GestioncasoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GestioncasoGroupByOutputType[P]>
            : GetScalarType<T[P], GestioncasoGroupByOutputType[P]>
        }
      >
    >


  export type gestioncasoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgestion?: boolean
    idcaso?: boolean
    contrato?: boolean
    operador?: boolean
    accion?: boolean
    observacion?: boolean
    fechaaccion?: boolean
    nuevaaccion?: boolean
    fechanuevaaccion?: boolean
    realizado?: boolean
    observacion_nuevaaccion?: boolean
  }, ExtArgs["result"]["gestioncaso"]>

  export type gestioncasoSelectScalar = {
    idgestion?: boolean
    idcaso?: boolean
    contrato?: boolean
    operador?: boolean
    accion?: boolean
    observacion?: boolean
    fechaaccion?: boolean
    nuevaaccion?: boolean
    fechanuevaaccion?: boolean
    realizado?: boolean
    observacion_nuevaaccion?: boolean
  }


  type gestioncasoGetPayload<S extends boolean | null | undefined | gestioncasoArgs> = $Types.GetResult<gestioncasoPayload, S>

  type gestioncasoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gestioncasoFindManyArgs, 'select' | 'include'> & {
      select?: GestioncasoCountAggregateInputType | true
    }

  export interface gestioncasoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gestioncaso'], meta: { name: 'gestioncaso' } }
    /**
     * Find zero or one Gestioncaso that matches the filter.
     * @param {gestioncasoFindUniqueArgs} args - Arguments to find a Gestioncaso
     * @example
     * // Get one Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gestioncasoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gestioncasoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gestioncaso'> extends True ? Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gestioncaso that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gestioncasoFindUniqueOrThrowArgs} args - Arguments to find a Gestioncaso
     * @example
     * // Get one Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gestioncasoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gestioncasoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gestioncaso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoFindFirstArgs} args - Arguments to find a Gestioncaso
     * @example
     * // Get one Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gestioncasoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gestioncasoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gestioncaso'> extends True ? Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gestioncaso that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoFindFirstOrThrowArgs} args - Arguments to find a Gestioncaso
     * @example
     * // Get one Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gestioncasoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gestioncasoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gestioncasos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gestioncasos
     * const gestioncasos = await prisma.gestioncaso.findMany()
     * 
     * // Get first 10 Gestioncasos
     * const gestioncasos = await prisma.gestioncaso.findMany({ take: 10 })
     * 
     * // Only select the `idgestion`
     * const gestioncasoWithIdgestionOnly = await prisma.gestioncaso.findMany({ select: { idgestion: true } })
     * 
    **/
    findMany<T extends gestioncasoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gestioncasoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gestioncaso.
     * @param {gestioncasoCreateArgs} args - Arguments to create a Gestioncaso.
     * @example
     * // Create one Gestioncaso
     * const Gestioncaso = await prisma.gestioncaso.create({
     *   data: {
     *     // ... data to create a Gestioncaso
     *   }
     * })
     * 
    **/
    create<T extends gestioncasoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gestioncasoCreateArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gestioncasos.
     *     @param {gestioncasoCreateManyArgs} args - Arguments to create many Gestioncasos.
     *     @example
     *     // Create many Gestioncasos
     *     const gestioncaso = await prisma.gestioncaso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gestioncasoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gestioncasoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gestioncaso.
     * @param {gestioncasoDeleteArgs} args - Arguments to delete one Gestioncaso.
     * @example
     * // Delete one Gestioncaso
     * const Gestioncaso = await prisma.gestioncaso.delete({
     *   where: {
     *     // ... filter to delete one Gestioncaso
     *   }
     * })
     * 
    **/
    delete<T extends gestioncasoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gestioncasoDeleteArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gestioncaso.
     * @param {gestioncasoUpdateArgs} args - Arguments to update one Gestioncaso.
     * @example
     * // Update one Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gestioncasoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gestioncasoUpdateArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gestioncasos.
     * @param {gestioncasoDeleteManyArgs} args - Arguments to filter Gestioncasos to delete.
     * @example
     * // Delete a few Gestioncasos
     * const { count } = await prisma.gestioncaso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gestioncasoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gestioncasoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gestioncasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gestioncasos
     * const gestioncaso = await prisma.gestioncaso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gestioncasoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gestioncasoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gestioncaso.
     * @param {gestioncasoUpsertArgs} args - Arguments to update or create a Gestioncaso.
     * @example
     * // Update or create a Gestioncaso
     * const gestioncaso = await prisma.gestioncaso.upsert({
     *   create: {
     *     // ... data to create a Gestioncaso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gestioncaso we want to update
     *   }
     * })
    **/
    upsert<T extends gestioncasoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gestioncasoUpsertArgs<ExtArgs>>
    ): Prisma__gestioncasoClient<$Types.GetResult<gestioncasoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gestioncasos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoCountArgs} args - Arguments to filter Gestioncasos to count.
     * @example
     * // Count the number of Gestioncasos
     * const count = await prisma.gestioncaso.count({
     *   where: {
     *     // ... the filter for the Gestioncasos we want to count
     *   }
     * })
    **/
    count<T extends gestioncasoCountArgs>(
      args?: Subset<T, gestioncasoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GestioncasoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gestioncaso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GestioncasoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GestioncasoAggregateArgs>(args: Subset<T, GestioncasoAggregateArgs>): Prisma.PrismaPromise<GetGestioncasoAggregateType<T>>

    /**
     * Group by Gestioncaso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gestioncasoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gestioncasoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gestioncasoGroupByArgs['orderBy'] }
        : { orderBy?: gestioncasoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gestioncasoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGestioncasoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gestioncaso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gestioncasoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gestioncaso base type for findUnique actions
   */
  export type gestioncasoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter, which gestioncaso to fetch.
     */
    where: gestioncasoWhereUniqueInput
  }

  /**
   * gestioncaso findUnique
   */
  export interface gestioncasoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gestioncasoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gestioncaso findUniqueOrThrow
   */
  export type gestioncasoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter, which gestioncaso to fetch.
     */
    where: gestioncasoWhereUniqueInput
  }


  /**
   * gestioncaso base type for findFirst actions
   */
  export type gestioncasoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter, which gestioncaso to fetch.
     */
    where?: gestioncasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gestioncasos to fetch.
     */
    orderBy?: gestioncasoOrderByWithRelationInput | gestioncasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gestioncasos.
     */
    cursor?: gestioncasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gestioncasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gestioncasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gestioncasos.
     */
    distinct?: GestioncasoScalarFieldEnum | GestioncasoScalarFieldEnum[]
  }

  /**
   * gestioncaso findFirst
   */
  export interface gestioncasoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gestioncasoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gestioncaso findFirstOrThrow
   */
  export type gestioncasoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter, which gestioncaso to fetch.
     */
    where?: gestioncasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gestioncasos to fetch.
     */
    orderBy?: gestioncasoOrderByWithRelationInput | gestioncasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gestioncasos.
     */
    cursor?: gestioncasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gestioncasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gestioncasos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gestioncasos.
     */
    distinct?: GestioncasoScalarFieldEnum | GestioncasoScalarFieldEnum[]
  }


  /**
   * gestioncaso findMany
   */
  export type gestioncasoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter, which gestioncasos to fetch.
     */
    where?: gestioncasoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gestioncasos to fetch.
     */
    orderBy?: gestioncasoOrderByWithRelationInput | gestioncasoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gestioncasos.
     */
    cursor?: gestioncasoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gestioncasos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gestioncasos.
     */
    skip?: number
    distinct?: GestioncasoScalarFieldEnum | GestioncasoScalarFieldEnum[]
  }


  /**
   * gestioncaso create
   */
  export type gestioncasoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * The data needed to create a gestioncaso.
     */
    data?: XOR<gestioncasoCreateInput, gestioncasoUncheckedCreateInput>
  }


  /**
   * gestioncaso createMany
   */
  export type gestioncasoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gestioncasos.
     */
    data: gestioncasoCreateManyInput | gestioncasoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gestioncaso update
   */
  export type gestioncasoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * The data needed to update a gestioncaso.
     */
    data: XOR<gestioncasoUpdateInput, gestioncasoUncheckedUpdateInput>
    /**
     * Choose, which gestioncaso to update.
     */
    where: gestioncasoWhereUniqueInput
  }


  /**
   * gestioncaso updateMany
   */
  export type gestioncasoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gestioncasos.
     */
    data: XOR<gestioncasoUpdateManyMutationInput, gestioncasoUncheckedUpdateManyInput>
    /**
     * Filter which gestioncasos to update
     */
    where?: gestioncasoWhereInput
  }


  /**
   * gestioncaso upsert
   */
  export type gestioncasoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * The filter to search for the gestioncaso to update in case it exists.
     */
    where: gestioncasoWhereUniqueInput
    /**
     * In case the gestioncaso found by the `where` argument doesn't exist, create a new gestioncaso with this data.
     */
    create: XOR<gestioncasoCreateInput, gestioncasoUncheckedCreateInput>
    /**
     * In case the gestioncaso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gestioncasoUpdateInput, gestioncasoUncheckedUpdateInput>
  }


  /**
   * gestioncaso delete
   */
  export type gestioncasoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
    /**
     * Filter which gestioncaso to delete.
     */
    where: gestioncasoWhereUniqueInput
  }


  /**
   * gestioncaso deleteMany
   */
  export type gestioncasoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gestioncasos to delete
     */
    where?: gestioncasoWhereInput
  }


  /**
   * gestioncaso without action
   */
  export type gestioncasoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gestioncaso
     */
    select?: gestioncasoSelect<ExtArgs> | null
  }



  /**
   * Model historial_acciones
   */


  export type AggregateHistorial_acciones = {
    _count: Historial_accionesCountAggregateOutputType | null
    _avg: Historial_accionesAvgAggregateOutputType | null
    _sum: Historial_accionesSumAggregateOutputType | null
    _min: Historial_accionesMinAggregateOutputType | null
    _max: Historial_accionesMaxAggregateOutputType | null
  }

  export type Historial_accionesAvgAggregateOutputType = {
    idhistorial: number | null
  }

  export type Historial_accionesSumAggregateOutputType = {
    idhistorial: number | null
  }

  export type Historial_accionesMinAggregateOutputType = {
    idhistorial: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_accionesMaxAggregateOutputType = {
    idhistorial: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_accionesCountAggregateOutputType = {
    idhistorial: number
    operador: number
    fecha: number
    accion: number
    _all: number
  }


  export type Historial_accionesAvgAggregateInputType = {
    idhistorial?: true
  }

  export type Historial_accionesSumAggregateInputType = {
    idhistorial?: true
  }

  export type Historial_accionesMinAggregateInputType = {
    idhistorial?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_accionesMaxAggregateInputType = {
    idhistorial?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_accionesCountAggregateInputType = {
    idhistorial?: true
    operador?: true
    fecha?: true
    accion?: true
    _all?: true
  }

  export type Historial_accionesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_acciones to aggregate.
     */
    where?: historial_accionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_acciones to fetch.
     */
    orderBy?: historial_accionesOrderByWithRelationInput | historial_accionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_accionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_acciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_acciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_acciones
    **/
    _count?: true | Historial_accionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_accionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_accionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_accionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_accionesMaxAggregateInputType
  }

  export type GetHistorial_accionesAggregateType<T extends Historial_accionesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_acciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_acciones[P]>
      : GetScalarType<T[P], AggregateHistorial_acciones[P]>
  }




  export type historial_accionesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_accionesWhereInput
    orderBy?: historial_accionesOrderByWithAggregationInput | historial_accionesOrderByWithAggregationInput[]
    by: Historial_accionesScalarFieldEnum[] | Historial_accionesScalarFieldEnum
    having?: historial_accionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_accionesCountAggregateInputType | true
    _avg?: Historial_accionesAvgAggregateInputType
    _sum?: Historial_accionesSumAggregateInputType
    _min?: Historial_accionesMinAggregateInputType
    _max?: Historial_accionesMaxAggregateInputType
  }


  export type Historial_accionesGroupByOutputType = {
    idhistorial: number
    operador: string | null
    fecha: Date | null
    accion: string | null
    _count: Historial_accionesCountAggregateOutputType | null
    _avg: Historial_accionesAvgAggregateOutputType | null
    _sum: Historial_accionesSumAggregateOutputType | null
    _min: Historial_accionesMinAggregateOutputType | null
    _max: Historial_accionesMaxAggregateOutputType | null
  }

  type GetHistorial_accionesGroupByPayload<T extends historial_accionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_accionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_accionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_accionesGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_accionesGroupByOutputType[P]>
        }
      >
    >


  export type historial_accionesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhistorial?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }, ExtArgs["result"]["historial_acciones"]>

  export type historial_accionesSelectScalar = {
    idhistorial?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }


  type historial_accionesGetPayload<S extends boolean | null | undefined | historial_accionesArgs> = $Types.GetResult<historial_accionesPayload, S>

  type historial_accionesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_accionesFindManyArgs, 'select' | 'include'> & {
      select?: Historial_accionesCountAggregateInputType | true
    }

  export interface historial_accionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_acciones'], meta: { name: 'historial_acciones' } }
    /**
     * Find zero or one Historial_acciones that matches the filter.
     * @param {historial_accionesFindUniqueArgs} args - Arguments to find a Historial_acciones
     * @example
     * // Get one Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_accionesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_accionesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_acciones'> extends True ? Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_acciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_accionesFindUniqueOrThrowArgs} args - Arguments to find a Historial_acciones
     * @example
     * // Get one Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_accionesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_accionesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_acciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesFindFirstArgs} args - Arguments to find a Historial_acciones
     * @example
     * // Get one Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_accionesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_accionesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_acciones'> extends True ? Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_acciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesFindFirstOrThrowArgs} args - Arguments to find a Historial_acciones
     * @example
     * // Get one Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_accionesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_accionesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_acciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findMany()
     * 
     * // Get first 10 Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_accionesWithIdhistorialOnly = await prisma.historial_acciones.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_accionesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_accionesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_acciones.
     * @param {historial_accionesCreateArgs} args - Arguments to create a Historial_acciones.
     * @example
     * // Create one Historial_acciones
     * const Historial_acciones = await prisma.historial_acciones.create({
     *   data: {
     *     // ... data to create a Historial_acciones
     *   }
     * })
     * 
    **/
    create<T extends historial_accionesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_accionesCreateArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_acciones.
     *     @param {historial_accionesCreateManyArgs} args - Arguments to create many Historial_acciones.
     *     @example
     *     // Create many Historial_acciones
     *     const historial_acciones = await prisma.historial_acciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_accionesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_accionesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_acciones.
     * @param {historial_accionesDeleteArgs} args - Arguments to delete one Historial_acciones.
     * @example
     * // Delete one Historial_acciones
     * const Historial_acciones = await prisma.historial_acciones.delete({
     *   where: {
     *     // ... filter to delete one Historial_acciones
     *   }
     * })
     * 
    **/
    delete<T extends historial_accionesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_accionesDeleteArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_acciones.
     * @param {historial_accionesUpdateArgs} args - Arguments to update one Historial_acciones.
     * @example
     * // Update one Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_accionesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_accionesUpdateArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_acciones.
     * @param {historial_accionesDeleteManyArgs} args - Arguments to filter Historial_acciones to delete.
     * @example
     * // Delete a few Historial_acciones
     * const { count } = await prisma.historial_acciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_accionesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_accionesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_acciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_accionesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_accionesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_acciones.
     * @param {historial_accionesUpsertArgs} args - Arguments to update or create a Historial_acciones.
     * @example
     * // Update or create a Historial_acciones
     * const historial_acciones = await prisma.historial_acciones.upsert({
     *   create: {
     *     // ... data to create a Historial_acciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_acciones we want to update
     *   }
     * })
    **/
    upsert<T extends historial_accionesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_accionesUpsertArgs<ExtArgs>>
    ): Prisma__historial_accionesClient<$Types.GetResult<historial_accionesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_acciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesCountArgs} args - Arguments to filter Historial_acciones to count.
     * @example
     * // Count the number of Historial_acciones
     * const count = await prisma.historial_acciones.count({
     *   where: {
     *     // ... the filter for the Historial_acciones we want to count
     *   }
     * })
    **/
    count<T extends historial_accionesCountArgs>(
      args?: Subset<T, historial_accionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_accionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_acciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_accionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_accionesAggregateArgs>(args: Subset<T, Historial_accionesAggregateArgs>): Prisma.PrismaPromise<GetHistorial_accionesAggregateType<T>>

    /**
     * Group by Historial_acciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_accionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_accionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_accionesGroupByArgs['orderBy'] }
        : { orderBy?: historial_accionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_accionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_accionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_acciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_accionesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_acciones base type for findUnique actions
   */
  export type historial_accionesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_acciones to fetch.
     */
    where: historial_accionesWhereUniqueInput
  }

  /**
   * historial_acciones findUnique
   */
  export interface historial_accionesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_accionesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_acciones findUniqueOrThrow
   */
  export type historial_accionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_acciones to fetch.
     */
    where: historial_accionesWhereUniqueInput
  }


  /**
   * historial_acciones base type for findFirst actions
   */
  export type historial_accionesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_acciones to fetch.
     */
    where?: historial_accionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_acciones to fetch.
     */
    orderBy?: historial_accionesOrderByWithRelationInput | historial_accionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_acciones.
     */
    cursor?: historial_accionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_acciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_acciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_acciones.
     */
    distinct?: Historial_accionesScalarFieldEnum | Historial_accionesScalarFieldEnum[]
  }

  /**
   * historial_acciones findFirst
   */
  export interface historial_accionesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_accionesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_acciones findFirstOrThrow
   */
  export type historial_accionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_acciones to fetch.
     */
    where?: historial_accionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_acciones to fetch.
     */
    orderBy?: historial_accionesOrderByWithRelationInput | historial_accionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_acciones.
     */
    cursor?: historial_accionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_acciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_acciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_acciones.
     */
    distinct?: Historial_accionesScalarFieldEnum | Historial_accionesScalarFieldEnum[]
  }


  /**
   * historial_acciones findMany
   */
  export type historial_accionesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_acciones to fetch.
     */
    where?: historial_accionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_acciones to fetch.
     */
    orderBy?: historial_accionesOrderByWithRelationInput | historial_accionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_acciones.
     */
    cursor?: historial_accionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_acciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_acciones.
     */
    skip?: number
    distinct?: Historial_accionesScalarFieldEnum | Historial_accionesScalarFieldEnum[]
  }


  /**
   * historial_acciones create
   */
  export type historial_accionesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_acciones.
     */
    data?: XOR<historial_accionesCreateInput, historial_accionesUncheckedCreateInput>
  }


  /**
   * historial_acciones createMany
   */
  export type historial_accionesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_acciones.
     */
    data: historial_accionesCreateManyInput | historial_accionesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_acciones update
   */
  export type historial_accionesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_acciones.
     */
    data: XOR<historial_accionesUpdateInput, historial_accionesUncheckedUpdateInput>
    /**
     * Choose, which historial_acciones to update.
     */
    where: historial_accionesWhereUniqueInput
  }


  /**
   * historial_acciones updateMany
   */
  export type historial_accionesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_acciones.
     */
    data: XOR<historial_accionesUpdateManyMutationInput, historial_accionesUncheckedUpdateManyInput>
    /**
     * Filter which historial_acciones to update
     */
    where?: historial_accionesWhereInput
  }


  /**
   * historial_acciones upsert
   */
  export type historial_accionesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_acciones to update in case it exists.
     */
    where: historial_accionesWhereUniqueInput
    /**
     * In case the historial_acciones found by the `where` argument doesn't exist, create a new historial_acciones with this data.
     */
    create: XOR<historial_accionesCreateInput, historial_accionesUncheckedCreateInput>
    /**
     * In case the historial_acciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_accionesUpdateInput, historial_accionesUncheckedUpdateInput>
  }


  /**
   * historial_acciones delete
   */
  export type historial_accionesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
    /**
     * Filter which historial_acciones to delete.
     */
    where: historial_accionesWhereUniqueInput
  }


  /**
   * historial_acciones deleteMany
   */
  export type historial_accionesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_acciones to delete
     */
    where?: historial_accionesWhereInput
  }


  /**
   * historial_acciones without action
   */
  export type historial_accionesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_acciones
     */
    select?: historial_accionesSelect<ExtArgs> | null
  }



  /**
   * Model historial_aprobacion_prestamos
   */


  export type AggregateHistorial_aprobacion_prestamos = {
    _count: Historial_aprobacion_prestamosCountAggregateOutputType | null
    _avg: Historial_aprobacion_prestamosAvgAggregateOutputType | null
    _sum: Historial_aprobacion_prestamosSumAggregateOutputType | null
    _min: Historial_aprobacion_prestamosMinAggregateOutputType | null
    _max: Historial_aprobacion_prestamosMaxAggregateOutputType | null
  }

  export type Historial_aprobacion_prestamosAvgAggregateOutputType = {
    idaprobacion: number | null
    idprestamo: number | null
    contrato: number | null
    productor: number | null
  }

  export type Historial_aprobacion_prestamosSumAggregateOutputType = {
    idaprobacion: number | null
    idprestamo: number | null
    contrato: number | null
    productor: number | null
  }

  export type Historial_aprobacion_prestamosMinAggregateOutputType = {
    idaprobacion: number | null
    operador: string | null
    idprestamo: number | null
    fecha: Date | null
    contrato: number | null
    afiliado: string | null
    productor: number | null
  }

  export type Historial_aprobacion_prestamosMaxAggregateOutputType = {
    idaprobacion: number | null
    operador: string | null
    idprestamo: number | null
    fecha: Date | null
    contrato: number | null
    afiliado: string | null
    productor: number | null
  }

  export type Historial_aprobacion_prestamosCountAggregateOutputType = {
    idaprobacion: number
    operador: number
    idprestamo: number
    fecha: number
    contrato: number
    afiliado: number
    productor: number
    _all: number
  }


  export type Historial_aprobacion_prestamosAvgAggregateInputType = {
    idaprobacion?: true
    idprestamo?: true
    contrato?: true
    productor?: true
  }

  export type Historial_aprobacion_prestamosSumAggregateInputType = {
    idaprobacion?: true
    idprestamo?: true
    contrato?: true
    productor?: true
  }

  export type Historial_aprobacion_prestamosMinAggregateInputType = {
    idaprobacion?: true
    operador?: true
    idprestamo?: true
    fecha?: true
    contrato?: true
    afiliado?: true
    productor?: true
  }

  export type Historial_aprobacion_prestamosMaxAggregateInputType = {
    idaprobacion?: true
    operador?: true
    idprestamo?: true
    fecha?: true
    contrato?: true
    afiliado?: true
    productor?: true
  }

  export type Historial_aprobacion_prestamosCountAggregateInputType = {
    idaprobacion?: true
    operador?: true
    idprestamo?: true
    fecha?: true
    contrato?: true
    afiliado?: true
    productor?: true
    _all?: true
  }

  export type Historial_aprobacion_prestamosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_aprobacion_prestamos to aggregate.
     */
    where?: historial_aprobacion_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_aprobacion_prestamos to fetch.
     */
    orderBy?: historial_aprobacion_prestamosOrderByWithRelationInput | historial_aprobacion_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_aprobacion_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_aprobacion_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_aprobacion_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_aprobacion_prestamos
    **/
    _count?: true | Historial_aprobacion_prestamosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_aprobacion_prestamosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_aprobacion_prestamosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_aprobacion_prestamosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_aprobacion_prestamosMaxAggregateInputType
  }

  export type GetHistorial_aprobacion_prestamosAggregateType<T extends Historial_aprobacion_prestamosAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_aprobacion_prestamos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_aprobacion_prestamos[P]>
      : GetScalarType<T[P], AggregateHistorial_aprobacion_prestamos[P]>
  }




  export type historial_aprobacion_prestamosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_aprobacion_prestamosWhereInput
    orderBy?: historial_aprobacion_prestamosOrderByWithAggregationInput | historial_aprobacion_prestamosOrderByWithAggregationInput[]
    by: Historial_aprobacion_prestamosScalarFieldEnum[] | Historial_aprobacion_prestamosScalarFieldEnum
    having?: historial_aprobacion_prestamosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_aprobacion_prestamosCountAggregateInputType | true
    _avg?: Historial_aprobacion_prestamosAvgAggregateInputType
    _sum?: Historial_aprobacion_prestamosSumAggregateInputType
    _min?: Historial_aprobacion_prestamosMinAggregateInputType
    _max?: Historial_aprobacion_prestamosMaxAggregateInputType
  }


  export type Historial_aprobacion_prestamosGroupByOutputType = {
    idaprobacion: number
    operador: string | null
    idprestamo: number | null
    fecha: Date | null
    contrato: number | null
    afiliado: string | null
    productor: number | null
    _count: Historial_aprobacion_prestamosCountAggregateOutputType | null
    _avg: Historial_aprobacion_prestamosAvgAggregateOutputType | null
    _sum: Historial_aprobacion_prestamosSumAggregateOutputType | null
    _min: Historial_aprobacion_prestamosMinAggregateOutputType | null
    _max: Historial_aprobacion_prestamosMaxAggregateOutputType | null
  }

  type GetHistorial_aprobacion_prestamosGroupByPayload<T extends historial_aprobacion_prestamosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_aprobacion_prestamosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_aprobacion_prestamosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_aprobacion_prestamosGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_aprobacion_prestamosGroupByOutputType[P]>
        }
      >
    >


  export type historial_aprobacion_prestamosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idaprobacion?: boolean
    operador?: boolean
    idprestamo?: boolean
    fecha?: boolean
    contrato?: boolean
    afiliado?: boolean
    productor?: boolean
  }, ExtArgs["result"]["historial_aprobacion_prestamos"]>

  export type historial_aprobacion_prestamosSelectScalar = {
    idaprobacion?: boolean
    operador?: boolean
    idprestamo?: boolean
    fecha?: boolean
    contrato?: boolean
    afiliado?: boolean
    productor?: boolean
  }


  type historial_aprobacion_prestamosGetPayload<S extends boolean | null | undefined | historial_aprobacion_prestamosArgs> = $Types.GetResult<historial_aprobacion_prestamosPayload, S>

  type historial_aprobacion_prestamosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_aprobacion_prestamosFindManyArgs, 'select' | 'include'> & {
      select?: Historial_aprobacion_prestamosCountAggregateInputType | true
    }

  export interface historial_aprobacion_prestamosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_aprobacion_prestamos'], meta: { name: 'historial_aprobacion_prestamos' } }
    /**
     * Find zero or one Historial_aprobacion_prestamos that matches the filter.
     * @param {historial_aprobacion_prestamosFindUniqueArgs} args - Arguments to find a Historial_aprobacion_prestamos
     * @example
     * // Get one Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_aprobacion_prestamosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_aprobacion_prestamosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_aprobacion_prestamos'> extends True ? Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_aprobacion_prestamos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_aprobacion_prestamosFindUniqueOrThrowArgs} args - Arguments to find a Historial_aprobacion_prestamos
     * @example
     * // Get one Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_aprobacion_prestamosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_aprobacion_prestamosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_aprobacion_prestamos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosFindFirstArgs} args - Arguments to find a Historial_aprobacion_prestamos
     * @example
     * // Get one Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_aprobacion_prestamosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_aprobacion_prestamosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_aprobacion_prestamos'> extends True ? Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_aprobacion_prestamos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosFindFirstOrThrowArgs} args - Arguments to find a Historial_aprobacion_prestamos
     * @example
     * // Get one Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_aprobacion_prestamosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_aprobacion_prestamosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_aprobacion_prestamos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findMany()
     * 
     * // Get first 10 Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.findMany({ take: 10 })
     * 
     * // Only select the `idaprobacion`
     * const historial_aprobacion_prestamosWithIdaprobacionOnly = await prisma.historial_aprobacion_prestamos.findMany({ select: { idaprobacion: true } })
     * 
    **/
    findMany<T extends historial_aprobacion_prestamosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_aprobacion_prestamosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_aprobacion_prestamos.
     * @param {historial_aprobacion_prestamosCreateArgs} args - Arguments to create a Historial_aprobacion_prestamos.
     * @example
     * // Create one Historial_aprobacion_prestamos
     * const Historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.create({
     *   data: {
     *     // ... data to create a Historial_aprobacion_prestamos
     *   }
     * })
     * 
    **/
    create<T extends historial_aprobacion_prestamosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_aprobacion_prestamosCreateArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_aprobacion_prestamos.
     *     @param {historial_aprobacion_prestamosCreateManyArgs} args - Arguments to create many Historial_aprobacion_prestamos.
     *     @example
     *     // Create many Historial_aprobacion_prestamos
     *     const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_aprobacion_prestamosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_aprobacion_prestamosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_aprobacion_prestamos.
     * @param {historial_aprobacion_prestamosDeleteArgs} args - Arguments to delete one Historial_aprobacion_prestamos.
     * @example
     * // Delete one Historial_aprobacion_prestamos
     * const Historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.delete({
     *   where: {
     *     // ... filter to delete one Historial_aprobacion_prestamos
     *   }
     * })
     * 
    **/
    delete<T extends historial_aprobacion_prestamosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_aprobacion_prestamosDeleteArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_aprobacion_prestamos.
     * @param {historial_aprobacion_prestamosUpdateArgs} args - Arguments to update one Historial_aprobacion_prestamos.
     * @example
     * // Update one Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_aprobacion_prestamosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_aprobacion_prestamosUpdateArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_aprobacion_prestamos.
     * @param {historial_aprobacion_prestamosDeleteManyArgs} args - Arguments to filter Historial_aprobacion_prestamos to delete.
     * @example
     * // Delete a few Historial_aprobacion_prestamos
     * const { count } = await prisma.historial_aprobacion_prestamos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_aprobacion_prestamosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_aprobacion_prestamosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_aprobacion_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_aprobacion_prestamosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_aprobacion_prestamosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_aprobacion_prestamos.
     * @param {historial_aprobacion_prestamosUpsertArgs} args - Arguments to update or create a Historial_aprobacion_prestamos.
     * @example
     * // Update or create a Historial_aprobacion_prestamos
     * const historial_aprobacion_prestamos = await prisma.historial_aprobacion_prestamos.upsert({
     *   create: {
     *     // ... data to create a Historial_aprobacion_prestamos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_aprobacion_prestamos we want to update
     *   }
     * })
    **/
    upsert<T extends historial_aprobacion_prestamosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_aprobacion_prestamosUpsertArgs<ExtArgs>>
    ): Prisma__historial_aprobacion_prestamosClient<$Types.GetResult<historial_aprobacion_prestamosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_aprobacion_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosCountArgs} args - Arguments to filter Historial_aprobacion_prestamos to count.
     * @example
     * // Count the number of Historial_aprobacion_prestamos
     * const count = await prisma.historial_aprobacion_prestamos.count({
     *   where: {
     *     // ... the filter for the Historial_aprobacion_prestamos we want to count
     *   }
     * })
    **/
    count<T extends historial_aprobacion_prestamosCountArgs>(
      args?: Subset<T, historial_aprobacion_prestamosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_aprobacion_prestamosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_aprobacion_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_aprobacion_prestamosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_aprobacion_prestamosAggregateArgs>(args: Subset<T, Historial_aprobacion_prestamosAggregateArgs>): Prisma.PrismaPromise<GetHistorial_aprobacion_prestamosAggregateType<T>>

    /**
     * Group by Historial_aprobacion_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_aprobacion_prestamosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_aprobacion_prestamosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_aprobacion_prestamosGroupByArgs['orderBy'] }
        : { orderBy?: historial_aprobacion_prestamosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_aprobacion_prestamosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_aprobacion_prestamosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_aprobacion_prestamos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_aprobacion_prestamosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_aprobacion_prestamos base type for findUnique actions
   */
  export type historial_aprobacion_prestamosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which historial_aprobacion_prestamos to fetch.
     */
    where: historial_aprobacion_prestamosWhereUniqueInput
  }

  /**
   * historial_aprobacion_prestamos findUnique
   */
  export interface historial_aprobacion_prestamosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_aprobacion_prestamosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_aprobacion_prestamos findUniqueOrThrow
   */
  export type historial_aprobacion_prestamosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which historial_aprobacion_prestamos to fetch.
     */
    where: historial_aprobacion_prestamosWhereUniqueInput
  }


  /**
   * historial_aprobacion_prestamos base type for findFirst actions
   */
  export type historial_aprobacion_prestamosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which historial_aprobacion_prestamos to fetch.
     */
    where?: historial_aprobacion_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_aprobacion_prestamos to fetch.
     */
    orderBy?: historial_aprobacion_prestamosOrderByWithRelationInput | historial_aprobacion_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_aprobacion_prestamos.
     */
    cursor?: historial_aprobacion_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_aprobacion_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_aprobacion_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_aprobacion_prestamos.
     */
    distinct?: Historial_aprobacion_prestamosScalarFieldEnum | Historial_aprobacion_prestamosScalarFieldEnum[]
  }

  /**
   * historial_aprobacion_prestamos findFirst
   */
  export interface historial_aprobacion_prestamosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_aprobacion_prestamosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_aprobacion_prestamos findFirstOrThrow
   */
  export type historial_aprobacion_prestamosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which historial_aprobacion_prestamos to fetch.
     */
    where?: historial_aprobacion_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_aprobacion_prestamos to fetch.
     */
    orderBy?: historial_aprobacion_prestamosOrderByWithRelationInput | historial_aprobacion_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_aprobacion_prestamos.
     */
    cursor?: historial_aprobacion_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_aprobacion_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_aprobacion_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_aprobacion_prestamos.
     */
    distinct?: Historial_aprobacion_prestamosScalarFieldEnum | Historial_aprobacion_prestamosScalarFieldEnum[]
  }


  /**
   * historial_aprobacion_prestamos findMany
   */
  export type historial_aprobacion_prestamosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which historial_aprobacion_prestamos to fetch.
     */
    where?: historial_aprobacion_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_aprobacion_prestamos to fetch.
     */
    orderBy?: historial_aprobacion_prestamosOrderByWithRelationInput | historial_aprobacion_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_aprobacion_prestamos.
     */
    cursor?: historial_aprobacion_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_aprobacion_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_aprobacion_prestamos.
     */
    skip?: number
    distinct?: Historial_aprobacion_prestamosScalarFieldEnum | Historial_aprobacion_prestamosScalarFieldEnum[]
  }


  /**
   * historial_aprobacion_prestamos create
   */
  export type historial_aprobacion_prestamosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_aprobacion_prestamos.
     */
    data?: XOR<historial_aprobacion_prestamosCreateInput, historial_aprobacion_prestamosUncheckedCreateInput>
  }


  /**
   * historial_aprobacion_prestamos createMany
   */
  export type historial_aprobacion_prestamosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_aprobacion_prestamos.
     */
    data: historial_aprobacion_prestamosCreateManyInput | historial_aprobacion_prestamosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_aprobacion_prestamos update
   */
  export type historial_aprobacion_prestamosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_aprobacion_prestamos.
     */
    data: XOR<historial_aprobacion_prestamosUpdateInput, historial_aprobacion_prestamosUncheckedUpdateInput>
    /**
     * Choose, which historial_aprobacion_prestamos to update.
     */
    where: historial_aprobacion_prestamosWhereUniqueInput
  }


  /**
   * historial_aprobacion_prestamos updateMany
   */
  export type historial_aprobacion_prestamosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_aprobacion_prestamos.
     */
    data: XOR<historial_aprobacion_prestamosUpdateManyMutationInput, historial_aprobacion_prestamosUncheckedUpdateManyInput>
    /**
     * Filter which historial_aprobacion_prestamos to update
     */
    where?: historial_aprobacion_prestamosWhereInput
  }


  /**
   * historial_aprobacion_prestamos upsert
   */
  export type historial_aprobacion_prestamosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_aprobacion_prestamos to update in case it exists.
     */
    where: historial_aprobacion_prestamosWhereUniqueInput
    /**
     * In case the historial_aprobacion_prestamos found by the `where` argument doesn't exist, create a new historial_aprobacion_prestamos with this data.
     */
    create: XOR<historial_aprobacion_prestamosCreateInput, historial_aprobacion_prestamosUncheckedCreateInput>
    /**
     * In case the historial_aprobacion_prestamos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_aprobacion_prestamosUpdateInput, historial_aprobacion_prestamosUncheckedUpdateInput>
  }


  /**
   * historial_aprobacion_prestamos delete
   */
  export type historial_aprobacion_prestamosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
    /**
     * Filter which historial_aprobacion_prestamos to delete.
     */
    where: historial_aprobacion_prestamosWhereUniqueInput
  }


  /**
   * historial_aprobacion_prestamos deleteMany
   */
  export type historial_aprobacion_prestamosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_aprobacion_prestamos to delete
     */
    where?: historial_aprobacion_prestamosWhereInput
  }


  /**
   * historial_aprobacion_prestamos without action
   */
  export type historial_aprobacion_prestamosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_aprobacion_prestamos
     */
    select?: historial_aprobacion_prestamosSelect<ExtArgs> | null
  }



  /**
   * Model historial_liquidaciones
   */


  export type AggregateHistorial_liquidaciones = {
    _count: Historial_liquidacionesCountAggregateOutputType | null
    _avg: Historial_liquidacionesAvgAggregateOutputType | null
    _sum: Historial_liquidacionesSumAggregateOutputType | null
    _min: Historial_liquidacionesMinAggregateOutputType | null
    _max: Historial_liquidacionesMaxAggregateOutputType | null
  }

  export type Historial_liquidacionesAvgAggregateOutputType = {
    idliquidacion: number | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
  }

  export type Historial_liquidacionesSumAggregateOutputType = {
    idliquidacion: number | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
  }

  export type Historial_liquidacionesMinAggregateOutputType = {
    idliquidacion: number | null
    operador: string | null
    fecha: string | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
    entidad: string | null
  }

  export type Historial_liquidacionesMaxAggregateOutputType = {
    idliquidacion: number | null
    operador: string | null
    fecha: string | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
    entidad: string | null
  }

  export type Historial_liquidacionesCountAggregateOutputType = {
    idliquidacion: number
    operador: number
    fecha: number
    mes: number
    ano: number
    cobranza: number
    total: number
    comision: number
    entidad: number
    _all: number
  }


  export type Historial_liquidacionesAvgAggregateInputType = {
    idliquidacion?: true
    mes?: true
    ano?: true
    cobranza?: true
    total?: true
    comision?: true
  }

  export type Historial_liquidacionesSumAggregateInputType = {
    idliquidacion?: true
    mes?: true
    ano?: true
    cobranza?: true
    total?: true
    comision?: true
  }

  export type Historial_liquidacionesMinAggregateInputType = {
    idliquidacion?: true
    operador?: true
    fecha?: true
    mes?: true
    ano?: true
    cobranza?: true
    total?: true
    comision?: true
    entidad?: true
  }

  export type Historial_liquidacionesMaxAggregateInputType = {
    idliquidacion?: true
    operador?: true
    fecha?: true
    mes?: true
    ano?: true
    cobranza?: true
    total?: true
    comision?: true
    entidad?: true
  }

  export type Historial_liquidacionesCountAggregateInputType = {
    idliquidacion?: true
    operador?: true
    fecha?: true
    mes?: true
    ano?: true
    cobranza?: true
    total?: true
    comision?: true
    entidad?: true
    _all?: true
  }

  export type Historial_liquidacionesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_liquidaciones to aggregate.
     */
    where?: historial_liquidacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_liquidaciones to fetch.
     */
    orderBy?: historial_liquidacionesOrderByWithRelationInput | historial_liquidacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_liquidacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_liquidaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_liquidaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_liquidaciones
    **/
    _count?: true | Historial_liquidacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_liquidacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_liquidacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_liquidacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_liquidacionesMaxAggregateInputType
  }

  export type GetHistorial_liquidacionesAggregateType<T extends Historial_liquidacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_liquidaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_liquidaciones[P]>
      : GetScalarType<T[P], AggregateHistorial_liquidaciones[P]>
  }




  export type historial_liquidacionesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_liquidacionesWhereInput
    orderBy?: historial_liquidacionesOrderByWithAggregationInput | historial_liquidacionesOrderByWithAggregationInput[]
    by: Historial_liquidacionesScalarFieldEnum[] | Historial_liquidacionesScalarFieldEnum
    having?: historial_liquidacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_liquidacionesCountAggregateInputType | true
    _avg?: Historial_liquidacionesAvgAggregateInputType
    _sum?: Historial_liquidacionesSumAggregateInputType
    _min?: Historial_liquidacionesMinAggregateInputType
    _max?: Historial_liquidacionesMaxAggregateInputType
  }


  export type Historial_liquidacionesGroupByOutputType = {
    idliquidacion: number
    operador: string | null
    fecha: string | null
    mes: number | null
    ano: number | null
    cobranza: number | null
    total: number | null
    comision: number | null
    entidad: string | null
    _count: Historial_liquidacionesCountAggregateOutputType | null
    _avg: Historial_liquidacionesAvgAggregateOutputType | null
    _sum: Historial_liquidacionesSumAggregateOutputType | null
    _min: Historial_liquidacionesMinAggregateOutputType | null
    _max: Historial_liquidacionesMaxAggregateOutputType | null
  }

  type GetHistorial_liquidacionesGroupByPayload<T extends historial_liquidacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_liquidacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_liquidacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_liquidacionesGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_liquidacionesGroupByOutputType[P]>
        }
      >
    >


  export type historial_liquidacionesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idliquidacion?: boolean
    operador?: boolean
    fecha?: boolean
    mes?: boolean
    ano?: boolean
    cobranza?: boolean
    total?: boolean
    comision?: boolean
    entidad?: boolean
  }, ExtArgs["result"]["historial_liquidaciones"]>

  export type historial_liquidacionesSelectScalar = {
    idliquidacion?: boolean
    operador?: boolean
    fecha?: boolean
    mes?: boolean
    ano?: boolean
    cobranza?: boolean
    total?: boolean
    comision?: boolean
    entidad?: boolean
  }


  type historial_liquidacionesGetPayload<S extends boolean | null | undefined | historial_liquidacionesArgs> = $Types.GetResult<historial_liquidacionesPayload, S>

  type historial_liquidacionesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_liquidacionesFindManyArgs, 'select' | 'include'> & {
      select?: Historial_liquidacionesCountAggregateInputType | true
    }

  export interface historial_liquidacionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_liquidaciones'], meta: { name: 'historial_liquidaciones' } }
    /**
     * Find zero or one Historial_liquidaciones that matches the filter.
     * @param {historial_liquidacionesFindUniqueArgs} args - Arguments to find a Historial_liquidaciones
     * @example
     * // Get one Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_liquidacionesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_liquidacionesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_liquidaciones'> extends True ? Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_liquidaciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_liquidacionesFindUniqueOrThrowArgs} args - Arguments to find a Historial_liquidaciones
     * @example
     * // Get one Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_liquidacionesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_liquidacionesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_liquidaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesFindFirstArgs} args - Arguments to find a Historial_liquidaciones
     * @example
     * // Get one Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_liquidacionesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_liquidacionesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_liquidaciones'> extends True ? Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_liquidaciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesFindFirstOrThrowArgs} args - Arguments to find a Historial_liquidaciones
     * @example
     * // Get one Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_liquidacionesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_liquidacionesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_liquidaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findMany()
     * 
     * // Get first 10 Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.findMany({ take: 10 })
     * 
     * // Only select the `idliquidacion`
     * const historial_liquidacionesWithIdliquidacionOnly = await prisma.historial_liquidaciones.findMany({ select: { idliquidacion: true } })
     * 
    **/
    findMany<T extends historial_liquidacionesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_liquidacionesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_liquidaciones.
     * @param {historial_liquidacionesCreateArgs} args - Arguments to create a Historial_liquidaciones.
     * @example
     * // Create one Historial_liquidaciones
     * const Historial_liquidaciones = await prisma.historial_liquidaciones.create({
     *   data: {
     *     // ... data to create a Historial_liquidaciones
     *   }
     * })
     * 
    **/
    create<T extends historial_liquidacionesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_liquidacionesCreateArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_liquidaciones.
     *     @param {historial_liquidacionesCreateManyArgs} args - Arguments to create many Historial_liquidaciones.
     *     @example
     *     // Create many Historial_liquidaciones
     *     const historial_liquidaciones = await prisma.historial_liquidaciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_liquidacionesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_liquidacionesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_liquidaciones.
     * @param {historial_liquidacionesDeleteArgs} args - Arguments to delete one Historial_liquidaciones.
     * @example
     * // Delete one Historial_liquidaciones
     * const Historial_liquidaciones = await prisma.historial_liquidaciones.delete({
     *   where: {
     *     // ... filter to delete one Historial_liquidaciones
     *   }
     * })
     * 
    **/
    delete<T extends historial_liquidacionesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_liquidacionesDeleteArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_liquidaciones.
     * @param {historial_liquidacionesUpdateArgs} args - Arguments to update one Historial_liquidaciones.
     * @example
     * // Update one Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_liquidacionesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_liquidacionesUpdateArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_liquidaciones.
     * @param {historial_liquidacionesDeleteManyArgs} args - Arguments to filter Historial_liquidaciones to delete.
     * @example
     * // Delete a few Historial_liquidaciones
     * const { count } = await prisma.historial_liquidaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_liquidacionesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_liquidacionesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_liquidaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_liquidacionesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_liquidacionesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_liquidaciones.
     * @param {historial_liquidacionesUpsertArgs} args - Arguments to update or create a Historial_liquidaciones.
     * @example
     * // Update or create a Historial_liquidaciones
     * const historial_liquidaciones = await prisma.historial_liquidaciones.upsert({
     *   create: {
     *     // ... data to create a Historial_liquidaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_liquidaciones we want to update
     *   }
     * })
    **/
    upsert<T extends historial_liquidacionesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_liquidacionesUpsertArgs<ExtArgs>>
    ): Prisma__historial_liquidacionesClient<$Types.GetResult<historial_liquidacionesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_liquidaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesCountArgs} args - Arguments to filter Historial_liquidaciones to count.
     * @example
     * // Count the number of Historial_liquidaciones
     * const count = await prisma.historial_liquidaciones.count({
     *   where: {
     *     // ... the filter for the Historial_liquidaciones we want to count
     *   }
     * })
    **/
    count<T extends historial_liquidacionesCountArgs>(
      args?: Subset<T, historial_liquidacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_liquidacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_liquidaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_liquidacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_liquidacionesAggregateArgs>(args: Subset<T, Historial_liquidacionesAggregateArgs>): Prisma.PrismaPromise<GetHistorial_liquidacionesAggregateType<T>>

    /**
     * Group by Historial_liquidaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_liquidacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_liquidacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_liquidacionesGroupByArgs['orderBy'] }
        : { orderBy?: historial_liquidacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_liquidacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_liquidacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_liquidaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_liquidacionesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_liquidaciones base type for findUnique actions
   */
  export type historial_liquidacionesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_liquidaciones to fetch.
     */
    where: historial_liquidacionesWhereUniqueInput
  }

  /**
   * historial_liquidaciones findUnique
   */
  export interface historial_liquidacionesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_liquidacionesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_liquidaciones findUniqueOrThrow
   */
  export type historial_liquidacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_liquidaciones to fetch.
     */
    where: historial_liquidacionesWhereUniqueInput
  }


  /**
   * historial_liquidaciones base type for findFirst actions
   */
  export type historial_liquidacionesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_liquidaciones to fetch.
     */
    where?: historial_liquidacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_liquidaciones to fetch.
     */
    orderBy?: historial_liquidacionesOrderByWithRelationInput | historial_liquidacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_liquidaciones.
     */
    cursor?: historial_liquidacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_liquidaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_liquidaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_liquidaciones.
     */
    distinct?: Historial_liquidacionesScalarFieldEnum | Historial_liquidacionesScalarFieldEnum[]
  }

  /**
   * historial_liquidaciones findFirst
   */
  export interface historial_liquidacionesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_liquidacionesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_liquidaciones findFirstOrThrow
   */
  export type historial_liquidacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_liquidaciones to fetch.
     */
    where?: historial_liquidacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_liquidaciones to fetch.
     */
    orderBy?: historial_liquidacionesOrderByWithRelationInput | historial_liquidacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_liquidaciones.
     */
    cursor?: historial_liquidacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_liquidaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_liquidaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_liquidaciones.
     */
    distinct?: Historial_liquidacionesScalarFieldEnum | Historial_liquidacionesScalarFieldEnum[]
  }


  /**
   * historial_liquidaciones findMany
   */
  export type historial_liquidacionesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter, which historial_liquidaciones to fetch.
     */
    where?: historial_liquidacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_liquidaciones to fetch.
     */
    orderBy?: historial_liquidacionesOrderByWithRelationInput | historial_liquidacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_liquidaciones.
     */
    cursor?: historial_liquidacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_liquidaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_liquidaciones.
     */
    skip?: number
    distinct?: Historial_liquidacionesScalarFieldEnum | Historial_liquidacionesScalarFieldEnum[]
  }


  /**
   * historial_liquidaciones create
   */
  export type historial_liquidacionesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_liquidaciones.
     */
    data?: XOR<historial_liquidacionesCreateInput, historial_liquidacionesUncheckedCreateInput>
  }


  /**
   * historial_liquidaciones createMany
   */
  export type historial_liquidacionesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_liquidaciones.
     */
    data: historial_liquidacionesCreateManyInput | historial_liquidacionesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_liquidaciones update
   */
  export type historial_liquidacionesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_liquidaciones.
     */
    data: XOR<historial_liquidacionesUpdateInput, historial_liquidacionesUncheckedUpdateInput>
    /**
     * Choose, which historial_liquidaciones to update.
     */
    where: historial_liquidacionesWhereUniqueInput
  }


  /**
   * historial_liquidaciones updateMany
   */
  export type historial_liquidacionesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_liquidaciones.
     */
    data: XOR<historial_liquidacionesUpdateManyMutationInput, historial_liquidacionesUncheckedUpdateManyInput>
    /**
     * Filter which historial_liquidaciones to update
     */
    where?: historial_liquidacionesWhereInput
  }


  /**
   * historial_liquidaciones upsert
   */
  export type historial_liquidacionesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_liquidaciones to update in case it exists.
     */
    where: historial_liquidacionesWhereUniqueInput
    /**
     * In case the historial_liquidaciones found by the `where` argument doesn't exist, create a new historial_liquidaciones with this data.
     */
    create: XOR<historial_liquidacionesCreateInput, historial_liquidacionesUncheckedCreateInput>
    /**
     * In case the historial_liquidaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_liquidacionesUpdateInput, historial_liquidacionesUncheckedUpdateInput>
  }


  /**
   * historial_liquidaciones delete
   */
  export type historial_liquidacionesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
    /**
     * Filter which historial_liquidaciones to delete.
     */
    where: historial_liquidacionesWhereUniqueInput
  }


  /**
   * historial_liquidaciones deleteMany
   */
  export type historial_liquidacionesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_liquidaciones to delete
     */
    where?: historial_liquidacionesWhereInput
  }


  /**
   * historial_liquidaciones without action
   */
  export type historial_liquidacionesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_liquidaciones
     */
    select?: historial_liquidacionesSelect<ExtArgs> | null
  }



  /**
   * Model intereses_tarjetas
   */


  export type AggregateIntereses_tarjetas = {
    _count: Intereses_tarjetasCountAggregateOutputType | null
    _avg: Intereses_tarjetasAvgAggregateOutputType | null
    _sum: Intereses_tarjetasSumAggregateOutputType | null
    _min: Intereses_tarjetasMinAggregateOutputType | null
    _max: Intereses_tarjetasMaxAggregateOutputType | null
  }

  export type Intereses_tarjetasAvgAggregateOutputType = {
    idplan: number | null
    plan_cuota: number | null
    interes: number | null
  }

  export type Intereses_tarjetasSumAggregateOutputType = {
    idplan: number | null
    plan_cuota: number | null
    interes: number | null
  }

  export type Intereses_tarjetasMinAggregateOutputType = {
    idplan: number | null
    plan_cuota: number | null
    interes: number | null
    tarjeta: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Intereses_tarjetasMaxAggregateOutputType = {
    idplan: number | null
    plan_cuota: number | null
    interes: number | null
    tarjeta: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Intereses_tarjetasCountAggregateOutputType = {
    idplan: number
    plan_cuota: number
    interes: number
    tarjeta: number
    fecha: number
    estado: number
    _all: number
  }


  export type Intereses_tarjetasAvgAggregateInputType = {
    idplan?: true
    plan_cuota?: true
    interes?: true
  }

  export type Intereses_tarjetasSumAggregateInputType = {
    idplan?: true
    plan_cuota?: true
    interes?: true
  }

  export type Intereses_tarjetasMinAggregateInputType = {
    idplan?: true
    plan_cuota?: true
    interes?: true
    tarjeta?: true
    fecha?: true
    estado?: true
  }

  export type Intereses_tarjetasMaxAggregateInputType = {
    idplan?: true
    plan_cuota?: true
    interes?: true
    tarjeta?: true
    fecha?: true
    estado?: true
  }

  export type Intereses_tarjetasCountAggregateInputType = {
    idplan?: true
    plan_cuota?: true
    interes?: true
    tarjeta?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type Intereses_tarjetasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which intereses_tarjetas to aggregate.
     */
    where?: intereses_tarjetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intereses_tarjetas to fetch.
     */
    orderBy?: intereses_tarjetasOrderByWithRelationInput | intereses_tarjetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: intereses_tarjetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intereses_tarjetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intereses_tarjetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned intereses_tarjetas
    **/
    _count?: true | Intereses_tarjetasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Intereses_tarjetasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Intereses_tarjetasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Intereses_tarjetasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Intereses_tarjetasMaxAggregateInputType
  }

  export type GetIntereses_tarjetasAggregateType<T extends Intereses_tarjetasAggregateArgs> = {
        [P in keyof T & keyof AggregateIntereses_tarjetas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntereses_tarjetas[P]>
      : GetScalarType<T[P], AggregateIntereses_tarjetas[P]>
  }




  export type intereses_tarjetasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: intereses_tarjetasWhereInput
    orderBy?: intereses_tarjetasOrderByWithAggregationInput | intereses_tarjetasOrderByWithAggregationInput[]
    by: Intereses_tarjetasScalarFieldEnum[] | Intereses_tarjetasScalarFieldEnum
    having?: intereses_tarjetasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Intereses_tarjetasCountAggregateInputType | true
    _avg?: Intereses_tarjetasAvgAggregateInputType
    _sum?: Intereses_tarjetasSumAggregateInputType
    _min?: Intereses_tarjetasMinAggregateInputType
    _max?: Intereses_tarjetasMaxAggregateInputType
  }


  export type Intereses_tarjetasGroupByOutputType = {
    idplan: number
    plan_cuota: number | null
    interes: number | null
    tarjeta: string | null
    fecha: Date | null
    estado: boolean | null
    _count: Intereses_tarjetasCountAggregateOutputType | null
    _avg: Intereses_tarjetasAvgAggregateOutputType | null
    _sum: Intereses_tarjetasSumAggregateOutputType | null
    _min: Intereses_tarjetasMinAggregateOutputType | null
    _max: Intereses_tarjetasMaxAggregateOutputType | null
  }

  type GetIntereses_tarjetasGroupByPayload<T extends intereses_tarjetasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Intereses_tarjetasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Intereses_tarjetasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Intereses_tarjetasGroupByOutputType[P]>
            : GetScalarType<T[P], Intereses_tarjetasGroupByOutputType[P]>
        }
      >
    >


  export type intereses_tarjetasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idplan?: boolean
    plan_cuota?: boolean
    interes?: boolean
    tarjeta?: boolean
    fecha?: boolean
    estado?: boolean
  }, ExtArgs["result"]["intereses_tarjetas"]>

  export type intereses_tarjetasSelectScalar = {
    idplan?: boolean
    plan_cuota?: boolean
    interes?: boolean
    tarjeta?: boolean
    fecha?: boolean
    estado?: boolean
  }


  type intereses_tarjetasGetPayload<S extends boolean | null | undefined | intereses_tarjetasArgs> = $Types.GetResult<intereses_tarjetasPayload, S>

  type intereses_tarjetasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<intereses_tarjetasFindManyArgs, 'select' | 'include'> & {
      select?: Intereses_tarjetasCountAggregateInputType | true
    }

  export interface intereses_tarjetasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['intereses_tarjetas'], meta: { name: 'intereses_tarjetas' } }
    /**
     * Find zero or one Intereses_tarjetas that matches the filter.
     * @param {intereses_tarjetasFindUniqueArgs} args - Arguments to find a Intereses_tarjetas
     * @example
     * // Get one Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends intereses_tarjetasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, intereses_tarjetasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'intereses_tarjetas'> extends True ? Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Intereses_tarjetas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {intereses_tarjetasFindUniqueOrThrowArgs} args - Arguments to find a Intereses_tarjetas
     * @example
     * // Get one Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends intereses_tarjetasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, intereses_tarjetasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Intereses_tarjetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasFindFirstArgs} args - Arguments to find a Intereses_tarjetas
     * @example
     * // Get one Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends intereses_tarjetasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, intereses_tarjetasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'intereses_tarjetas'> extends True ? Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Intereses_tarjetas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasFindFirstOrThrowArgs} args - Arguments to find a Intereses_tarjetas
     * @example
     * // Get one Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends intereses_tarjetasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, intereses_tarjetasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Intereses_tarjetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findMany()
     * 
     * // Get first 10 Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.findMany({ take: 10 })
     * 
     * // Only select the `idplan`
     * const intereses_tarjetasWithIdplanOnly = await prisma.intereses_tarjetas.findMany({ select: { idplan: true } })
     * 
    **/
    findMany<T extends intereses_tarjetasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, intereses_tarjetasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Intereses_tarjetas.
     * @param {intereses_tarjetasCreateArgs} args - Arguments to create a Intereses_tarjetas.
     * @example
     * // Create one Intereses_tarjetas
     * const Intereses_tarjetas = await prisma.intereses_tarjetas.create({
     *   data: {
     *     // ... data to create a Intereses_tarjetas
     *   }
     * })
     * 
    **/
    create<T extends intereses_tarjetasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, intereses_tarjetasCreateArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Intereses_tarjetas.
     *     @param {intereses_tarjetasCreateManyArgs} args - Arguments to create many Intereses_tarjetas.
     *     @example
     *     // Create many Intereses_tarjetas
     *     const intereses_tarjetas = await prisma.intereses_tarjetas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends intereses_tarjetasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, intereses_tarjetasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Intereses_tarjetas.
     * @param {intereses_tarjetasDeleteArgs} args - Arguments to delete one Intereses_tarjetas.
     * @example
     * // Delete one Intereses_tarjetas
     * const Intereses_tarjetas = await prisma.intereses_tarjetas.delete({
     *   where: {
     *     // ... filter to delete one Intereses_tarjetas
     *   }
     * })
     * 
    **/
    delete<T extends intereses_tarjetasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, intereses_tarjetasDeleteArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Intereses_tarjetas.
     * @param {intereses_tarjetasUpdateArgs} args - Arguments to update one Intereses_tarjetas.
     * @example
     * // Update one Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends intereses_tarjetasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, intereses_tarjetasUpdateArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Intereses_tarjetas.
     * @param {intereses_tarjetasDeleteManyArgs} args - Arguments to filter Intereses_tarjetas to delete.
     * @example
     * // Delete a few Intereses_tarjetas
     * const { count } = await prisma.intereses_tarjetas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends intereses_tarjetasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, intereses_tarjetasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intereses_tarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends intereses_tarjetasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, intereses_tarjetasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Intereses_tarjetas.
     * @param {intereses_tarjetasUpsertArgs} args - Arguments to update or create a Intereses_tarjetas.
     * @example
     * // Update or create a Intereses_tarjetas
     * const intereses_tarjetas = await prisma.intereses_tarjetas.upsert({
     *   create: {
     *     // ... data to create a Intereses_tarjetas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intereses_tarjetas we want to update
     *   }
     * })
    **/
    upsert<T extends intereses_tarjetasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, intereses_tarjetasUpsertArgs<ExtArgs>>
    ): Prisma__intereses_tarjetasClient<$Types.GetResult<intereses_tarjetasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Intereses_tarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasCountArgs} args - Arguments to filter Intereses_tarjetas to count.
     * @example
     * // Count the number of Intereses_tarjetas
     * const count = await prisma.intereses_tarjetas.count({
     *   where: {
     *     // ... the filter for the Intereses_tarjetas we want to count
     *   }
     * })
    **/
    count<T extends intereses_tarjetasCountArgs>(
      args?: Subset<T, intereses_tarjetasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Intereses_tarjetasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intereses_tarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intereses_tarjetasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Intereses_tarjetasAggregateArgs>(args: Subset<T, Intereses_tarjetasAggregateArgs>): Prisma.PrismaPromise<GetIntereses_tarjetasAggregateType<T>>

    /**
     * Group by Intereses_tarjetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intereses_tarjetasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends intereses_tarjetasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: intereses_tarjetasGroupByArgs['orderBy'] }
        : { orderBy?: intereses_tarjetasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, intereses_tarjetasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntereses_tarjetasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for intereses_tarjetas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__intereses_tarjetasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * intereses_tarjetas base type for findUnique actions
   */
  export type intereses_tarjetasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter, which intereses_tarjetas to fetch.
     */
    where: intereses_tarjetasWhereUniqueInput
  }

  /**
   * intereses_tarjetas findUnique
   */
  export interface intereses_tarjetasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends intereses_tarjetasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * intereses_tarjetas findUniqueOrThrow
   */
  export type intereses_tarjetasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter, which intereses_tarjetas to fetch.
     */
    where: intereses_tarjetasWhereUniqueInput
  }


  /**
   * intereses_tarjetas base type for findFirst actions
   */
  export type intereses_tarjetasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter, which intereses_tarjetas to fetch.
     */
    where?: intereses_tarjetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intereses_tarjetas to fetch.
     */
    orderBy?: intereses_tarjetasOrderByWithRelationInput | intereses_tarjetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intereses_tarjetas.
     */
    cursor?: intereses_tarjetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intereses_tarjetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intereses_tarjetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intereses_tarjetas.
     */
    distinct?: Intereses_tarjetasScalarFieldEnum | Intereses_tarjetasScalarFieldEnum[]
  }

  /**
   * intereses_tarjetas findFirst
   */
  export interface intereses_tarjetasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends intereses_tarjetasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * intereses_tarjetas findFirstOrThrow
   */
  export type intereses_tarjetasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter, which intereses_tarjetas to fetch.
     */
    where?: intereses_tarjetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intereses_tarjetas to fetch.
     */
    orderBy?: intereses_tarjetasOrderByWithRelationInput | intereses_tarjetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intereses_tarjetas.
     */
    cursor?: intereses_tarjetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intereses_tarjetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intereses_tarjetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intereses_tarjetas.
     */
    distinct?: Intereses_tarjetasScalarFieldEnum | Intereses_tarjetasScalarFieldEnum[]
  }


  /**
   * intereses_tarjetas findMany
   */
  export type intereses_tarjetasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter, which intereses_tarjetas to fetch.
     */
    where?: intereses_tarjetasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intereses_tarjetas to fetch.
     */
    orderBy?: intereses_tarjetasOrderByWithRelationInput | intereses_tarjetasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing intereses_tarjetas.
     */
    cursor?: intereses_tarjetasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intereses_tarjetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intereses_tarjetas.
     */
    skip?: number
    distinct?: Intereses_tarjetasScalarFieldEnum | Intereses_tarjetasScalarFieldEnum[]
  }


  /**
   * intereses_tarjetas create
   */
  export type intereses_tarjetasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * The data needed to create a intereses_tarjetas.
     */
    data?: XOR<intereses_tarjetasCreateInput, intereses_tarjetasUncheckedCreateInput>
  }


  /**
   * intereses_tarjetas createMany
   */
  export type intereses_tarjetasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many intereses_tarjetas.
     */
    data: intereses_tarjetasCreateManyInput | intereses_tarjetasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * intereses_tarjetas update
   */
  export type intereses_tarjetasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * The data needed to update a intereses_tarjetas.
     */
    data: XOR<intereses_tarjetasUpdateInput, intereses_tarjetasUncheckedUpdateInput>
    /**
     * Choose, which intereses_tarjetas to update.
     */
    where: intereses_tarjetasWhereUniqueInput
  }


  /**
   * intereses_tarjetas updateMany
   */
  export type intereses_tarjetasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update intereses_tarjetas.
     */
    data: XOR<intereses_tarjetasUpdateManyMutationInput, intereses_tarjetasUncheckedUpdateManyInput>
    /**
     * Filter which intereses_tarjetas to update
     */
    where?: intereses_tarjetasWhereInput
  }


  /**
   * intereses_tarjetas upsert
   */
  export type intereses_tarjetasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * The filter to search for the intereses_tarjetas to update in case it exists.
     */
    where: intereses_tarjetasWhereUniqueInput
    /**
     * In case the intereses_tarjetas found by the `where` argument doesn't exist, create a new intereses_tarjetas with this data.
     */
    create: XOR<intereses_tarjetasCreateInput, intereses_tarjetasUncheckedCreateInput>
    /**
     * In case the intereses_tarjetas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<intereses_tarjetasUpdateInput, intereses_tarjetasUncheckedUpdateInput>
  }


  /**
   * intereses_tarjetas delete
   */
  export type intereses_tarjetasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
    /**
     * Filter which intereses_tarjetas to delete.
     */
    where: intereses_tarjetasWhereUniqueInput
  }


  /**
   * intereses_tarjetas deleteMany
   */
  export type intereses_tarjetasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which intereses_tarjetas to delete
     */
    where?: intereses_tarjetasWhereInput
  }


  /**
   * intereses_tarjetas without action
   */
  export type intereses_tarjetasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intereses_tarjetas
     */
    select?: intereses_tarjetasSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual
   */


  export type AggregateLegajo_virtual = {
    _count: Legajo_virtualCountAggregateOutputType | null
    _avg: Legajo_virtualAvgAggregateOutputType | null
    _sum: Legajo_virtualSumAggregateOutputType | null
    _min: Legajo_virtualMinAggregateOutputType | null
    _max: Legajo_virtualMaxAggregateOutputType | null
  }

  export type Legajo_virtualAvgAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
  }

  export type Legajo_virtualSumAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
  }

  export type Legajo_virtualMinAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    tipoarchivo: string | null
  }

  export type Legajo_virtualMaxAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    tipoarchivo: string | null
  }

  export type Legajo_virtualCountAggregateOutputType = {
    idlegajo: number
    contrato: number
    archivo: number
    fecha_subida: number
    empresa: number
    tipoarchivo: number
    _all: number
  }


  export type Legajo_virtualAvgAggregateInputType = {
    idlegajo?: true
    contrato?: true
  }

  export type Legajo_virtualSumAggregateInputType = {
    idlegajo?: true
    contrato?: true
  }

  export type Legajo_virtualMinAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    tipoarchivo?: true
  }

  export type Legajo_virtualMaxAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    tipoarchivo?: true
  }

  export type Legajo_virtualCountAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    tipoarchivo?: true
    _all?: true
  }

  export type Legajo_virtualAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual to aggregate.
     */
    where?: legajo_virtualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtuals to fetch.
     */
    orderBy?: legajo_virtualOrderByWithRelationInput | legajo_virtualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtuals
    **/
    _count?: true | Legajo_virtualCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtualAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtualSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtualMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtualMaxAggregateInputType
  }

  export type GetLegajo_virtualAggregateType<T extends Legajo_virtualAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual[P]>
  }




  export type legajo_virtualGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtualWhereInput
    orderBy?: legajo_virtualOrderByWithAggregationInput | legajo_virtualOrderByWithAggregationInput[]
    by: Legajo_virtualScalarFieldEnum[] | Legajo_virtualScalarFieldEnum
    having?: legajo_virtualScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtualCountAggregateInputType | true
    _avg?: Legajo_virtualAvgAggregateInputType
    _sum?: Legajo_virtualSumAggregateInputType
    _min?: Legajo_virtualMinAggregateInputType
    _max?: Legajo_virtualMaxAggregateInputType
  }


  export type Legajo_virtualGroupByOutputType = {
    idlegajo: number
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    tipoarchivo: string | null
    _count: Legajo_virtualCountAggregateOutputType | null
    _avg: Legajo_virtualAvgAggregateOutputType | null
    _sum: Legajo_virtualSumAggregateOutputType | null
    _min: Legajo_virtualMinAggregateOutputType | null
    _max: Legajo_virtualMaxAggregateOutputType | null
  }

  type GetLegajo_virtualGroupByPayload<T extends legajo_virtualGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtualGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtualGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtualGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtualGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtualSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    contrato?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
    tipoarchivo?: boolean
  }, ExtArgs["result"]["legajo_virtual"]>

  export type legajo_virtualSelectScalar = {
    idlegajo?: boolean
    contrato?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
    tipoarchivo?: boolean
  }


  type legajo_virtualGetPayload<S extends boolean | null | undefined | legajo_virtualArgs> = $Types.GetResult<legajo_virtualPayload, S>

  type legajo_virtualCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtualFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtualCountAggregateInputType | true
    }

  export interface legajo_virtualDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual'], meta: { name: 'legajo_virtual' } }
    /**
     * Find zero or one Legajo_virtual that matches the filter.
     * @param {legajo_virtualFindUniqueArgs} args - Arguments to find a Legajo_virtual
     * @example
     * // Get one Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtualFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtualFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual'> extends True ? Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtualFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual
     * @example
     * // Get one Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtualFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtualFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualFindFirstArgs} args - Arguments to find a Legajo_virtual
     * @example
     * // Get one Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtualFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtualFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual'> extends True ? Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual
     * @example
     * // Get one Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtualFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtualFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtuals
     * const legajo_virtuals = await prisma.legajo_virtual.findMany()
     * 
     * // Get first 10 Legajo_virtuals
     * const legajo_virtuals = await prisma.legajo_virtual.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtualWithIdlegajoOnly = await prisma.legajo_virtual.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtualFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtualFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual.
     * @param {legajo_virtualCreateArgs} args - Arguments to create a Legajo_virtual.
     * @example
     * // Create one Legajo_virtual
     * const Legajo_virtual = await prisma.legajo_virtual.create({
     *   data: {
     *     // ... data to create a Legajo_virtual
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtualCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtualCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtuals.
     *     @param {legajo_virtualCreateManyArgs} args - Arguments to create many Legajo_virtuals.
     *     @example
     *     // Create many Legajo_virtuals
     *     const legajo_virtual = await prisma.legajo_virtual.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtualCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtualCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual.
     * @param {legajo_virtualDeleteArgs} args - Arguments to delete one Legajo_virtual.
     * @example
     * // Delete one Legajo_virtual
     * const Legajo_virtual = await prisma.legajo_virtual.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtualDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtualDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual.
     * @param {legajo_virtualUpdateArgs} args - Arguments to update one Legajo_virtual.
     * @example
     * // Update one Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtualUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtualUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtuals.
     * @param {legajo_virtualDeleteManyArgs} args - Arguments to filter Legajo_virtuals to delete.
     * @example
     * // Delete a few Legajo_virtuals
     * const { count } = await prisma.legajo_virtual.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtualDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtualDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtuals
     * const legajo_virtual = await prisma.legajo_virtual.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtualUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtualUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual.
     * @param {legajo_virtualUpsertArgs} args - Arguments to update or create a Legajo_virtual.
     * @example
     * // Update or create a Legajo_virtual
     * const legajo_virtual = await prisma.legajo_virtual.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtualUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtualUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtualClient<$Types.GetResult<legajo_virtualPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualCountArgs} args - Arguments to filter Legajo_virtuals to count.
     * @example
     * // Count the number of Legajo_virtuals
     * const count = await prisma.legajo_virtual.count({
     *   where: {
     *     // ... the filter for the Legajo_virtuals we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtualCountArgs>(
      args?: Subset<T, legajo_virtualCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtualCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtualAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtualAggregateArgs>(args: Subset<T, Legajo_virtualAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtualAggregateType<T>>

    /**
     * Group by Legajo_virtual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtualGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtualGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtualGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtualGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtualGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtualGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtualClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual base type for findUnique actions
   */
  export type legajo_virtualFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual to fetch.
     */
    where: legajo_virtualWhereUniqueInput
  }

  /**
   * legajo_virtual findUnique
   */
  export interface legajo_virtualFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtualFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual findUniqueOrThrow
   */
  export type legajo_virtualFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual to fetch.
     */
    where: legajo_virtualWhereUniqueInput
  }


  /**
   * legajo_virtual base type for findFirst actions
   */
  export type legajo_virtualFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual to fetch.
     */
    where?: legajo_virtualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtuals to fetch.
     */
    orderBy?: legajo_virtualOrderByWithRelationInput | legajo_virtualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtuals.
     */
    cursor?: legajo_virtualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtuals.
     */
    distinct?: Legajo_virtualScalarFieldEnum | Legajo_virtualScalarFieldEnum[]
  }

  /**
   * legajo_virtual findFirst
   */
  export interface legajo_virtualFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtualFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual findFirstOrThrow
   */
  export type legajo_virtualFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual to fetch.
     */
    where?: legajo_virtualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtuals to fetch.
     */
    orderBy?: legajo_virtualOrderByWithRelationInput | legajo_virtualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtuals.
     */
    cursor?: legajo_virtualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtuals.
     */
    distinct?: Legajo_virtualScalarFieldEnum | Legajo_virtualScalarFieldEnum[]
  }


  /**
   * legajo_virtual findMany
   */
  export type legajo_virtualFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtuals to fetch.
     */
    where?: legajo_virtualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtuals to fetch.
     */
    orderBy?: legajo_virtualOrderByWithRelationInput | legajo_virtualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtuals.
     */
    cursor?: legajo_virtualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtuals.
     */
    skip?: number
    distinct?: Legajo_virtualScalarFieldEnum | Legajo_virtualScalarFieldEnum[]
  }


  /**
   * legajo_virtual create
   */
  export type legajo_virtualCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual.
     */
    data?: XOR<legajo_virtualCreateInput, legajo_virtualUncheckedCreateInput>
  }


  /**
   * legajo_virtual createMany
   */
  export type legajo_virtualCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtuals.
     */
    data: legajo_virtualCreateManyInput | legajo_virtualCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual update
   */
  export type legajo_virtualUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual.
     */
    data: XOR<legajo_virtualUpdateInput, legajo_virtualUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual to update.
     */
    where: legajo_virtualWhereUniqueInput
  }


  /**
   * legajo_virtual updateMany
   */
  export type legajo_virtualUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtuals.
     */
    data: XOR<legajo_virtualUpdateManyMutationInput, legajo_virtualUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtuals to update
     */
    where?: legajo_virtualWhereInput
  }


  /**
   * legajo_virtual upsert
   */
  export type legajo_virtualUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual to update in case it exists.
     */
    where: legajo_virtualWhereUniqueInput
    /**
     * In case the legajo_virtual found by the `where` argument doesn't exist, create a new legajo_virtual with this data.
     */
    create: XOR<legajo_virtualCreateInput, legajo_virtualUncheckedCreateInput>
    /**
     * In case the legajo_virtual was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtualUpdateInput, legajo_virtualUncheckedUpdateInput>
  }


  /**
   * legajo_virtual delete
   */
  export type legajo_virtualDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual to delete.
     */
    where: legajo_virtualWhereUniqueInput
  }


  /**
   * legajo_virtual deleteMany
   */
  export type legajo_virtualDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtuals to delete
     */
    where?: legajo_virtualWhereInput
  }


  /**
   * legajo_virtual without action
   */
  export type legajo_virtualArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual
     */
    select?: legajo_virtualSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_cajas
   */


  export type AggregateLegajo_virtual_cajas = {
    _count: Legajo_virtual_cajasCountAggregateOutputType | null
    _avg: Legajo_virtual_cajasAvgAggregateOutputType | null
    _sum: Legajo_virtual_cajasSumAggregateOutputType | null
    _min: Legajo_virtual_cajasMinAggregateOutputType | null
    _max: Legajo_virtual_cajasMaxAggregateOutputType | null
  }

  export type Legajo_virtual_cajasAvgAggregateOutputType = {
    idlegajo: number | null
    idcaja: number | null
  }

  export type Legajo_virtual_cajasSumAggregateOutputType = {
    idlegajo: number | null
    idcaja: number | null
  }

  export type Legajo_virtual_cajasMinAggregateOutputType = {
    idlegajo: number | null
    idcaja: number | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_cajasMaxAggregateOutputType = {
    idlegajo: number | null
    idcaja: number | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_cajasCountAggregateOutputType = {
    idlegajo: number
    idcaja: number
    archivo: number
    fecha_subida: number
    _all: number
  }


  export type Legajo_virtual_cajasAvgAggregateInputType = {
    idlegajo?: true
    idcaja?: true
  }

  export type Legajo_virtual_cajasSumAggregateInputType = {
    idlegajo?: true
    idcaja?: true
  }

  export type Legajo_virtual_cajasMinAggregateInputType = {
    idlegajo?: true
    idcaja?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_cajasMaxAggregateInputType = {
    idlegajo?: true
    idcaja?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_cajasCountAggregateInputType = {
    idlegajo?: true
    idcaja?: true
    archivo?: true
    fecha_subida?: true
    _all?: true
  }

  export type Legajo_virtual_cajasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_cajas to aggregate.
     */
    where?: legajo_virtual_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_cajas to fetch.
     */
    orderBy?: legajo_virtual_cajasOrderByWithRelationInput | legajo_virtual_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_cajas
    **/
    _count?: true | Legajo_virtual_cajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_cajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_cajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_cajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_cajasMaxAggregateInputType
  }

  export type GetLegajo_virtual_cajasAggregateType<T extends Legajo_virtual_cajasAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_cajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_cajas[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_cajas[P]>
  }




  export type legajo_virtual_cajasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_cajasWhereInput
    orderBy?: legajo_virtual_cajasOrderByWithAggregationInput | legajo_virtual_cajasOrderByWithAggregationInput[]
    by: Legajo_virtual_cajasScalarFieldEnum[] | Legajo_virtual_cajasScalarFieldEnum
    having?: legajo_virtual_cajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_cajasCountAggregateInputType | true
    _avg?: Legajo_virtual_cajasAvgAggregateInputType
    _sum?: Legajo_virtual_cajasSumAggregateInputType
    _min?: Legajo_virtual_cajasMinAggregateInputType
    _max?: Legajo_virtual_cajasMaxAggregateInputType
  }


  export type Legajo_virtual_cajasGroupByOutputType = {
    idlegajo: number
    idcaja: number | null
    archivo: string | null
    fecha_subida: Date | null
    _count: Legajo_virtual_cajasCountAggregateOutputType | null
    _avg: Legajo_virtual_cajasAvgAggregateOutputType | null
    _sum: Legajo_virtual_cajasSumAggregateOutputType | null
    _min: Legajo_virtual_cajasMinAggregateOutputType | null
    _max: Legajo_virtual_cajasMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_cajasGroupByPayload<T extends legajo_virtual_cajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_cajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_cajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_cajasGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_cajasGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_cajasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    idcaja?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }, ExtArgs["result"]["legajo_virtual_cajas"]>

  export type legajo_virtual_cajasSelectScalar = {
    idlegajo?: boolean
    idcaja?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }


  type legajo_virtual_cajasGetPayload<S extends boolean | null | undefined | legajo_virtual_cajasArgs> = $Types.GetResult<legajo_virtual_cajasPayload, S>

  type legajo_virtual_cajasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_cajasFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_cajasCountAggregateInputType | true
    }

  export interface legajo_virtual_cajasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_cajas'], meta: { name: 'legajo_virtual_cajas' } }
    /**
     * Find zero or one Legajo_virtual_cajas that matches the filter.
     * @param {legajo_virtual_cajasFindUniqueArgs} args - Arguments to find a Legajo_virtual_cajas
     * @example
     * // Get one Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_cajasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_cajasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_cajas'> extends True ? Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_cajas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_cajasFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_cajas
     * @example
     * // Get one Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_cajasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_cajasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasFindFirstArgs} args - Arguments to find a Legajo_virtual_cajas
     * @example
     * // Get one Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_cajasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_cajasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_cajas'> extends True ? Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_cajas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_cajas
     * @example
     * // Get one Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_cajasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_cajasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findMany()
     * 
     * // Get first 10 Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_cajasWithIdlegajoOnly = await prisma.legajo_virtual_cajas.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_cajasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_cajasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_cajas.
     * @param {legajo_virtual_cajasCreateArgs} args - Arguments to create a Legajo_virtual_cajas.
     * @example
     * // Create one Legajo_virtual_cajas
     * const Legajo_virtual_cajas = await prisma.legajo_virtual_cajas.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_cajas
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_cajasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_cajasCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_cajas.
     *     @param {legajo_virtual_cajasCreateManyArgs} args - Arguments to create many Legajo_virtual_cajas.
     *     @example
     *     // Create many Legajo_virtual_cajas
     *     const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_cajasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_cajasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_cajas.
     * @param {legajo_virtual_cajasDeleteArgs} args - Arguments to delete one Legajo_virtual_cajas.
     * @example
     * // Delete one Legajo_virtual_cajas
     * const Legajo_virtual_cajas = await prisma.legajo_virtual_cajas.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_cajas
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_cajasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_cajasDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_cajas.
     * @param {legajo_virtual_cajasUpdateArgs} args - Arguments to update one Legajo_virtual_cajas.
     * @example
     * // Update one Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_cajasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_cajasUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_cajas.
     * @param {legajo_virtual_cajasDeleteManyArgs} args - Arguments to filter Legajo_virtual_cajas to delete.
     * @example
     * // Delete a few Legajo_virtual_cajas
     * const { count } = await prisma.legajo_virtual_cajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_cajasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_cajasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_cajasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_cajasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_cajas.
     * @param {legajo_virtual_cajasUpsertArgs} args - Arguments to update or create a Legajo_virtual_cajas.
     * @example
     * // Update or create a Legajo_virtual_cajas
     * const legajo_virtual_cajas = await prisma.legajo_virtual_cajas.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_cajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_cajas we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_cajasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_cajasUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_cajasClient<$Types.GetResult<legajo_virtual_cajasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasCountArgs} args - Arguments to filter Legajo_virtual_cajas to count.
     * @example
     * // Count the number of Legajo_virtual_cajas
     * const count = await prisma.legajo_virtual_cajas.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_cajas we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_cajasCountArgs>(
      args?: Subset<T, legajo_virtual_cajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_cajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_cajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_cajasAggregateArgs>(args: Subset<T, Legajo_virtual_cajasAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_cajasAggregateType<T>>

    /**
     * Group by Legajo_virtual_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_cajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_cajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_cajasGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_cajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_cajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_cajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_cajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_cajasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_cajas base type for findUnique actions
   */
  export type legajo_virtual_cajasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_cajas to fetch.
     */
    where: legajo_virtual_cajasWhereUniqueInput
  }

  /**
   * legajo_virtual_cajas findUnique
   */
  export interface legajo_virtual_cajasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_cajasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_cajas findUniqueOrThrow
   */
  export type legajo_virtual_cajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_cajas to fetch.
     */
    where: legajo_virtual_cajasWhereUniqueInput
  }


  /**
   * legajo_virtual_cajas base type for findFirst actions
   */
  export type legajo_virtual_cajasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_cajas to fetch.
     */
    where?: legajo_virtual_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_cajas to fetch.
     */
    orderBy?: legajo_virtual_cajasOrderByWithRelationInput | legajo_virtual_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_cajas.
     */
    cursor?: legajo_virtual_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_cajas.
     */
    distinct?: Legajo_virtual_cajasScalarFieldEnum | Legajo_virtual_cajasScalarFieldEnum[]
  }

  /**
   * legajo_virtual_cajas findFirst
   */
  export interface legajo_virtual_cajasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_cajasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_cajas findFirstOrThrow
   */
  export type legajo_virtual_cajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_cajas to fetch.
     */
    where?: legajo_virtual_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_cajas to fetch.
     */
    orderBy?: legajo_virtual_cajasOrderByWithRelationInput | legajo_virtual_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_cajas.
     */
    cursor?: legajo_virtual_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_cajas.
     */
    distinct?: Legajo_virtual_cajasScalarFieldEnum | Legajo_virtual_cajasScalarFieldEnum[]
  }


  /**
   * legajo_virtual_cajas findMany
   */
  export type legajo_virtual_cajasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_cajas to fetch.
     */
    where?: legajo_virtual_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_cajas to fetch.
     */
    orderBy?: legajo_virtual_cajasOrderByWithRelationInput | legajo_virtual_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_cajas.
     */
    cursor?: legajo_virtual_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_cajas.
     */
    skip?: number
    distinct?: Legajo_virtual_cajasScalarFieldEnum | Legajo_virtual_cajasScalarFieldEnum[]
  }


  /**
   * legajo_virtual_cajas create
   */
  export type legajo_virtual_cajasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_cajas.
     */
    data?: XOR<legajo_virtual_cajasCreateInput, legajo_virtual_cajasUncheckedCreateInput>
  }


  /**
   * legajo_virtual_cajas createMany
   */
  export type legajo_virtual_cajasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_cajas.
     */
    data: legajo_virtual_cajasCreateManyInput | legajo_virtual_cajasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_cajas update
   */
  export type legajo_virtual_cajasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_cajas.
     */
    data: XOR<legajo_virtual_cajasUpdateInput, legajo_virtual_cajasUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_cajas to update.
     */
    where: legajo_virtual_cajasWhereUniqueInput
  }


  /**
   * legajo_virtual_cajas updateMany
   */
  export type legajo_virtual_cajasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_cajas.
     */
    data: XOR<legajo_virtual_cajasUpdateManyMutationInput, legajo_virtual_cajasUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_cajas to update
     */
    where?: legajo_virtual_cajasWhereInput
  }


  /**
   * legajo_virtual_cajas upsert
   */
  export type legajo_virtual_cajasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_cajas to update in case it exists.
     */
    where: legajo_virtual_cajasWhereUniqueInput
    /**
     * In case the legajo_virtual_cajas found by the `where` argument doesn't exist, create a new legajo_virtual_cajas with this data.
     */
    create: XOR<legajo_virtual_cajasCreateInput, legajo_virtual_cajasUncheckedCreateInput>
    /**
     * In case the legajo_virtual_cajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_cajasUpdateInput, legajo_virtual_cajasUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_cajas delete
   */
  export type legajo_virtual_cajasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_cajas to delete.
     */
    where: legajo_virtual_cajasWhereUniqueInput
  }


  /**
   * legajo_virtual_cajas deleteMany
   */
  export type legajo_virtual_cajasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_cajas to delete
     */
    where?: legajo_virtual_cajasWhereInput
  }


  /**
   * legajo_virtual_cajas without action
   */
  export type legajo_virtual_cajasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_cajas
     */
    select?: legajo_virtual_cajasSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_ordenes
   */


  export type AggregateLegajo_virtual_ordenes = {
    _count: Legajo_virtual_ordenesCountAggregateOutputType | null
    _avg: Legajo_virtual_ordenesAvgAggregateOutputType | null
    _sum: Legajo_virtual_ordenesSumAggregateOutputType | null
    _min: Legajo_virtual_ordenesMinAggregateOutputType | null
    _max: Legajo_virtual_ordenesMaxAggregateOutputType | null
  }

  export type Legajo_virtual_ordenesAvgAggregateOutputType = {
    idlegajo: number | null
    idorden: number | null
  }

  export type Legajo_virtual_ordenesSumAggregateOutputType = {
    idlegajo: number | null
    idorden: number | null
  }

  export type Legajo_virtual_ordenesMinAggregateOutputType = {
    idlegajo: number | null
    idorden: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_ordenesMaxAggregateOutputType = {
    idlegajo: number | null
    idorden: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_ordenesCountAggregateOutputType = {
    idlegajo: number
    idorden: number
    archivo: number
    fecha_subida: number
    empresa: number
    _all: number
  }


  export type Legajo_virtual_ordenesAvgAggregateInputType = {
    idlegajo?: true
    idorden?: true
  }

  export type Legajo_virtual_ordenesSumAggregateInputType = {
    idlegajo?: true
    idorden?: true
  }

  export type Legajo_virtual_ordenesMinAggregateInputType = {
    idlegajo?: true
    idorden?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_ordenesMaxAggregateInputType = {
    idlegajo?: true
    idorden?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_ordenesCountAggregateInputType = {
    idlegajo?: true
    idorden?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    _all?: true
  }

  export type Legajo_virtual_ordenesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_ordenes to aggregate.
     */
    where?: legajo_virtual_ordenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_ordenes to fetch.
     */
    orderBy?: legajo_virtual_ordenesOrderByWithRelationInput | legajo_virtual_ordenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_ordenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_ordenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_ordenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_ordenes
    **/
    _count?: true | Legajo_virtual_ordenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_ordenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_ordenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_ordenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_ordenesMaxAggregateInputType
  }

  export type GetLegajo_virtual_ordenesAggregateType<T extends Legajo_virtual_ordenesAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_ordenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_ordenes[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_ordenes[P]>
  }




  export type legajo_virtual_ordenesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_ordenesWhereInput
    orderBy?: legajo_virtual_ordenesOrderByWithAggregationInput | legajo_virtual_ordenesOrderByWithAggregationInput[]
    by: Legajo_virtual_ordenesScalarFieldEnum[] | Legajo_virtual_ordenesScalarFieldEnum
    having?: legajo_virtual_ordenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_ordenesCountAggregateInputType | true
    _avg?: Legajo_virtual_ordenesAvgAggregateInputType
    _sum?: Legajo_virtual_ordenesSumAggregateInputType
    _min?: Legajo_virtual_ordenesMinAggregateInputType
    _max?: Legajo_virtual_ordenesMaxAggregateInputType
  }


  export type Legajo_virtual_ordenesGroupByOutputType = {
    idlegajo: number
    idorden: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    _count: Legajo_virtual_ordenesCountAggregateOutputType | null
    _avg: Legajo_virtual_ordenesAvgAggregateOutputType | null
    _sum: Legajo_virtual_ordenesSumAggregateOutputType | null
    _min: Legajo_virtual_ordenesMinAggregateOutputType | null
    _max: Legajo_virtual_ordenesMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_ordenesGroupByPayload<T extends legajo_virtual_ordenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_ordenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_ordenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_ordenesGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_ordenesGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_ordenesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    idorden?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }, ExtArgs["result"]["legajo_virtual_ordenes"]>

  export type legajo_virtual_ordenesSelectScalar = {
    idlegajo?: boolean
    idorden?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }


  type legajo_virtual_ordenesGetPayload<S extends boolean | null | undefined | legajo_virtual_ordenesArgs> = $Types.GetResult<legajo_virtual_ordenesPayload, S>

  type legajo_virtual_ordenesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_ordenesFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_ordenesCountAggregateInputType | true
    }

  export interface legajo_virtual_ordenesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_ordenes'], meta: { name: 'legajo_virtual_ordenes' } }
    /**
     * Find zero or one Legajo_virtual_ordenes that matches the filter.
     * @param {legajo_virtual_ordenesFindUniqueArgs} args - Arguments to find a Legajo_virtual_ordenes
     * @example
     * // Get one Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_ordenesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_ordenesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_ordenes'> extends True ? Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_ordenes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_ordenesFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_ordenes
     * @example
     * // Get one Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_ordenesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_ordenesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_ordenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesFindFirstArgs} args - Arguments to find a Legajo_virtual_ordenes
     * @example
     * // Get one Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_ordenesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_ordenesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_ordenes'> extends True ? Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_ordenes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_ordenes
     * @example
     * // Get one Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_ordenesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_ordenesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_ordenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findMany()
     * 
     * // Get first 10 Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_ordenesWithIdlegajoOnly = await prisma.legajo_virtual_ordenes.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_ordenesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_ordenesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_ordenes.
     * @param {legajo_virtual_ordenesCreateArgs} args - Arguments to create a Legajo_virtual_ordenes.
     * @example
     * // Create one Legajo_virtual_ordenes
     * const Legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_ordenes
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_ordenesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_ordenesCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_ordenes.
     *     @param {legajo_virtual_ordenesCreateManyArgs} args - Arguments to create many Legajo_virtual_ordenes.
     *     @example
     *     // Create many Legajo_virtual_ordenes
     *     const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_ordenesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_ordenesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_ordenes.
     * @param {legajo_virtual_ordenesDeleteArgs} args - Arguments to delete one Legajo_virtual_ordenes.
     * @example
     * // Delete one Legajo_virtual_ordenes
     * const Legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_ordenes
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_ordenesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_ordenesDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_ordenes.
     * @param {legajo_virtual_ordenesUpdateArgs} args - Arguments to update one Legajo_virtual_ordenes.
     * @example
     * // Update one Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_ordenesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_ordenesUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_ordenes.
     * @param {legajo_virtual_ordenesDeleteManyArgs} args - Arguments to filter Legajo_virtual_ordenes to delete.
     * @example
     * // Delete a few Legajo_virtual_ordenes
     * const { count } = await prisma.legajo_virtual_ordenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_ordenesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_ordenesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_ordenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_ordenesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_ordenesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_ordenes.
     * @param {legajo_virtual_ordenesUpsertArgs} args - Arguments to update or create a Legajo_virtual_ordenes.
     * @example
     * // Update or create a Legajo_virtual_ordenes
     * const legajo_virtual_ordenes = await prisma.legajo_virtual_ordenes.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_ordenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_ordenes we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_ordenesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_ordenesUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_ordenesClient<$Types.GetResult<legajo_virtual_ordenesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_ordenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesCountArgs} args - Arguments to filter Legajo_virtual_ordenes to count.
     * @example
     * // Count the number of Legajo_virtual_ordenes
     * const count = await prisma.legajo_virtual_ordenes.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_ordenes we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_ordenesCountArgs>(
      args?: Subset<T, legajo_virtual_ordenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_ordenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_ordenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_ordenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_ordenesAggregateArgs>(args: Subset<T, Legajo_virtual_ordenesAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_ordenesAggregateType<T>>

    /**
     * Group by Legajo_virtual_ordenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_ordenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_ordenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_ordenesGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_ordenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_ordenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_ordenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_ordenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_ordenesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_ordenes base type for findUnique actions
   */
  export type legajo_virtual_ordenesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_ordenes to fetch.
     */
    where: legajo_virtual_ordenesWhereUniqueInput
  }

  /**
   * legajo_virtual_ordenes findUnique
   */
  export interface legajo_virtual_ordenesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_ordenesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_ordenes findUniqueOrThrow
   */
  export type legajo_virtual_ordenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_ordenes to fetch.
     */
    where: legajo_virtual_ordenesWhereUniqueInput
  }


  /**
   * legajo_virtual_ordenes base type for findFirst actions
   */
  export type legajo_virtual_ordenesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_ordenes to fetch.
     */
    where?: legajo_virtual_ordenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_ordenes to fetch.
     */
    orderBy?: legajo_virtual_ordenesOrderByWithRelationInput | legajo_virtual_ordenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_ordenes.
     */
    cursor?: legajo_virtual_ordenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_ordenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_ordenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_ordenes.
     */
    distinct?: Legajo_virtual_ordenesScalarFieldEnum | Legajo_virtual_ordenesScalarFieldEnum[]
  }

  /**
   * legajo_virtual_ordenes findFirst
   */
  export interface legajo_virtual_ordenesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_ordenesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_ordenes findFirstOrThrow
   */
  export type legajo_virtual_ordenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_ordenes to fetch.
     */
    where?: legajo_virtual_ordenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_ordenes to fetch.
     */
    orderBy?: legajo_virtual_ordenesOrderByWithRelationInput | legajo_virtual_ordenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_ordenes.
     */
    cursor?: legajo_virtual_ordenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_ordenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_ordenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_ordenes.
     */
    distinct?: Legajo_virtual_ordenesScalarFieldEnum | Legajo_virtual_ordenesScalarFieldEnum[]
  }


  /**
   * legajo_virtual_ordenes findMany
   */
  export type legajo_virtual_ordenesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_ordenes to fetch.
     */
    where?: legajo_virtual_ordenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_ordenes to fetch.
     */
    orderBy?: legajo_virtual_ordenesOrderByWithRelationInput | legajo_virtual_ordenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_ordenes.
     */
    cursor?: legajo_virtual_ordenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_ordenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_ordenes.
     */
    skip?: number
    distinct?: Legajo_virtual_ordenesScalarFieldEnum | Legajo_virtual_ordenesScalarFieldEnum[]
  }


  /**
   * legajo_virtual_ordenes create
   */
  export type legajo_virtual_ordenesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_ordenes.
     */
    data?: XOR<legajo_virtual_ordenesCreateInput, legajo_virtual_ordenesUncheckedCreateInput>
  }


  /**
   * legajo_virtual_ordenes createMany
   */
  export type legajo_virtual_ordenesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_ordenes.
     */
    data: legajo_virtual_ordenesCreateManyInput | legajo_virtual_ordenesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_ordenes update
   */
  export type legajo_virtual_ordenesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_ordenes.
     */
    data: XOR<legajo_virtual_ordenesUpdateInput, legajo_virtual_ordenesUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_ordenes to update.
     */
    where: legajo_virtual_ordenesWhereUniqueInput
  }


  /**
   * legajo_virtual_ordenes updateMany
   */
  export type legajo_virtual_ordenesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_ordenes.
     */
    data: XOR<legajo_virtual_ordenesUpdateManyMutationInput, legajo_virtual_ordenesUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_ordenes to update
     */
    where?: legajo_virtual_ordenesWhereInput
  }


  /**
   * legajo_virtual_ordenes upsert
   */
  export type legajo_virtual_ordenesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_ordenes to update in case it exists.
     */
    where: legajo_virtual_ordenesWhereUniqueInput
    /**
     * In case the legajo_virtual_ordenes found by the `where` argument doesn't exist, create a new legajo_virtual_ordenes with this data.
     */
    create: XOR<legajo_virtual_ordenesCreateInput, legajo_virtual_ordenesUncheckedCreateInput>
    /**
     * In case the legajo_virtual_ordenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_ordenesUpdateInput, legajo_virtual_ordenesUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_ordenes delete
   */
  export type legajo_virtual_ordenesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_ordenes to delete.
     */
    where: legajo_virtual_ordenesWhereUniqueInput
  }


  /**
   * legajo_virtual_ordenes deleteMany
   */
  export type legajo_virtual_ordenesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_ordenes to delete
     */
    where?: legajo_virtual_ordenesWhereInput
  }


  /**
   * legajo_virtual_ordenes without action
   */
  export type legajo_virtual_ordenesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_ordenes
     */
    select?: legajo_virtual_ordenesSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_personal
   */


  export type AggregateLegajo_virtual_personal = {
    _count: Legajo_virtual_personalCountAggregateOutputType | null
    _avg: Legajo_virtual_personalAvgAggregateOutputType | null
    _sum: Legajo_virtual_personalSumAggregateOutputType | null
    _min: Legajo_virtual_personalMinAggregateOutputType | null
    _max: Legajo_virtual_personalMaxAggregateOutputType | null
  }

  export type Legajo_virtual_personalAvgAggregateOutputType = {
    idlegajo: number | null
    idpersonal: number | null
  }

  export type Legajo_virtual_personalSumAggregateOutputType = {
    idlegajo: number | null
    idpersonal: number | null
  }

  export type Legajo_virtual_personalMinAggregateOutputType = {
    idlegajo: number | null
    idpersonal: number | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_personalMaxAggregateOutputType = {
    idlegajo: number | null
    idpersonal: number | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_personalCountAggregateOutputType = {
    idlegajo: number
    idpersonal: number
    archivo: number
    fecha_subida: number
    _all: number
  }


  export type Legajo_virtual_personalAvgAggregateInputType = {
    idlegajo?: true
    idpersonal?: true
  }

  export type Legajo_virtual_personalSumAggregateInputType = {
    idlegajo?: true
    idpersonal?: true
  }

  export type Legajo_virtual_personalMinAggregateInputType = {
    idlegajo?: true
    idpersonal?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_personalMaxAggregateInputType = {
    idlegajo?: true
    idpersonal?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_personalCountAggregateInputType = {
    idlegajo?: true
    idpersonal?: true
    archivo?: true
    fecha_subida?: true
    _all?: true
  }

  export type Legajo_virtual_personalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_personal to aggregate.
     */
    where?: legajo_virtual_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_personals to fetch.
     */
    orderBy?: legajo_virtual_personalOrderByWithRelationInput | legajo_virtual_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_personals
    **/
    _count?: true | Legajo_virtual_personalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_personalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_personalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_personalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_personalMaxAggregateInputType
  }

  export type GetLegajo_virtual_personalAggregateType<T extends Legajo_virtual_personalAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_personal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_personal[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_personal[P]>
  }




  export type legajo_virtual_personalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_personalWhereInput
    orderBy?: legajo_virtual_personalOrderByWithAggregationInput | legajo_virtual_personalOrderByWithAggregationInput[]
    by: Legajo_virtual_personalScalarFieldEnum[] | Legajo_virtual_personalScalarFieldEnum
    having?: legajo_virtual_personalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_personalCountAggregateInputType | true
    _avg?: Legajo_virtual_personalAvgAggregateInputType
    _sum?: Legajo_virtual_personalSumAggregateInputType
    _min?: Legajo_virtual_personalMinAggregateInputType
    _max?: Legajo_virtual_personalMaxAggregateInputType
  }


  export type Legajo_virtual_personalGroupByOutputType = {
    idlegajo: number
    idpersonal: number | null
    archivo: string | null
    fecha_subida: Date | null
    _count: Legajo_virtual_personalCountAggregateOutputType | null
    _avg: Legajo_virtual_personalAvgAggregateOutputType | null
    _sum: Legajo_virtual_personalSumAggregateOutputType | null
    _min: Legajo_virtual_personalMinAggregateOutputType | null
    _max: Legajo_virtual_personalMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_personalGroupByPayload<T extends legajo_virtual_personalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_personalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_personalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_personalGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_personalGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_personalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    idpersonal?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }, ExtArgs["result"]["legajo_virtual_personal"]>

  export type legajo_virtual_personalSelectScalar = {
    idlegajo?: boolean
    idpersonal?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }


  type legajo_virtual_personalGetPayload<S extends boolean | null | undefined | legajo_virtual_personalArgs> = $Types.GetResult<legajo_virtual_personalPayload, S>

  type legajo_virtual_personalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_personalFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_personalCountAggregateInputType | true
    }

  export interface legajo_virtual_personalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_personal'], meta: { name: 'legajo_virtual_personal' } }
    /**
     * Find zero or one Legajo_virtual_personal that matches the filter.
     * @param {legajo_virtual_personalFindUniqueArgs} args - Arguments to find a Legajo_virtual_personal
     * @example
     * // Get one Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_personalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_personalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_personal'> extends True ? Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_personalFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_personal
     * @example
     * // Get one Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_personalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_personalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalFindFirstArgs} args - Arguments to find a Legajo_virtual_personal
     * @example
     * // Get one Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_personalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_personalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_personal'> extends True ? Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_personal
     * @example
     * // Get one Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_personalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_personalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_personals
     * const legajo_virtual_personals = await prisma.legajo_virtual_personal.findMany()
     * 
     * // Get first 10 Legajo_virtual_personals
     * const legajo_virtual_personals = await prisma.legajo_virtual_personal.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_personalWithIdlegajoOnly = await prisma.legajo_virtual_personal.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_personalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_personalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_personal.
     * @param {legajo_virtual_personalCreateArgs} args - Arguments to create a Legajo_virtual_personal.
     * @example
     * // Create one Legajo_virtual_personal
     * const Legajo_virtual_personal = await prisma.legajo_virtual_personal.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_personal
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_personalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_personalCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_personals.
     *     @param {legajo_virtual_personalCreateManyArgs} args - Arguments to create many Legajo_virtual_personals.
     *     @example
     *     // Create many Legajo_virtual_personals
     *     const legajo_virtual_personal = await prisma.legajo_virtual_personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_personalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_personalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_personal.
     * @param {legajo_virtual_personalDeleteArgs} args - Arguments to delete one Legajo_virtual_personal.
     * @example
     * // Delete one Legajo_virtual_personal
     * const Legajo_virtual_personal = await prisma.legajo_virtual_personal.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_personal
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_personalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_personalDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_personal.
     * @param {legajo_virtual_personalUpdateArgs} args - Arguments to update one Legajo_virtual_personal.
     * @example
     * // Update one Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_personalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_personalUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_personals.
     * @param {legajo_virtual_personalDeleteManyArgs} args - Arguments to filter Legajo_virtual_personals to delete.
     * @example
     * // Delete a few Legajo_virtual_personals
     * const { count } = await prisma.legajo_virtual_personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_personalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_personalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_personals
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_personalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_personalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_personal.
     * @param {legajo_virtual_personalUpsertArgs} args - Arguments to update or create a Legajo_virtual_personal.
     * @example
     * // Update or create a Legajo_virtual_personal
     * const legajo_virtual_personal = await prisma.legajo_virtual_personal.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_personal we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_personalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_personalUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_personalClient<$Types.GetResult<legajo_virtual_personalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalCountArgs} args - Arguments to filter Legajo_virtual_personals to count.
     * @example
     * // Count the number of Legajo_virtual_personals
     * const count = await prisma.legajo_virtual_personal.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_personals we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_personalCountArgs>(
      args?: Subset<T, legajo_virtual_personalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_personalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_personalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_personalAggregateArgs>(args: Subset<T, Legajo_virtual_personalAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_personalAggregateType<T>>

    /**
     * Group by Legajo_virtual_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_personalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_personalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_personalGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_personalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_personalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_personalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_personalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_personal base type for findUnique actions
   */
  export type legajo_virtual_personalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_personal to fetch.
     */
    where: legajo_virtual_personalWhereUniqueInput
  }

  /**
   * legajo_virtual_personal findUnique
   */
  export interface legajo_virtual_personalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_personalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_personal findUniqueOrThrow
   */
  export type legajo_virtual_personalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_personal to fetch.
     */
    where: legajo_virtual_personalWhereUniqueInput
  }


  /**
   * legajo_virtual_personal base type for findFirst actions
   */
  export type legajo_virtual_personalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_personal to fetch.
     */
    where?: legajo_virtual_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_personals to fetch.
     */
    orderBy?: legajo_virtual_personalOrderByWithRelationInput | legajo_virtual_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_personals.
     */
    cursor?: legajo_virtual_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_personals.
     */
    distinct?: Legajo_virtual_personalScalarFieldEnum | Legajo_virtual_personalScalarFieldEnum[]
  }

  /**
   * legajo_virtual_personal findFirst
   */
  export interface legajo_virtual_personalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_personalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_personal findFirstOrThrow
   */
  export type legajo_virtual_personalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_personal to fetch.
     */
    where?: legajo_virtual_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_personals to fetch.
     */
    orderBy?: legajo_virtual_personalOrderByWithRelationInput | legajo_virtual_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_personals.
     */
    cursor?: legajo_virtual_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_personals.
     */
    distinct?: Legajo_virtual_personalScalarFieldEnum | Legajo_virtual_personalScalarFieldEnum[]
  }


  /**
   * legajo_virtual_personal findMany
   */
  export type legajo_virtual_personalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_personals to fetch.
     */
    where?: legajo_virtual_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_personals to fetch.
     */
    orderBy?: legajo_virtual_personalOrderByWithRelationInput | legajo_virtual_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_personals.
     */
    cursor?: legajo_virtual_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_personals.
     */
    skip?: number
    distinct?: Legajo_virtual_personalScalarFieldEnum | Legajo_virtual_personalScalarFieldEnum[]
  }


  /**
   * legajo_virtual_personal create
   */
  export type legajo_virtual_personalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_personal.
     */
    data?: XOR<legajo_virtual_personalCreateInput, legajo_virtual_personalUncheckedCreateInput>
  }


  /**
   * legajo_virtual_personal createMany
   */
  export type legajo_virtual_personalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_personals.
     */
    data: legajo_virtual_personalCreateManyInput | legajo_virtual_personalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_personal update
   */
  export type legajo_virtual_personalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_personal.
     */
    data: XOR<legajo_virtual_personalUpdateInput, legajo_virtual_personalUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_personal to update.
     */
    where: legajo_virtual_personalWhereUniqueInput
  }


  /**
   * legajo_virtual_personal updateMany
   */
  export type legajo_virtual_personalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_personals.
     */
    data: XOR<legajo_virtual_personalUpdateManyMutationInput, legajo_virtual_personalUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_personals to update
     */
    where?: legajo_virtual_personalWhereInput
  }


  /**
   * legajo_virtual_personal upsert
   */
  export type legajo_virtual_personalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_personal to update in case it exists.
     */
    where: legajo_virtual_personalWhereUniqueInput
    /**
     * In case the legajo_virtual_personal found by the `where` argument doesn't exist, create a new legajo_virtual_personal with this data.
     */
    create: XOR<legajo_virtual_personalCreateInput, legajo_virtual_personalUncheckedCreateInput>
    /**
     * In case the legajo_virtual_personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_personalUpdateInput, legajo_virtual_personalUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_personal delete
   */
  export type legajo_virtual_personalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_personal to delete.
     */
    where: legajo_virtual_personalWhereUniqueInput
  }


  /**
   * legajo_virtual_personal deleteMany
   */
  export type legajo_virtual_personalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_personals to delete
     */
    where?: legajo_virtual_personalWhereInput
  }


  /**
   * legajo_virtual_personal without action
   */
  export type legajo_virtual_personalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_personal
     */
    select?: legajo_virtual_personalSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_prestamos
   */


  export type AggregateLegajo_virtual_prestamos = {
    _count: Legajo_virtual_prestamosCountAggregateOutputType | null
    _avg: Legajo_virtual_prestamosAvgAggregateOutputType | null
    _sum: Legajo_virtual_prestamosSumAggregateOutputType | null
    _min: Legajo_virtual_prestamosMinAggregateOutputType | null
    _max: Legajo_virtual_prestamosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_prestamosAvgAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
  }

  export type Legajo_virtual_prestamosSumAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
  }

  export type Legajo_virtual_prestamosMinAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    cod_ptm_leg: string | null
  }

  export type Legajo_virtual_prestamosMaxAggregateOutputType = {
    idlegajo: number | null
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    cod_ptm_leg: string | null
  }

  export type Legajo_virtual_prestamosCountAggregateOutputType = {
    idlegajo: number
    contrato: number
    archivo: number
    fecha_subida: number
    empresa: number
    cod_ptm_leg: number
    _all: number
  }


  export type Legajo_virtual_prestamosAvgAggregateInputType = {
    idlegajo?: true
    contrato?: true
  }

  export type Legajo_virtual_prestamosSumAggregateInputType = {
    idlegajo?: true
    contrato?: true
  }

  export type Legajo_virtual_prestamosMinAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    cod_ptm_leg?: true
  }

  export type Legajo_virtual_prestamosMaxAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    cod_ptm_leg?: true
  }

  export type Legajo_virtual_prestamosCountAggregateInputType = {
    idlegajo?: true
    contrato?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    cod_ptm_leg?: true
    _all?: true
  }

  export type Legajo_virtual_prestamosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_prestamos to aggregate.
     */
    where?: legajo_virtual_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_prestamos to fetch.
     */
    orderBy?: legajo_virtual_prestamosOrderByWithRelationInput | legajo_virtual_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_prestamos
    **/
    _count?: true | Legajo_virtual_prestamosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_prestamosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_prestamosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_prestamosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_prestamosMaxAggregateInputType
  }

  export type GetLegajo_virtual_prestamosAggregateType<T extends Legajo_virtual_prestamosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_prestamos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_prestamos[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_prestamos[P]>
  }




  export type legajo_virtual_prestamosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_prestamosWhereInput
    orderBy?: legajo_virtual_prestamosOrderByWithAggregationInput | legajo_virtual_prestamosOrderByWithAggregationInput[]
    by: Legajo_virtual_prestamosScalarFieldEnum[] | Legajo_virtual_prestamosScalarFieldEnum
    having?: legajo_virtual_prestamosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_prestamosCountAggregateInputType | true
    _avg?: Legajo_virtual_prestamosAvgAggregateInputType
    _sum?: Legajo_virtual_prestamosSumAggregateInputType
    _min?: Legajo_virtual_prestamosMinAggregateInputType
    _max?: Legajo_virtual_prestamosMaxAggregateInputType
  }


  export type Legajo_virtual_prestamosGroupByOutputType = {
    idlegajo: number
    contrato: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    cod_ptm_leg: string | null
    _count: Legajo_virtual_prestamosCountAggregateOutputType | null
    _avg: Legajo_virtual_prestamosAvgAggregateOutputType | null
    _sum: Legajo_virtual_prestamosSumAggregateOutputType | null
    _min: Legajo_virtual_prestamosMinAggregateOutputType | null
    _max: Legajo_virtual_prestamosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_prestamosGroupByPayload<T extends legajo_virtual_prestamosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_prestamosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_prestamosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_prestamosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_prestamosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_prestamosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    contrato?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
    cod_ptm_leg?: boolean
  }, ExtArgs["result"]["legajo_virtual_prestamos"]>

  export type legajo_virtual_prestamosSelectScalar = {
    idlegajo?: boolean
    contrato?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
    cod_ptm_leg?: boolean
  }


  type legajo_virtual_prestamosGetPayload<S extends boolean | null | undefined | legajo_virtual_prestamosArgs> = $Types.GetResult<legajo_virtual_prestamosPayload, S>

  type legajo_virtual_prestamosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_prestamosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_prestamosCountAggregateInputType | true
    }

  export interface legajo_virtual_prestamosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_prestamos'], meta: { name: 'legajo_virtual_prestamos' } }
    /**
     * Find zero or one Legajo_virtual_prestamos that matches the filter.
     * @param {legajo_virtual_prestamosFindUniqueArgs} args - Arguments to find a Legajo_virtual_prestamos
     * @example
     * // Get one Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_prestamosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_prestamosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_prestamos'> extends True ? Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_prestamos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_prestamosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_prestamos
     * @example
     * // Get one Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_prestamosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_prestamosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_prestamos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosFindFirstArgs} args - Arguments to find a Legajo_virtual_prestamos
     * @example
     * // Get one Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_prestamosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_prestamosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_prestamos'> extends True ? Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_prestamos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_prestamos
     * @example
     * // Get one Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_prestamosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_prestamosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_prestamos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findMany()
     * 
     * // Get first 10 Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_prestamosWithIdlegajoOnly = await prisma.legajo_virtual_prestamos.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_prestamosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_prestamosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_prestamos.
     * @param {legajo_virtual_prestamosCreateArgs} args - Arguments to create a Legajo_virtual_prestamos.
     * @example
     * // Create one Legajo_virtual_prestamos
     * const Legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_prestamos
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_prestamosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_prestamosCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_prestamos.
     *     @param {legajo_virtual_prestamosCreateManyArgs} args - Arguments to create many Legajo_virtual_prestamos.
     *     @example
     *     // Create many Legajo_virtual_prestamos
     *     const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_prestamosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_prestamosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_prestamos.
     * @param {legajo_virtual_prestamosDeleteArgs} args - Arguments to delete one Legajo_virtual_prestamos.
     * @example
     * // Delete one Legajo_virtual_prestamos
     * const Legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_prestamos
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_prestamosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_prestamosDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_prestamos.
     * @param {legajo_virtual_prestamosUpdateArgs} args - Arguments to update one Legajo_virtual_prestamos.
     * @example
     * // Update one Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_prestamosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_prestamosUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_prestamos.
     * @param {legajo_virtual_prestamosDeleteManyArgs} args - Arguments to filter Legajo_virtual_prestamos to delete.
     * @example
     * // Delete a few Legajo_virtual_prestamos
     * const { count } = await prisma.legajo_virtual_prestamos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_prestamosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_prestamosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_prestamosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_prestamosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_prestamos.
     * @param {legajo_virtual_prestamosUpsertArgs} args - Arguments to update or create a Legajo_virtual_prestamos.
     * @example
     * // Update or create a Legajo_virtual_prestamos
     * const legajo_virtual_prestamos = await prisma.legajo_virtual_prestamos.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_prestamos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_prestamos we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_prestamosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_prestamosUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_prestamosClient<$Types.GetResult<legajo_virtual_prestamosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosCountArgs} args - Arguments to filter Legajo_virtual_prestamos to count.
     * @example
     * // Count the number of Legajo_virtual_prestamos
     * const count = await prisma.legajo_virtual_prestamos.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_prestamos we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_prestamosCountArgs>(
      args?: Subset<T, legajo_virtual_prestamosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_prestamosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_prestamosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_prestamosAggregateArgs>(args: Subset<T, Legajo_virtual_prestamosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_prestamosAggregateType<T>>

    /**
     * Group by Legajo_virtual_prestamos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_prestamosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_prestamosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_prestamosGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_prestamosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_prestamosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_prestamosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_prestamos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_prestamosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_prestamos base type for findUnique actions
   */
  export type legajo_virtual_prestamosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_prestamos to fetch.
     */
    where: legajo_virtual_prestamosWhereUniqueInput
  }

  /**
   * legajo_virtual_prestamos findUnique
   */
  export interface legajo_virtual_prestamosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_prestamosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_prestamos findUniqueOrThrow
   */
  export type legajo_virtual_prestamosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_prestamos to fetch.
     */
    where: legajo_virtual_prestamosWhereUniqueInput
  }


  /**
   * legajo_virtual_prestamos base type for findFirst actions
   */
  export type legajo_virtual_prestamosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_prestamos to fetch.
     */
    where?: legajo_virtual_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_prestamos to fetch.
     */
    orderBy?: legajo_virtual_prestamosOrderByWithRelationInput | legajo_virtual_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_prestamos.
     */
    cursor?: legajo_virtual_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_prestamos.
     */
    distinct?: Legajo_virtual_prestamosScalarFieldEnum | Legajo_virtual_prestamosScalarFieldEnum[]
  }

  /**
   * legajo_virtual_prestamos findFirst
   */
  export interface legajo_virtual_prestamosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_prestamosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_prestamos findFirstOrThrow
   */
  export type legajo_virtual_prestamosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_prestamos to fetch.
     */
    where?: legajo_virtual_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_prestamos to fetch.
     */
    orderBy?: legajo_virtual_prestamosOrderByWithRelationInput | legajo_virtual_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_prestamos.
     */
    cursor?: legajo_virtual_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_prestamos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_prestamos.
     */
    distinct?: Legajo_virtual_prestamosScalarFieldEnum | Legajo_virtual_prestamosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_prestamos findMany
   */
  export type legajo_virtual_prestamosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_prestamos to fetch.
     */
    where?: legajo_virtual_prestamosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_prestamos to fetch.
     */
    orderBy?: legajo_virtual_prestamosOrderByWithRelationInput | legajo_virtual_prestamosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_prestamos.
     */
    cursor?: legajo_virtual_prestamosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_prestamos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_prestamos.
     */
    skip?: number
    distinct?: Legajo_virtual_prestamosScalarFieldEnum | Legajo_virtual_prestamosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_prestamos create
   */
  export type legajo_virtual_prestamosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_prestamos.
     */
    data?: XOR<legajo_virtual_prestamosCreateInput, legajo_virtual_prestamosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_prestamos createMany
   */
  export type legajo_virtual_prestamosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_prestamos.
     */
    data: legajo_virtual_prestamosCreateManyInput | legajo_virtual_prestamosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_prestamos update
   */
  export type legajo_virtual_prestamosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_prestamos.
     */
    data: XOR<legajo_virtual_prestamosUpdateInput, legajo_virtual_prestamosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_prestamos to update.
     */
    where: legajo_virtual_prestamosWhereUniqueInput
  }


  /**
   * legajo_virtual_prestamos updateMany
   */
  export type legajo_virtual_prestamosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_prestamos.
     */
    data: XOR<legajo_virtual_prestamosUpdateManyMutationInput, legajo_virtual_prestamosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_prestamos to update
     */
    where?: legajo_virtual_prestamosWhereInput
  }


  /**
   * legajo_virtual_prestamos upsert
   */
  export type legajo_virtual_prestamosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_prestamos to update in case it exists.
     */
    where: legajo_virtual_prestamosWhereUniqueInput
    /**
     * In case the legajo_virtual_prestamos found by the `where` argument doesn't exist, create a new legajo_virtual_prestamos with this data.
     */
    create: XOR<legajo_virtual_prestamosCreateInput, legajo_virtual_prestamosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_prestamos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_prestamosUpdateInput, legajo_virtual_prestamosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_prestamos delete
   */
  export type legajo_virtual_prestamosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_prestamos to delete.
     */
    where: legajo_virtual_prestamosWhereUniqueInput
  }


  /**
   * legajo_virtual_prestamos deleteMany
   */
  export type legajo_virtual_prestamosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_prestamos to delete
     */
    where?: legajo_virtual_prestamosWhereInput
  }


  /**
   * legajo_virtual_prestamos without action
   */
  export type legajo_virtual_prestamosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_prestamos
     */
    select?: legajo_virtual_prestamosSelect<ExtArgs> | null
  }



  /**
   * Model locador
   */


  export type AggregateLocador = {
    _count: LocadorCountAggregateOutputType | null
    _avg: LocadorAvgAggregateOutputType | null
    _sum: LocadorSumAggregateOutputType | null
    _min: LocadorMinAggregateOutputType | null
    _max: LocadorMaxAggregateOutputType | null
  }

  export type LocadorAvgAggregateOutputType = {
    dni: number | null
  }

  export type LocadorSumAggregateOutputType = {
    dni: number | null
  }

  export type LocadorMinAggregateOutputType = {
    dni: number | null
    apellido: string | null
    nombre: string | null
    domicilio: string | null
    barrio: string | null
    localidad: string | null
    provincia: string | null
  }

  export type LocadorMaxAggregateOutputType = {
    dni: number | null
    apellido: string | null
    nombre: string | null
    domicilio: string | null
    barrio: string | null
    localidad: string | null
    provincia: string | null
  }

  export type LocadorCountAggregateOutputType = {
    dni: number
    apellido: number
    nombre: number
    domicilio: number
    barrio: number
    localidad: number
    provincia: number
    _all: number
  }


  export type LocadorAvgAggregateInputType = {
    dni?: true
  }

  export type LocadorSumAggregateInputType = {
    dni?: true
  }

  export type LocadorMinAggregateInputType = {
    dni?: true
    apellido?: true
    nombre?: true
    domicilio?: true
    barrio?: true
    localidad?: true
    provincia?: true
  }

  export type LocadorMaxAggregateInputType = {
    dni?: true
    apellido?: true
    nombre?: true
    domicilio?: true
    barrio?: true
    localidad?: true
    provincia?: true
  }

  export type LocadorCountAggregateInputType = {
    dni?: true
    apellido?: true
    nombre?: true
    domicilio?: true
    barrio?: true
    localidad?: true
    provincia?: true
    _all?: true
  }

  export type LocadorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which locador to aggregate.
     */
    where?: locadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locadors to fetch.
     */
    orderBy?: locadorOrderByWithRelationInput | locadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locadors
    **/
    _count?: true | LocadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocadorMaxAggregateInputType
  }

  export type GetLocadorAggregateType<T extends LocadorAggregateArgs> = {
        [P in keyof T & keyof AggregateLocador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocador[P]>
      : GetScalarType<T[P], AggregateLocador[P]>
  }




  export type locadorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: locadorWhereInput
    orderBy?: locadorOrderByWithAggregationInput | locadorOrderByWithAggregationInput[]
    by: LocadorScalarFieldEnum[] | LocadorScalarFieldEnum
    having?: locadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocadorCountAggregateInputType | true
    _avg?: LocadorAvgAggregateInputType
    _sum?: LocadorSumAggregateInputType
    _min?: LocadorMinAggregateInputType
    _max?: LocadorMaxAggregateInputType
  }


  export type LocadorGroupByOutputType = {
    dni: number
    apellido: string
    nombre: string
    domicilio: string
    barrio: string | null
    localidad: string
    provincia: string
    _count: LocadorCountAggregateOutputType | null
    _avg: LocadorAvgAggregateOutputType | null
    _sum: LocadorSumAggregateOutputType | null
    _min: LocadorMinAggregateOutputType | null
    _max: LocadorMaxAggregateOutputType | null
  }

  type GetLocadorGroupByPayload<T extends locadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocadorGroupByOutputType[P]>
            : GetScalarType<T[P], LocadorGroupByOutputType[P]>
        }
      >
    >


  export type locadorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    domicilio?: boolean
    barrio?: boolean
    localidad?: boolean
    provincia?: boolean
  }, ExtArgs["result"]["locador"]>

  export type locadorSelectScalar = {
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    domicilio?: boolean
    barrio?: boolean
    localidad?: boolean
    provincia?: boolean
  }


  type locadorGetPayload<S extends boolean | null | undefined | locadorArgs> = $Types.GetResult<locadorPayload, S>

  type locadorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<locadorFindManyArgs, 'select' | 'include'> & {
      select?: LocadorCountAggregateInputType | true
    }

  export interface locadorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locador'], meta: { name: 'locador' } }
    /**
     * Find zero or one Locador that matches the filter.
     * @param {locadorFindUniqueArgs} args - Arguments to find a Locador
     * @example
     * // Get one Locador
     * const locador = await prisma.locador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locadorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locadorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'locador'> extends True ? Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Locador that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {locadorFindUniqueOrThrowArgs} args - Arguments to find a Locador
     * @example
     * // Get one Locador
     * const locador = await prisma.locador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locadorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, locadorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Locador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorFindFirstArgs} args - Arguments to find a Locador
     * @example
     * // Get one Locador
     * const locador = await prisma.locador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locadorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locadorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'locador'> extends True ? Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Locador that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorFindFirstOrThrowArgs} args - Arguments to find a Locador
     * @example
     * // Get one Locador
     * const locador = await prisma.locador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locadorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, locadorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Locadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locadors
     * const locadors = await prisma.locador.findMany()
     * 
     * // Get first 10 Locadors
     * const locadors = await prisma.locador.findMany({ take: 10 })
     * 
     * // Only select the `dni`
     * const locadorWithDniOnly = await prisma.locador.findMany({ select: { dni: true } })
     * 
    **/
    findMany<T extends locadorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locadorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<locadorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Locador.
     * @param {locadorCreateArgs} args - Arguments to create a Locador.
     * @example
     * // Create one Locador
     * const Locador = await prisma.locador.create({
     *   data: {
     *     // ... data to create a Locador
     *   }
     * })
     * 
    **/
    create<T extends locadorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, locadorCreateArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Locadors.
     *     @param {locadorCreateManyArgs} args - Arguments to create many Locadors.
     *     @example
     *     // Create many Locadors
     *     const locador = await prisma.locador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locadorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locadorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locador.
     * @param {locadorDeleteArgs} args - Arguments to delete one Locador.
     * @example
     * // Delete one Locador
     * const Locador = await prisma.locador.delete({
     *   where: {
     *     // ... filter to delete one Locador
     *   }
     * })
     * 
    **/
    delete<T extends locadorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, locadorDeleteArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Locador.
     * @param {locadorUpdateArgs} args - Arguments to update one Locador.
     * @example
     * // Update one Locador
     * const locador = await prisma.locador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locadorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, locadorUpdateArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Locadors.
     * @param {locadorDeleteManyArgs} args - Arguments to filter Locadors to delete.
     * @example
     * // Delete a few Locadors
     * const { count } = await prisma.locador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locadorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, locadorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locadors
     * const locador = await prisma.locador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locadorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, locadorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locador.
     * @param {locadorUpsertArgs} args - Arguments to update or create a Locador.
     * @example
     * // Update or create a Locador
     * const locador = await prisma.locador.upsert({
     *   create: {
     *     // ... data to create a Locador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locador we want to update
     *   }
     * })
    **/
    upsert<T extends locadorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, locadorUpsertArgs<ExtArgs>>
    ): Prisma__locadorClient<$Types.GetResult<locadorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Locadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorCountArgs} args - Arguments to filter Locadors to count.
     * @example
     * // Count the number of Locadors
     * const count = await prisma.locador.count({
     *   where: {
     *     // ... the filter for the Locadors we want to count
     *   }
     * })
    **/
    count<T extends locadorCountArgs>(
      args?: Subset<T, locadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocadorAggregateArgs>(args: Subset<T, LocadorAggregateArgs>): Prisma.PrismaPromise<GetLocadorAggregateType<T>>

    /**
     * Group by Locador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locadorGroupByArgs['orderBy'] }
        : { orderBy?: locadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for locador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locadorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * locador base type for findUnique actions
   */
  export type locadorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter, which locador to fetch.
     */
    where: locadorWhereUniqueInput
  }

  /**
   * locador findUnique
   */
  export interface locadorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends locadorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locador findUniqueOrThrow
   */
  export type locadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter, which locador to fetch.
     */
    where: locadorWhereUniqueInput
  }


  /**
   * locador base type for findFirst actions
   */
  export type locadorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter, which locador to fetch.
     */
    where?: locadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locadors to fetch.
     */
    orderBy?: locadorOrderByWithRelationInput | locadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locadors.
     */
    cursor?: locadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locadors.
     */
    distinct?: LocadorScalarFieldEnum | LocadorScalarFieldEnum[]
  }

  /**
   * locador findFirst
   */
  export interface locadorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends locadorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locador findFirstOrThrow
   */
  export type locadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter, which locador to fetch.
     */
    where?: locadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locadors to fetch.
     */
    orderBy?: locadorOrderByWithRelationInput | locadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locadors.
     */
    cursor?: locadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locadors.
     */
    distinct?: LocadorScalarFieldEnum | LocadorScalarFieldEnum[]
  }


  /**
   * locador findMany
   */
  export type locadorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter, which locadors to fetch.
     */
    where?: locadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locadors to fetch.
     */
    orderBy?: locadorOrderByWithRelationInput | locadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locadors.
     */
    cursor?: locadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locadors.
     */
    skip?: number
    distinct?: LocadorScalarFieldEnum | LocadorScalarFieldEnum[]
  }


  /**
   * locador create
   */
  export type locadorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * The data needed to create a locador.
     */
    data: XOR<locadorCreateInput, locadorUncheckedCreateInput>
  }


  /**
   * locador createMany
   */
  export type locadorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locadors.
     */
    data: locadorCreateManyInput | locadorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * locador update
   */
  export type locadorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * The data needed to update a locador.
     */
    data: XOR<locadorUpdateInput, locadorUncheckedUpdateInput>
    /**
     * Choose, which locador to update.
     */
    where: locadorWhereUniqueInput
  }


  /**
   * locador updateMany
   */
  export type locadorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locadors.
     */
    data: XOR<locadorUpdateManyMutationInput, locadorUncheckedUpdateManyInput>
    /**
     * Filter which locadors to update
     */
    where?: locadorWhereInput
  }


  /**
   * locador upsert
   */
  export type locadorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * The filter to search for the locador to update in case it exists.
     */
    where: locadorWhereUniqueInput
    /**
     * In case the locador found by the `where` argument doesn't exist, create a new locador with this data.
     */
    create: XOR<locadorCreateInput, locadorUncheckedCreateInput>
    /**
     * In case the locador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locadorUpdateInput, locadorUncheckedUpdateInput>
  }


  /**
   * locador delete
   */
  export type locadorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
    /**
     * Filter which locador to delete.
     */
    where: locadorWhereUniqueInput
  }


  /**
   * locador deleteMany
   */
  export type locadorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which locadors to delete
     */
    where?: locadorWhereInput
  }


  /**
   * locador without action
   */
  export type locadorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locador
     */
    select?: locadorSelect<ExtArgs> | null
  }



  /**
   * Model mails
   */


  export type AggregateMails = {
    _count: MailsCountAggregateOutputType | null
    _avg: MailsAvgAggregateOutputType | null
    _sum: MailsSumAggregateOutputType | null
    _min: MailsMinAggregateOutputType | null
    _max: MailsMaxAggregateOutputType | null
  }

  export type MailsAvgAggregateOutputType = {
    idmail: number | null
  }

  export type MailsSumAggregateOutputType = {
    idmail: number | null
  }

  export type MailsMinAggregateOutputType = {
    idmail: number | null
    fecha: Date | null
    envia: string | null
    recibe: string | null
    descrip: string | null
    codmail: string | null
    asunto: string | null
    leido: boolean | null
    fecha_leido: Date | null
    url_caja: string | null
  }

  export type MailsMaxAggregateOutputType = {
    idmail: number | null
    fecha: Date | null
    envia: string | null
    recibe: string | null
    descrip: string | null
    codmail: string | null
    asunto: string | null
    leido: boolean | null
    fecha_leido: Date | null
    url_caja: string | null
  }

  export type MailsCountAggregateOutputType = {
    idmail: number
    fecha: number
    envia: number
    recibe: number
    descrip: number
    codmail: number
    asunto: number
    leido: number
    fecha_leido: number
    url_caja: number
    _all: number
  }


  export type MailsAvgAggregateInputType = {
    idmail?: true
  }

  export type MailsSumAggregateInputType = {
    idmail?: true
  }

  export type MailsMinAggregateInputType = {
    idmail?: true
    fecha?: true
    envia?: true
    recibe?: true
    descrip?: true
    codmail?: true
    asunto?: true
    leido?: true
    fecha_leido?: true
    url_caja?: true
  }

  export type MailsMaxAggregateInputType = {
    idmail?: true
    fecha?: true
    envia?: true
    recibe?: true
    descrip?: true
    codmail?: true
    asunto?: true
    leido?: true
    fecha_leido?: true
    url_caja?: true
  }

  export type MailsCountAggregateInputType = {
    idmail?: true
    fecha?: true
    envia?: true
    recibe?: true
    descrip?: true
    codmail?: true
    asunto?: true
    leido?: true
    fecha_leido?: true
    url_caja?: true
    _all?: true
  }

  export type MailsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mails to aggregate.
     */
    where?: mailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails to fetch.
     */
    orderBy?: mailsOrderByWithRelationInput | mailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mails
    **/
    _count?: true | MailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailsMaxAggregateInputType
  }

  export type GetMailsAggregateType<T extends MailsAggregateArgs> = {
        [P in keyof T & keyof AggregateMails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMails[P]>
      : GetScalarType<T[P], AggregateMails[P]>
  }




  export type mailsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mailsWhereInput
    orderBy?: mailsOrderByWithAggregationInput | mailsOrderByWithAggregationInput[]
    by: MailsScalarFieldEnum[] | MailsScalarFieldEnum
    having?: mailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailsCountAggregateInputType | true
    _avg?: MailsAvgAggregateInputType
    _sum?: MailsSumAggregateInputType
    _min?: MailsMinAggregateInputType
    _max?: MailsMaxAggregateInputType
  }


  export type MailsGroupByOutputType = {
    idmail: number
    fecha: Date | null
    envia: string | null
    recibe: string | null
    descrip: string | null
    codmail: string | null
    asunto: string | null
    leido: boolean | null
    fecha_leido: Date | null
    url_caja: string | null
    _count: MailsCountAggregateOutputType | null
    _avg: MailsAvgAggregateOutputType | null
    _sum: MailsSumAggregateOutputType | null
    _min: MailsMinAggregateOutputType | null
    _max: MailsMaxAggregateOutputType | null
  }

  type GetMailsGroupByPayload<T extends mailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailsGroupByOutputType[P]>
            : GetScalarType<T[P], MailsGroupByOutputType[P]>
        }
      >
    >


  export type mailsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idmail?: boolean
    fecha?: boolean
    envia?: boolean
    recibe?: boolean
    descrip?: boolean
    codmail?: boolean
    asunto?: boolean
    leido?: boolean
    fecha_leido?: boolean
    url_caja?: boolean
  }, ExtArgs["result"]["mails"]>

  export type mailsSelectScalar = {
    idmail?: boolean
    fecha?: boolean
    envia?: boolean
    recibe?: boolean
    descrip?: boolean
    codmail?: boolean
    asunto?: boolean
    leido?: boolean
    fecha_leido?: boolean
    url_caja?: boolean
  }


  type mailsGetPayload<S extends boolean | null | undefined | mailsArgs> = $Types.GetResult<mailsPayload, S>

  type mailsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mailsFindManyArgs, 'select' | 'include'> & {
      select?: MailsCountAggregateInputType | true
    }

  export interface mailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mails'], meta: { name: 'mails' } }
    /**
     * Find zero or one Mails that matches the filter.
     * @param {mailsFindUniqueArgs} args - Arguments to find a Mails
     * @example
     * // Get one Mails
     * const mails = await prisma.mails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mailsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mailsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mails'> extends True ? Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Mails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mailsFindUniqueOrThrowArgs} args - Arguments to find a Mails
     * @example
     * // Get one Mails
     * const mails = await prisma.mails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Mails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsFindFirstArgs} args - Arguments to find a Mails
     * @example
     * // Get one Mails
     * const mails = await prisma.mails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mailsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mailsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mails'> extends True ? Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Mails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsFindFirstOrThrowArgs} args - Arguments to find a Mails
     * @example
     * // Get one Mails
     * const mails = await prisma.mails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Mails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mails
     * const mails = await prisma.mails.findMany()
     * 
     * // Get first 10 Mails
     * const mails = await prisma.mails.findMany({ take: 10 })
     * 
     * // Only select the `idmail`
     * const mailsWithIdmailOnly = await prisma.mails.findMany({ select: { idmail: true } })
     * 
    **/
    findMany<T extends mailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<mailsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Mails.
     * @param {mailsCreateArgs} args - Arguments to create a Mails.
     * @example
     * // Create one Mails
     * const Mails = await prisma.mails.create({
     *   data: {
     *     // ... data to create a Mails
     *   }
     * })
     * 
    **/
    create<T extends mailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mailsCreateArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Mails.
     *     @param {mailsCreateManyArgs} args - Arguments to create many Mails.
     *     @example
     *     // Create many Mails
     *     const mails = await prisma.mails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mails.
     * @param {mailsDeleteArgs} args - Arguments to delete one Mails.
     * @example
     * // Delete one Mails
     * const Mails = await prisma.mails.delete({
     *   where: {
     *     // ... filter to delete one Mails
     *   }
     * })
     * 
    **/
    delete<T extends mailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mailsDeleteArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Mails.
     * @param {mailsUpdateArgs} args - Arguments to update one Mails.
     * @example
     * // Update one Mails
     * const mails = await prisma.mails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mailsUpdateArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Mails.
     * @param {mailsDeleteManyArgs} args - Arguments to filter Mails to delete.
     * @example
     * // Delete a few Mails
     * const { count } = await prisma.mails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mails
     * const mails = await prisma.mails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mails.
     * @param {mailsUpsertArgs} args - Arguments to update or create a Mails.
     * @example
     * // Update or create a Mails
     * const mails = await prisma.mails.upsert({
     *   create: {
     *     // ... data to create a Mails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mails we want to update
     *   }
     * })
    **/
    upsert<T extends mailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mailsUpsertArgs<ExtArgs>>
    ): Prisma__mailsClient<$Types.GetResult<mailsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Mails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsCountArgs} args - Arguments to filter Mails to count.
     * @example
     * // Count the number of Mails
     * const count = await prisma.mails.count({
     *   where: {
     *     // ... the filter for the Mails we want to count
     *   }
     * })
    **/
    count<T extends mailsCountArgs>(
      args?: Subset<T, mailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailsAggregateArgs>(args: Subset<T, MailsAggregateArgs>): Prisma.PrismaPromise<GetMailsAggregateType<T>>

    /**
     * Group by Mails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mailsGroupByArgs['orderBy'] }
        : { orderBy?: mailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mailsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mails base type for findUnique actions
   */
  export type mailsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter, which mails to fetch.
     */
    where: mailsWhereUniqueInput
  }

  /**
   * mails findUnique
   */
  export interface mailsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mailsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mails findUniqueOrThrow
   */
  export type mailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter, which mails to fetch.
     */
    where: mailsWhereUniqueInput
  }


  /**
   * mails base type for findFirst actions
   */
  export type mailsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter, which mails to fetch.
     */
    where?: mailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails to fetch.
     */
    orderBy?: mailsOrderByWithRelationInput | mailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mails.
     */
    cursor?: mailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mails.
     */
    distinct?: MailsScalarFieldEnum | MailsScalarFieldEnum[]
  }

  /**
   * mails findFirst
   */
  export interface mailsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mailsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mails findFirstOrThrow
   */
  export type mailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter, which mails to fetch.
     */
    where?: mailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails to fetch.
     */
    orderBy?: mailsOrderByWithRelationInput | mailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mails.
     */
    cursor?: mailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mails.
     */
    distinct?: MailsScalarFieldEnum | MailsScalarFieldEnum[]
  }


  /**
   * mails findMany
   */
  export type mailsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter, which mails to fetch.
     */
    where?: mailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails to fetch.
     */
    orderBy?: mailsOrderByWithRelationInput | mailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mails.
     */
    cursor?: mailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails.
     */
    skip?: number
    distinct?: MailsScalarFieldEnum | MailsScalarFieldEnum[]
  }


  /**
   * mails create
   */
  export type mailsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * The data needed to create a mails.
     */
    data?: XOR<mailsCreateInput, mailsUncheckedCreateInput>
  }


  /**
   * mails createMany
   */
  export type mailsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mails.
     */
    data: mailsCreateManyInput | mailsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mails update
   */
  export type mailsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * The data needed to update a mails.
     */
    data: XOR<mailsUpdateInput, mailsUncheckedUpdateInput>
    /**
     * Choose, which mails to update.
     */
    where: mailsWhereUniqueInput
  }


  /**
   * mails updateMany
   */
  export type mailsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mails.
     */
    data: XOR<mailsUpdateManyMutationInput, mailsUncheckedUpdateManyInput>
    /**
     * Filter which mails to update
     */
    where?: mailsWhereInput
  }


  /**
   * mails upsert
   */
  export type mailsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * The filter to search for the mails to update in case it exists.
     */
    where: mailsWhereUniqueInput
    /**
     * In case the mails found by the `where` argument doesn't exist, create a new mails with this data.
     */
    create: XOR<mailsCreateInput, mailsUncheckedCreateInput>
    /**
     * In case the mails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mailsUpdateInput, mailsUncheckedUpdateInput>
  }


  /**
   * mails delete
   */
  export type mailsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
    /**
     * Filter which mails to delete.
     */
    where: mailsWhereUniqueInput
  }


  /**
   * mails deleteMany
   */
  export type mailsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mails to delete
     */
    where?: mailsWhereInput
  }


  /**
   * mails without action
   */
  export type mailsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails
     */
    select?: mailsSelect<ExtArgs> | null
  }



  /**
   * Model mails_adjuntos
   */


  export type AggregateMails_adjuntos = {
    _count: Mails_adjuntosCountAggregateOutputType | null
    _avg: Mails_adjuntosAvgAggregateOutputType | null
    _sum: Mails_adjuntosSumAggregateOutputType | null
    _min: Mails_adjuntosMinAggregateOutputType | null
    _max: Mails_adjuntosMaxAggregateOutputType | null
  }

  export type Mails_adjuntosAvgAggregateOutputType = {
    idadjunto: number | null
  }

  export type Mails_adjuntosSumAggregateOutputType = {
    idadjunto: number | null
  }

  export type Mails_adjuntosMinAggregateOutputType = {
    idadjunto: number | null
    codmail: string | null
    adjunto: string | null
    tipo: string | null
  }

  export type Mails_adjuntosMaxAggregateOutputType = {
    idadjunto: number | null
    codmail: string | null
    adjunto: string | null
    tipo: string | null
  }

  export type Mails_adjuntosCountAggregateOutputType = {
    idadjunto: number
    codmail: number
    adjunto: number
    tipo: number
    _all: number
  }


  export type Mails_adjuntosAvgAggregateInputType = {
    idadjunto?: true
  }

  export type Mails_adjuntosSumAggregateInputType = {
    idadjunto?: true
  }

  export type Mails_adjuntosMinAggregateInputType = {
    idadjunto?: true
    codmail?: true
    adjunto?: true
    tipo?: true
  }

  export type Mails_adjuntosMaxAggregateInputType = {
    idadjunto?: true
    codmail?: true
    adjunto?: true
    tipo?: true
  }

  export type Mails_adjuntosCountAggregateInputType = {
    idadjunto?: true
    codmail?: true
    adjunto?: true
    tipo?: true
    _all?: true
  }

  export type Mails_adjuntosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mails_adjuntos to aggregate.
     */
    where?: mails_adjuntosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails_adjuntos to fetch.
     */
    orderBy?: mails_adjuntosOrderByWithRelationInput | mails_adjuntosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mails_adjuntosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails_adjuntos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails_adjuntos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mails_adjuntos
    **/
    _count?: true | Mails_adjuntosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mails_adjuntosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mails_adjuntosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mails_adjuntosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mails_adjuntosMaxAggregateInputType
  }

  export type GetMails_adjuntosAggregateType<T extends Mails_adjuntosAggregateArgs> = {
        [P in keyof T & keyof AggregateMails_adjuntos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMails_adjuntos[P]>
      : GetScalarType<T[P], AggregateMails_adjuntos[P]>
  }




  export type mails_adjuntosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mails_adjuntosWhereInput
    orderBy?: mails_adjuntosOrderByWithAggregationInput | mails_adjuntosOrderByWithAggregationInput[]
    by: Mails_adjuntosScalarFieldEnum[] | Mails_adjuntosScalarFieldEnum
    having?: mails_adjuntosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mails_adjuntosCountAggregateInputType | true
    _avg?: Mails_adjuntosAvgAggregateInputType
    _sum?: Mails_adjuntosSumAggregateInputType
    _min?: Mails_adjuntosMinAggregateInputType
    _max?: Mails_adjuntosMaxAggregateInputType
  }


  export type Mails_adjuntosGroupByOutputType = {
    idadjunto: number
    codmail: string | null
    adjunto: string | null
    tipo: string | null
    _count: Mails_adjuntosCountAggregateOutputType | null
    _avg: Mails_adjuntosAvgAggregateOutputType | null
    _sum: Mails_adjuntosSumAggregateOutputType | null
    _min: Mails_adjuntosMinAggregateOutputType | null
    _max: Mails_adjuntosMaxAggregateOutputType | null
  }

  type GetMails_adjuntosGroupByPayload<T extends mails_adjuntosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mails_adjuntosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mails_adjuntosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mails_adjuntosGroupByOutputType[P]>
            : GetScalarType<T[P], Mails_adjuntosGroupByOutputType[P]>
        }
      >
    >


  export type mails_adjuntosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idadjunto?: boolean
    codmail?: boolean
    adjunto?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["mails_adjuntos"]>

  export type mails_adjuntosSelectScalar = {
    idadjunto?: boolean
    codmail?: boolean
    adjunto?: boolean
    tipo?: boolean
  }


  type mails_adjuntosGetPayload<S extends boolean | null | undefined | mails_adjuntosArgs> = $Types.GetResult<mails_adjuntosPayload, S>

  type mails_adjuntosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mails_adjuntosFindManyArgs, 'select' | 'include'> & {
      select?: Mails_adjuntosCountAggregateInputType | true
    }

  export interface mails_adjuntosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mails_adjuntos'], meta: { name: 'mails_adjuntos' } }
    /**
     * Find zero or one Mails_adjuntos that matches the filter.
     * @param {mails_adjuntosFindUniqueArgs} args - Arguments to find a Mails_adjuntos
     * @example
     * // Get one Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mails_adjuntosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mails_adjuntosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mails_adjuntos'> extends True ? Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Mails_adjuntos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mails_adjuntosFindUniqueOrThrowArgs} args - Arguments to find a Mails_adjuntos
     * @example
     * // Get one Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mails_adjuntosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mails_adjuntosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Mails_adjuntos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosFindFirstArgs} args - Arguments to find a Mails_adjuntos
     * @example
     * // Get one Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mails_adjuntosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mails_adjuntosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mails_adjuntos'> extends True ? Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Mails_adjuntos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosFindFirstOrThrowArgs} args - Arguments to find a Mails_adjuntos
     * @example
     * // Get one Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mails_adjuntosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mails_adjuntosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Mails_adjuntos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findMany()
     * 
     * // Get first 10 Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.findMany({ take: 10 })
     * 
     * // Only select the `idadjunto`
     * const mails_adjuntosWithIdadjuntoOnly = await prisma.mails_adjuntos.findMany({ select: { idadjunto: true } })
     * 
    **/
    findMany<T extends mails_adjuntosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mails_adjuntosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Mails_adjuntos.
     * @param {mails_adjuntosCreateArgs} args - Arguments to create a Mails_adjuntos.
     * @example
     * // Create one Mails_adjuntos
     * const Mails_adjuntos = await prisma.mails_adjuntos.create({
     *   data: {
     *     // ... data to create a Mails_adjuntos
     *   }
     * })
     * 
    **/
    create<T extends mails_adjuntosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mails_adjuntosCreateArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Mails_adjuntos.
     *     @param {mails_adjuntosCreateManyArgs} args - Arguments to create many Mails_adjuntos.
     *     @example
     *     // Create many Mails_adjuntos
     *     const mails_adjuntos = await prisma.mails_adjuntos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mails_adjuntosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mails_adjuntosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mails_adjuntos.
     * @param {mails_adjuntosDeleteArgs} args - Arguments to delete one Mails_adjuntos.
     * @example
     * // Delete one Mails_adjuntos
     * const Mails_adjuntos = await prisma.mails_adjuntos.delete({
     *   where: {
     *     // ... filter to delete one Mails_adjuntos
     *   }
     * })
     * 
    **/
    delete<T extends mails_adjuntosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mails_adjuntosDeleteArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Mails_adjuntos.
     * @param {mails_adjuntosUpdateArgs} args - Arguments to update one Mails_adjuntos.
     * @example
     * // Update one Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mails_adjuntosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mails_adjuntosUpdateArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Mails_adjuntos.
     * @param {mails_adjuntosDeleteManyArgs} args - Arguments to filter Mails_adjuntos to delete.
     * @example
     * // Delete a few Mails_adjuntos
     * const { count } = await prisma.mails_adjuntos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mails_adjuntosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mails_adjuntosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mails_adjuntos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mails_adjuntosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mails_adjuntosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mails_adjuntos.
     * @param {mails_adjuntosUpsertArgs} args - Arguments to update or create a Mails_adjuntos.
     * @example
     * // Update or create a Mails_adjuntos
     * const mails_adjuntos = await prisma.mails_adjuntos.upsert({
     *   create: {
     *     // ... data to create a Mails_adjuntos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mails_adjuntos we want to update
     *   }
     * })
    **/
    upsert<T extends mails_adjuntosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mails_adjuntosUpsertArgs<ExtArgs>>
    ): Prisma__mails_adjuntosClient<$Types.GetResult<mails_adjuntosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Mails_adjuntos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosCountArgs} args - Arguments to filter Mails_adjuntos to count.
     * @example
     * // Count the number of Mails_adjuntos
     * const count = await prisma.mails_adjuntos.count({
     *   where: {
     *     // ... the filter for the Mails_adjuntos we want to count
     *   }
     * })
    **/
    count<T extends mails_adjuntosCountArgs>(
      args?: Subset<T, mails_adjuntosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mails_adjuntosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mails_adjuntos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mails_adjuntosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mails_adjuntosAggregateArgs>(args: Subset<T, Mails_adjuntosAggregateArgs>): Prisma.PrismaPromise<GetMails_adjuntosAggregateType<T>>

    /**
     * Group by Mails_adjuntos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mails_adjuntosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mails_adjuntosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mails_adjuntosGroupByArgs['orderBy'] }
        : { orderBy?: mails_adjuntosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mails_adjuntosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMails_adjuntosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mails_adjuntos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mails_adjuntosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mails_adjuntos base type for findUnique actions
   */
  export type mails_adjuntosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter, which mails_adjuntos to fetch.
     */
    where: mails_adjuntosWhereUniqueInput
  }

  /**
   * mails_adjuntos findUnique
   */
  export interface mails_adjuntosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mails_adjuntosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mails_adjuntos findUniqueOrThrow
   */
  export type mails_adjuntosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter, which mails_adjuntos to fetch.
     */
    where: mails_adjuntosWhereUniqueInput
  }


  /**
   * mails_adjuntos base type for findFirst actions
   */
  export type mails_adjuntosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter, which mails_adjuntos to fetch.
     */
    where?: mails_adjuntosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails_adjuntos to fetch.
     */
    orderBy?: mails_adjuntosOrderByWithRelationInput | mails_adjuntosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mails_adjuntos.
     */
    cursor?: mails_adjuntosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails_adjuntos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails_adjuntos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mails_adjuntos.
     */
    distinct?: Mails_adjuntosScalarFieldEnum | Mails_adjuntosScalarFieldEnum[]
  }

  /**
   * mails_adjuntos findFirst
   */
  export interface mails_adjuntosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mails_adjuntosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mails_adjuntos findFirstOrThrow
   */
  export type mails_adjuntosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter, which mails_adjuntos to fetch.
     */
    where?: mails_adjuntosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails_adjuntos to fetch.
     */
    orderBy?: mails_adjuntosOrderByWithRelationInput | mails_adjuntosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mails_adjuntos.
     */
    cursor?: mails_adjuntosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails_adjuntos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails_adjuntos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mails_adjuntos.
     */
    distinct?: Mails_adjuntosScalarFieldEnum | Mails_adjuntosScalarFieldEnum[]
  }


  /**
   * mails_adjuntos findMany
   */
  export type mails_adjuntosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter, which mails_adjuntos to fetch.
     */
    where?: mails_adjuntosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mails_adjuntos to fetch.
     */
    orderBy?: mails_adjuntosOrderByWithRelationInput | mails_adjuntosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mails_adjuntos.
     */
    cursor?: mails_adjuntosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mails_adjuntos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mails_adjuntos.
     */
    skip?: number
    distinct?: Mails_adjuntosScalarFieldEnum | Mails_adjuntosScalarFieldEnum[]
  }


  /**
   * mails_adjuntos create
   */
  export type mails_adjuntosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * The data needed to create a mails_adjuntos.
     */
    data?: XOR<mails_adjuntosCreateInput, mails_adjuntosUncheckedCreateInput>
  }


  /**
   * mails_adjuntos createMany
   */
  export type mails_adjuntosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mails_adjuntos.
     */
    data: mails_adjuntosCreateManyInput | mails_adjuntosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mails_adjuntos update
   */
  export type mails_adjuntosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * The data needed to update a mails_adjuntos.
     */
    data: XOR<mails_adjuntosUpdateInput, mails_adjuntosUncheckedUpdateInput>
    /**
     * Choose, which mails_adjuntos to update.
     */
    where: mails_adjuntosWhereUniqueInput
  }


  /**
   * mails_adjuntos updateMany
   */
  export type mails_adjuntosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mails_adjuntos.
     */
    data: XOR<mails_adjuntosUpdateManyMutationInput, mails_adjuntosUncheckedUpdateManyInput>
    /**
     * Filter which mails_adjuntos to update
     */
    where?: mails_adjuntosWhereInput
  }


  /**
   * mails_adjuntos upsert
   */
  export type mails_adjuntosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * The filter to search for the mails_adjuntos to update in case it exists.
     */
    where: mails_adjuntosWhereUniqueInput
    /**
     * In case the mails_adjuntos found by the `where` argument doesn't exist, create a new mails_adjuntos with this data.
     */
    create: XOR<mails_adjuntosCreateInput, mails_adjuntosUncheckedCreateInput>
    /**
     * In case the mails_adjuntos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mails_adjuntosUpdateInput, mails_adjuntosUncheckedUpdateInput>
  }


  /**
   * mails_adjuntos delete
   */
  export type mails_adjuntosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
    /**
     * Filter which mails_adjuntos to delete.
     */
    where: mails_adjuntosWhereUniqueInput
  }


  /**
   * mails_adjuntos deleteMany
   */
  export type mails_adjuntosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mails_adjuntos to delete
     */
    where?: mails_adjuntosWhereInput
  }


  /**
   * mails_adjuntos without action
   */
  export type mails_adjuntosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mails_adjuntos
     */
    select?: mails_adjuntosSelect<ExtArgs> | null
  }



  /**
   * Model mbanconv
   */


  export type AggregateMbanconv = {
    _count: MbanconvCountAggregateOutputType | null
    _avg: MbanconvAvgAggregateOutputType | null
    _sum: MbanconvSumAggregateOutputType | null
    _min: MbanconvMinAggregateOutputType | null
    _max: MbanconvMaxAggregateOutputType | null
  }

  export type MbanconvAvgAggregateOutputType = {
    id_mora: number | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
  }

  export type MbanconvSumAggregateOutputType = {
    id_mora: number | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
  }

  export type MbanconvMinAggregateOutputType = {
    id_mora: number | null
    tipo: string | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
  }

  export type MbanconvMaxAggregateOutputType = {
    id_mora: number | null
    tipo: string | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
  }

  export type MbanconvCountAggregateOutputType = {
    id_mora: number
    tipo: number
    mora: number
    fichas: number
    morarec: number
    fichasrec: number
    mes: number
    ano: number
    _all: number
  }


  export type MbanconvAvgAggregateInputType = {
    id_mora?: true
    mora?: true
    fichas?: true
    morarec?: true
    fichasrec?: true
    mes?: true
    ano?: true
  }

  export type MbanconvSumAggregateInputType = {
    id_mora?: true
    mora?: true
    fichas?: true
    morarec?: true
    fichasrec?: true
    mes?: true
    ano?: true
  }

  export type MbanconvMinAggregateInputType = {
    id_mora?: true
    tipo?: true
    mora?: true
    fichas?: true
    morarec?: true
    fichasrec?: true
    mes?: true
    ano?: true
  }

  export type MbanconvMaxAggregateInputType = {
    id_mora?: true
    tipo?: true
    mora?: true
    fichas?: true
    morarec?: true
    fichasrec?: true
    mes?: true
    ano?: true
  }

  export type MbanconvCountAggregateInputType = {
    id_mora?: true
    tipo?: true
    mora?: true
    fichas?: true
    morarec?: true
    fichasrec?: true
    mes?: true
    ano?: true
    _all?: true
  }

  export type MbanconvAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mbanconv to aggregate.
     */
    where?: mbanconvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mbanconvs to fetch.
     */
    orderBy?: mbanconvOrderByWithRelationInput | mbanconvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mbanconvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mbanconvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mbanconvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mbanconvs
    **/
    _count?: true | MbanconvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MbanconvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MbanconvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MbanconvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MbanconvMaxAggregateInputType
  }

  export type GetMbanconvAggregateType<T extends MbanconvAggregateArgs> = {
        [P in keyof T & keyof AggregateMbanconv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMbanconv[P]>
      : GetScalarType<T[P], AggregateMbanconv[P]>
  }




  export type mbanconvGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mbanconvWhereInput
    orderBy?: mbanconvOrderByWithAggregationInput | mbanconvOrderByWithAggregationInput[]
    by: MbanconvScalarFieldEnum[] | MbanconvScalarFieldEnum
    having?: mbanconvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MbanconvCountAggregateInputType | true
    _avg?: MbanconvAvgAggregateInputType
    _sum?: MbanconvSumAggregateInputType
    _min?: MbanconvMinAggregateInputType
    _max?: MbanconvMaxAggregateInputType
  }


  export type MbanconvGroupByOutputType = {
    id_mora: number
    tipo: string | null
    mora: number | null
    fichas: number | null
    morarec: number | null
    fichasrec: number | null
    mes: number | null
    ano: number | null
    _count: MbanconvCountAggregateOutputType | null
    _avg: MbanconvAvgAggregateOutputType | null
    _sum: MbanconvSumAggregateOutputType | null
    _min: MbanconvMinAggregateOutputType | null
    _max: MbanconvMaxAggregateOutputType | null
  }

  type GetMbanconvGroupByPayload<T extends mbanconvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MbanconvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MbanconvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MbanconvGroupByOutputType[P]>
            : GetScalarType<T[P], MbanconvGroupByOutputType[P]>
        }
      >
    >


  export type mbanconvSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_mora?: boolean
    tipo?: boolean
    mora?: boolean
    fichas?: boolean
    morarec?: boolean
    fichasrec?: boolean
    mes?: boolean
    ano?: boolean
  }, ExtArgs["result"]["mbanconv"]>

  export type mbanconvSelectScalar = {
    id_mora?: boolean
    tipo?: boolean
    mora?: boolean
    fichas?: boolean
    morarec?: boolean
    fichasrec?: boolean
    mes?: boolean
    ano?: boolean
  }


  type mbanconvGetPayload<S extends boolean | null | undefined | mbanconvArgs> = $Types.GetResult<mbanconvPayload, S>

  type mbanconvCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mbanconvFindManyArgs, 'select' | 'include'> & {
      select?: MbanconvCountAggregateInputType | true
    }

  export interface mbanconvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mbanconv'], meta: { name: 'mbanconv' } }
    /**
     * Find zero or one Mbanconv that matches the filter.
     * @param {mbanconvFindUniqueArgs} args - Arguments to find a Mbanconv
     * @example
     * // Get one Mbanconv
     * const mbanconv = await prisma.mbanconv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mbanconvFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mbanconvFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mbanconv'> extends True ? Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Mbanconv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mbanconvFindUniqueOrThrowArgs} args - Arguments to find a Mbanconv
     * @example
     * // Get one Mbanconv
     * const mbanconv = await prisma.mbanconv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mbanconvFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mbanconvFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Mbanconv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvFindFirstArgs} args - Arguments to find a Mbanconv
     * @example
     * // Get one Mbanconv
     * const mbanconv = await prisma.mbanconv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mbanconvFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mbanconvFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mbanconv'> extends True ? Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Mbanconv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvFindFirstOrThrowArgs} args - Arguments to find a Mbanconv
     * @example
     * // Get one Mbanconv
     * const mbanconv = await prisma.mbanconv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mbanconvFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mbanconvFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Mbanconvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mbanconvs
     * const mbanconvs = await prisma.mbanconv.findMany()
     * 
     * // Get first 10 Mbanconvs
     * const mbanconvs = await prisma.mbanconv.findMany({ take: 10 })
     * 
     * // Only select the `id_mora`
     * const mbanconvWithId_moraOnly = await prisma.mbanconv.findMany({ select: { id_mora: true } })
     * 
    **/
    findMany<T extends mbanconvFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mbanconvFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Mbanconv.
     * @param {mbanconvCreateArgs} args - Arguments to create a Mbanconv.
     * @example
     * // Create one Mbanconv
     * const Mbanconv = await prisma.mbanconv.create({
     *   data: {
     *     // ... data to create a Mbanconv
     *   }
     * })
     * 
    **/
    create<T extends mbanconvCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mbanconvCreateArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Mbanconvs.
     *     @param {mbanconvCreateManyArgs} args - Arguments to create many Mbanconvs.
     *     @example
     *     // Create many Mbanconvs
     *     const mbanconv = await prisma.mbanconv.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mbanconvCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mbanconvCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mbanconv.
     * @param {mbanconvDeleteArgs} args - Arguments to delete one Mbanconv.
     * @example
     * // Delete one Mbanconv
     * const Mbanconv = await prisma.mbanconv.delete({
     *   where: {
     *     // ... filter to delete one Mbanconv
     *   }
     * })
     * 
    **/
    delete<T extends mbanconvDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mbanconvDeleteArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Mbanconv.
     * @param {mbanconvUpdateArgs} args - Arguments to update one Mbanconv.
     * @example
     * // Update one Mbanconv
     * const mbanconv = await prisma.mbanconv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mbanconvUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mbanconvUpdateArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Mbanconvs.
     * @param {mbanconvDeleteManyArgs} args - Arguments to filter Mbanconvs to delete.
     * @example
     * // Delete a few Mbanconvs
     * const { count } = await prisma.mbanconv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mbanconvDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mbanconvDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mbanconvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mbanconvs
     * const mbanconv = await prisma.mbanconv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mbanconvUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mbanconvUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mbanconv.
     * @param {mbanconvUpsertArgs} args - Arguments to update or create a Mbanconv.
     * @example
     * // Update or create a Mbanconv
     * const mbanconv = await prisma.mbanconv.upsert({
     *   create: {
     *     // ... data to create a Mbanconv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mbanconv we want to update
     *   }
     * })
    **/
    upsert<T extends mbanconvUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mbanconvUpsertArgs<ExtArgs>>
    ): Prisma__mbanconvClient<$Types.GetResult<mbanconvPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Mbanconvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvCountArgs} args - Arguments to filter Mbanconvs to count.
     * @example
     * // Count the number of Mbanconvs
     * const count = await prisma.mbanconv.count({
     *   where: {
     *     // ... the filter for the Mbanconvs we want to count
     *   }
     * })
    **/
    count<T extends mbanconvCountArgs>(
      args?: Subset<T, mbanconvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MbanconvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mbanconv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MbanconvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MbanconvAggregateArgs>(args: Subset<T, MbanconvAggregateArgs>): Prisma.PrismaPromise<GetMbanconvAggregateType<T>>

    /**
     * Group by Mbanconv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mbanconvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mbanconvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mbanconvGroupByArgs['orderBy'] }
        : { orderBy?: mbanconvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mbanconvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMbanconvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mbanconv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mbanconvClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mbanconv base type for findUnique actions
   */
  export type mbanconvFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter, which mbanconv to fetch.
     */
    where: mbanconvWhereUniqueInput
  }

  /**
   * mbanconv findUnique
   */
  export interface mbanconvFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mbanconvFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mbanconv findUniqueOrThrow
   */
  export type mbanconvFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter, which mbanconv to fetch.
     */
    where: mbanconvWhereUniqueInput
  }


  /**
   * mbanconv base type for findFirst actions
   */
  export type mbanconvFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter, which mbanconv to fetch.
     */
    where?: mbanconvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mbanconvs to fetch.
     */
    orderBy?: mbanconvOrderByWithRelationInput | mbanconvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mbanconvs.
     */
    cursor?: mbanconvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mbanconvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mbanconvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mbanconvs.
     */
    distinct?: MbanconvScalarFieldEnum | MbanconvScalarFieldEnum[]
  }

  /**
   * mbanconv findFirst
   */
  export interface mbanconvFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mbanconvFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mbanconv findFirstOrThrow
   */
  export type mbanconvFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter, which mbanconv to fetch.
     */
    where?: mbanconvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mbanconvs to fetch.
     */
    orderBy?: mbanconvOrderByWithRelationInput | mbanconvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mbanconvs.
     */
    cursor?: mbanconvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mbanconvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mbanconvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mbanconvs.
     */
    distinct?: MbanconvScalarFieldEnum | MbanconvScalarFieldEnum[]
  }


  /**
   * mbanconv findMany
   */
  export type mbanconvFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter, which mbanconvs to fetch.
     */
    where?: mbanconvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mbanconvs to fetch.
     */
    orderBy?: mbanconvOrderByWithRelationInput | mbanconvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mbanconvs.
     */
    cursor?: mbanconvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mbanconvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mbanconvs.
     */
    skip?: number
    distinct?: MbanconvScalarFieldEnum | MbanconvScalarFieldEnum[]
  }


  /**
   * mbanconv create
   */
  export type mbanconvCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * The data needed to create a mbanconv.
     */
    data?: XOR<mbanconvCreateInput, mbanconvUncheckedCreateInput>
  }


  /**
   * mbanconv createMany
   */
  export type mbanconvCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mbanconvs.
     */
    data: mbanconvCreateManyInput | mbanconvCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * mbanconv update
   */
  export type mbanconvUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * The data needed to update a mbanconv.
     */
    data: XOR<mbanconvUpdateInput, mbanconvUncheckedUpdateInput>
    /**
     * Choose, which mbanconv to update.
     */
    where: mbanconvWhereUniqueInput
  }


  /**
   * mbanconv updateMany
   */
  export type mbanconvUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mbanconvs.
     */
    data: XOR<mbanconvUpdateManyMutationInput, mbanconvUncheckedUpdateManyInput>
    /**
     * Filter which mbanconvs to update
     */
    where?: mbanconvWhereInput
  }


  /**
   * mbanconv upsert
   */
  export type mbanconvUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * The filter to search for the mbanconv to update in case it exists.
     */
    where: mbanconvWhereUniqueInput
    /**
     * In case the mbanconv found by the `where` argument doesn't exist, create a new mbanconv with this data.
     */
    create: XOR<mbanconvCreateInput, mbanconvUncheckedCreateInput>
    /**
     * In case the mbanconv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mbanconvUpdateInput, mbanconvUncheckedUpdateInput>
  }


  /**
   * mbanconv delete
   */
  export type mbanconvDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
    /**
     * Filter which mbanconv to delete.
     */
    where: mbanconvWhereUniqueInput
  }


  /**
   * mbanconv deleteMany
   */
  export type mbanconvDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which mbanconvs to delete
     */
    where?: mbanconvWhereInput
  }


  /**
   * mbanconv without action
   */
  export type mbanconvArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mbanconv
     */
    select?: mbanconvSelect<ExtArgs> | null
  }



  /**
   * Model movimiento_caja_sucursales
   */


  export type AggregateMovimiento_caja_sucursales = {
    _count: Movimiento_caja_sucursalesCountAggregateOutputType | null
    _avg: Movimiento_caja_sucursalesAvgAggregateOutputType | null
    _sum: Movimiento_caja_sucursalesSumAggregateOutputType | null
    _min: Movimiento_caja_sucursalesMinAggregateOutputType | null
    _max: Movimiento_caja_sucursalesMaxAggregateOutputType | null
  }

  export type Movimiento_caja_sucursalesAvgAggregateOutputType = {
    idmovimiento: number | null
    importe: number | null
    idcaja: number | null
  }

  export type Movimiento_caja_sucursalesSumAggregateOutputType = {
    idmovimiento: number | null
    importe: number | null
    idcaja: number | null
  }

  export type Movimiento_caja_sucursalesMinAggregateOutputType = {
    idmovimiento: number | null
    fecha_carga: Date | null
    fecha_movimiento: Date | null
    sucursal: string | null
    concepto: string | null
    movimiento: string | null
    importe: number | null
    operador_carga: string | null
    idcaja: number | null
    empresa: string | null
  }

  export type Movimiento_caja_sucursalesMaxAggregateOutputType = {
    idmovimiento: number | null
    fecha_carga: Date | null
    fecha_movimiento: Date | null
    sucursal: string | null
    concepto: string | null
    movimiento: string | null
    importe: number | null
    operador_carga: string | null
    idcaja: number | null
    empresa: string | null
  }

  export type Movimiento_caja_sucursalesCountAggregateOutputType = {
    idmovimiento: number
    fecha_carga: number
    fecha_movimiento: number
    sucursal: number
    concepto: number
    movimiento: number
    importe: number
    operador_carga: number
    idcaja: number
    empresa: number
    _all: number
  }


  export type Movimiento_caja_sucursalesAvgAggregateInputType = {
    idmovimiento?: true
    importe?: true
    idcaja?: true
  }

  export type Movimiento_caja_sucursalesSumAggregateInputType = {
    idmovimiento?: true
    importe?: true
    idcaja?: true
  }

  export type Movimiento_caja_sucursalesMinAggregateInputType = {
    idmovimiento?: true
    fecha_carga?: true
    fecha_movimiento?: true
    sucursal?: true
    concepto?: true
    movimiento?: true
    importe?: true
    operador_carga?: true
    idcaja?: true
    empresa?: true
  }

  export type Movimiento_caja_sucursalesMaxAggregateInputType = {
    idmovimiento?: true
    fecha_carga?: true
    fecha_movimiento?: true
    sucursal?: true
    concepto?: true
    movimiento?: true
    importe?: true
    operador_carga?: true
    idcaja?: true
    empresa?: true
  }

  export type Movimiento_caja_sucursalesCountAggregateInputType = {
    idmovimiento?: true
    fecha_carga?: true
    fecha_movimiento?: true
    sucursal?: true
    concepto?: true
    movimiento?: true
    importe?: true
    operador_carga?: true
    idcaja?: true
    empresa?: true
    _all?: true
  }

  export type Movimiento_caja_sucursalesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which movimiento_caja_sucursales to aggregate.
     */
    where?: movimiento_caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_caja_sucursales to fetch.
     */
    orderBy?: movimiento_caja_sucursalesOrderByWithRelationInput | movimiento_caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: movimiento_caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movimiento_caja_sucursales
    **/
    _count?: true | Movimiento_caja_sucursalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Movimiento_caja_sucursalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Movimiento_caja_sucursalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Movimiento_caja_sucursalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Movimiento_caja_sucursalesMaxAggregateInputType
  }

  export type GetMovimiento_caja_sucursalesAggregateType<T extends Movimiento_caja_sucursalesAggregateArgs> = {
        [P in keyof T & keyof AggregateMovimiento_caja_sucursales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovimiento_caja_sucursales[P]>
      : GetScalarType<T[P], AggregateMovimiento_caja_sucursales[P]>
  }




  export type movimiento_caja_sucursalesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: movimiento_caja_sucursalesWhereInput
    orderBy?: movimiento_caja_sucursalesOrderByWithAggregationInput | movimiento_caja_sucursalesOrderByWithAggregationInput[]
    by: Movimiento_caja_sucursalesScalarFieldEnum[] | Movimiento_caja_sucursalesScalarFieldEnum
    having?: movimiento_caja_sucursalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Movimiento_caja_sucursalesCountAggregateInputType | true
    _avg?: Movimiento_caja_sucursalesAvgAggregateInputType
    _sum?: Movimiento_caja_sucursalesSumAggregateInputType
    _min?: Movimiento_caja_sucursalesMinAggregateInputType
    _max?: Movimiento_caja_sucursalesMaxAggregateInputType
  }


  export type Movimiento_caja_sucursalesGroupByOutputType = {
    idmovimiento: number
    fecha_carga: Date | null
    fecha_movimiento: Date | null
    sucursal: string | null
    concepto: string | null
    movimiento: string | null
    importe: number | null
    operador_carga: string | null
    idcaja: number | null
    empresa: string | null
    _count: Movimiento_caja_sucursalesCountAggregateOutputType | null
    _avg: Movimiento_caja_sucursalesAvgAggregateOutputType | null
    _sum: Movimiento_caja_sucursalesSumAggregateOutputType | null
    _min: Movimiento_caja_sucursalesMinAggregateOutputType | null
    _max: Movimiento_caja_sucursalesMaxAggregateOutputType | null
  }

  type GetMovimiento_caja_sucursalesGroupByPayload<T extends movimiento_caja_sucursalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Movimiento_caja_sucursalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Movimiento_caja_sucursalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Movimiento_caja_sucursalesGroupByOutputType[P]>
            : GetScalarType<T[P], Movimiento_caja_sucursalesGroupByOutputType[P]>
        }
      >
    >


  export type movimiento_caja_sucursalesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idmovimiento?: boolean
    fecha_carga?: boolean
    fecha_movimiento?: boolean
    sucursal?: boolean
    concepto?: boolean
    movimiento?: boolean
    importe?: boolean
    operador_carga?: boolean
    idcaja?: boolean
    empresa?: boolean
  }, ExtArgs["result"]["movimiento_caja_sucursales"]>

  export type movimiento_caja_sucursalesSelectScalar = {
    idmovimiento?: boolean
    fecha_carga?: boolean
    fecha_movimiento?: boolean
    sucursal?: boolean
    concepto?: boolean
    movimiento?: boolean
    importe?: boolean
    operador_carga?: boolean
    idcaja?: boolean
    empresa?: boolean
  }


  type movimiento_caja_sucursalesGetPayload<S extends boolean | null | undefined | movimiento_caja_sucursalesArgs> = $Types.GetResult<movimiento_caja_sucursalesPayload, S>

  type movimiento_caja_sucursalesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<movimiento_caja_sucursalesFindManyArgs, 'select' | 'include'> & {
      select?: Movimiento_caja_sucursalesCountAggregateInputType | true
    }

  export interface movimiento_caja_sucursalesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['movimiento_caja_sucursales'], meta: { name: 'movimiento_caja_sucursales' } }
    /**
     * Find zero or one Movimiento_caja_sucursales that matches the filter.
     * @param {movimiento_caja_sucursalesFindUniqueArgs} args - Arguments to find a Movimiento_caja_sucursales
     * @example
     * // Get one Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends movimiento_caja_sucursalesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, movimiento_caja_sucursalesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'movimiento_caja_sucursales'> extends True ? Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Movimiento_caja_sucursales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {movimiento_caja_sucursalesFindUniqueOrThrowArgs} args - Arguments to find a Movimiento_caja_sucursales
     * @example
     * // Get one Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends movimiento_caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, movimiento_caja_sucursalesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Movimiento_caja_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesFindFirstArgs} args - Arguments to find a Movimiento_caja_sucursales
     * @example
     * // Get one Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends movimiento_caja_sucursalesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, movimiento_caja_sucursalesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'movimiento_caja_sucursales'> extends True ? Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Movimiento_caja_sucursales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesFindFirstOrThrowArgs} args - Arguments to find a Movimiento_caja_sucursales
     * @example
     * // Get one Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends movimiento_caja_sucursalesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, movimiento_caja_sucursalesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Movimiento_caja_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findMany()
     * 
     * // Get first 10 Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.findMany({ take: 10 })
     * 
     * // Only select the `idmovimiento`
     * const movimiento_caja_sucursalesWithIdmovimientoOnly = await prisma.movimiento_caja_sucursales.findMany({ select: { idmovimiento: true } })
     * 
    **/
    findMany<T extends movimiento_caja_sucursalesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, movimiento_caja_sucursalesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Movimiento_caja_sucursales.
     * @param {movimiento_caja_sucursalesCreateArgs} args - Arguments to create a Movimiento_caja_sucursales.
     * @example
     * // Create one Movimiento_caja_sucursales
     * const Movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.create({
     *   data: {
     *     // ... data to create a Movimiento_caja_sucursales
     *   }
     * })
     * 
    **/
    create<T extends movimiento_caja_sucursalesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, movimiento_caja_sucursalesCreateArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Movimiento_caja_sucursales.
     *     @param {movimiento_caja_sucursalesCreateManyArgs} args - Arguments to create many Movimiento_caja_sucursales.
     *     @example
     *     // Create many Movimiento_caja_sucursales
     *     const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends movimiento_caja_sucursalesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, movimiento_caja_sucursalesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Movimiento_caja_sucursales.
     * @param {movimiento_caja_sucursalesDeleteArgs} args - Arguments to delete one Movimiento_caja_sucursales.
     * @example
     * // Delete one Movimiento_caja_sucursales
     * const Movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.delete({
     *   where: {
     *     // ... filter to delete one Movimiento_caja_sucursales
     *   }
     * })
     * 
    **/
    delete<T extends movimiento_caja_sucursalesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, movimiento_caja_sucursalesDeleteArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Movimiento_caja_sucursales.
     * @param {movimiento_caja_sucursalesUpdateArgs} args - Arguments to update one Movimiento_caja_sucursales.
     * @example
     * // Update one Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends movimiento_caja_sucursalesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, movimiento_caja_sucursalesUpdateArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Movimiento_caja_sucursales.
     * @param {movimiento_caja_sucursalesDeleteManyArgs} args - Arguments to filter Movimiento_caja_sucursales to delete.
     * @example
     * // Delete a few Movimiento_caja_sucursales
     * const { count } = await prisma.movimiento_caja_sucursales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends movimiento_caja_sucursalesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, movimiento_caja_sucursalesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movimiento_caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends movimiento_caja_sucursalesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, movimiento_caja_sucursalesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movimiento_caja_sucursales.
     * @param {movimiento_caja_sucursalesUpsertArgs} args - Arguments to update or create a Movimiento_caja_sucursales.
     * @example
     * // Update or create a Movimiento_caja_sucursales
     * const movimiento_caja_sucursales = await prisma.movimiento_caja_sucursales.upsert({
     *   create: {
     *     // ... data to create a Movimiento_caja_sucursales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movimiento_caja_sucursales we want to update
     *   }
     * })
    **/
    upsert<T extends movimiento_caja_sucursalesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, movimiento_caja_sucursalesUpsertArgs<ExtArgs>>
    ): Prisma__movimiento_caja_sucursalesClient<$Types.GetResult<movimiento_caja_sucursalesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Movimiento_caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesCountArgs} args - Arguments to filter Movimiento_caja_sucursales to count.
     * @example
     * // Count the number of Movimiento_caja_sucursales
     * const count = await prisma.movimiento_caja_sucursales.count({
     *   where: {
     *     // ... the filter for the Movimiento_caja_sucursales we want to count
     *   }
     * })
    **/
    count<T extends movimiento_caja_sucursalesCountArgs>(
      args?: Subset<T, movimiento_caja_sucursalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Movimiento_caja_sucursalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movimiento_caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Movimiento_caja_sucursalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Movimiento_caja_sucursalesAggregateArgs>(args: Subset<T, Movimiento_caja_sucursalesAggregateArgs>): Prisma.PrismaPromise<GetMovimiento_caja_sucursalesAggregateType<T>>

    /**
     * Group by Movimiento_caja_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_caja_sucursalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends movimiento_caja_sucursalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: movimiento_caja_sucursalesGroupByArgs['orderBy'] }
        : { orderBy?: movimiento_caja_sucursalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, movimiento_caja_sucursalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovimiento_caja_sucursalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for movimiento_caja_sucursales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__movimiento_caja_sucursalesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * movimiento_caja_sucursales base type for findUnique actions
   */
  export type movimiento_caja_sucursalesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which movimiento_caja_sucursales to fetch.
     */
    where: movimiento_caja_sucursalesWhereUniqueInput
  }

  /**
   * movimiento_caja_sucursales findUnique
   */
  export interface movimiento_caja_sucursalesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends movimiento_caja_sucursalesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movimiento_caja_sucursales findUniqueOrThrow
   */
  export type movimiento_caja_sucursalesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which movimiento_caja_sucursales to fetch.
     */
    where: movimiento_caja_sucursalesWhereUniqueInput
  }


  /**
   * movimiento_caja_sucursales base type for findFirst actions
   */
  export type movimiento_caja_sucursalesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which movimiento_caja_sucursales to fetch.
     */
    where?: movimiento_caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_caja_sucursales to fetch.
     */
    orderBy?: movimiento_caja_sucursalesOrderByWithRelationInput | movimiento_caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movimiento_caja_sucursales.
     */
    cursor?: movimiento_caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movimiento_caja_sucursales.
     */
    distinct?: Movimiento_caja_sucursalesScalarFieldEnum | Movimiento_caja_sucursalesScalarFieldEnum[]
  }

  /**
   * movimiento_caja_sucursales findFirst
   */
  export interface movimiento_caja_sucursalesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends movimiento_caja_sucursalesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movimiento_caja_sucursales findFirstOrThrow
   */
  export type movimiento_caja_sucursalesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which movimiento_caja_sucursales to fetch.
     */
    where?: movimiento_caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_caja_sucursales to fetch.
     */
    orderBy?: movimiento_caja_sucursalesOrderByWithRelationInput | movimiento_caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movimiento_caja_sucursales.
     */
    cursor?: movimiento_caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_caja_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movimiento_caja_sucursales.
     */
    distinct?: Movimiento_caja_sucursalesScalarFieldEnum | Movimiento_caja_sucursalesScalarFieldEnum[]
  }


  /**
   * movimiento_caja_sucursales findMany
   */
  export type movimiento_caja_sucursalesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which movimiento_caja_sucursales to fetch.
     */
    where?: movimiento_caja_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_caja_sucursales to fetch.
     */
    orderBy?: movimiento_caja_sucursalesOrderByWithRelationInput | movimiento_caja_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movimiento_caja_sucursales.
     */
    cursor?: movimiento_caja_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_caja_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_caja_sucursales.
     */
    skip?: number
    distinct?: Movimiento_caja_sucursalesScalarFieldEnum | Movimiento_caja_sucursalesScalarFieldEnum[]
  }


  /**
   * movimiento_caja_sucursales create
   */
  export type movimiento_caja_sucursalesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to create a movimiento_caja_sucursales.
     */
    data?: XOR<movimiento_caja_sucursalesCreateInput, movimiento_caja_sucursalesUncheckedCreateInput>
  }


  /**
   * movimiento_caja_sucursales createMany
   */
  export type movimiento_caja_sucursalesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many movimiento_caja_sucursales.
     */
    data: movimiento_caja_sucursalesCreateManyInput | movimiento_caja_sucursalesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * movimiento_caja_sucursales update
   */
  export type movimiento_caja_sucursalesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to update a movimiento_caja_sucursales.
     */
    data: XOR<movimiento_caja_sucursalesUpdateInput, movimiento_caja_sucursalesUncheckedUpdateInput>
    /**
     * Choose, which movimiento_caja_sucursales to update.
     */
    where: movimiento_caja_sucursalesWhereUniqueInput
  }


  /**
   * movimiento_caja_sucursales updateMany
   */
  export type movimiento_caja_sucursalesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update movimiento_caja_sucursales.
     */
    data: XOR<movimiento_caja_sucursalesUpdateManyMutationInput, movimiento_caja_sucursalesUncheckedUpdateManyInput>
    /**
     * Filter which movimiento_caja_sucursales to update
     */
    where?: movimiento_caja_sucursalesWhereInput
  }


  /**
   * movimiento_caja_sucursales upsert
   */
  export type movimiento_caja_sucursalesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * The filter to search for the movimiento_caja_sucursales to update in case it exists.
     */
    where: movimiento_caja_sucursalesWhereUniqueInput
    /**
     * In case the movimiento_caja_sucursales found by the `where` argument doesn't exist, create a new movimiento_caja_sucursales with this data.
     */
    create: XOR<movimiento_caja_sucursalesCreateInput, movimiento_caja_sucursalesUncheckedCreateInput>
    /**
     * In case the movimiento_caja_sucursales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<movimiento_caja_sucursalesUpdateInput, movimiento_caja_sucursalesUncheckedUpdateInput>
  }


  /**
   * movimiento_caja_sucursales delete
   */
  export type movimiento_caja_sucursalesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
    /**
     * Filter which movimiento_caja_sucursales to delete.
     */
    where: movimiento_caja_sucursalesWhereUniqueInput
  }


  /**
   * movimiento_caja_sucursales deleteMany
   */
  export type movimiento_caja_sucursalesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which movimiento_caja_sucursales to delete
     */
    where?: movimiento_caja_sucursalesWhereInput
  }


  /**
   * movimiento_caja_sucursales without action
   */
  export type movimiento_caja_sucursalesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_caja_sucursales
     */
    select?: movimiento_caja_sucursalesSelect<ExtArgs> | null
  }



  /**
   * Model noticia
   */


  export type AggregateNoticia = {
    _count: NoticiaCountAggregateOutputType | null
    _avg: NoticiaAvgAggregateOutputType | null
    _sum: NoticiaSumAggregateOutputType | null
    _min: NoticiaMinAggregateOutputType | null
    _max: NoticiaMaxAggregateOutputType | null
  }

  export type NoticiaAvgAggregateOutputType = {
    idnoticia: number | null
    perfil: number | null
  }

  export type NoticiaSumAggregateOutputType = {
    idnoticia: number | null
    perfil: number | null
  }

  export type NoticiaMinAggregateOutputType = {
    idnoticia: number | null
    fecha: Date | null
    noticia: string | null
    operador: string | null
    perfil: number | null
  }

  export type NoticiaMaxAggregateOutputType = {
    idnoticia: number | null
    fecha: Date | null
    noticia: string | null
    operador: string | null
    perfil: number | null
  }

  export type NoticiaCountAggregateOutputType = {
    idnoticia: number
    fecha: number
    noticia: number
    operador: number
    perfil: number
    _all: number
  }


  export type NoticiaAvgAggregateInputType = {
    idnoticia?: true
    perfil?: true
  }

  export type NoticiaSumAggregateInputType = {
    idnoticia?: true
    perfil?: true
  }

  export type NoticiaMinAggregateInputType = {
    idnoticia?: true
    fecha?: true
    noticia?: true
    operador?: true
    perfil?: true
  }

  export type NoticiaMaxAggregateInputType = {
    idnoticia?: true
    fecha?: true
    noticia?: true
    operador?: true
    perfil?: true
  }

  export type NoticiaCountAggregateInputType = {
    idnoticia?: true
    fecha?: true
    noticia?: true
    operador?: true
    perfil?: true
    _all?: true
  }

  export type NoticiaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which noticia to aggregate.
     */
    where?: noticiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noticias to fetch.
     */
    orderBy?: noticiaOrderByWithRelationInput | noticiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noticiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noticias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noticias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned noticias
    **/
    _count?: true | NoticiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticiaMaxAggregateInputType
  }

  export type GetNoticiaAggregateType<T extends NoticiaAggregateArgs> = {
        [P in keyof T & keyof AggregateNoticia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoticia[P]>
      : GetScalarType<T[P], AggregateNoticia[P]>
  }




  export type noticiaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: noticiaWhereInput
    orderBy?: noticiaOrderByWithAggregationInput | noticiaOrderByWithAggregationInput[]
    by: NoticiaScalarFieldEnum[] | NoticiaScalarFieldEnum
    having?: noticiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticiaCountAggregateInputType | true
    _avg?: NoticiaAvgAggregateInputType
    _sum?: NoticiaSumAggregateInputType
    _min?: NoticiaMinAggregateInputType
    _max?: NoticiaMaxAggregateInputType
  }


  export type NoticiaGroupByOutputType = {
    idnoticia: number
    fecha: Date | null
    noticia: string | null
    operador: string | null
    perfil: number | null
    _count: NoticiaCountAggregateOutputType | null
    _avg: NoticiaAvgAggregateOutputType | null
    _sum: NoticiaSumAggregateOutputType | null
    _min: NoticiaMinAggregateOutputType | null
    _max: NoticiaMaxAggregateOutputType | null
  }

  type GetNoticiaGroupByPayload<T extends noticiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticiaGroupByOutputType[P]>
            : GetScalarType<T[P], NoticiaGroupByOutputType[P]>
        }
      >
    >


  export type noticiaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnoticia?: boolean
    fecha?: boolean
    noticia?: boolean
    operador?: boolean
    perfil?: boolean
  }, ExtArgs["result"]["noticia"]>

  export type noticiaSelectScalar = {
    idnoticia?: boolean
    fecha?: boolean
    noticia?: boolean
    operador?: boolean
    perfil?: boolean
  }


  type noticiaGetPayload<S extends boolean | null | undefined | noticiaArgs> = $Types.GetResult<noticiaPayload, S>

  type noticiaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<noticiaFindManyArgs, 'select' | 'include'> & {
      select?: NoticiaCountAggregateInputType | true
    }

  export interface noticiaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['noticia'], meta: { name: 'noticia' } }
    /**
     * Find zero or one Noticia that matches the filter.
     * @param {noticiaFindUniqueArgs} args - Arguments to find a Noticia
     * @example
     * // Get one Noticia
     * const noticia = await prisma.noticia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends noticiaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, noticiaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'noticia'> extends True ? Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Noticia that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {noticiaFindUniqueOrThrowArgs} args - Arguments to find a Noticia
     * @example
     * // Get one Noticia
     * const noticia = await prisma.noticia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends noticiaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, noticiaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Noticia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaFindFirstArgs} args - Arguments to find a Noticia
     * @example
     * // Get one Noticia
     * const noticia = await prisma.noticia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends noticiaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, noticiaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'noticia'> extends True ? Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Noticia that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaFindFirstOrThrowArgs} args - Arguments to find a Noticia
     * @example
     * // Get one Noticia
     * const noticia = await prisma.noticia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends noticiaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, noticiaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Noticias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Noticias
     * const noticias = await prisma.noticia.findMany()
     * 
     * // Get first 10 Noticias
     * const noticias = await prisma.noticia.findMany({ take: 10 })
     * 
     * // Only select the `idnoticia`
     * const noticiaWithIdnoticiaOnly = await prisma.noticia.findMany({ select: { idnoticia: true } })
     * 
    **/
    findMany<T extends noticiaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, noticiaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Noticia.
     * @param {noticiaCreateArgs} args - Arguments to create a Noticia.
     * @example
     * // Create one Noticia
     * const Noticia = await prisma.noticia.create({
     *   data: {
     *     // ... data to create a Noticia
     *   }
     * })
     * 
    **/
    create<T extends noticiaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, noticiaCreateArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Noticias.
     *     @param {noticiaCreateManyArgs} args - Arguments to create many Noticias.
     *     @example
     *     // Create many Noticias
     *     const noticia = await prisma.noticia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends noticiaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, noticiaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Noticia.
     * @param {noticiaDeleteArgs} args - Arguments to delete one Noticia.
     * @example
     * // Delete one Noticia
     * const Noticia = await prisma.noticia.delete({
     *   where: {
     *     // ... filter to delete one Noticia
     *   }
     * })
     * 
    **/
    delete<T extends noticiaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, noticiaDeleteArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Noticia.
     * @param {noticiaUpdateArgs} args - Arguments to update one Noticia.
     * @example
     * // Update one Noticia
     * const noticia = await prisma.noticia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends noticiaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, noticiaUpdateArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Noticias.
     * @param {noticiaDeleteManyArgs} args - Arguments to filter Noticias to delete.
     * @example
     * // Delete a few Noticias
     * const { count } = await prisma.noticia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends noticiaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, noticiaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Noticias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Noticias
     * const noticia = await prisma.noticia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends noticiaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, noticiaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Noticia.
     * @param {noticiaUpsertArgs} args - Arguments to update or create a Noticia.
     * @example
     * // Update or create a Noticia
     * const noticia = await prisma.noticia.upsert({
     *   create: {
     *     // ... data to create a Noticia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Noticia we want to update
     *   }
     * })
    **/
    upsert<T extends noticiaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, noticiaUpsertArgs<ExtArgs>>
    ): Prisma__noticiaClient<$Types.GetResult<noticiaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Noticias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaCountArgs} args - Arguments to filter Noticias to count.
     * @example
     * // Count the number of Noticias
     * const count = await prisma.noticia.count({
     *   where: {
     *     // ... the filter for the Noticias we want to count
     *   }
     * })
    **/
    count<T extends noticiaCountArgs>(
      args?: Subset<T, noticiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Noticia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticiaAggregateArgs>(args: Subset<T, NoticiaAggregateArgs>): Prisma.PrismaPromise<GetNoticiaAggregateType<T>>

    /**
     * Group by Noticia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noticiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noticiaGroupByArgs['orderBy'] }
        : { orderBy?: noticiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noticiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for noticia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__noticiaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * noticia base type for findUnique actions
   */
  export type noticiaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter, which noticia to fetch.
     */
    where: noticiaWhereUniqueInput
  }

  /**
   * noticia findUnique
   */
  export interface noticiaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends noticiaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * noticia findUniqueOrThrow
   */
  export type noticiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter, which noticia to fetch.
     */
    where: noticiaWhereUniqueInput
  }


  /**
   * noticia base type for findFirst actions
   */
  export type noticiaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter, which noticia to fetch.
     */
    where?: noticiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noticias to fetch.
     */
    orderBy?: noticiaOrderByWithRelationInput | noticiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noticias.
     */
    cursor?: noticiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noticias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noticias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noticias.
     */
    distinct?: NoticiaScalarFieldEnum | NoticiaScalarFieldEnum[]
  }

  /**
   * noticia findFirst
   */
  export interface noticiaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends noticiaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * noticia findFirstOrThrow
   */
  export type noticiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter, which noticia to fetch.
     */
    where?: noticiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noticias to fetch.
     */
    orderBy?: noticiaOrderByWithRelationInput | noticiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for noticias.
     */
    cursor?: noticiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noticias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noticias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of noticias.
     */
    distinct?: NoticiaScalarFieldEnum | NoticiaScalarFieldEnum[]
  }


  /**
   * noticia findMany
   */
  export type noticiaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter, which noticias to fetch.
     */
    where?: noticiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of noticias to fetch.
     */
    orderBy?: noticiaOrderByWithRelationInput | noticiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing noticias.
     */
    cursor?: noticiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` noticias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` noticias.
     */
    skip?: number
    distinct?: NoticiaScalarFieldEnum | NoticiaScalarFieldEnum[]
  }


  /**
   * noticia create
   */
  export type noticiaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * The data needed to create a noticia.
     */
    data?: XOR<noticiaCreateInput, noticiaUncheckedCreateInput>
  }


  /**
   * noticia createMany
   */
  export type noticiaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many noticias.
     */
    data: noticiaCreateManyInput | noticiaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * noticia update
   */
  export type noticiaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * The data needed to update a noticia.
     */
    data: XOR<noticiaUpdateInput, noticiaUncheckedUpdateInput>
    /**
     * Choose, which noticia to update.
     */
    where: noticiaWhereUniqueInput
  }


  /**
   * noticia updateMany
   */
  export type noticiaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update noticias.
     */
    data: XOR<noticiaUpdateManyMutationInput, noticiaUncheckedUpdateManyInput>
    /**
     * Filter which noticias to update
     */
    where?: noticiaWhereInput
  }


  /**
   * noticia upsert
   */
  export type noticiaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * The filter to search for the noticia to update in case it exists.
     */
    where: noticiaWhereUniqueInput
    /**
     * In case the noticia found by the `where` argument doesn't exist, create a new noticia with this data.
     */
    create: XOR<noticiaCreateInput, noticiaUncheckedCreateInput>
    /**
     * In case the noticia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noticiaUpdateInput, noticiaUncheckedUpdateInput>
  }


  /**
   * noticia delete
   */
  export type noticiaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
    /**
     * Filter which noticia to delete.
     */
    where: noticiaWhereUniqueInput
  }


  /**
   * noticia deleteMany
   */
  export type noticiaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which noticias to delete
     */
    where?: noticiaWhereInput
  }


  /**
   * noticia without action
   */
  export type noticiaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the noticia
     */
    select?: noticiaSelect<ExtArgs> | null
  }



  /**
   * Model novedades
   */


  export type AggregateNovedades = {
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  export type NovedadesAvgAggregateOutputType = {
    idnovedades: number | null
  }

  export type NovedadesSumAggregateOutputType = {
    idnovedades: number | null
  }

  export type NovedadesMinAggregateOutputType = {
    idnovedades: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type NovedadesMaxAggregateOutputType = {
    idnovedades: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type NovedadesCountAggregateOutputType = {
    idnovedades: number
    novedad: number
    fecha: number
    operador: number
    estado: number
    _all: number
  }


  export type NovedadesAvgAggregateInputType = {
    idnovedades?: true
  }

  export type NovedadesSumAggregateInputType = {
    idnovedades?: true
  }

  export type NovedadesMinAggregateInputType = {
    idnovedades?: true
    novedad?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type NovedadesMaxAggregateInputType = {
    idnovedades?: true
    novedad?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type NovedadesCountAggregateInputType = {
    idnovedades?: true
    novedad?: true
    fecha?: true
    operador?: true
    estado?: true
    _all?: true
  }

  export type NovedadesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to aggregate.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned novedades
    **/
    _count?: true | NovedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovedadesMaxAggregateInputType
  }

  export type GetNovedadesAggregateType<T extends NovedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateNovedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovedades[P]>
      : GetScalarType<T[P], AggregateNovedades[P]>
  }




  export type novedadesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: novedadesWhereInput
    orderBy?: novedadesOrderByWithAggregationInput | novedadesOrderByWithAggregationInput[]
    by: NovedadesScalarFieldEnum[] | NovedadesScalarFieldEnum
    having?: novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovedadesCountAggregateInputType | true
    _avg?: NovedadesAvgAggregateInputType
    _sum?: NovedadesSumAggregateInputType
    _min?: NovedadesMinAggregateInputType
    _max?: NovedadesMaxAggregateInputType
  }


  export type NovedadesGroupByOutputType = {
    idnovedades: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  type GetNovedadesGroupByPayload<T extends novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
            : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
        }
      >
    >


  export type novedadesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovedades?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }, ExtArgs["result"]["novedades"]>

  export type novedadesSelectScalar = {
    idnovedades?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }


  type novedadesGetPayload<S extends boolean | null | undefined | novedadesArgs> = $Types.GetResult<novedadesPayload, S>

  type novedadesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<novedadesFindManyArgs, 'select' | 'include'> & {
      select?: NovedadesCountAggregateInputType | true
    }

  export interface novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['novedades'], meta: { name: 'novedades' } }
    /**
     * Find zero or one Novedades that matches the filter.
     * @param {novedadesFindUniqueArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends novedadesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, novedadesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {novedadesFindUniqueOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends novedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends novedadesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, novedadesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends novedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Novedades
     * const novedades = await prisma.novedades.findMany()
     * 
     * // Get first 10 Novedades
     * const novedades = await prisma.novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedades`
     * const novedadesWithIdnovedadesOnly = await prisma.novedades.findMany({ select: { idnovedades: true } })
     * 
    **/
    findMany<T extends novedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Novedades.
     * @param {novedadesCreateArgs} args - Arguments to create a Novedades.
     * @example
     * // Create one Novedades
     * const Novedades = await prisma.novedades.create({
     *   data: {
     *     // ... data to create a Novedades
     *   }
     * })
     * 
    **/
    create<T extends novedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesCreateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Novedades.
     *     @param {novedadesCreateManyArgs} args - Arguments to create many Novedades.
     *     @example
     *     // Create many Novedades
     *     const novedades = await prisma.novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends novedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Novedades.
     * @param {novedadesDeleteArgs} args - Arguments to delete one Novedades.
     * @example
     * // Delete one Novedades
     * const Novedades = await prisma.novedades.delete({
     *   where: {
     *     // ... filter to delete one Novedades
     *   }
     * })
     * 
    **/
    delete<T extends novedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesDeleteArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Novedades.
     * @param {novedadesUpdateArgs} args - Arguments to update one Novedades.
     * @example
     * // Update one Novedades
     * const novedades = await prisma.novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends novedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Novedades.
     * @param {novedadesDeleteManyArgs} args - Arguments to filter Novedades to delete.
     * @example
     * // Delete a few Novedades
     * const { count } = await prisma.novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends novedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Novedades
     * const novedades = await prisma.novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends novedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Novedades.
     * @param {novedadesUpsertArgs} args - Arguments to update or create a Novedades.
     * @example
     * // Update or create a Novedades
     * const novedades = await prisma.novedades.upsert({
     *   create: {
     *     // ... data to create a Novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Novedades we want to update
     *   }
     * })
    **/
    upsert<T extends novedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpsertArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesCountArgs} args - Arguments to filter Novedades to count.
     * @example
     * // Count the number of Novedades
     * const count = await prisma.novedades.count({
     *   where: {
     *     // ... the filter for the Novedades we want to count
     *   }
     * })
    **/
    count<T extends novedadesCountArgs>(
      args?: Subset<T, novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovedadesAggregateArgs>(args: Subset<T, NovedadesAggregateArgs>): Prisma.PrismaPromise<GetNovedadesAggregateType<T>>

    /**
     * Group by Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: novedadesGroupByArgs['orderBy'] }
        : { orderBy?: novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__novedadesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * novedades base type for findUnique actions
   */
  export type novedadesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }

  /**
   * novedades findUnique
   */
  export interface novedadesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findUniqueOrThrow
   */
  export type novedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades base type for findFirst actions
   */
  export type novedadesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }

  /**
   * novedades findFirst
   */
  export interface novedadesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findFirstOrThrow
   */
  export type novedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades findMany
   */
  export type novedadesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades create
   */
  export type novedadesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a novedades.
     */
    data?: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
  }


  /**
   * novedades createMany
   */
  export type novedadesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many novedades.
     */
    data: novedadesCreateManyInput | novedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * novedades update
   */
  export type novedadesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a novedades.
     */
    data: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
    /**
     * Choose, which novedades to update.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades updateMany
   */
  export type novedadesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update novedades.
     */
    data: XOR<novedadesUpdateManyMutationInput, novedadesUncheckedUpdateManyInput>
    /**
     * Filter which novedades to update
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades upsert
   */
  export type novedadesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the novedades to update in case it exists.
     */
    where: novedadesWhereUniqueInput
    /**
     * In case the novedades found by the `where` argument doesn't exist, create a new novedades with this data.
     */
    create: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
    /**
     * In case the novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
  }


  /**
   * novedades delete
   */
  export type novedadesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter which novedades to delete.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades deleteMany
   */
  export type novedadesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to delete
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades without action
   */
  export type novedadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
  }



  /**
   * Model obsequios
   */


  export type AggregateObsequios = {
    _count: ObsequiosCountAggregateOutputType | null
    _avg: ObsequiosAvgAggregateOutputType | null
    _sum: ObsequiosSumAggregateOutputType | null
    _min: ObsequiosMinAggregateOutputType | null
    _max: ObsequiosMaxAggregateOutputType | null
  }

  export type ObsequiosAvgAggregateOutputType = {
    idobsequio: number | null
    precio: number | null
    stock: number | null
  }

  export type ObsequiosSumAggregateOutputType = {
    idobsequio: number | null
    precio: number | null
    stock: number | null
  }

  export type ObsequiosMinAggregateOutputType = {
    idobsequio: number | null
    producto: string | null
    marca: string | null
    categoria: string | null
    precio: number | null
    stock: number | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    fecha_reposicion: string | null
    operador_rep: string | null
  }

  export type ObsequiosMaxAggregateOutputType = {
    idobsequio: number | null
    producto: string | null
    marca: string | null
    categoria: string | null
    precio: number | null
    stock: number | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    fecha_reposicion: string | null
    operador_rep: string | null
  }

  export type ObsequiosCountAggregateOutputType = {
    idobsequio: number
    producto: number
    marca: number
    categoria: number
    precio: number
    stock: number
    operador: number
    fecha: number
    observacion: number
    fecha_reposicion: number
    operador_rep: number
    _all: number
  }


  export type ObsequiosAvgAggregateInputType = {
    idobsequio?: true
    precio?: true
    stock?: true
  }

  export type ObsequiosSumAggregateInputType = {
    idobsequio?: true
    precio?: true
    stock?: true
  }

  export type ObsequiosMinAggregateInputType = {
    idobsequio?: true
    producto?: true
    marca?: true
    categoria?: true
    precio?: true
    stock?: true
    operador?: true
    fecha?: true
    observacion?: true
    fecha_reposicion?: true
    operador_rep?: true
  }

  export type ObsequiosMaxAggregateInputType = {
    idobsequio?: true
    producto?: true
    marca?: true
    categoria?: true
    precio?: true
    stock?: true
    operador?: true
    fecha?: true
    observacion?: true
    fecha_reposicion?: true
    operador_rep?: true
  }

  export type ObsequiosCountAggregateInputType = {
    idobsequio?: true
    producto?: true
    marca?: true
    categoria?: true
    precio?: true
    stock?: true
    operador?: true
    fecha?: true
    observacion?: true
    fecha_reposicion?: true
    operador_rep?: true
    _all?: true
  }

  export type ObsequiosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which obsequios to aggregate.
     */
    where?: obsequiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obsequios to fetch.
     */
    orderBy?: obsequiosOrderByWithRelationInput | obsequiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: obsequiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned obsequios
    **/
    _count?: true | ObsequiosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObsequiosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObsequiosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObsequiosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObsequiosMaxAggregateInputType
  }

  export type GetObsequiosAggregateType<T extends ObsequiosAggregateArgs> = {
        [P in keyof T & keyof AggregateObsequios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObsequios[P]>
      : GetScalarType<T[P], AggregateObsequios[P]>
  }




  export type obsequiosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: obsequiosWhereInput
    orderBy?: obsequiosOrderByWithAggregationInput | obsequiosOrderByWithAggregationInput[]
    by: ObsequiosScalarFieldEnum[] | ObsequiosScalarFieldEnum
    having?: obsequiosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObsequiosCountAggregateInputType | true
    _avg?: ObsequiosAvgAggregateInputType
    _sum?: ObsequiosSumAggregateInputType
    _min?: ObsequiosMinAggregateInputType
    _max?: ObsequiosMaxAggregateInputType
  }


  export type ObsequiosGroupByOutputType = {
    idobsequio: number
    producto: string | null
    marca: string | null
    categoria: string | null
    precio: number | null
    stock: number | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    fecha_reposicion: string | null
    operador_rep: string | null
    _count: ObsequiosCountAggregateOutputType | null
    _avg: ObsequiosAvgAggregateOutputType | null
    _sum: ObsequiosSumAggregateOutputType | null
    _min: ObsequiosMinAggregateOutputType | null
    _max: ObsequiosMaxAggregateOutputType | null
  }

  type GetObsequiosGroupByPayload<T extends obsequiosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObsequiosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObsequiosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObsequiosGroupByOutputType[P]>
            : GetScalarType<T[P], ObsequiosGroupByOutputType[P]>
        }
      >
    >


  export type obsequiosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idobsequio?: boolean
    producto?: boolean
    marca?: boolean
    categoria?: boolean
    precio?: boolean
    stock?: boolean
    operador?: boolean
    fecha?: boolean
    observacion?: boolean
    fecha_reposicion?: boolean
    operador_rep?: boolean
  }, ExtArgs["result"]["obsequios"]>

  export type obsequiosSelectScalar = {
    idobsequio?: boolean
    producto?: boolean
    marca?: boolean
    categoria?: boolean
    precio?: boolean
    stock?: boolean
    operador?: boolean
    fecha?: boolean
    observacion?: boolean
    fecha_reposicion?: boolean
    operador_rep?: boolean
  }


  type obsequiosGetPayload<S extends boolean | null | undefined | obsequiosArgs> = $Types.GetResult<obsequiosPayload, S>

  type obsequiosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<obsequiosFindManyArgs, 'select' | 'include'> & {
      select?: ObsequiosCountAggregateInputType | true
    }

  export interface obsequiosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['obsequios'], meta: { name: 'obsequios' } }
    /**
     * Find zero or one Obsequios that matches the filter.
     * @param {obsequiosFindUniqueArgs} args - Arguments to find a Obsequios
     * @example
     * // Get one Obsequios
     * const obsequios = await prisma.obsequios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends obsequiosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, obsequiosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'obsequios'> extends True ? Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Obsequios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {obsequiosFindUniqueOrThrowArgs} args - Arguments to find a Obsequios
     * @example
     * // Get one Obsequios
     * const obsequios = await prisma.obsequios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends obsequiosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, obsequiosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Obsequios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosFindFirstArgs} args - Arguments to find a Obsequios
     * @example
     * // Get one Obsequios
     * const obsequios = await prisma.obsequios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends obsequiosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, obsequiosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'obsequios'> extends True ? Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Obsequios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosFindFirstOrThrowArgs} args - Arguments to find a Obsequios
     * @example
     * // Get one Obsequios
     * const obsequios = await prisma.obsequios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends obsequiosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, obsequiosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Obsequios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obsequios
     * const obsequios = await prisma.obsequios.findMany()
     * 
     * // Get first 10 Obsequios
     * const obsequios = await prisma.obsequios.findMany({ take: 10 })
     * 
     * // Only select the `idobsequio`
     * const obsequiosWithIdobsequioOnly = await prisma.obsequios.findMany({ select: { idobsequio: true } })
     * 
    **/
    findMany<T extends obsequiosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obsequiosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Obsequios.
     * @param {obsequiosCreateArgs} args - Arguments to create a Obsequios.
     * @example
     * // Create one Obsequios
     * const Obsequios = await prisma.obsequios.create({
     *   data: {
     *     // ... data to create a Obsequios
     *   }
     * })
     * 
    **/
    create<T extends obsequiosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, obsequiosCreateArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Obsequios.
     *     @param {obsequiosCreateManyArgs} args - Arguments to create many Obsequios.
     *     @example
     *     // Create many Obsequios
     *     const obsequios = await prisma.obsequios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends obsequiosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obsequiosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Obsequios.
     * @param {obsequiosDeleteArgs} args - Arguments to delete one Obsequios.
     * @example
     * // Delete one Obsequios
     * const Obsequios = await prisma.obsequios.delete({
     *   where: {
     *     // ... filter to delete one Obsequios
     *   }
     * })
     * 
    **/
    delete<T extends obsequiosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, obsequiosDeleteArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Obsequios.
     * @param {obsequiosUpdateArgs} args - Arguments to update one Obsequios.
     * @example
     * // Update one Obsequios
     * const obsequios = await prisma.obsequios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends obsequiosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, obsequiosUpdateArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Obsequios.
     * @param {obsequiosDeleteManyArgs} args - Arguments to filter Obsequios to delete.
     * @example
     * // Delete a few Obsequios
     * const { count } = await prisma.obsequios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends obsequiosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obsequiosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obsequios
     * const obsequios = await prisma.obsequios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends obsequiosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, obsequiosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Obsequios.
     * @param {obsequiosUpsertArgs} args - Arguments to update or create a Obsequios.
     * @example
     * // Update or create a Obsequios
     * const obsequios = await prisma.obsequios.upsert({
     *   create: {
     *     // ... data to create a Obsequios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obsequios we want to update
     *   }
     * })
    **/
    upsert<T extends obsequiosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, obsequiosUpsertArgs<ExtArgs>>
    ): Prisma__obsequiosClient<$Types.GetResult<obsequiosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosCountArgs} args - Arguments to filter Obsequios to count.
     * @example
     * // Count the number of Obsequios
     * const count = await prisma.obsequios.count({
     *   where: {
     *     // ... the filter for the Obsequios we want to count
     *   }
     * })
    **/
    count<T extends obsequiosCountArgs>(
      args?: Subset<T, obsequiosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObsequiosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObsequiosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObsequiosAggregateArgs>(args: Subset<T, ObsequiosAggregateArgs>): Prisma.PrismaPromise<GetObsequiosAggregateType<T>>

    /**
     * Group by Obsequios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obsequiosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends obsequiosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: obsequiosGroupByArgs['orderBy'] }
        : { orderBy?: obsequiosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, obsequiosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObsequiosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for obsequios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__obsequiosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * obsequios base type for findUnique actions
   */
  export type obsequiosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter, which obsequios to fetch.
     */
    where: obsequiosWhereUniqueInput
  }

  /**
   * obsequios findUnique
   */
  export interface obsequiosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends obsequiosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * obsequios findUniqueOrThrow
   */
  export type obsequiosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter, which obsequios to fetch.
     */
    where: obsequiosWhereUniqueInput
  }


  /**
   * obsequios base type for findFirst actions
   */
  export type obsequiosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter, which obsequios to fetch.
     */
    where?: obsequiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obsequios to fetch.
     */
    orderBy?: obsequiosOrderByWithRelationInput | obsequiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for obsequios.
     */
    cursor?: obsequiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of obsequios.
     */
    distinct?: ObsequiosScalarFieldEnum | ObsequiosScalarFieldEnum[]
  }

  /**
   * obsequios findFirst
   */
  export interface obsequiosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends obsequiosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * obsequios findFirstOrThrow
   */
  export type obsequiosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter, which obsequios to fetch.
     */
    where?: obsequiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obsequios to fetch.
     */
    orderBy?: obsequiosOrderByWithRelationInput | obsequiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for obsequios.
     */
    cursor?: obsequiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obsequios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of obsequios.
     */
    distinct?: ObsequiosScalarFieldEnum | ObsequiosScalarFieldEnum[]
  }


  /**
   * obsequios findMany
   */
  export type obsequiosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter, which obsequios to fetch.
     */
    where?: obsequiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obsequios to fetch.
     */
    orderBy?: obsequiosOrderByWithRelationInput | obsequiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing obsequios.
     */
    cursor?: obsequiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obsequios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obsequios.
     */
    skip?: number
    distinct?: ObsequiosScalarFieldEnum | ObsequiosScalarFieldEnum[]
  }


  /**
   * obsequios create
   */
  export type obsequiosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * The data needed to create a obsequios.
     */
    data?: XOR<obsequiosCreateInput, obsequiosUncheckedCreateInput>
  }


  /**
   * obsequios createMany
   */
  export type obsequiosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many obsequios.
     */
    data: obsequiosCreateManyInput | obsequiosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * obsequios update
   */
  export type obsequiosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * The data needed to update a obsequios.
     */
    data: XOR<obsequiosUpdateInput, obsequiosUncheckedUpdateInput>
    /**
     * Choose, which obsequios to update.
     */
    where: obsequiosWhereUniqueInput
  }


  /**
   * obsequios updateMany
   */
  export type obsequiosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update obsequios.
     */
    data: XOR<obsequiosUpdateManyMutationInput, obsequiosUncheckedUpdateManyInput>
    /**
     * Filter which obsequios to update
     */
    where?: obsequiosWhereInput
  }


  /**
   * obsequios upsert
   */
  export type obsequiosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * The filter to search for the obsequios to update in case it exists.
     */
    where: obsequiosWhereUniqueInput
    /**
     * In case the obsequios found by the `where` argument doesn't exist, create a new obsequios with this data.
     */
    create: XOR<obsequiosCreateInput, obsequiosUncheckedCreateInput>
    /**
     * In case the obsequios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<obsequiosUpdateInput, obsequiosUncheckedUpdateInput>
  }


  /**
   * obsequios delete
   */
  export type obsequiosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
    /**
     * Filter which obsequios to delete.
     */
    where: obsequiosWhereUniqueInput
  }


  /**
   * obsequios deleteMany
   */
  export type obsequiosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which obsequios to delete
     */
    where?: obsequiosWhereInput
  }


  /**
   * obsequios without action
   */
  export type obsequiosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obsequios
     */
    select?: obsequiosSelect<ExtArgs> | null
  }



  /**
   * Model openia_keys
   */


  export type AggregateOpenia_keys = {
    _count: Openia_keysCountAggregateOutputType | null
    _avg: Openia_keysAvgAggregateOutputType | null
    _sum: Openia_keysSumAggregateOutputType | null
    _min: Openia_keysMinAggregateOutputType | null
    _max: Openia_keysMaxAggregateOutputType | null
  }

  export type Openia_keysAvgAggregateOutputType = {
    idkey: number | null
  }

  export type Openia_keysSumAggregateOutputType = {
    idkey: number | null
  }

  export type Openia_keysMinAggregateOutputType = {
    idkey: number | null
    key: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Openia_keysMaxAggregateOutputType = {
    idkey: number | null
    key: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Openia_keysCountAggregateOutputType = {
    idkey: number
    key: number
    fecha: number
    estado: number
    _all: number
  }


  export type Openia_keysAvgAggregateInputType = {
    idkey?: true
  }

  export type Openia_keysSumAggregateInputType = {
    idkey?: true
  }

  export type Openia_keysMinAggregateInputType = {
    idkey?: true
    key?: true
    fecha?: true
    estado?: true
  }

  export type Openia_keysMaxAggregateInputType = {
    idkey?: true
    key?: true
    fecha?: true
    estado?: true
  }

  export type Openia_keysCountAggregateInputType = {
    idkey?: true
    key?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type Openia_keysAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which openia_keys to aggregate.
     */
    where?: openia_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of openia_keys to fetch.
     */
    orderBy?: openia_keysOrderByWithRelationInput | openia_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: openia_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` openia_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` openia_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned openia_keys
    **/
    _count?: true | Openia_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Openia_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Openia_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Openia_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Openia_keysMaxAggregateInputType
  }

  export type GetOpenia_keysAggregateType<T extends Openia_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenia_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenia_keys[P]>
      : GetScalarType<T[P], AggregateOpenia_keys[P]>
  }




  export type openia_keysGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: openia_keysWhereInput
    orderBy?: openia_keysOrderByWithAggregationInput | openia_keysOrderByWithAggregationInput[]
    by: Openia_keysScalarFieldEnum[] | Openia_keysScalarFieldEnum
    having?: openia_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Openia_keysCountAggregateInputType | true
    _avg?: Openia_keysAvgAggregateInputType
    _sum?: Openia_keysSumAggregateInputType
    _min?: Openia_keysMinAggregateInputType
    _max?: Openia_keysMaxAggregateInputType
  }


  export type Openia_keysGroupByOutputType = {
    idkey: number
    key: string | null
    fecha: Date | null
    estado: boolean | null
    _count: Openia_keysCountAggregateOutputType | null
    _avg: Openia_keysAvgAggregateOutputType | null
    _sum: Openia_keysSumAggregateOutputType | null
    _min: Openia_keysMinAggregateOutputType | null
    _max: Openia_keysMaxAggregateOutputType | null
  }

  type GetOpenia_keysGroupByPayload<T extends openia_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Openia_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Openia_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Openia_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Openia_keysGroupByOutputType[P]>
        }
      >
    >


  export type openia_keysSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idkey?: boolean
    key?: boolean
    fecha?: boolean
    estado?: boolean
  }, ExtArgs["result"]["openia_keys"]>

  export type openia_keysSelectScalar = {
    idkey?: boolean
    key?: boolean
    fecha?: boolean
    estado?: boolean
  }


  type openia_keysGetPayload<S extends boolean | null | undefined | openia_keysArgs> = $Types.GetResult<openia_keysPayload, S>

  type openia_keysCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<openia_keysFindManyArgs, 'select' | 'include'> & {
      select?: Openia_keysCountAggregateInputType | true
    }

  export interface openia_keysDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['openia_keys'], meta: { name: 'openia_keys' } }
    /**
     * Find zero or one Openia_keys that matches the filter.
     * @param {openia_keysFindUniqueArgs} args - Arguments to find a Openia_keys
     * @example
     * // Get one Openia_keys
     * const openia_keys = await prisma.openia_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends openia_keysFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, openia_keysFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'openia_keys'> extends True ? Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Openia_keys that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {openia_keysFindUniqueOrThrowArgs} args - Arguments to find a Openia_keys
     * @example
     * // Get one Openia_keys
     * const openia_keys = await prisma.openia_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends openia_keysFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, openia_keysFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Openia_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysFindFirstArgs} args - Arguments to find a Openia_keys
     * @example
     * // Get one Openia_keys
     * const openia_keys = await prisma.openia_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends openia_keysFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, openia_keysFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'openia_keys'> extends True ? Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Openia_keys that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysFindFirstOrThrowArgs} args - Arguments to find a Openia_keys
     * @example
     * // Get one Openia_keys
     * const openia_keys = await prisma.openia_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends openia_keysFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, openia_keysFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Openia_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Openia_keys
     * const openia_keys = await prisma.openia_keys.findMany()
     * 
     * // Get first 10 Openia_keys
     * const openia_keys = await prisma.openia_keys.findMany({ take: 10 })
     * 
     * // Only select the `idkey`
     * const openia_keysWithIdkeyOnly = await prisma.openia_keys.findMany({ select: { idkey: true } })
     * 
    **/
    findMany<T extends openia_keysFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, openia_keysFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Openia_keys.
     * @param {openia_keysCreateArgs} args - Arguments to create a Openia_keys.
     * @example
     * // Create one Openia_keys
     * const Openia_keys = await prisma.openia_keys.create({
     *   data: {
     *     // ... data to create a Openia_keys
     *   }
     * })
     * 
    **/
    create<T extends openia_keysCreateArgs<ExtArgs>>(
      args: SelectSubset<T, openia_keysCreateArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Openia_keys.
     *     @param {openia_keysCreateManyArgs} args - Arguments to create many Openia_keys.
     *     @example
     *     // Create many Openia_keys
     *     const openia_keys = await prisma.openia_keys.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends openia_keysCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, openia_keysCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Openia_keys.
     * @param {openia_keysDeleteArgs} args - Arguments to delete one Openia_keys.
     * @example
     * // Delete one Openia_keys
     * const Openia_keys = await prisma.openia_keys.delete({
     *   where: {
     *     // ... filter to delete one Openia_keys
     *   }
     * })
     * 
    **/
    delete<T extends openia_keysDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, openia_keysDeleteArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Openia_keys.
     * @param {openia_keysUpdateArgs} args - Arguments to update one Openia_keys.
     * @example
     * // Update one Openia_keys
     * const openia_keys = await prisma.openia_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends openia_keysUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, openia_keysUpdateArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Openia_keys.
     * @param {openia_keysDeleteManyArgs} args - Arguments to filter Openia_keys to delete.
     * @example
     * // Delete a few Openia_keys
     * const { count } = await prisma.openia_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends openia_keysDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, openia_keysDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Openia_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Openia_keys
     * const openia_keys = await prisma.openia_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends openia_keysUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, openia_keysUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Openia_keys.
     * @param {openia_keysUpsertArgs} args - Arguments to update or create a Openia_keys.
     * @example
     * // Update or create a Openia_keys
     * const openia_keys = await prisma.openia_keys.upsert({
     *   create: {
     *     // ... data to create a Openia_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Openia_keys we want to update
     *   }
     * })
    **/
    upsert<T extends openia_keysUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, openia_keysUpsertArgs<ExtArgs>>
    ): Prisma__openia_keysClient<$Types.GetResult<openia_keysPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Openia_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysCountArgs} args - Arguments to filter Openia_keys to count.
     * @example
     * // Count the number of Openia_keys
     * const count = await prisma.openia_keys.count({
     *   where: {
     *     // ... the filter for the Openia_keys we want to count
     *   }
     * })
    **/
    count<T extends openia_keysCountArgs>(
      args?: Subset<T, openia_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Openia_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Openia_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Openia_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Openia_keysAggregateArgs>(args: Subset<T, Openia_keysAggregateArgs>): Prisma.PrismaPromise<GetOpenia_keysAggregateType<T>>

    /**
     * Group by Openia_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {openia_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends openia_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: openia_keysGroupByArgs['orderBy'] }
        : { orderBy?: openia_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, openia_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenia_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for openia_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__openia_keysClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * openia_keys base type for findUnique actions
   */
  export type openia_keysFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter, which openia_keys to fetch.
     */
    where: openia_keysWhereUniqueInput
  }

  /**
   * openia_keys findUnique
   */
  export interface openia_keysFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends openia_keysFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * openia_keys findUniqueOrThrow
   */
  export type openia_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter, which openia_keys to fetch.
     */
    where: openia_keysWhereUniqueInput
  }


  /**
   * openia_keys base type for findFirst actions
   */
  export type openia_keysFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter, which openia_keys to fetch.
     */
    where?: openia_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of openia_keys to fetch.
     */
    orderBy?: openia_keysOrderByWithRelationInput | openia_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for openia_keys.
     */
    cursor?: openia_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` openia_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` openia_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of openia_keys.
     */
    distinct?: Openia_keysScalarFieldEnum | Openia_keysScalarFieldEnum[]
  }

  /**
   * openia_keys findFirst
   */
  export interface openia_keysFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends openia_keysFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * openia_keys findFirstOrThrow
   */
  export type openia_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter, which openia_keys to fetch.
     */
    where?: openia_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of openia_keys to fetch.
     */
    orderBy?: openia_keysOrderByWithRelationInput | openia_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for openia_keys.
     */
    cursor?: openia_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` openia_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` openia_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of openia_keys.
     */
    distinct?: Openia_keysScalarFieldEnum | Openia_keysScalarFieldEnum[]
  }


  /**
   * openia_keys findMany
   */
  export type openia_keysFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter, which openia_keys to fetch.
     */
    where?: openia_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of openia_keys to fetch.
     */
    orderBy?: openia_keysOrderByWithRelationInput | openia_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing openia_keys.
     */
    cursor?: openia_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` openia_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` openia_keys.
     */
    skip?: number
    distinct?: Openia_keysScalarFieldEnum | Openia_keysScalarFieldEnum[]
  }


  /**
   * openia_keys create
   */
  export type openia_keysCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * The data needed to create a openia_keys.
     */
    data?: XOR<openia_keysCreateInput, openia_keysUncheckedCreateInput>
  }


  /**
   * openia_keys createMany
   */
  export type openia_keysCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many openia_keys.
     */
    data: openia_keysCreateManyInput | openia_keysCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * openia_keys update
   */
  export type openia_keysUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * The data needed to update a openia_keys.
     */
    data: XOR<openia_keysUpdateInput, openia_keysUncheckedUpdateInput>
    /**
     * Choose, which openia_keys to update.
     */
    where: openia_keysWhereUniqueInput
  }


  /**
   * openia_keys updateMany
   */
  export type openia_keysUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update openia_keys.
     */
    data: XOR<openia_keysUpdateManyMutationInput, openia_keysUncheckedUpdateManyInput>
    /**
     * Filter which openia_keys to update
     */
    where?: openia_keysWhereInput
  }


  /**
   * openia_keys upsert
   */
  export type openia_keysUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * The filter to search for the openia_keys to update in case it exists.
     */
    where: openia_keysWhereUniqueInput
    /**
     * In case the openia_keys found by the `where` argument doesn't exist, create a new openia_keys with this data.
     */
    create: XOR<openia_keysCreateInput, openia_keysUncheckedCreateInput>
    /**
     * In case the openia_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<openia_keysUpdateInput, openia_keysUncheckedUpdateInput>
  }


  /**
   * openia_keys delete
   */
  export type openia_keysDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
    /**
     * Filter which openia_keys to delete.
     */
    where: openia_keysWhereUniqueInput
  }


  /**
   * openia_keys deleteMany
   */
  export type openia_keysDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which openia_keys to delete
     */
    where?: openia_keysWhereInput
  }


  /**
   * openia_keys without action
   */
  export type openia_keysArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the openia_keys
     */
    select?: openia_keysSelect<ExtArgs> | null
  }



  /**
   * Model operador
   */


  export type AggregateOperador = {
    _count: OperadorCountAggregateOutputType | null
    _avg: OperadorAvgAggregateOutputType | null
    _sum: OperadorSumAggregateOutputType | null
    _min: OperadorMinAggregateOutputType | null
    _max: OperadorMaxAggregateOutputType | null
  }

  export type OperadorAvgAggregateOutputType = {
    id: number | null
    puestom: number | null
    perfil: number | null
    puestow: number | null
    codigo: number | null
  }

  export type OperadorSumAggregateOutputType = {
    id: number | null
    puestom: number | null
    perfil: number | null
    puestow: number | null
    codigo: number | null
  }

  export type OperadorMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    usuario: string | null
    contrasena: string | null
    createdAt: Date | null
    updatedAt: Date | null
    puestom: number | null
    perfil: number | null
    estado: boolean | null
    puestow: number | null
    codigo: number | null
    medicos: boolean | null
    sucursal: string | null
    prestamos: boolean | null
    ordenpago: boolean | null
    clubwerchow: boolean | null
    ventas: boolean | null
    administracion: boolean | null
    campanas: boolean | null
    socios: boolean | null
    sepelio: boolean | null
  }

  export type OperadorMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    usuario: string | null
    contrasena: string | null
    createdAt: Date | null
    updatedAt: Date | null
    puestom: number | null
    perfil: number | null
    estado: boolean | null
    puestow: number | null
    codigo: number | null
    medicos: boolean | null
    sucursal: string | null
    prestamos: boolean | null
    ordenpago: boolean | null
    clubwerchow: boolean | null
    ventas: boolean | null
    administracion: boolean | null
    campanas: boolean | null
    socios: boolean | null
    sepelio: boolean | null
  }

  export type OperadorCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    usuario: number
    contrasena: number
    createdAt: number
    updatedAt: number
    puestom: number
    perfil: number
    estado: number
    puestow: number
    codigo: number
    medicos: number
    sucursal: number
    prestamos: number
    ordenpago: number
    clubwerchow: number
    ventas: number
    administracion: number
    campanas: number
    socios: number
    sepelio: number
    _all: number
  }


  export type OperadorAvgAggregateInputType = {
    id?: true
    puestom?: true
    perfil?: true
    puestow?: true
    codigo?: true
  }

  export type OperadorSumAggregateInputType = {
    id?: true
    puestom?: true
    perfil?: true
    puestow?: true
    codigo?: true
  }

  export type OperadorMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    usuario?: true
    contrasena?: true
    createdAt?: true
    updatedAt?: true
    puestom?: true
    perfil?: true
    estado?: true
    puestow?: true
    codigo?: true
    medicos?: true
    sucursal?: true
    prestamos?: true
    ordenpago?: true
    clubwerchow?: true
    ventas?: true
    administracion?: true
    campanas?: true
    socios?: true
    sepelio?: true
  }

  export type OperadorMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    usuario?: true
    contrasena?: true
    createdAt?: true
    updatedAt?: true
    puestom?: true
    perfil?: true
    estado?: true
    puestow?: true
    codigo?: true
    medicos?: true
    sucursal?: true
    prestamos?: true
    ordenpago?: true
    clubwerchow?: true
    ventas?: true
    administracion?: true
    campanas?: true
    socios?: true
    sepelio?: true
  }

  export type OperadorCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    usuario?: true
    contrasena?: true
    createdAt?: true
    updatedAt?: true
    puestom?: true
    perfil?: true
    estado?: true
    puestow?: true
    codigo?: true
    medicos?: true
    sucursal?: true
    prestamos?: true
    ordenpago?: true
    clubwerchow?: true
    ventas?: true
    administracion?: true
    campanas?: true
    socios?: true
    sepelio?: true
    _all?: true
  }

  export type OperadorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operador to aggregate.
     */
    where?: operadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadors to fetch.
     */
    orderBy?: operadorOrderByWithRelationInput | operadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operadors
    **/
    _count?: true | OperadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperadorMaxAggregateInputType
  }

  export type GetOperadorAggregateType<T extends OperadorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperador[P]>
      : GetScalarType<T[P], AggregateOperador[P]>
  }




  export type operadorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: operadorWhereInput
    orderBy?: operadorOrderByWithAggregationInput | operadorOrderByWithAggregationInput[]
    by: OperadorScalarFieldEnum[] | OperadorScalarFieldEnum
    having?: operadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperadorCountAggregateInputType | true
    _avg?: OperadorAvgAggregateInputType
    _sum?: OperadorSumAggregateInputType
    _min?: OperadorMinAggregateInputType
    _max?: OperadorMaxAggregateInputType
  }


  export type OperadorGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    usuario: string
    contrasena: string
    createdAt: Date
    updatedAt: Date
    puestom: number | null
    perfil: number | null
    estado: boolean | null
    puestow: number | null
    codigo: number | null
    medicos: boolean | null
    sucursal: string | null
    prestamos: boolean | null
    ordenpago: boolean | null
    clubwerchow: boolean | null
    ventas: boolean | null
    administracion: boolean | null
    campanas: boolean | null
    socios: boolean | null
    sepelio: boolean | null
    _count: OperadorCountAggregateOutputType | null
    _avg: OperadorAvgAggregateOutputType | null
    _sum: OperadorSumAggregateOutputType | null
    _min: OperadorMinAggregateOutputType | null
    _max: OperadorMaxAggregateOutputType | null
  }

  type GetOperadorGroupByPayload<T extends operadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperadorGroupByOutputType[P]>
            : GetScalarType<T[P], OperadorGroupByOutputType[P]>
        }
      >
    >


  export type operadorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    usuario?: boolean
    contrasena?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    puestom?: boolean
    perfil?: boolean
    estado?: boolean
    puestow?: boolean
    codigo?: boolean
    medicos?: boolean
    sucursal?: boolean
    prestamos?: boolean
    ordenpago?: boolean
    clubwerchow?: boolean
    ventas?: boolean
    administracion?: boolean
    campanas?: boolean
    socios?: boolean
    sepelio?: boolean
  }, ExtArgs["result"]["operador"]>

  export type operadorSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    usuario?: boolean
    contrasena?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    puestom?: boolean
    perfil?: boolean
    estado?: boolean
    puestow?: boolean
    codigo?: boolean
    medicos?: boolean
    sucursal?: boolean
    prestamos?: boolean
    ordenpago?: boolean
    clubwerchow?: boolean
    ventas?: boolean
    administracion?: boolean
    campanas?: boolean
    socios?: boolean
    sepelio?: boolean
  }


  type operadorGetPayload<S extends boolean | null | undefined | operadorArgs> = $Types.GetResult<operadorPayload, S>

  type operadorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<operadorFindManyArgs, 'select' | 'include'> & {
      select?: OperadorCountAggregateInputType | true
    }

  export interface operadorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operador'], meta: { name: 'operador' } }
    /**
     * Find zero or one Operador that matches the filter.
     * @param {operadorFindUniqueArgs} args - Arguments to find a Operador
     * @example
     * // Get one Operador
     * const operador = await prisma.operador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operadorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operadorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operador'> extends True ? Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Operador that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operadorFindUniqueOrThrowArgs} args - Arguments to find a Operador
     * @example
     * // Get one Operador
     * const operador = await prisma.operador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operadorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Operador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorFindFirstArgs} args - Arguments to find a Operador
     * @example
     * // Get one Operador
     * const operador = await prisma.operador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operadorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operadorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operador'> extends True ? Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Operador that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorFindFirstOrThrowArgs} args - Arguments to find a Operador
     * @example
     * // Get one Operador
     * const operador = await prisma.operador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operadorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Operadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operadors
     * const operadors = await prisma.operador.findMany()
     * 
     * // Get first 10 Operadors
     * const operadors = await prisma.operador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operadorWithIdOnly = await prisma.operador.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends operadorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<operadorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Operador.
     * @param {operadorCreateArgs} args - Arguments to create a Operador.
     * @example
     * // Create one Operador
     * const Operador = await prisma.operador.create({
     *   data: {
     *     // ... data to create a Operador
     *   }
     * })
     * 
    **/
    create<T extends operadorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorCreateArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Operadors.
     *     @param {operadorCreateManyArgs} args - Arguments to create many Operadors.
     *     @example
     *     // Create many Operadors
     *     const operador = await prisma.operador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operadorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operador.
     * @param {operadorDeleteArgs} args - Arguments to delete one Operador.
     * @example
     * // Delete one Operador
     * const Operador = await prisma.operador.delete({
     *   where: {
     *     // ... filter to delete one Operador
     *   }
     * })
     * 
    **/
    delete<T extends operadorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, operadorDeleteArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Operador.
     * @param {operadorUpdateArgs} args - Arguments to update one Operador.
     * @example
     * // Update one Operador
     * const operador = await prisma.operador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operadorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorUpdateArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Operadors.
     * @param {operadorDeleteManyArgs} args - Arguments to filter Operadors to delete.
     * @example
     * // Delete a few Operadors
     * const { count } = await prisma.operador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operadorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operadors
     * const operador = await prisma.operador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operadorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, operadorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operador.
     * @param {operadorUpsertArgs} args - Arguments to update or create a Operador.
     * @example
     * // Update or create a Operador
     * const operador = await prisma.operador.upsert({
     *   create: {
     *     // ... data to create a Operador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operador we want to update
     *   }
     * })
    **/
    upsert<T extends operadorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, operadorUpsertArgs<ExtArgs>>
    ): Prisma__operadorClient<$Types.GetResult<operadorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Operadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorCountArgs} args - Arguments to filter Operadors to count.
     * @example
     * // Count the number of Operadors
     * const count = await prisma.operador.count({
     *   where: {
     *     // ... the filter for the Operadors we want to count
     *   }
     * })
    **/
    count<T extends operadorCountArgs>(
      args?: Subset<T, operadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperadorAggregateArgs>(args: Subset<T, OperadorAggregateArgs>): Prisma.PrismaPromise<GetOperadorAggregateType<T>>

    /**
     * Group by Operador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operadorGroupByArgs['orderBy'] }
        : { orderBy?: operadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operadorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operador base type for findUnique actions
   */
  export type operadorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter, which operador to fetch.
     */
    where: operadorWhereUniqueInput
  }

  /**
   * operador findUnique
   */
  export interface operadorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operador findUniqueOrThrow
   */
  export type operadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter, which operador to fetch.
     */
    where: operadorWhereUniqueInput
  }


  /**
   * operador base type for findFirst actions
   */
  export type operadorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter, which operador to fetch.
     */
    where?: operadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadors to fetch.
     */
    orderBy?: operadorOrderByWithRelationInput | operadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadors.
     */
    cursor?: operadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadors.
     */
    distinct?: OperadorScalarFieldEnum | OperadorScalarFieldEnum[]
  }

  /**
   * operador findFirst
   */
  export interface operadorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operador findFirstOrThrow
   */
  export type operadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter, which operador to fetch.
     */
    where?: operadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadors to fetch.
     */
    orderBy?: operadorOrderByWithRelationInput | operadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadors.
     */
    cursor?: operadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadors.
     */
    distinct?: OperadorScalarFieldEnum | OperadorScalarFieldEnum[]
  }


  /**
   * operador findMany
   */
  export type operadorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter, which operadors to fetch.
     */
    where?: operadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadors to fetch.
     */
    orderBy?: operadorOrderByWithRelationInput | operadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operadors.
     */
    cursor?: operadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadors.
     */
    skip?: number
    distinct?: OperadorScalarFieldEnum | OperadorScalarFieldEnum[]
  }


  /**
   * operador create
   */
  export type operadorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * The data needed to create a operador.
     */
    data: XOR<operadorCreateInput, operadorUncheckedCreateInput>
  }


  /**
   * operador createMany
   */
  export type operadorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operadors.
     */
    data: operadorCreateManyInput | operadorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * operador update
   */
  export type operadorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * The data needed to update a operador.
     */
    data: XOR<operadorUpdateInput, operadorUncheckedUpdateInput>
    /**
     * Choose, which operador to update.
     */
    where: operadorWhereUniqueInput
  }


  /**
   * operador updateMany
   */
  export type operadorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operadors.
     */
    data: XOR<operadorUpdateManyMutationInput, operadorUncheckedUpdateManyInput>
    /**
     * Filter which operadors to update
     */
    where?: operadorWhereInput
  }


  /**
   * operador upsert
   */
  export type operadorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * The filter to search for the operador to update in case it exists.
     */
    where: operadorWhereUniqueInput
    /**
     * In case the operador found by the `where` argument doesn't exist, create a new operador with this data.
     */
    create: XOR<operadorCreateInput, operadorUncheckedCreateInput>
    /**
     * In case the operador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operadorUpdateInput, operadorUncheckedUpdateInput>
  }


  /**
   * operador delete
   */
  export type operadorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
    /**
     * Filter which operador to delete.
     */
    where: operadorWhereUniqueInput
  }


  /**
   * operador deleteMany
   */
  export type operadorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operadors to delete
     */
    where?: operadorWhereInput
  }


  /**
   * operador without action
   */
  export type operadorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operador
     */
    select?: operadorSelect<ExtArgs> | null
  }



  /**
   * Model ordenes_pago
   */


  export type AggregateOrdenes_pago = {
    _count: Ordenes_pagoCountAggregateOutputType | null
    _avg: Ordenes_pagoAvgAggregateOutputType | null
    _sum: Ordenes_pagoSumAggregateOutputType | null
    _min: Ordenes_pagoMinAggregateOutputType | null
    _max: Ordenes_pagoMaxAggregateOutputType | null
  }

  export type Ordenes_pagoAvgAggregateOutputType = {
    idorden: number | null
    total: number | null
  }

  export type Ordenes_pagoSumAggregateOutputType = {
    idorden: number | null
    total: number | null
  }

  export type Ordenes_pagoMinAggregateOutputType = {
    idorden: number | null
    fecha: Date | null
    proveedor: string | null
    cuit_cuil: string | null
    total: number | null
    operador_carga: string | null
    autorizado: boolean | null
    operador_autorizacion: string | null
    fecha_autorizacion: Date | null
    norden: string | null
    observacion: string | null
    nombre: string | null
    tipo_orden: string | null
    nfactura: string | null
    tipo_factura: string | null
    fecha_pago: Date | null
    pagado: boolean | null
    estado: boolean | null
  }

  export type Ordenes_pagoMaxAggregateOutputType = {
    idorden: number | null
    fecha: Date | null
    proveedor: string | null
    cuit_cuil: string | null
    total: number | null
    operador_carga: string | null
    autorizado: boolean | null
    operador_autorizacion: string | null
    fecha_autorizacion: Date | null
    norden: string | null
    observacion: string | null
    nombre: string | null
    tipo_orden: string | null
    nfactura: string | null
    tipo_factura: string | null
    fecha_pago: Date | null
    pagado: boolean | null
    estado: boolean | null
  }

  export type Ordenes_pagoCountAggregateOutputType = {
    idorden: number
    fecha: number
    proveedor: number
    cuit_cuil: number
    total: number
    operador_carga: number
    autorizado: number
    operador_autorizacion: number
    fecha_autorizacion: number
    norden: number
    observacion: number
    nombre: number
    tipo_orden: number
    nfactura: number
    tipo_factura: number
    fecha_pago: number
    pagado: number
    estado: number
    _all: number
  }


  export type Ordenes_pagoAvgAggregateInputType = {
    idorden?: true
    total?: true
  }

  export type Ordenes_pagoSumAggregateInputType = {
    idorden?: true
    total?: true
  }

  export type Ordenes_pagoMinAggregateInputType = {
    idorden?: true
    fecha?: true
    proveedor?: true
    cuit_cuil?: true
    total?: true
    operador_carga?: true
    autorizado?: true
    operador_autorizacion?: true
    fecha_autorizacion?: true
    norden?: true
    observacion?: true
    nombre?: true
    tipo_orden?: true
    nfactura?: true
    tipo_factura?: true
    fecha_pago?: true
    pagado?: true
    estado?: true
  }

  export type Ordenes_pagoMaxAggregateInputType = {
    idorden?: true
    fecha?: true
    proveedor?: true
    cuit_cuil?: true
    total?: true
    operador_carga?: true
    autorizado?: true
    operador_autorizacion?: true
    fecha_autorizacion?: true
    norden?: true
    observacion?: true
    nombre?: true
    tipo_orden?: true
    nfactura?: true
    tipo_factura?: true
    fecha_pago?: true
    pagado?: true
    estado?: true
  }

  export type Ordenes_pagoCountAggregateInputType = {
    idorden?: true
    fecha?: true
    proveedor?: true
    cuit_cuil?: true
    total?: true
    operador_carga?: true
    autorizado?: true
    operador_autorizacion?: true
    fecha_autorizacion?: true
    norden?: true
    observacion?: true
    nombre?: true
    tipo_orden?: true
    nfactura?: true
    tipo_factura?: true
    fecha_pago?: true
    pagado?: true
    estado?: true
    _all?: true
  }

  export type Ordenes_pagoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordenes_pago to aggregate.
     */
    where?: ordenes_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_pagos to fetch.
     */
    orderBy?: ordenes_pagoOrderByWithRelationInput | ordenes_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordenes_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ordenes_pagos
    **/
    _count?: true | Ordenes_pagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ordenes_pagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ordenes_pagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ordenes_pagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ordenes_pagoMaxAggregateInputType
  }

  export type GetOrdenes_pagoAggregateType<T extends Ordenes_pagoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdenes_pago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdenes_pago[P]>
      : GetScalarType<T[P], AggregateOrdenes_pago[P]>
  }




  export type ordenes_pagoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ordenes_pagoWhereInput
    orderBy?: ordenes_pagoOrderByWithAggregationInput | ordenes_pagoOrderByWithAggregationInput[]
    by: Ordenes_pagoScalarFieldEnum[] | Ordenes_pagoScalarFieldEnum
    having?: ordenes_pagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ordenes_pagoCountAggregateInputType | true
    _avg?: Ordenes_pagoAvgAggregateInputType
    _sum?: Ordenes_pagoSumAggregateInputType
    _min?: Ordenes_pagoMinAggregateInputType
    _max?: Ordenes_pagoMaxAggregateInputType
  }


  export type Ordenes_pagoGroupByOutputType = {
    idorden: number
    fecha: Date | null
    proveedor: string | null
    cuit_cuil: string | null
    total: number | null
    operador_carga: string | null
    autorizado: boolean | null
    operador_autorizacion: string | null
    fecha_autorizacion: Date | null
    norden: string | null
    observacion: string | null
    nombre: string | null
    tipo_orden: string | null
    nfactura: string | null
    tipo_factura: string | null
    fecha_pago: Date | null
    pagado: boolean | null
    estado: boolean | null
    _count: Ordenes_pagoCountAggregateOutputType | null
    _avg: Ordenes_pagoAvgAggregateOutputType | null
    _sum: Ordenes_pagoSumAggregateOutputType | null
    _min: Ordenes_pagoMinAggregateOutputType | null
    _max: Ordenes_pagoMaxAggregateOutputType | null
  }

  type GetOrdenes_pagoGroupByPayload<T extends ordenes_pagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ordenes_pagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ordenes_pagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ordenes_pagoGroupByOutputType[P]>
            : GetScalarType<T[P], Ordenes_pagoGroupByOutputType[P]>
        }
      >
    >


  export type ordenes_pagoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idorden?: boolean
    fecha?: boolean
    proveedor?: boolean
    cuit_cuil?: boolean
    total?: boolean
    operador_carga?: boolean
    autorizado?: boolean
    operador_autorizacion?: boolean
    fecha_autorizacion?: boolean
    norden?: boolean
    observacion?: boolean
    nombre?: boolean
    tipo_orden?: boolean
    nfactura?: boolean
    tipo_factura?: boolean
    fecha_pago?: boolean
    pagado?: boolean
    estado?: boolean
  }, ExtArgs["result"]["ordenes_pago"]>

  export type ordenes_pagoSelectScalar = {
    idorden?: boolean
    fecha?: boolean
    proveedor?: boolean
    cuit_cuil?: boolean
    total?: boolean
    operador_carga?: boolean
    autorizado?: boolean
    operador_autorizacion?: boolean
    fecha_autorizacion?: boolean
    norden?: boolean
    observacion?: boolean
    nombre?: boolean
    tipo_orden?: boolean
    nfactura?: boolean
    tipo_factura?: boolean
    fecha_pago?: boolean
    pagado?: boolean
    estado?: boolean
  }


  type ordenes_pagoGetPayload<S extends boolean | null | undefined | ordenes_pagoArgs> = $Types.GetResult<ordenes_pagoPayload, S>

  type ordenes_pagoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ordenes_pagoFindManyArgs, 'select' | 'include'> & {
      select?: Ordenes_pagoCountAggregateInputType | true
    }

  export interface ordenes_pagoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ordenes_pago'], meta: { name: 'ordenes_pago' } }
    /**
     * Find zero or one Ordenes_pago that matches the filter.
     * @param {ordenes_pagoFindUniqueArgs} args - Arguments to find a Ordenes_pago
     * @example
     * // Get one Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ordenes_pagoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ordenes_pagoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ordenes_pago'> extends True ? Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ordenes_pago that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ordenes_pagoFindUniqueOrThrowArgs} args - Arguments to find a Ordenes_pago
     * @example
     * // Get one Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ordenes_pagoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ordenes_pagoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ordenes_pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoFindFirstArgs} args - Arguments to find a Ordenes_pago
     * @example
     * // Get one Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ordenes_pagoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ordenes_pagoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ordenes_pago'> extends True ? Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ordenes_pago that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoFindFirstOrThrowArgs} args - Arguments to find a Ordenes_pago
     * @example
     * // Get one Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ordenes_pagoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ordenes_pagoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ordenes_pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ordenes_pagos
     * const ordenes_pagos = await prisma.ordenes_pago.findMany()
     * 
     * // Get first 10 Ordenes_pagos
     * const ordenes_pagos = await prisma.ordenes_pago.findMany({ take: 10 })
     * 
     * // Only select the `idorden`
     * const ordenes_pagoWithIdordenOnly = await prisma.ordenes_pago.findMany({ select: { idorden: true } })
     * 
    **/
    findMany<T extends ordenes_pagoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordenes_pagoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ordenes_pago.
     * @param {ordenes_pagoCreateArgs} args - Arguments to create a Ordenes_pago.
     * @example
     * // Create one Ordenes_pago
     * const Ordenes_pago = await prisma.ordenes_pago.create({
     *   data: {
     *     // ... data to create a Ordenes_pago
     *   }
     * })
     * 
    **/
    create<T extends ordenes_pagoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ordenes_pagoCreateArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ordenes_pagos.
     *     @param {ordenes_pagoCreateManyArgs} args - Arguments to create many Ordenes_pagos.
     *     @example
     *     // Create many Ordenes_pagos
     *     const ordenes_pago = await prisma.ordenes_pago.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ordenes_pagoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordenes_pagoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ordenes_pago.
     * @param {ordenes_pagoDeleteArgs} args - Arguments to delete one Ordenes_pago.
     * @example
     * // Delete one Ordenes_pago
     * const Ordenes_pago = await prisma.ordenes_pago.delete({
     *   where: {
     *     // ... filter to delete one Ordenes_pago
     *   }
     * })
     * 
    **/
    delete<T extends ordenes_pagoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ordenes_pagoDeleteArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ordenes_pago.
     * @param {ordenes_pagoUpdateArgs} args - Arguments to update one Ordenes_pago.
     * @example
     * // Update one Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ordenes_pagoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ordenes_pagoUpdateArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ordenes_pagos.
     * @param {ordenes_pagoDeleteManyArgs} args - Arguments to filter Ordenes_pagos to delete.
     * @example
     * // Delete a few Ordenes_pagos
     * const { count } = await prisma.ordenes_pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ordenes_pagoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ordenes_pagoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ordenes_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ordenes_pagos
     * const ordenes_pago = await prisma.ordenes_pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ordenes_pagoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ordenes_pagoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ordenes_pago.
     * @param {ordenes_pagoUpsertArgs} args - Arguments to update or create a Ordenes_pago.
     * @example
     * // Update or create a Ordenes_pago
     * const ordenes_pago = await prisma.ordenes_pago.upsert({
     *   create: {
     *     // ... data to create a Ordenes_pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ordenes_pago we want to update
     *   }
     * })
    **/
    upsert<T extends ordenes_pagoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ordenes_pagoUpsertArgs<ExtArgs>>
    ): Prisma__ordenes_pagoClient<$Types.GetResult<ordenes_pagoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ordenes_pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoCountArgs} args - Arguments to filter Ordenes_pagos to count.
     * @example
     * // Count the number of Ordenes_pagos
     * const count = await prisma.ordenes_pago.count({
     *   where: {
     *     // ... the filter for the Ordenes_pagos we want to count
     *   }
     * })
    **/
    count<T extends ordenes_pagoCountArgs>(
      args?: Subset<T, ordenes_pagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ordenes_pagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ordenes_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ordenes_pagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ordenes_pagoAggregateArgs>(args: Subset<T, Ordenes_pagoAggregateArgs>): Prisma.PrismaPromise<GetOrdenes_pagoAggregateType<T>>

    /**
     * Group by Ordenes_pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordenes_pagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordenes_pagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordenes_pagoGroupByArgs['orderBy'] }
        : { orderBy?: ordenes_pagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordenes_pagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdenes_pagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ordenes_pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ordenes_pagoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ordenes_pago base type for findUnique actions
   */
  export type ordenes_pagoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter, which ordenes_pago to fetch.
     */
    where: ordenes_pagoWhereUniqueInput
  }

  /**
   * ordenes_pago findUnique
   */
  export interface ordenes_pagoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ordenes_pagoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ordenes_pago findUniqueOrThrow
   */
  export type ordenes_pagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter, which ordenes_pago to fetch.
     */
    where: ordenes_pagoWhereUniqueInput
  }


  /**
   * ordenes_pago base type for findFirst actions
   */
  export type ordenes_pagoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter, which ordenes_pago to fetch.
     */
    where?: ordenes_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_pagos to fetch.
     */
    orderBy?: ordenes_pagoOrderByWithRelationInput | ordenes_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordenes_pagos.
     */
    cursor?: ordenes_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordenes_pagos.
     */
    distinct?: Ordenes_pagoScalarFieldEnum | Ordenes_pagoScalarFieldEnum[]
  }

  /**
   * ordenes_pago findFirst
   */
  export interface ordenes_pagoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ordenes_pagoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ordenes_pago findFirstOrThrow
   */
  export type ordenes_pagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter, which ordenes_pago to fetch.
     */
    where?: ordenes_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_pagos to fetch.
     */
    orderBy?: ordenes_pagoOrderByWithRelationInput | ordenes_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ordenes_pagos.
     */
    cursor?: ordenes_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ordenes_pagos.
     */
    distinct?: Ordenes_pagoScalarFieldEnum | Ordenes_pagoScalarFieldEnum[]
  }


  /**
   * ordenes_pago findMany
   */
  export type ordenes_pagoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter, which ordenes_pagos to fetch.
     */
    where?: ordenes_pagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ordenes_pagos to fetch.
     */
    orderBy?: ordenes_pagoOrderByWithRelationInput | ordenes_pagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ordenes_pagos.
     */
    cursor?: ordenes_pagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ordenes_pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ordenes_pagos.
     */
    skip?: number
    distinct?: Ordenes_pagoScalarFieldEnum | Ordenes_pagoScalarFieldEnum[]
  }


  /**
   * ordenes_pago create
   */
  export type ordenes_pagoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * The data needed to create a ordenes_pago.
     */
    data?: XOR<ordenes_pagoCreateInput, ordenes_pagoUncheckedCreateInput>
  }


  /**
   * ordenes_pago createMany
   */
  export type ordenes_pagoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ordenes_pagos.
     */
    data: ordenes_pagoCreateManyInput | ordenes_pagoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ordenes_pago update
   */
  export type ordenes_pagoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * The data needed to update a ordenes_pago.
     */
    data: XOR<ordenes_pagoUpdateInput, ordenes_pagoUncheckedUpdateInput>
    /**
     * Choose, which ordenes_pago to update.
     */
    where: ordenes_pagoWhereUniqueInput
  }


  /**
   * ordenes_pago updateMany
   */
  export type ordenes_pagoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ordenes_pagos.
     */
    data: XOR<ordenes_pagoUpdateManyMutationInput, ordenes_pagoUncheckedUpdateManyInput>
    /**
     * Filter which ordenes_pagos to update
     */
    where?: ordenes_pagoWhereInput
  }


  /**
   * ordenes_pago upsert
   */
  export type ordenes_pagoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * The filter to search for the ordenes_pago to update in case it exists.
     */
    where: ordenes_pagoWhereUniqueInput
    /**
     * In case the ordenes_pago found by the `where` argument doesn't exist, create a new ordenes_pago with this data.
     */
    create: XOR<ordenes_pagoCreateInput, ordenes_pagoUncheckedCreateInput>
    /**
     * In case the ordenes_pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordenes_pagoUpdateInput, ordenes_pagoUncheckedUpdateInput>
  }


  /**
   * ordenes_pago delete
   */
  export type ordenes_pagoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
    /**
     * Filter which ordenes_pago to delete.
     */
    where: ordenes_pagoWhereUniqueInput
  }


  /**
   * ordenes_pago deleteMany
   */
  export type ordenes_pagoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ordenes_pagos to delete
     */
    where?: ordenes_pagoWhereInput
  }


  /**
   * ordenes_pago without action
   */
  export type ordenes_pagoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ordenes_pago
     */
    select?: ordenes_pagoSelect<ExtArgs> | null
  }



  /**
   * Model personal
   */


  export type AggregatePersonal = {
    _count: PersonalCountAggregateOutputType | null
    _avg: PersonalAvgAggregateOutputType | null
    _sum: PersonalSumAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  export type PersonalAvgAggregateOutputType = {
    idpersonal: number | null
    dni: number | null
  }

  export type PersonalSumAggregateOutputType = {
    idpersonal: number | null
    dni: number | null
  }

  export type PersonalMinAggregateOutputType = {
    idpersonal: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    alta: Date | null
    rol: string | null
    legajo: string | null
    baja: Date | null
  }

  export type PersonalMaxAggregateOutputType = {
    idpersonal: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    alta: Date | null
    rol: string | null
    legajo: string | null
    baja: Date | null
  }

  export type PersonalCountAggregateOutputType = {
    idpersonal: number
    apellido: number
    nombre: number
    dni: number
    alta: number
    rol: number
    legajo: number
    baja: number
    _all: number
  }


  export type PersonalAvgAggregateInputType = {
    idpersonal?: true
    dni?: true
  }

  export type PersonalSumAggregateInputType = {
    idpersonal?: true
    dni?: true
  }

  export type PersonalMinAggregateInputType = {
    idpersonal?: true
    apellido?: true
    nombre?: true
    dni?: true
    alta?: true
    rol?: true
    legajo?: true
    baja?: true
  }

  export type PersonalMaxAggregateInputType = {
    idpersonal?: true
    apellido?: true
    nombre?: true
    dni?: true
    alta?: true
    rol?: true
    legajo?: true
    baja?: true
  }

  export type PersonalCountAggregateInputType = {
    idpersonal?: true
    apellido?: true
    nombre?: true
    dni?: true
    alta?: true
    rol?: true
    legajo?: true
    baja?: true
    _all?: true
  }

  export type PersonalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which personal to aggregate.
     */
    where?: personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personals to fetch.
     */
    orderBy?: personalOrderByWithRelationInput | personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personals
    **/
    _count?: true | PersonalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalMaxAggregateInputType
  }

  export type GetPersonalAggregateType<T extends PersonalAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal[P]>
      : GetScalarType<T[P], AggregatePersonal[P]>
  }




  export type personalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: personalWhereInput
    orderBy?: personalOrderByWithAggregationInput | personalOrderByWithAggregationInput[]
    by: PersonalScalarFieldEnum[] | PersonalScalarFieldEnum
    having?: personalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalCountAggregateInputType | true
    _avg?: PersonalAvgAggregateInputType
    _sum?: PersonalSumAggregateInputType
    _min?: PersonalMinAggregateInputType
    _max?: PersonalMaxAggregateInputType
  }


  export type PersonalGroupByOutputType = {
    idpersonal: number
    apellido: string | null
    nombre: string | null
    dni: number | null
    alta: Date | null
    rol: string | null
    legajo: string | null
    baja: Date | null
    _count: PersonalCountAggregateOutputType | null
    _avg: PersonalAvgAggregateOutputType | null
    _sum: PersonalSumAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  type GetPersonalGroupByPayload<T extends personalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalGroupByOutputType[P]>
        }
      >
    >


  export type personalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpersonal?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    alta?: boolean
    rol?: boolean
    legajo?: boolean
    baja?: boolean
  }, ExtArgs["result"]["personal"]>

  export type personalSelectScalar = {
    idpersonal?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    alta?: boolean
    rol?: boolean
    legajo?: boolean
    baja?: boolean
  }


  type personalGetPayload<S extends boolean | null | undefined | personalArgs> = $Types.GetResult<personalPayload, S>

  type personalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<personalFindManyArgs, 'select' | 'include'> & {
      select?: PersonalCountAggregateInputType | true
    }

  export interface personalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personal'], meta: { name: 'personal' } }
    /**
     * Find zero or one Personal that matches the filter.
     * @param {personalFindUniqueArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'personal'> extends True ? Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {personalFindUniqueOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends personalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, personalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalFindFirstArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'personal'> extends True ? Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalFindFirstOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends personalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, personalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personals
     * const personals = await prisma.personal.findMany()
     * 
     * // Get first 10 Personals
     * const personals = await prisma.personal.findMany({ take: 10 })
     * 
     * // Only select the `idpersonal`
     * const personalWithIdpersonalOnly = await prisma.personal.findMany({ select: { idpersonal: true } })
     * 
    **/
    findMany<T extends personalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<personalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Personal.
     * @param {personalCreateArgs} args - Arguments to create a Personal.
     * @example
     * // Create one Personal
     * const Personal = await prisma.personal.create({
     *   data: {
     *     // ... data to create a Personal
     *   }
     * })
     * 
    **/
    create<T extends personalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, personalCreateArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Personals.
     *     @param {personalCreateManyArgs} args - Arguments to create many Personals.
     *     @example
     *     // Create many Personals
     *     const personal = await prisma.personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personal.
     * @param {personalDeleteArgs} args - Arguments to delete one Personal.
     * @example
     * // Delete one Personal
     * const Personal = await prisma.personal.delete({
     *   where: {
     *     // ... filter to delete one Personal
     *   }
     * })
     * 
    **/
    delete<T extends personalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, personalDeleteArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Personal.
     * @param {personalUpdateArgs} args - Arguments to update one Personal.
     * @example
     * // Update one Personal
     * const personal = await prisma.personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, personalUpdateArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Personals.
     * @param {personalDeleteManyArgs} args - Arguments to filter Personals to delete.
     * @example
     * // Delete a few Personals
     * const { count } = await prisma.personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, personalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personals
     * const personal = await prisma.personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, personalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal.
     * @param {personalUpsertArgs} args - Arguments to update or create a Personal.
     * @example
     * // Update or create a Personal
     * const personal = await prisma.personal.upsert({
     *   create: {
     *     // ... data to create a Personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal we want to update
     *   }
     * })
    **/
    upsert<T extends personalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, personalUpsertArgs<ExtArgs>>
    ): Prisma__personalClient<$Types.GetResult<personalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalCountArgs} args - Arguments to filter Personals to count.
     * @example
     * // Count the number of Personals
     * const count = await prisma.personal.count({
     *   where: {
     *     // ... the filter for the Personals we want to count
     *   }
     * })
    **/
    count<T extends personalCountArgs>(
      args?: Subset<T, personalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalAggregateArgs>(args: Subset<T, PersonalAggregateArgs>): Prisma.PrismaPromise<GetPersonalAggregateType<T>>

    /**
     * Group by Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personalGroupByArgs['orderBy'] }
        : { orderBy?: personalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * personal base type for findUnique actions
   */
  export type personalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter, which personal to fetch.
     */
    where: personalWhereUniqueInput
  }

  /**
   * personal findUnique
   */
  export interface personalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends personalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personal findUniqueOrThrow
   */
  export type personalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter, which personal to fetch.
     */
    where: personalWhereUniqueInput
  }


  /**
   * personal base type for findFirst actions
   */
  export type personalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter, which personal to fetch.
     */
    where?: personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personals to fetch.
     */
    orderBy?: personalOrderByWithRelationInput | personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personals.
     */
    cursor?: personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personals.
     */
    distinct?: PersonalScalarFieldEnum | PersonalScalarFieldEnum[]
  }

  /**
   * personal findFirst
   */
  export interface personalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends personalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personal findFirstOrThrow
   */
  export type personalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter, which personal to fetch.
     */
    where?: personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personals to fetch.
     */
    orderBy?: personalOrderByWithRelationInput | personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personals.
     */
    cursor?: personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personals.
     */
    distinct?: PersonalScalarFieldEnum | PersonalScalarFieldEnum[]
  }


  /**
   * personal findMany
   */
  export type personalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter, which personals to fetch.
     */
    where?: personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personals to fetch.
     */
    orderBy?: personalOrderByWithRelationInput | personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personals.
     */
    cursor?: personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personals.
     */
    skip?: number
    distinct?: PersonalScalarFieldEnum | PersonalScalarFieldEnum[]
  }


  /**
   * personal create
   */
  export type personalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * The data needed to create a personal.
     */
    data?: XOR<personalCreateInput, personalUncheckedCreateInput>
  }


  /**
   * personal createMany
   */
  export type personalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personals.
     */
    data: personalCreateManyInput | personalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * personal update
   */
  export type personalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * The data needed to update a personal.
     */
    data: XOR<personalUpdateInput, personalUncheckedUpdateInput>
    /**
     * Choose, which personal to update.
     */
    where: personalWhereUniqueInput
  }


  /**
   * personal updateMany
   */
  export type personalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personals.
     */
    data: XOR<personalUpdateManyMutationInput, personalUncheckedUpdateManyInput>
    /**
     * Filter which personals to update
     */
    where?: personalWhereInput
  }


  /**
   * personal upsert
   */
  export type personalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * The filter to search for the personal to update in case it exists.
     */
    where: personalWhereUniqueInput
    /**
     * In case the personal found by the `where` argument doesn't exist, create a new personal with this data.
     */
    create: XOR<personalCreateInput, personalUncheckedCreateInput>
    /**
     * In case the personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personalUpdateInput, personalUncheckedUpdateInput>
  }


  /**
   * personal delete
   */
  export type personalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
    /**
     * Filter which personal to delete.
     */
    where: personalWhereUniqueInput
  }


  /**
   * personal deleteMany
   */
  export type personalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which personals to delete
     */
    where?: personalWhereInput
  }


  /**
   * personal without action
   */
  export type personalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personal
     */
    select?: personalSelect<ExtArgs> | null
  }



  /**
   * Model plan_cuentas
   */


  export type AggregatePlan_cuentas = {
    _count: Plan_cuentasCountAggregateOutputType | null
    _avg: Plan_cuentasAvgAggregateOutputType | null
    _sum: Plan_cuentasSumAggregateOutputType | null
    _min: Plan_cuentasMinAggregateOutputType | null
    _max: Plan_cuentasMaxAggregateOutputType | null
  }

  export type Plan_cuentasAvgAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    asiento: number | null
  }

  export type Plan_cuentasSumAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    asiento: number | null
  }

  export type Plan_cuentasMinAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }

  export type Plan_cuentasMaxAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }

  export type Plan_cuentasCountAggregateOutputType = {
    idcuenta: number
    idempresa: number
    codigo: number
    descripcion: number
    asiento: number
    tipo: number
    _all: number
  }


  export type Plan_cuentasAvgAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    asiento?: true
  }

  export type Plan_cuentasSumAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    asiento?: true
  }

  export type Plan_cuentasMinAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
  }

  export type Plan_cuentasMaxAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
  }

  export type Plan_cuentasCountAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
    _all?: true
  }

  export type Plan_cuentasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_cuentas to aggregate.
     */
    where?: plan_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas to fetch.
     */
    orderBy?: plan_cuentasOrderByWithRelationInput | plan_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_cuentas
    **/
    _count?: true | Plan_cuentasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_cuentasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_cuentasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_cuentasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_cuentasMaxAggregateInputType
  }

  export type GetPlan_cuentasAggregateType<T extends Plan_cuentasAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_cuentas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_cuentas[P]>
      : GetScalarType<T[P], AggregatePlan_cuentas[P]>
  }




  export type plan_cuentasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: plan_cuentasWhereInput
    orderBy?: plan_cuentasOrderByWithAggregationInput | plan_cuentasOrderByWithAggregationInput[]
    by: Plan_cuentasScalarFieldEnum[] | Plan_cuentasScalarFieldEnum
    having?: plan_cuentasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_cuentasCountAggregateInputType | true
    _avg?: Plan_cuentasAvgAggregateInputType
    _sum?: Plan_cuentasSumAggregateInputType
    _min?: Plan_cuentasMinAggregateInputType
    _max?: Plan_cuentasMaxAggregateInputType
  }


  export type Plan_cuentasGroupByOutputType = {
    idcuenta: number
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
    _count: Plan_cuentasCountAggregateOutputType | null
    _avg: Plan_cuentasAvgAggregateOutputType | null
    _sum: Plan_cuentasSumAggregateOutputType | null
    _min: Plan_cuentasMinAggregateOutputType | null
    _max: Plan_cuentasMaxAggregateOutputType | null
  }

  type GetPlan_cuentasGroupByPayload<T extends plan_cuentasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_cuentasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_cuentasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_cuentasGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_cuentasGroupByOutputType[P]>
        }
      >
    >


  export type plan_cuentasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcuenta?: boolean
    idempresa?: boolean
    codigo?: boolean
    descripcion?: boolean
    asiento?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["plan_cuentas"]>

  export type plan_cuentasSelectScalar = {
    idcuenta?: boolean
    idempresa?: boolean
    codigo?: boolean
    descripcion?: boolean
    asiento?: boolean
    tipo?: boolean
  }


  type plan_cuentasGetPayload<S extends boolean | null | undefined | plan_cuentasArgs> = $Types.GetResult<plan_cuentasPayload, S>

  type plan_cuentasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<plan_cuentasFindManyArgs, 'select' | 'include'> & {
      select?: Plan_cuentasCountAggregateInputType | true
    }

  export interface plan_cuentasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_cuentas'], meta: { name: 'plan_cuentas' } }
    /**
     * Find zero or one Plan_cuentas that matches the filter.
     * @param {plan_cuentasFindUniqueArgs} args - Arguments to find a Plan_cuentas
     * @example
     * // Get one Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plan_cuentasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plan_cuentasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plan_cuentas'> extends True ? Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Plan_cuentas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {plan_cuentasFindUniqueOrThrowArgs} args - Arguments to find a Plan_cuentas
     * @example
     * // Get one Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plan_cuentasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Plan_cuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasFindFirstArgs} args - Arguments to find a Plan_cuentas
     * @example
     * // Get one Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plan_cuentasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plan_cuentasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plan_cuentas'> extends True ? Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Plan_cuentas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasFindFirstOrThrowArgs} args - Arguments to find a Plan_cuentas
     * @example
     * // Get one Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plan_cuentasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Plan_cuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findMany()
     * 
     * // Get first 10 Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.findMany({ take: 10 })
     * 
     * // Only select the `idcuenta`
     * const plan_cuentasWithIdcuentaOnly = await prisma.plan_cuentas.findMany({ select: { idcuenta: true } })
     * 
    **/
    findMany<T extends plan_cuentasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Plan_cuentas.
     * @param {plan_cuentasCreateArgs} args - Arguments to create a Plan_cuentas.
     * @example
     * // Create one Plan_cuentas
     * const Plan_cuentas = await prisma.plan_cuentas.create({
     *   data: {
     *     // ... data to create a Plan_cuentas
     *   }
     * })
     * 
    **/
    create<T extends plan_cuentasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentasCreateArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Plan_cuentas.
     *     @param {plan_cuentasCreateManyArgs} args - Arguments to create many Plan_cuentas.
     *     @example
     *     // Create many Plan_cuentas
     *     const plan_cuentas = await prisma.plan_cuentas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plan_cuentasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_cuentas.
     * @param {plan_cuentasDeleteArgs} args - Arguments to delete one Plan_cuentas.
     * @example
     * // Delete one Plan_cuentas
     * const Plan_cuentas = await prisma.plan_cuentas.delete({
     *   where: {
     *     // ... filter to delete one Plan_cuentas
     *   }
     * })
     * 
    **/
    delete<T extends plan_cuentasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentasDeleteArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Plan_cuentas.
     * @param {plan_cuentasUpdateArgs} args - Arguments to update one Plan_cuentas.
     * @example
     * // Update one Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plan_cuentasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentasUpdateArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Plan_cuentas.
     * @param {plan_cuentasDeleteManyArgs} args - Arguments to filter Plan_cuentas to delete.
     * @example
     * // Delete a few Plan_cuentas
     * const { count } = await prisma.plan_cuentas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plan_cuentasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plan_cuentasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_cuentas.
     * @param {plan_cuentasUpsertArgs} args - Arguments to update or create a Plan_cuentas.
     * @example
     * // Update or create a Plan_cuentas
     * const plan_cuentas = await prisma.plan_cuentas.upsert({
     *   create: {
     *     // ... data to create a Plan_cuentas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_cuentas we want to update
     *   }
     * })
    **/
    upsert<T extends plan_cuentasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentasUpsertArgs<ExtArgs>>
    ): Prisma__plan_cuentasClient<$Types.GetResult<plan_cuentasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Plan_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasCountArgs} args - Arguments to filter Plan_cuentas to count.
     * @example
     * // Count the number of Plan_cuentas
     * const count = await prisma.plan_cuentas.count({
     *   where: {
     *     // ... the filter for the Plan_cuentas we want to count
     *   }
     * })
    **/
    count<T extends plan_cuentasCountArgs>(
      args?: Subset<T, plan_cuentasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_cuentasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_cuentasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_cuentasAggregateArgs>(args: Subset<T, Plan_cuentasAggregateArgs>): Prisma.PrismaPromise<GetPlan_cuentasAggregateType<T>>

    /**
     * Group by Plan_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_cuentasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_cuentasGroupByArgs['orderBy'] }
        : { orderBy?: plan_cuentasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_cuentasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_cuentasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_cuentas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plan_cuentasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plan_cuentas base type for findUnique actions
   */
  export type plan_cuentasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas to fetch.
     */
    where: plan_cuentasWhereUniqueInput
  }

  /**
   * plan_cuentas findUnique
   */
  export interface plan_cuentasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_cuentasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_cuentas findUniqueOrThrow
   */
  export type plan_cuentasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas to fetch.
     */
    where: plan_cuentasWhereUniqueInput
  }


  /**
   * plan_cuentas base type for findFirst actions
   */
  export type plan_cuentasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas to fetch.
     */
    where?: plan_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas to fetch.
     */
    orderBy?: plan_cuentasOrderByWithRelationInput | plan_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_cuentas.
     */
    cursor?: plan_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_cuentas.
     */
    distinct?: Plan_cuentasScalarFieldEnum | Plan_cuentasScalarFieldEnum[]
  }

  /**
   * plan_cuentas findFirst
   */
  export interface plan_cuentasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_cuentasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_cuentas findFirstOrThrow
   */
  export type plan_cuentasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas to fetch.
     */
    where?: plan_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas to fetch.
     */
    orderBy?: plan_cuentasOrderByWithRelationInput | plan_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_cuentas.
     */
    cursor?: plan_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_cuentas.
     */
    distinct?: Plan_cuentasScalarFieldEnum | Plan_cuentasScalarFieldEnum[]
  }


  /**
   * plan_cuentas findMany
   */
  export type plan_cuentasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas to fetch.
     */
    where?: plan_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas to fetch.
     */
    orderBy?: plan_cuentasOrderByWithRelationInput | plan_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_cuentas.
     */
    cursor?: plan_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas.
     */
    skip?: number
    distinct?: Plan_cuentasScalarFieldEnum | Plan_cuentasScalarFieldEnum[]
  }


  /**
   * plan_cuentas create
   */
  export type plan_cuentasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * The data needed to create a plan_cuentas.
     */
    data?: XOR<plan_cuentasCreateInput, plan_cuentasUncheckedCreateInput>
  }


  /**
   * plan_cuentas createMany
   */
  export type plan_cuentasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_cuentas.
     */
    data: plan_cuentasCreateManyInput | plan_cuentasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * plan_cuentas update
   */
  export type plan_cuentasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * The data needed to update a plan_cuentas.
     */
    data: XOR<plan_cuentasUpdateInput, plan_cuentasUncheckedUpdateInput>
    /**
     * Choose, which plan_cuentas to update.
     */
    where: plan_cuentasWhereUniqueInput
  }


  /**
   * plan_cuentas updateMany
   */
  export type plan_cuentasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_cuentas.
     */
    data: XOR<plan_cuentasUpdateManyMutationInput, plan_cuentasUncheckedUpdateManyInput>
    /**
     * Filter which plan_cuentas to update
     */
    where?: plan_cuentasWhereInput
  }


  /**
   * plan_cuentas upsert
   */
  export type plan_cuentasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * The filter to search for the plan_cuentas to update in case it exists.
     */
    where: plan_cuentasWhereUniqueInput
    /**
     * In case the plan_cuentas found by the `where` argument doesn't exist, create a new plan_cuentas with this data.
     */
    create: XOR<plan_cuentasCreateInput, plan_cuentasUncheckedCreateInput>
    /**
     * In case the plan_cuentas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_cuentasUpdateInput, plan_cuentasUncheckedUpdateInput>
  }


  /**
   * plan_cuentas delete
   */
  export type plan_cuentasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
    /**
     * Filter which plan_cuentas to delete.
     */
    where: plan_cuentasWhereUniqueInput
  }


  /**
   * plan_cuentas deleteMany
   */
  export type plan_cuentasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_cuentas to delete
     */
    where?: plan_cuentasWhereInput
  }


  /**
   * plan_cuentas without action
   */
  export type plan_cuentasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas
     */
    select?: plan_cuentasSelect<ExtArgs> | null
  }



  /**
   * Model plan_cuentas_x
   */


  export type AggregatePlan_cuentas_x = {
    _count: Plan_cuentas_xCountAggregateOutputType | null
    _avg: Plan_cuentas_xAvgAggregateOutputType | null
    _sum: Plan_cuentas_xSumAggregateOutputType | null
    _min: Plan_cuentas_xMinAggregateOutputType | null
    _max: Plan_cuentas_xMaxAggregateOutputType | null
  }

  export type Plan_cuentas_xAvgAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    asiento: number | null
  }

  export type Plan_cuentas_xSumAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    asiento: number | null
  }

  export type Plan_cuentas_xMinAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }

  export type Plan_cuentas_xMaxAggregateOutputType = {
    idcuenta: number | null
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
  }

  export type Plan_cuentas_xCountAggregateOutputType = {
    idcuenta: number
    idempresa: number
    codigo: number
    descripcion: number
    asiento: number
    tipo: number
    _all: number
  }


  export type Plan_cuentas_xAvgAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    asiento?: true
  }

  export type Plan_cuentas_xSumAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    asiento?: true
  }

  export type Plan_cuentas_xMinAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
  }

  export type Plan_cuentas_xMaxAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
  }

  export type Plan_cuentas_xCountAggregateInputType = {
    idcuenta?: true
    idempresa?: true
    codigo?: true
    descripcion?: true
    asiento?: true
    tipo?: true
    _all?: true
  }

  export type Plan_cuentas_xAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_cuentas_x to aggregate.
     */
    where?: plan_cuentas_xWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas_xes to fetch.
     */
    orderBy?: plan_cuentas_xOrderByWithRelationInput | plan_cuentas_xOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_cuentas_xWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas_xes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas_xes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_cuentas_xes
    **/
    _count?: true | Plan_cuentas_xCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_cuentas_xAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_cuentas_xSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_cuentas_xMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_cuentas_xMaxAggregateInputType
  }

  export type GetPlan_cuentas_xAggregateType<T extends Plan_cuentas_xAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_cuentas_x]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_cuentas_x[P]>
      : GetScalarType<T[P], AggregatePlan_cuentas_x[P]>
  }




  export type plan_cuentas_xGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: plan_cuentas_xWhereInput
    orderBy?: plan_cuentas_xOrderByWithAggregationInput | plan_cuentas_xOrderByWithAggregationInput[]
    by: Plan_cuentas_xScalarFieldEnum[] | Plan_cuentas_xScalarFieldEnum
    having?: plan_cuentas_xScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_cuentas_xCountAggregateInputType | true
    _avg?: Plan_cuentas_xAvgAggregateInputType
    _sum?: Plan_cuentas_xSumAggregateInputType
    _min?: Plan_cuentas_xMinAggregateInputType
    _max?: Plan_cuentas_xMaxAggregateInputType
  }


  export type Plan_cuentas_xGroupByOutputType = {
    idcuenta: number
    idempresa: number | null
    codigo: number | null
    descripcion: string | null
    asiento: number | null
    tipo: string | null
    _count: Plan_cuentas_xCountAggregateOutputType | null
    _avg: Plan_cuentas_xAvgAggregateOutputType | null
    _sum: Plan_cuentas_xSumAggregateOutputType | null
    _min: Plan_cuentas_xMinAggregateOutputType | null
    _max: Plan_cuentas_xMaxAggregateOutputType | null
  }

  type GetPlan_cuentas_xGroupByPayload<T extends plan_cuentas_xGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_cuentas_xGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_cuentas_xGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_cuentas_xGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_cuentas_xGroupByOutputType[P]>
        }
      >
    >


  export type plan_cuentas_xSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcuenta?: boolean
    idempresa?: boolean
    codigo?: boolean
    descripcion?: boolean
    asiento?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["plan_cuentas_x"]>

  export type plan_cuentas_xSelectScalar = {
    idcuenta?: boolean
    idempresa?: boolean
    codigo?: boolean
    descripcion?: boolean
    asiento?: boolean
    tipo?: boolean
  }


  type plan_cuentas_xGetPayload<S extends boolean | null | undefined | plan_cuentas_xArgs> = $Types.GetResult<plan_cuentas_xPayload, S>

  type plan_cuentas_xCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<plan_cuentas_xFindManyArgs, 'select' | 'include'> & {
      select?: Plan_cuentas_xCountAggregateInputType | true
    }

  export interface plan_cuentas_xDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_cuentas_x'], meta: { name: 'plan_cuentas_x' } }
    /**
     * Find zero or one Plan_cuentas_x that matches the filter.
     * @param {plan_cuentas_xFindUniqueArgs} args - Arguments to find a Plan_cuentas_x
     * @example
     * // Get one Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plan_cuentas_xFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plan_cuentas_xFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plan_cuentas_x'> extends True ? Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Plan_cuentas_x that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {plan_cuentas_xFindUniqueOrThrowArgs} args - Arguments to find a Plan_cuentas_x
     * @example
     * // Get one Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plan_cuentas_xFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentas_xFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Plan_cuentas_x that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xFindFirstArgs} args - Arguments to find a Plan_cuentas_x
     * @example
     * // Get one Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plan_cuentas_xFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plan_cuentas_xFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plan_cuentas_x'> extends True ? Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Plan_cuentas_x that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xFindFirstOrThrowArgs} args - Arguments to find a Plan_cuentas_x
     * @example
     * // Get one Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plan_cuentas_xFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentas_xFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Plan_cuentas_xes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_cuentas_xes
     * const plan_cuentas_xes = await prisma.plan_cuentas_x.findMany()
     * 
     * // Get first 10 Plan_cuentas_xes
     * const plan_cuentas_xes = await prisma.plan_cuentas_x.findMany({ take: 10 })
     * 
     * // Only select the `idcuenta`
     * const plan_cuentas_xWithIdcuentaOnly = await prisma.plan_cuentas_x.findMany({ select: { idcuenta: true } })
     * 
    **/
    findMany<T extends plan_cuentas_xFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentas_xFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Plan_cuentas_x.
     * @param {plan_cuentas_xCreateArgs} args - Arguments to create a Plan_cuentas_x.
     * @example
     * // Create one Plan_cuentas_x
     * const Plan_cuentas_x = await prisma.plan_cuentas_x.create({
     *   data: {
     *     // ... data to create a Plan_cuentas_x
     *   }
     * })
     * 
    **/
    create<T extends plan_cuentas_xCreateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentas_xCreateArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Plan_cuentas_xes.
     *     @param {plan_cuentas_xCreateManyArgs} args - Arguments to create many Plan_cuentas_xes.
     *     @example
     *     // Create many Plan_cuentas_xes
     *     const plan_cuentas_x = await prisma.plan_cuentas_x.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plan_cuentas_xCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentas_xCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_cuentas_x.
     * @param {plan_cuentas_xDeleteArgs} args - Arguments to delete one Plan_cuentas_x.
     * @example
     * // Delete one Plan_cuentas_x
     * const Plan_cuentas_x = await prisma.plan_cuentas_x.delete({
     *   where: {
     *     // ... filter to delete one Plan_cuentas_x
     *   }
     * })
     * 
    **/
    delete<T extends plan_cuentas_xDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentas_xDeleteArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Plan_cuentas_x.
     * @param {plan_cuentas_xUpdateArgs} args - Arguments to update one Plan_cuentas_x.
     * @example
     * // Update one Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plan_cuentas_xUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentas_xUpdateArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Plan_cuentas_xes.
     * @param {plan_cuentas_xDeleteManyArgs} args - Arguments to filter Plan_cuentas_xes to delete.
     * @example
     * // Delete a few Plan_cuentas_xes
     * const { count } = await prisma.plan_cuentas_x.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plan_cuentas_xDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_cuentas_xDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_cuentas_xes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_cuentas_xes
     * const plan_cuentas_x = await prisma.plan_cuentas_x.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plan_cuentas_xUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentas_xUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_cuentas_x.
     * @param {plan_cuentas_xUpsertArgs} args - Arguments to update or create a Plan_cuentas_x.
     * @example
     * // Update or create a Plan_cuentas_x
     * const plan_cuentas_x = await prisma.plan_cuentas_x.upsert({
     *   create: {
     *     // ... data to create a Plan_cuentas_x
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_cuentas_x we want to update
     *   }
     * })
    **/
    upsert<T extends plan_cuentas_xUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, plan_cuentas_xUpsertArgs<ExtArgs>>
    ): Prisma__plan_cuentas_xClient<$Types.GetResult<plan_cuentas_xPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Plan_cuentas_xes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xCountArgs} args - Arguments to filter Plan_cuentas_xes to count.
     * @example
     * // Count the number of Plan_cuentas_xes
     * const count = await prisma.plan_cuentas_x.count({
     *   where: {
     *     // ... the filter for the Plan_cuentas_xes we want to count
     *   }
     * })
    **/
    count<T extends plan_cuentas_xCountArgs>(
      args?: Subset<T, plan_cuentas_xCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_cuentas_xCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_cuentas_x.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_cuentas_xAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_cuentas_xAggregateArgs>(args: Subset<T, Plan_cuentas_xAggregateArgs>): Prisma.PrismaPromise<GetPlan_cuentas_xAggregateType<T>>

    /**
     * Group by Plan_cuentas_x.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_cuentas_xGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_cuentas_xGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_cuentas_xGroupByArgs['orderBy'] }
        : { orderBy?: plan_cuentas_xGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_cuentas_xGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_cuentas_xGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_cuentas_x.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plan_cuentas_xClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plan_cuentas_x base type for findUnique actions
   */
  export type plan_cuentas_xFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas_x to fetch.
     */
    where: plan_cuentas_xWhereUniqueInput
  }

  /**
   * plan_cuentas_x findUnique
   */
  export interface plan_cuentas_xFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_cuentas_xFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_cuentas_x findUniqueOrThrow
   */
  export type plan_cuentas_xFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas_x to fetch.
     */
    where: plan_cuentas_xWhereUniqueInput
  }


  /**
   * plan_cuentas_x base type for findFirst actions
   */
  export type plan_cuentas_xFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas_x to fetch.
     */
    where?: plan_cuentas_xWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas_xes to fetch.
     */
    orderBy?: plan_cuentas_xOrderByWithRelationInput | plan_cuentas_xOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_cuentas_xes.
     */
    cursor?: plan_cuentas_xWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas_xes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas_xes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_cuentas_xes.
     */
    distinct?: Plan_cuentas_xScalarFieldEnum | Plan_cuentas_xScalarFieldEnum[]
  }

  /**
   * plan_cuentas_x findFirst
   */
  export interface plan_cuentas_xFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_cuentas_xFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_cuentas_x findFirstOrThrow
   */
  export type plan_cuentas_xFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas_x to fetch.
     */
    where?: plan_cuentas_xWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas_xes to fetch.
     */
    orderBy?: plan_cuentas_xOrderByWithRelationInput | plan_cuentas_xOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_cuentas_xes.
     */
    cursor?: plan_cuentas_xWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas_xes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas_xes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_cuentas_xes.
     */
    distinct?: Plan_cuentas_xScalarFieldEnum | Plan_cuentas_xScalarFieldEnum[]
  }


  /**
   * plan_cuentas_x findMany
   */
  export type plan_cuentas_xFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter, which plan_cuentas_xes to fetch.
     */
    where?: plan_cuentas_xWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_cuentas_xes to fetch.
     */
    orderBy?: plan_cuentas_xOrderByWithRelationInput | plan_cuentas_xOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_cuentas_xes.
     */
    cursor?: plan_cuentas_xWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_cuentas_xes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_cuentas_xes.
     */
    skip?: number
    distinct?: Plan_cuentas_xScalarFieldEnum | Plan_cuentas_xScalarFieldEnum[]
  }


  /**
   * plan_cuentas_x create
   */
  export type plan_cuentas_xCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * The data needed to create a plan_cuentas_x.
     */
    data?: XOR<plan_cuentas_xCreateInput, plan_cuentas_xUncheckedCreateInput>
  }


  /**
   * plan_cuentas_x createMany
   */
  export type plan_cuentas_xCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_cuentas_xes.
     */
    data: plan_cuentas_xCreateManyInput | plan_cuentas_xCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * plan_cuentas_x update
   */
  export type plan_cuentas_xUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * The data needed to update a plan_cuentas_x.
     */
    data: XOR<plan_cuentas_xUpdateInput, plan_cuentas_xUncheckedUpdateInput>
    /**
     * Choose, which plan_cuentas_x to update.
     */
    where: plan_cuentas_xWhereUniqueInput
  }


  /**
   * plan_cuentas_x updateMany
   */
  export type plan_cuentas_xUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_cuentas_xes.
     */
    data: XOR<plan_cuentas_xUpdateManyMutationInput, plan_cuentas_xUncheckedUpdateManyInput>
    /**
     * Filter which plan_cuentas_xes to update
     */
    where?: plan_cuentas_xWhereInput
  }


  /**
   * plan_cuentas_x upsert
   */
  export type plan_cuentas_xUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * The filter to search for the plan_cuentas_x to update in case it exists.
     */
    where: plan_cuentas_xWhereUniqueInput
    /**
     * In case the plan_cuentas_x found by the `where` argument doesn't exist, create a new plan_cuentas_x with this data.
     */
    create: XOR<plan_cuentas_xCreateInput, plan_cuentas_xUncheckedCreateInput>
    /**
     * In case the plan_cuentas_x was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_cuentas_xUpdateInput, plan_cuentas_xUncheckedUpdateInput>
  }


  /**
   * plan_cuentas_x delete
   */
  export type plan_cuentas_xDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
    /**
     * Filter which plan_cuentas_x to delete.
     */
    where: plan_cuentas_xWhereUniqueInput
  }


  /**
   * plan_cuentas_x deleteMany
   */
  export type plan_cuentas_xDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_cuentas_xes to delete
     */
    where?: plan_cuentas_xWhereInput
  }


  /**
   * plan_cuentas_x without action
   */
  export type plan_cuentas_xArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_cuentas_x
     */
    select?: plan_cuentas_xSelect<ExtArgs> | null
  }



  /**
   * Model plan_detalle
   */


  export type AggregatePlan_detalle = {
    _count: Plan_detalleCountAggregateOutputType | null
    _avg: Plan_detalleAvgAggregateOutputType | null
    _sum: Plan_detalleSumAggregateOutputType | null
    _min: Plan_detalleMinAggregateOutputType | null
    _max: Plan_detalleMaxAggregateOutputType | null
  }

  export type Plan_detalleAvgAggregateOutputType = {
    id_plandetalle: number | null
    cuota: number | null
    id_plan: number | null
  }

  export type Plan_detalleSumAggregateOutputType = {
    id_plandetalle: number | null
    cuota: number | null
    id_plan: number | null
  }

  export type Plan_detalleMinAggregateOutputType = {
    id_plandetalle: number | null
    detalle: string | null
    cuota: number | null
    sub_ext: boolean | null
    vigencia: string | null
    id_plan: number | null
  }

  export type Plan_detalleMaxAggregateOutputType = {
    id_plandetalle: number | null
    detalle: string | null
    cuota: number | null
    sub_ext: boolean | null
    vigencia: string | null
    id_plan: number | null
  }

  export type Plan_detalleCountAggregateOutputType = {
    id_plandetalle: number
    detalle: number
    cuota: number
    sub_ext: number
    vigencia: number
    id_plan: number
    _all: number
  }


  export type Plan_detalleAvgAggregateInputType = {
    id_plandetalle?: true
    cuota?: true
    id_plan?: true
  }

  export type Plan_detalleSumAggregateInputType = {
    id_plandetalle?: true
    cuota?: true
    id_plan?: true
  }

  export type Plan_detalleMinAggregateInputType = {
    id_plandetalle?: true
    detalle?: true
    cuota?: true
    sub_ext?: true
    vigencia?: true
    id_plan?: true
  }

  export type Plan_detalleMaxAggregateInputType = {
    id_plandetalle?: true
    detalle?: true
    cuota?: true
    sub_ext?: true
    vigencia?: true
    id_plan?: true
  }

  export type Plan_detalleCountAggregateInputType = {
    id_plandetalle?: true
    detalle?: true
    cuota?: true
    sub_ext?: true
    vigencia?: true
    id_plan?: true
    _all?: true
  }

  export type Plan_detalleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_detalle to aggregate.
     */
    where?: plan_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_detalles to fetch.
     */
    orderBy?: plan_detalleOrderByWithRelationInput | plan_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_detalles
    **/
    _count?: true | Plan_detalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_detalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_detalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_detalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_detalleMaxAggregateInputType
  }

  export type GetPlan_detalleAggregateType<T extends Plan_detalleAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_detalle[P]>
      : GetScalarType<T[P], AggregatePlan_detalle[P]>
  }




  export type plan_detalleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: plan_detalleWhereInput
    orderBy?: plan_detalleOrderByWithAggregationInput | plan_detalleOrderByWithAggregationInput[]
    by: Plan_detalleScalarFieldEnum[] | Plan_detalleScalarFieldEnum
    having?: plan_detalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_detalleCountAggregateInputType | true
    _avg?: Plan_detalleAvgAggregateInputType
    _sum?: Plan_detalleSumAggregateInputType
    _min?: Plan_detalleMinAggregateInputType
    _max?: Plan_detalleMaxAggregateInputType
  }


  export type Plan_detalleGroupByOutputType = {
    id_plandetalle: number
    detalle: string | null
    cuota: number | null
    sub_ext: boolean | null
    vigencia: string | null
    id_plan: number | null
    _count: Plan_detalleCountAggregateOutputType | null
    _avg: Plan_detalleAvgAggregateOutputType | null
    _sum: Plan_detalleSumAggregateOutputType | null
    _min: Plan_detalleMinAggregateOutputType | null
    _max: Plan_detalleMaxAggregateOutputType | null
  }

  type GetPlan_detalleGroupByPayload<T extends plan_detalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_detalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_detalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_detalleGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_detalleGroupByOutputType[P]>
        }
      >
    >


  export type plan_detalleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_plandetalle?: boolean
    detalle?: boolean
    cuota?: boolean
    sub_ext?: boolean
    vigencia?: boolean
    id_plan?: boolean
  }, ExtArgs["result"]["plan_detalle"]>

  export type plan_detalleSelectScalar = {
    id_plandetalle?: boolean
    detalle?: boolean
    cuota?: boolean
    sub_ext?: boolean
    vigencia?: boolean
    id_plan?: boolean
  }


  type plan_detalleGetPayload<S extends boolean | null | undefined | plan_detalleArgs> = $Types.GetResult<plan_detallePayload, S>

  type plan_detalleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<plan_detalleFindManyArgs, 'select' | 'include'> & {
      select?: Plan_detalleCountAggregateInputType | true
    }

  export interface plan_detalleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_detalle'], meta: { name: 'plan_detalle' } }
    /**
     * Find zero or one Plan_detalle that matches the filter.
     * @param {plan_detalleFindUniqueArgs} args - Arguments to find a Plan_detalle
     * @example
     * // Get one Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plan_detalleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plan_detalleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plan_detalle'> extends True ? Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Plan_detalle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {plan_detalleFindUniqueOrThrowArgs} args - Arguments to find a Plan_detalle
     * @example
     * // Get one Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plan_detalleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_detalleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Plan_detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleFindFirstArgs} args - Arguments to find a Plan_detalle
     * @example
     * // Get one Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plan_detalleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plan_detalleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plan_detalle'> extends True ? Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Plan_detalle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleFindFirstOrThrowArgs} args - Arguments to find a Plan_detalle
     * @example
     * // Get one Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plan_detalleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_detalleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Plan_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_detalles
     * const plan_detalles = await prisma.plan_detalle.findMany()
     * 
     * // Get first 10 Plan_detalles
     * const plan_detalles = await prisma.plan_detalle.findMany({ take: 10 })
     * 
     * // Only select the `id_plandetalle`
     * const plan_detalleWithId_plandetalleOnly = await prisma.plan_detalle.findMany({ select: { id_plandetalle: true } })
     * 
    **/
    findMany<T extends plan_detalleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_detalleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Plan_detalle.
     * @param {plan_detalleCreateArgs} args - Arguments to create a Plan_detalle.
     * @example
     * // Create one Plan_detalle
     * const Plan_detalle = await prisma.plan_detalle.create({
     *   data: {
     *     // ... data to create a Plan_detalle
     *   }
     * })
     * 
    **/
    create<T extends plan_detalleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_detalleCreateArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Plan_detalles.
     *     @param {plan_detalleCreateManyArgs} args - Arguments to create many Plan_detalles.
     *     @example
     *     // Create many Plan_detalles
     *     const plan_detalle = await prisma.plan_detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plan_detalleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_detalleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_detalle.
     * @param {plan_detalleDeleteArgs} args - Arguments to delete one Plan_detalle.
     * @example
     * // Delete one Plan_detalle
     * const Plan_detalle = await prisma.plan_detalle.delete({
     *   where: {
     *     // ... filter to delete one Plan_detalle
     *   }
     * })
     * 
    **/
    delete<T extends plan_detalleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, plan_detalleDeleteArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Plan_detalle.
     * @param {plan_detalleUpdateArgs} args - Arguments to update one Plan_detalle.
     * @example
     * // Update one Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plan_detalleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_detalleUpdateArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Plan_detalles.
     * @param {plan_detalleDeleteManyArgs} args - Arguments to filter Plan_detalles to delete.
     * @example
     * // Delete a few Plan_detalles
     * const { count } = await prisma.plan_detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plan_detalleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_detalleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_detalles
     * const plan_detalle = await prisma.plan_detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plan_detalleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, plan_detalleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_detalle.
     * @param {plan_detalleUpsertArgs} args - Arguments to update or create a Plan_detalle.
     * @example
     * // Update or create a Plan_detalle
     * const plan_detalle = await prisma.plan_detalle.upsert({
     *   create: {
     *     // ... data to create a Plan_detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_detalle we want to update
     *   }
     * })
    **/
    upsert<T extends plan_detalleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, plan_detalleUpsertArgs<ExtArgs>>
    ): Prisma__plan_detalleClient<$Types.GetResult<plan_detallePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Plan_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleCountArgs} args - Arguments to filter Plan_detalles to count.
     * @example
     * // Count the number of Plan_detalles
     * const count = await prisma.plan_detalle.count({
     *   where: {
     *     // ... the filter for the Plan_detalles we want to count
     *   }
     * })
    **/
    count<T extends plan_detalleCountArgs>(
      args?: Subset<T, plan_detalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_detalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_detalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_detalleAggregateArgs>(args: Subset<T, Plan_detalleAggregateArgs>): Prisma.PrismaPromise<GetPlan_detalleAggregateType<T>>

    /**
     * Group by Plan_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_detalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_detalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_detalleGroupByArgs['orderBy'] }
        : { orderBy?: plan_detalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_detalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_detalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plan_detalleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plan_detalle base type for findUnique actions
   */
  export type plan_detalleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter, which plan_detalle to fetch.
     */
    where: plan_detalleWhereUniqueInput
  }

  /**
   * plan_detalle findUnique
   */
  export interface plan_detalleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_detalleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_detalle findUniqueOrThrow
   */
  export type plan_detalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter, which plan_detalle to fetch.
     */
    where: plan_detalleWhereUniqueInput
  }


  /**
   * plan_detalle base type for findFirst actions
   */
  export type plan_detalleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter, which plan_detalle to fetch.
     */
    where?: plan_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_detalles to fetch.
     */
    orderBy?: plan_detalleOrderByWithRelationInput | plan_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_detalles.
     */
    cursor?: plan_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_detalles.
     */
    distinct?: Plan_detalleScalarFieldEnum | Plan_detalleScalarFieldEnum[]
  }

  /**
   * plan_detalle findFirst
   */
  export interface plan_detalleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_detalleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_detalle findFirstOrThrow
   */
  export type plan_detalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter, which plan_detalle to fetch.
     */
    where?: plan_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_detalles to fetch.
     */
    orderBy?: plan_detalleOrderByWithRelationInput | plan_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_detalles.
     */
    cursor?: plan_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_detalles.
     */
    distinct?: Plan_detalleScalarFieldEnum | Plan_detalleScalarFieldEnum[]
  }


  /**
   * plan_detalle findMany
   */
  export type plan_detalleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter, which plan_detalles to fetch.
     */
    where?: plan_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_detalles to fetch.
     */
    orderBy?: plan_detalleOrderByWithRelationInput | plan_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_detalles.
     */
    cursor?: plan_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_detalles.
     */
    skip?: number
    distinct?: Plan_detalleScalarFieldEnum | Plan_detalleScalarFieldEnum[]
  }


  /**
   * plan_detalle create
   */
  export type plan_detalleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * The data needed to create a plan_detalle.
     */
    data?: XOR<plan_detalleCreateInput, plan_detalleUncheckedCreateInput>
  }


  /**
   * plan_detalle createMany
   */
  export type plan_detalleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_detalles.
     */
    data: plan_detalleCreateManyInput | plan_detalleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * plan_detalle update
   */
  export type plan_detalleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * The data needed to update a plan_detalle.
     */
    data: XOR<plan_detalleUpdateInput, plan_detalleUncheckedUpdateInput>
    /**
     * Choose, which plan_detalle to update.
     */
    where: plan_detalleWhereUniqueInput
  }


  /**
   * plan_detalle updateMany
   */
  export type plan_detalleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_detalles.
     */
    data: XOR<plan_detalleUpdateManyMutationInput, plan_detalleUncheckedUpdateManyInput>
    /**
     * Filter which plan_detalles to update
     */
    where?: plan_detalleWhereInput
  }


  /**
   * plan_detalle upsert
   */
  export type plan_detalleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * The filter to search for the plan_detalle to update in case it exists.
     */
    where: plan_detalleWhereUniqueInput
    /**
     * In case the plan_detalle found by the `where` argument doesn't exist, create a new plan_detalle with this data.
     */
    create: XOR<plan_detalleCreateInput, plan_detalleUncheckedCreateInput>
    /**
     * In case the plan_detalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_detalleUpdateInput, plan_detalleUncheckedUpdateInput>
  }


  /**
   * plan_detalle delete
   */
  export type plan_detalleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
    /**
     * Filter which plan_detalle to delete.
     */
    where: plan_detalleWhereUniqueInput
  }


  /**
   * plan_detalle deleteMany
   */
  export type plan_detalleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_detalles to delete
     */
    where?: plan_detalleWhereInput
  }


  /**
   * plan_detalle without action
   */
  export type plan_detalleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_detalle
     */
    select?: plan_detalleSelect<ExtArgs> | null
  }



  /**
   * Model plan_precio
   */


  export type AggregatePlan_precio = {
    _count: Plan_precioCountAggregateOutputType | null
    _avg: Plan_precioAvgAggregateOutputType | null
    _sum: Plan_precioSumAggregateOutputType | null
    _min: Plan_precioMinAggregateOutputType | null
    _max: Plan_precioMaxAggregateOutputType | null
  }

  export type Plan_precioAvgAggregateOutputType = {
    id_plan: number | null
  }

  export type Plan_precioSumAggregateOutputType = {
    id_plan: number | null
  }

  export type Plan_precioMinAggregateOutputType = {
    id_plan: number | null
    plan: string | null
    tipo_plan: string | null
    codigo: string | null
  }

  export type Plan_precioMaxAggregateOutputType = {
    id_plan: number | null
    plan: string | null
    tipo_plan: string | null
    codigo: string | null
  }

  export type Plan_precioCountAggregateOutputType = {
    id_plan: number
    plan: number
    tipo_plan: number
    codigo: number
    _all: number
  }


  export type Plan_precioAvgAggregateInputType = {
    id_plan?: true
  }

  export type Plan_precioSumAggregateInputType = {
    id_plan?: true
  }

  export type Plan_precioMinAggregateInputType = {
    id_plan?: true
    plan?: true
    tipo_plan?: true
    codigo?: true
  }

  export type Plan_precioMaxAggregateInputType = {
    id_plan?: true
    plan?: true
    tipo_plan?: true
    codigo?: true
  }

  export type Plan_precioCountAggregateInputType = {
    id_plan?: true
    plan?: true
    tipo_plan?: true
    codigo?: true
    _all?: true
  }

  export type Plan_precioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_precio to aggregate.
     */
    where?: plan_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_precios to fetch.
     */
    orderBy?: plan_precioOrderByWithRelationInput | plan_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_precios
    **/
    _count?: true | Plan_precioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plan_precioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plan_precioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_precioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_precioMaxAggregateInputType
  }

  export type GetPlan_precioAggregateType<T extends Plan_precioAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_precio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_precio[P]>
      : GetScalarType<T[P], AggregatePlan_precio[P]>
  }




  export type plan_precioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: plan_precioWhereInput
    orderBy?: plan_precioOrderByWithAggregationInput | plan_precioOrderByWithAggregationInput[]
    by: Plan_precioScalarFieldEnum[] | Plan_precioScalarFieldEnum
    having?: plan_precioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_precioCountAggregateInputType | true
    _avg?: Plan_precioAvgAggregateInputType
    _sum?: Plan_precioSumAggregateInputType
    _min?: Plan_precioMinAggregateInputType
    _max?: Plan_precioMaxAggregateInputType
  }


  export type Plan_precioGroupByOutputType = {
    id_plan: number
    plan: string | null
    tipo_plan: string | null
    codigo: string | null
    _count: Plan_precioCountAggregateOutputType | null
    _avg: Plan_precioAvgAggregateOutputType | null
    _sum: Plan_precioSumAggregateOutputType | null
    _min: Plan_precioMinAggregateOutputType | null
    _max: Plan_precioMaxAggregateOutputType | null
  }

  type GetPlan_precioGroupByPayload<T extends plan_precioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_precioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_precioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_precioGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_precioGroupByOutputType[P]>
        }
      >
    >


  export type plan_precioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_plan?: boolean
    plan?: boolean
    tipo_plan?: boolean
    codigo?: boolean
  }, ExtArgs["result"]["plan_precio"]>

  export type plan_precioSelectScalar = {
    id_plan?: boolean
    plan?: boolean
    tipo_plan?: boolean
    codigo?: boolean
  }


  type plan_precioGetPayload<S extends boolean | null | undefined | plan_precioArgs> = $Types.GetResult<plan_precioPayload, S>

  type plan_precioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<plan_precioFindManyArgs, 'select' | 'include'> & {
      select?: Plan_precioCountAggregateInputType | true
    }

  export interface plan_precioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_precio'], meta: { name: 'plan_precio' } }
    /**
     * Find zero or one Plan_precio that matches the filter.
     * @param {plan_precioFindUniqueArgs} args - Arguments to find a Plan_precio
     * @example
     * // Get one Plan_precio
     * const plan_precio = await prisma.plan_precio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plan_precioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plan_precioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plan_precio'> extends True ? Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Plan_precio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {plan_precioFindUniqueOrThrowArgs} args - Arguments to find a Plan_precio
     * @example
     * // Get one Plan_precio
     * const plan_precio = await prisma.plan_precio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plan_precioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_precioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Plan_precio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioFindFirstArgs} args - Arguments to find a Plan_precio
     * @example
     * // Get one Plan_precio
     * const plan_precio = await prisma.plan_precio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plan_precioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plan_precioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plan_precio'> extends True ? Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Plan_precio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioFindFirstOrThrowArgs} args - Arguments to find a Plan_precio
     * @example
     * // Get one Plan_precio
     * const plan_precio = await prisma.plan_precio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plan_precioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_precioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Plan_precios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_precios
     * const plan_precios = await prisma.plan_precio.findMany()
     * 
     * // Get first 10 Plan_precios
     * const plan_precios = await prisma.plan_precio.findMany({ take: 10 })
     * 
     * // Only select the `id_plan`
     * const plan_precioWithId_planOnly = await prisma.plan_precio.findMany({ select: { id_plan: true } })
     * 
    **/
    findMany<T extends plan_precioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_precioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Plan_precio.
     * @param {plan_precioCreateArgs} args - Arguments to create a Plan_precio.
     * @example
     * // Create one Plan_precio
     * const Plan_precio = await prisma.plan_precio.create({
     *   data: {
     *     // ... data to create a Plan_precio
     *   }
     * })
     * 
    **/
    create<T extends plan_precioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_precioCreateArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Plan_precios.
     *     @param {plan_precioCreateManyArgs} args - Arguments to create many Plan_precios.
     *     @example
     *     // Create many Plan_precios
     *     const plan_precio = await prisma.plan_precio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plan_precioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_precioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_precio.
     * @param {plan_precioDeleteArgs} args - Arguments to delete one Plan_precio.
     * @example
     * // Delete one Plan_precio
     * const Plan_precio = await prisma.plan_precio.delete({
     *   where: {
     *     // ... filter to delete one Plan_precio
     *   }
     * })
     * 
    **/
    delete<T extends plan_precioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, plan_precioDeleteArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Plan_precio.
     * @param {plan_precioUpdateArgs} args - Arguments to update one Plan_precio.
     * @example
     * // Update one Plan_precio
     * const plan_precio = await prisma.plan_precio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plan_precioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, plan_precioUpdateArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Plan_precios.
     * @param {plan_precioDeleteManyArgs} args - Arguments to filter Plan_precios to delete.
     * @example
     * // Delete a few Plan_precios
     * const { count } = await prisma.plan_precio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plan_precioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, plan_precioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_precios
     * const plan_precio = await prisma.plan_precio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plan_precioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, plan_precioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_precio.
     * @param {plan_precioUpsertArgs} args - Arguments to update or create a Plan_precio.
     * @example
     * // Update or create a Plan_precio
     * const plan_precio = await prisma.plan_precio.upsert({
     *   create: {
     *     // ... data to create a Plan_precio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_precio we want to update
     *   }
     * })
    **/
    upsert<T extends plan_precioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, plan_precioUpsertArgs<ExtArgs>>
    ): Prisma__plan_precioClient<$Types.GetResult<plan_precioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Plan_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioCountArgs} args - Arguments to filter Plan_precios to count.
     * @example
     * // Count the number of Plan_precios
     * const count = await prisma.plan_precio.count({
     *   where: {
     *     // ... the filter for the Plan_precios we want to count
     *   }
     * })
    **/
    count<T extends plan_precioCountArgs>(
      args?: Subset<T, plan_precioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_precioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_precioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_precioAggregateArgs>(args: Subset<T, Plan_precioAggregateArgs>): Prisma.PrismaPromise<GetPlan_precioAggregateType<T>>

    /**
     * Group by Plan_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_precioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_precioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_precioGroupByArgs['orderBy'] }
        : { orderBy?: plan_precioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_precioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_precioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_precio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plan_precioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plan_precio base type for findUnique actions
   */
  export type plan_precioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter, which plan_precio to fetch.
     */
    where: plan_precioWhereUniqueInput
  }

  /**
   * plan_precio findUnique
   */
  export interface plan_precioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_precioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_precio findUniqueOrThrow
   */
  export type plan_precioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter, which plan_precio to fetch.
     */
    where: plan_precioWhereUniqueInput
  }


  /**
   * plan_precio base type for findFirst actions
   */
  export type plan_precioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter, which plan_precio to fetch.
     */
    where?: plan_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_precios to fetch.
     */
    orderBy?: plan_precioOrderByWithRelationInput | plan_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_precios.
     */
    cursor?: plan_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_precios.
     */
    distinct?: Plan_precioScalarFieldEnum | Plan_precioScalarFieldEnum[]
  }

  /**
   * plan_precio findFirst
   */
  export interface plan_precioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends plan_precioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plan_precio findFirstOrThrow
   */
  export type plan_precioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter, which plan_precio to fetch.
     */
    where?: plan_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_precios to fetch.
     */
    orderBy?: plan_precioOrderByWithRelationInput | plan_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_precios.
     */
    cursor?: plan_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_precios.
     */
    distinct?: Plan_precioScalarFieldEnum | Plan_precioScalarFieldEnum[]
  }


  /**
   * plan_precio findMany
   */
  export type plan_precioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter, which plan_precios to fetch.
     */
    where?: plan_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_precios to fetch.
     */
    orderBy?: plan_precioOrderByWithRelationInput | plan_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_precios.
     */
    cursor?: plan_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_precios.
     */
    skip?: number
    distinct?: Plan_precioScalarFieldEnum | Plan_precioScalarFieldEnum[]
  }


  /**
   * plan_precio create
   */
  export type plan_precioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * The data needed to create a plan_precio.
     */
    data?: XOR<plan_precioCreateInput, plan_precioUncheckedCreateInput>
  }


  /**
   * plan_precio createMany
   */
  export type plan_precioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_precios.
     */
    data: plan_precioCreateManyInput | plan_precioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * plan_precio update
   */
  export type plan_precioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * The data needed to update a plan_precio.
     */
    data: XOR<plan_precioUpdateInput, plan_precioUncheckedUpdateInput>
    /**
     * Choose, which plan_precio to update.
     */
    where: plan_precioWhereUniqueInput
  }


  /**
   * plan_precio updateMany
   */
  export type plan_precioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_precios.
     */
    data: XOR<plan_precioUpdateManyMutationInput, plan_precioUncheckedUpdateManyInput>
    /**
     * Filter which plan_precios to update
     */
    where?: plan_precioWhereInput
  }


  /**
   * plan_precio upsert
   */
  export type plan_precioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * The filter to search for the plan_precio to update in case it exists.
     */
    where: plan_precioWhereUniqueInput
    /**
     * In case the plan_precio found by the `where` argument doesn't exist, create a new plan_precio with this data.
     */
    create: XOR<plan_precioCreateInput, plan_precioUncheckedCreateInput>
    /**
     * In case the plan_precio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_precioUpdateInput, plan_precioUncheckedUpdateInput>
  }


  /**
   * plan_precio delete
   */
  export type plan_precioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
    /**
     * Filter which plan_precio to delete.
     */
    where: plan_precioWhereUniqueInput
  }


  /**
   * plan_precio deleteMany
   */
  export type plan_precioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_precios to delete
     */
    where?: plan_precioWhereInput
  }


  /**
   * plan_precio without action
   */
  export type plan_precioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_precio
     */
    select?: plan_precioSelect<ExtArgs> | null
  }



  /**
   * Model porcentaje_liq
   */


  export type AggregatePorcentaje_liq = {
    _count: Porcentaje_liqCountAggregateOutputType | null
    _avg: Porcentaje_liqAvgAggregateOutputType | null
    _sum: Porcentaje_liqSumAggregateOutputType | null
    _min: Porcentaje_liqMinAggregateOutputType | null
    _max: Porcentaje_liqMaxAggregateOutputType | null
  }

  export type Porcentaje_liqAvgAggregateOutputType = {
    porcliq_id: number | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
  }

  export type Porcentaje_liqSumAggregateOutputType = {
    porcliq_id: number | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
  }

  export type Porcentaje_liqMinAggregateOutputType = {
    porcliq_id: number | null
    porcliq_nombre: string | null
    porcliq_descrip: string | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
  }

  export type Porcentaje_liqMaxAggregateOutputType = {
    porcliq_id: number | null
    porcliq_nombre: string | null
    porcliq_descrip: string | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
  }

  export type Porcentaje_liqCountAggregateOutputType = {
    porcliq_id: number
    porcliq_nombre: number
    porcliq_descrip: number
    porcliq_cuotas: number
    porcliq_porcentaje: number
    _all: number
  }


  export type Porcentaje_liqAvgAggregateInputType = {
    porcliq_id?: true
    porcliq_cuotas?: true
    porcliq_porcentaje?: true
  }

  export type Porcentaje_liqSumAggregateInputType = {
    porcliq_id?: true
    porcliq_cuotas?: true
    porcliq_porcentaje?: true
  }

  export type Porcentaje_liqMinAggregateInputType = {
    porcliq_id?: true
    porcliq_nombre?: true
    porcliq_descrip?: true
    porcliq_cuotas?: true
    porcliq_porcentaje?: true
  }

  export type Porcentaje_liqMaxAggregateInputType = {
    porcliq_id?: true
    porcliq_nombre?: true
    porcliq_descrip?: true
    porcliq_cuotas?: true
    porcliq_porcentaje?: true
  }

  export type Porcentaje_liqCountAggregateInputType = {
    porcliq_id?: true
    porcliq_nombre?: true
    porcliq_descrip?: true
    porcliq_cuotas?: true
    porcliq_porcentaje?: true
    _all?: true
  }

  export type Porcentaje_liqAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which porcentaje_liq to aggregate.
     */
    where?: porcentaje_liqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of porcentaje_liqs to fetch.
     */
    orderBy?: porcentaje_liqOrderByWithRelationInput | porcentaje_liqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: porcentaje_liqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` porcentaje_liqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` porcentaje_liqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned porcentaje_liqs
    **/
    _count?: true | Porcentaje_liqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Porcentaje_liqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Porcentaje_liqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Porcentaje_liqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Porcentaje_liqMaxAggregateInputType
  }

  export type GetPorcentaje_liqAggregateType<T extends Porcentaje_liqAggregateArgs> = {
        [P in keyof T & keyof AggregatePorcentaje_liq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePorcentaje_liq[P]>
      : GetScalarType<T[P], AggregatePorcentaje_liq[P]>
  }




  export type porcentaje_liqGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: porcentaje_liqWhereInput
    orderBy?: porcentaje_liqOrderByWithAggregationInput | porcentaje_liqOrderByWithAggregationInput[]
    by: Porcentaje_liqScalarFieldEnum[] | Porcentaje_liqScalarFieldEnum
    having?: porcentaje_liqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Porcentaje_liqCountAggregateInputType | true
    _avg?: Porcentaje_liqAvgAggregateInputType
    _sum?: Porcentaje_liqSumAggregateInputType
    _min?: Porcentaje_liqMinAggregateInputType
    _max?: Porcentaje_liqMaxAggregateInputType
  }


  export type Porcentaje_liqGroupByOutputType = {
    porcliq_id: number
    porcliq_nombre: string | null
    porcliq_descrip: string | null
    porcliq_cuotas: number | null
    porcliq_porcentaje: number | null
    _count: Porcentaje_liqCountAggregateOutputType | null
    _avg: Porcentaje_liqAvgAggregateOutputType | null
    _sum: Porcentaje_liqSumAggregateOutputType | null
    _min: Porcentaje_liqMinAggregateOutputType | null
    _max: Porcentaje_liqMaxAggregateOutputType | null
  }

  type GetPorcentaje_liqGroupByPayload<T extends porcentaje_liqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Porcentaje_liqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Porcentaje_liqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Porcentaje_liqGroupByOutputType[P]>
            : GetScalarType<T[P], Porcentaje_liqGroupByOutputType[P]>
        }
      >
    >


  export type porcentaje_liqSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    porcliq_id?: boolean
    porcliq_nombre?: boolean
    porcliq_descrip?: boolean
    porcliq_cuotas?: boolean
    porcliq_porcentaje?: boolean
  }, ExtArgs["result"]["porcentaje_liq"]>

  export type porcentaje_liqSelectScalar = {
    porcliq_id?: boolean
    porcliq_nombre?: boolean
    porcliq_descrip?: boolean
    porcliq_cuotas?: boolean
    porcliq_porcentaje?: boolean
  }


  type porcentaje_liqGetPayload<S extends boolean | null | undefined | porcentaje_liqArgs> = $Types.GetResult<porcentaje_liqPayload, S>

  type porcentaje_liqCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<porcentaje_liqFindManyArgs, 'select' | 'include'> & {
      select?: Porcentaje_liqCountAggregateInputType | true
    }

  export interface porcentaje_liqDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['porcentaje_liq'], meta: { name: 'porcentaje_liq' } }
    /**
     * Find zero or one Porcentaje_liq that matches the filter.
     * @param {porcentaje_liqFindUniqueArgs} args - Arguments to find a Porcentaje_liq
     * @example
     * // Get one Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends porcentaje_liqFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, porcentaje_liqFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'porcentaje_liq'> extends True ? Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Porcentaje_liq that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {porcentaje_liqFindUniqueOrThrowArgs} args - Arguments to find a Porcentaje_liq
     * @example
     * // Get one Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends porcentaje_liqFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, porcentaje_liqFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Porcentaje_liq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqFindFirstArgs} args - Arguments to find a Porcentaje_liq
     * @example
     * // Get one Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends porcentaje_liqFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, porcentaje_liqFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'porcentaje_liq'> extends True ? Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Porcentaje_liq that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqFindFirstOrThrowArgs} args - Arguments to find a Porcentaje_liq
     * @example
     * // Get one Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends porcentaje_liqFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, porcentaje_liqFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Porcentaje_liqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Porcentaje_liqs
     * const porcentaje_liqs = await prisma.porcentaje_liq.findMany()
     * 
     * // Get first 10 Porcentaje_liqs
     * const porcentaje_liqs = await prisma.porcentaje_liq.findMany({ take: 10 })
     * 
     * // Only select the `porcliq_id`
     * const porcentaje_liqWithPorcliq_idOnly = await prisma.porcentaje_liq.findMany({ select: { porcliq_id: true } })
     * 
    **/
    findMany<T extends porcentaje_liqFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, porcentaje_liqFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Porcentaje_liq.
     * @param {porcentaje_liqCreateArgs} args - Arguments to create a Porcentaje_liq.
     * @example
     * // Create one Porcentaje_liq
     * const Porcentaje_liq = await prisma.porcentaje_liq.create({
     *   data: {
     *     // ... data to create a Porcentaje_liq
     *   }
     * })
     * 
    **/
    create<T extends porcentaje_liqCreateArgs<ExtArgs>>(
      args: SelectSubset<T, porcentaje_liqCreateArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Porcentaje_liqs.
     *     @param {porcentaje_liqCreateManyArgs} args - Arguments to create many Porcentaje_liqs.
     *     @example
     *     // Create many Porcentaje_liqs
     *     const porcentaje_liq = await prisma.porcentaje_liq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends porcentaje_liqCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, porcentaje_liqCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Porcentaje_liq.
     * @param {porcentaje_liqDeleteArgs} args - Arguments to delete one Porcentaje_liq.
     * @example
     * // Delete one Porcentaje_liq
     * const Porcentaje_liq = await prisma.porcentaje_liq.delete({
     *   where: {
     *     // ... filter to delete one Porcentaje_liq
     *   }
     * })
     * 
    **/
    delete<T extends porcentaje_liqDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, porcentaje_liqDeleteArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Porcentaje_liq.
     * @param {porcentaje_liqUpdateArgs} args - Arguments to update one Porcentaje_liq.
     * @example
     * // Update one Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends porcentaje_liqUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, porcentaje_liqUpdateArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Porcentaje_liqs.
     * @param {porcentaje_liqDeleteManyArgs} args - Arguments to filter Porcentaje_liqs to delete.
     * @example
     * // Delete a few Porcentaje_liqs
     * const { count } = await prisma.porcentaje_liq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends porcentaje_liqDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, porcentaje_liqDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Porcentaje_liqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Porcentaje_liqs
     * const porcentaje_liq = await prisma.porcentaje_liq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends porcentaje_liqUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, porcentaje_liqUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Porcentaje_liq.
     * @param {porcentaje_liqUpsertArgs} args - Arguments to update or create a Porcentaje_liq.
     * @example
     * // Update or create a Porcentaje_liq
     * const porcentaje_liq = await prisma.porcentaje_liq.upsert({
     *   create: {
     *     // ... data to create a Porcentaje_liq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Porcentaje_liq we want to update
     *   }
     * })
    **/
    upsert<T extends porcentaje_liqUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, porcentaje_liqUpsertArgs<ExtArgs>>
    ): Prisma__porcentaje_liqClient<$Types.GetResult<porcentaje_liqPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Porcentaje_liqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqCountArgs} args - Arguments to filter Porcentaje_liqs to count.
     * @example
     * // Count the number of Porcentaje_liqs
     * const count = await prisma.porcentaje_liq.count({
     *   where: {
     *     // ... the filter for the Porcentaje_liqs we want to count
     *   }
     * })
    **/
    count<T extends porcentaje_liqCountArgs>(
      args?: Subset<T, porcentaje_liqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Porcentaje_liqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Porcentaje_liq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Porcentaje_liqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Porcentaje_liqAggregateArgs>(args: Subset<T, Porcentaje_liqAggregateArgs>): Prisma.PrismaPromise<GetPorcentaje_liqAggregateType<T>>

    /**
     * Group by Porcentaje_liq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {porcentaje_liqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends porcentaje_liqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: porcentaje_liqGroupByArgs['orderBy'] }
        : { orderBy?: porcentaje_liqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, porcentaje_liqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPorcentaje_liqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for porcentaje_liq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__porcentaje_liqClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * porcentaje_liq base type for findUnique actions
   */
  export type porcentaje_liqFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter, which porcentaje_liq to fetch.
     */
    where: porcentaje_liqWhereUniqueInput
  }

  /**
   * porcentaje_liq findUnique
   */
  export interface porcentaje_liqFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends porcentaje_liqFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * porcentaje_liq findUniqueOrThrow
   */
  export type porcentaje_liqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter, which porcentaje_liq to fetch.
     */
    where: porcentaje_liqWhereUniqueInput
  }


  /**
   * porcentaje_liq base type for findFirst actions
   */
  export type porcentaje_liqFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter, which porcentaje_liq to fetch.
     */
    where?: porcentaje_liqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of porcentaje_liqs to fetch.
     */
    orderBy?: porcentaje_liqOrderByWithRelationInput | porcentaje_liqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for porcentaje_liqs.
     */
    cursor?: porcentaje_liqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` porcentaje_liqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` porcentaje_liqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of porcentaje_liqs.
     */
    distinct?: Porcentaje_liqScalarFieldEnum | Porcentaje_liqScalarFieldEnum[]
  }

  /**
   * porcentaje_liq findFirst
   */
  export interface porcentaje_liqFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends porcentaje_liqFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * porcentaje_liq findFirstOrThrow
   */
  export type porcentaje_liqFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter, which porcentaje_liq to fetch.
     */
    where?: porcentaje_liqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of porcentaje_liqs to fetch.
     */
    orderBy?: porcentaje_liqOrderByWithRelationInput | porcentaje_liqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for porcentaje_liqs.
     */
    cursor?: porcentaje_liqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` porcentaje_liqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` porcentaje_liqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of porcentaje_liqs.
     */
    distinct?: Porcentaje_liqScalarFieldEnum | Porcentaje_liqScalarFieldEnum[]
  }


  /**
   * porcentaje_liq findMany
   */
  export type porcentaje_liqFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter, which porcentaje_liqs to fetch.
     */
    where?: porcentaje_liqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of porcentaje_liqs to fetch.
     */
    orderBy?: porcentaje_liqOrderByWithRelationInput | porcentaje_liqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing porcentaje_liqs.
     */
    cursor?: porcentaje_liqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` porcentaje_liqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` porcentaje_liqs.
     */
    skip?: number
    distinct?: Porcentaje_liqScalarFieldEnum | Porcentaje_liqScalarFieldEnum[]
  }


  /**
   * porcentaje_liq create
   */
  export type porcentaje_liqCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * The data needed to create a porcentaje_liq.
     */
    data?: XOR<porcentaje_liqCreateInput, porcentaje_liqUncheckedCreateInput>
  }


  /**
   * porcentaje_liq createMany
   */
  export type porcentaje_liqCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many porcentaje_liqs.
     */
    data: porcentaje_liqCreateManyInput | porcentaje_liqCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * porcentaje_liq update
   */
  export type porcentaje_liqUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * The data needed to update a porcentaje_liq.
     */
    data: XOR<porcentaje_liqUpdateInput, porcentaje_liqUncheckedUpdateInput>
    /**
     * Choose, which porcentaje_liq to update.
     */
    where: porcentaje_liqWhereUniqueInput
  }


  /**
   * porcentaje_liq updateMany
   */
  export type porcentaje_liqUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update porcentaje_liqs.
     */
    data: XOR<porcentaje_liqUpdateManyMutationInput, porcentaje_liqUncheckedUpdateManyInput>
    /**
     * Filter which porcentaje_liqs to update
     */
    where?: porcentaje_liqWhereInput
  }


  /**
   * porcentaje_liq upsert
   */
  export type porcentaje_liqUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * The filter to search for the porcentaje_liq to update in case it exists.
     */
    where: porcentaje_liqWhereUniqueInput
    /**
     * In case the porcentaje_liq found by the `where` argument doesn't exist, create a new porcentaje_liq with this data.
     */
    create: XOR<porcentaje_liqCreateInput, porcentaje_liqUncheckedCreateInput>
    /**
     * In case the porcentaje_liq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<porcentaje_liqUpdateInput, porcentaje_liqUncheckedUpdateInput>
  }


  /**
   * porcentaje_liq delete
   */
  export type porcentaje_liqDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
    /**
     * Filter which porcentaje_liq to delete.
     */
    where: porcentaje_liqWhereUniqueInput
  }


  /**
   * porcentaje_liq deleteMany
   */
  export type porcentaje_liqDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which porcentaje_liqs to delete
     */
    where?: porcentaje_liqWhereInput
  }


  /**
   * porcentaje_liq without action
   */
  export type porcentaje_liqArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the porcentaje_liq
     */
    select?: porcentaje_liqSelect<ExtArgs> | null
  }



  /**
   * Model prestamos_empleados
   */


  export type AggregatePrestamos_empleados = {
    _count: Prestamos_empleadosCountAggregateOutputType | null
    _avg: Prestamos_empleadosAvgAggregateOutputType | null
    _sum: Prestamos_empleadosSumAggregateOutputType | null
    _min: Prestamos_empleadosMinAggregateOutputType | null
    _max: Prestamos_empleadosMaxAggregateOutputType | null
  }

  export type Prestamos_empleadosAvgAggregateOutputType = {
    idprestamo: number | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
  }

  export type Prestamos_empleadosSumAggregateOutputType = {
    idprestamo: number | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
  }

  export type Prestamos_empleadosMinAggregateOutputType = {
    idprestamo: number | null
    empleado: string | null
    fecha_solicitud: Date | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
    inicia: string | null
    termina: string | null
    estado: string | null
    capinoaut: boolean | null
  }

  export type Prestamos_empleadosMaxAggregateOutputType = {
    idprestamo: number | null
    empleado: string | null
    fecha_solicitud: Date | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
    inicia: string | null
    termina: string | null
    estado: string | null
    capinoaut: boolean | null
  }

  export type Prestamos_empleadosCountAggregateOutputType = {
    idprestamo: number
    empleado: number
    fecha_solicitud: number
    capital: number
    plan_cuotas: number
    cuota_mensual: number
    capital_dev: number
    inicia: number
    termina: number
    estado: number
    capinoaut: number
    _all: number
  }


  export type Prestamos_empleadosAvgAggregateInputType = {
    idprestamo?: true
    capital?: true
    plan_cuotas?: true
    cuota_mensual?: true
    capital_dev?: true
  }

  export type Prestamos_empleadosSumAggregateInputType = {
    idprestamo?: true
    capital?: true
    plan_cuotas?: true
    cuota_mensual?: true
    capital_dev?: true
  }

  export type Prestamos_empleadosMinAggregateInputType = {
    idprestamo?: true
    empleado?: true
    fecha_solicitud?: true
    capital?: true
    plan_cuotas?: true
    cuota_mensual?: true
    capital_dev?: true
    inicia?: true
    termina?: true
    estado?: true
    capinoaut?: true
  }

  export type Prestamos_empleadosMaxAggregateInputType = {
    idprestamo?: true
    empleado?: true
    fecha_solicitud?: true
    capital?: true
    plan_cuotas?: true
    cuota_mensual?: true
    capital_dev?: true
    inicia?: true
    termina?: true
    estado?: true
    capinoaut?: true
  }

  export type Prestamos_empleadosCountAggregateInputType = {
    idprestamo?: true
    empleado?: true
    fecha_solicitud?: true
    capital?: true
    plan_cuotas?: true
    cuota_mensual?: true
    capital_dev?: true
    inicia?: true
    termina?: true
    estado?: true
    capinoaut?: true
    _all?: true
  }

  export type Prestamos_empleadosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_empleados to aggregate.
     */
    where?: prestamos_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados to fetch.
     */
    orderBy?: prestamos_empleadosOrderByWithRelationInput | prestamos_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prestamos_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prestamos_empleados
    **/
    _count?: true | Prestamos_empleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prestamos_empleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prestamos_empleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prestamos_empleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prestamos_empleadosMaxAggregateInputType
  }

  export type GetPrestamos_empleadosAggregateType<T extends Prestamos_empleadosAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestamos_empleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestamos_empleados[P]>
      : GetScalarType<T[P], AggregatePrestamos_empleados[P]>
  }




  export type prestamos_empleadosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: prestamos_empleadosWhereInput
    orderBy?: prestamos_empleadosOrderByWithAggregationInput | prestamos_empleadosOrderByWithAggregationInput[]
    by: Prestamos_empleadosScalarFieldEnum[] | Prestamos_empleadosScalarFieldEnum
    having?: prestamos_empleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prestamos_empleadosCountAggregateInputType | true
    _avg?: Prestamos_empleadosAvgAggregateInputType
    _sum?: Prestamos_empleadosSumAggregateInputType
    _min?: Prestamos_empleadosMinAggregateInputType
    _max?: Prestamos_empleadosMaxAggregateInputType
  }


  export type Prestamos_empleadosGroupByOutputType = {
    idprestamo: number
    empleado: string | null
    fecha_solicitud: Date | null
    capital: number | null
    plan_cuotas: number | null
    cuota_mensual: number | null
    capital_dev: number | null
    inicia: string | null
    termina: string | null
    estado: string | null
    capinoaut: boolean | null
    _count: Prestamos_empleadosCountAggregateOutputType | null
    _avg: Prestamos_empleadosAvgAggregateOutputType | null
    _sum: Prestamos_empleadosSumAggregateOutputType | null
    _min: Prestamos_empleadosMinAggregateOutputType | null
    _max: Prestamos_empleadosMaxAggregateOutputType | null
  }

  type GetPrestamos_empleadosGroupByPayload<T extends prestamos_empleadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prestamos_empleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prestamos_empleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prestamos_empleadosGroupByOutputType[P]>
            : GetScalarType<T[P], Prestamos_empleadosGroupByOutputType[P]>
        }
      >
    >


  export type prestamos_empleadosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprestamo?: boolean
    empleado?: boolean
    fecha_solicitud?: boolean
    capital?: boolean
    plan_cuotas?: boolean
    cuota_mensual?: boolean
    capital_dev?: boolean
    inicia?: boolean
    termina?: boolean
    estado?: boolean
    capinoaut?: boolean
  }, ExtArgs["result"]["prestamos_empleados"]>

  export type prestamos_empleadosSelectScalar = {
    idprestamo?: boolean
    empleado?: boolean
    fecha_solicitud?: boolean
    capital?: boolean
    plan_cuotas?: boolean
    cuota_mensual?: boolean
    capital_dev?: boolean
    inicia?: boolean
    termina?: boolean
    estado?: boolean
    capinoaut?: boolean
  }


  type prestamos_empleadosGetPayload<S extends boolean | null | undefined | prestamos_empleadosArgs> = $Types.GetResult<prestamos_empleadosPayload, S>

  type prestamos_empleadosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<prestamos_empleadosFindManyArgs, 'select' | 'include'> & {
      select?: Prestamos_empleadosCountAggregateInputType | true
    }

  export interface prestamos_empleadosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prestamos_empleados'], meta: { name: 'prestamos_empleados' } }
    /**
     * Find zero or one Prestamos_empleados that matches the filter.
     * @param {prestamos_empleadosFindUniqueArgs} args - Arguments to find a Prestamos_empleados
     * @example
     * // Get one Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prestamos_empleadosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, prestamos_empleadosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'prestamos_empleados'> extends True ? Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Prestamos_empleados that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prestamos_empleadosFindUniqueOrThrowArgs} args - Arguments to find a Prestamos_empleados
     * @example
     * // Get one Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prestamos_empleadosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleadosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Prestamos_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosFindFirstArgs} args - Arguments to find a Prestamos_empleados
     * @example
     * // Get one Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prestamos_empleadosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, prestamos_empleadosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'prestamos_empleados'> extends True ? Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Prestamos_empleados that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosFindFirstOrThrowArgs} args - Arguments to find a Prestamos_empleados
     * @example
     * // Get one Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prestamos_empleadosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleadosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prestamos_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findMany()
     * 
     * // Get first 10 Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.findMany({ take: 10 })
     * 
     * // Only select the `idprestamo`
     * const prestamos_empleadosWithIdprestamoOnly = await prisma.prestamos_empleados.findMany({ select: { idprestamo: true } })
     * 
    **/
    findMany<T extends prestamos_empleadosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleadosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Prestamos_empleados.
     * @param {prestamos_empleadosCreateArgs} args - Arguments to create a Prestamos_empleados.
     * @example
     * // Create one Prestamos_empleados
     * const Prestamos_empleados = await prisma.prestamos_empleados.create({
     *   data: {
     *     // ... data to create a Prestamos_empleados
     *   }
     * })
     * 
    **/
    create<T extends prestamos_empleadosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleadosCreateArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prestamos_empleados.
     *     @param {prestamos_empleadosCreateManyArgs} args - Arguments to create many Prestamos_empleados.
     *     @example
     *     // Create many Prestamos_empleados
     *     const prestamos_empleados = await prisma.prestamos_empleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prestamos_empleadosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleadosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestamos_empleados.
     * @param {prestamos_empleadosDeleteArgs} args - Arguments to delete one Prestamos_empleados.
     * @example
     * // Delete one Prestamos_empleados
     * const Prestamos_empleados = await prisma.prestamos_empleados.delete({
     *   where: {
     *     // ... filter to delete one Prestamos_empleados
     *   }
     * })
     * 
    **/
    delete<T extends prestamos_empleadosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleadosDeleteArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Prestamos_empleados.
     * @param {prestamos_empleadosUpdateArgs} args - Arguments to update one Prestamos_empleados.
     * @example
     * // Update one Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prestamos_empleadosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleadosUpdateArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prestamos_empleados.
     * @param {prestamos_empleadosDeleteManyArgs} args - Arguments to filter Prestamos_empleados to delete.
     * @example
     * // Delete a few Prestamos_empleados
     * const { count } = await prisma.prestamos_empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prestamos_empleadosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleadosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestamos_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prestamos_empleadosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleadosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestamos_empleados.
     * @param {prestamos_empleadosUpsertArgs} args - Arguments to update or create a Prestamos_empleados.
     * @example
     * // Update or create a Prestamos_empleados
     * const prestamos_empleados = await prisma.prestamos_empleados.upsert({
     *   create: {
     *     // ... data to create a Prestamos_empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestamos_empleados we want to update
     *   }
     * })
    **/
    upsert<T extends prestamos_empleadosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleadosUpsertArgs<ExtArgs>>
    ): Prisma__prestamos_empleadosClient<$Types.GetResult<prestamos_empleadosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prestamos_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosCountArgs} args - Arguments to filter Prestamos_empleados to count.
     * @example
     * // Count the number of Prestamos_empleados
     * const count = await prisma.prestamos_empleados.count({
     *   where: {
     *     // ... the filter for the Prestamos_empleados we want to count
     *   }
     * })
    **/
    count<T extends prestamos_empleadosCountArgs>(
      args?: Subset<T, prestamos_empleadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prestamos_empleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestamos_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prestamos_empleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prestamos_empleadosAggregateArgs>(args: Subset<T, Prestamos_empleadosAggregateArgs>): Prisma.PrismaPromise<GetPrestamos_empleadosAggregateType<T>>

    /**
     * Group by Prestamos_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prestamos_empleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prestamos_empleadosGroupByArgs['orderBy'] }
        : { orderBy?: prestamos_empleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prestamos_empleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestamos_empleadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for prestamos_empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prestamos_empleadosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * prestamos_empleados base type for findUnique actions
   */
  export type prestamos_empleadosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados to fetch.
     */
    where: prestamos_empleadosWhereUniqueInput
  }

  /**
   * prestamos_empleados findUnique
   */
  export interface prestamos_empleadosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_empleadosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_empleados findUniqueOrThrow
   */
  export type prestamos_empleadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados to fetch.
     */
    where: prestamos_empleadosWhereUniqueInput
  }


  /**
   * prestamos_empleados base type for findFirst actions
   */
  export type prestamos_empleadosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados to fetch.
     */
    where?: prestamos_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados to fetch.
     */
    orderBy?: prestamos_empleadosOrderByWithRelationInput | prestamos_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_empleados.
     */
    cursor?: prestamos_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_empleados.
     */
    distinct?: Prestamos_empleadosScalarFieldEnum | Prestamos_empleadosScalarFieldEnum[]
  }

  /**
   * prestamos_empleados findFirst
   */
  export interface prestamos_empleadosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_empleadosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_empleados findFirstOrThrow
   */
  export type prestamos_empleadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados to fetch.
     */
    where?: prestamos_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados to fetch.
     */
    orderBy?: prestamos_empleadosOrderByWithRelationInput | prestamos_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_empleados.
     */
    cursor?: prestamos_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_empleados.
     */
    distinct?: Prestamos_empleadosScalarFieldEnum | Prestamos_empleadosScalarFieldEnum[]
  }


  /**
   * prestamos_empleados findMany
   */
  export type prestamos_empleadosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados to fetch.
     */
    where?: prestamos_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados to fetch.
     */
    orderBy?: prestamos_empleadosOrderByWithRelationInput | prestamos_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prestamos_empleados.
     */
    cursor?: prestamos_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados.
     */
    skip?: number
    distinct?: Prestamos_empleadosScalarFieldEnum | Prestamos_empleadosScalarFieldEnum[]
  }


  /**
   * prestamos_empleados create
   */
  export type prestamos_empleadosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * The data needed to create a prestamos_empleados.
     */
    data?: XOR<prestamos_empleadosCreateInput, prestamos_empleadosUncheckedCreateInput>
  }


  /**
   * prestamos_empleados createMany
   */
  export type prestamos_empleadosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prestamos_empleados.
     */
    data: prestamos_empleadosCreateManyInput | prestamos_empleadosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prestamos_empleados update
   */
  export type prestamos_empleadosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * The data needed to update a prestamos_empleados.
     */
    data: XOR<prestamos_empleadosUpdateInput, prestamos_empleadosUncheckedUpdateInput>
    /**
     * Choose, which prestamos_empleados to update.
     */
    where: prestamos_empleadosWhereUniqueInput
  }


  /**
   * prestamos_empleados updateMany
   */
  export type prestamos_empleadosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prestamos_empleados.
     */
    data: XOR<prestamos_empleadosUpdateManyMutationInput, prestamos_empleadosUncheckedUpdateManyInput>
    /**
     * Filter which prestamos_empleados to update
     */
    where?: prestamos_empleadosWhereInput
  }


  /**
   * prestamos_empleados upsert
   */
  export type prestamos_empleadosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * The filter to search for the prestamos_empleados to update in case it exists.
     */
    where: prestamos_empleadosWhereUniqueInput
    /**
     * In case the prestamos_empleados found by the `where` argument doesn't exist, create a new prestamos_empleados with this data.
     */
    create: XOR<prestamos_empleadosCreateInput, prestamos_empleadosUncheckedCreateInput>
    /**
     * In case the prestamos_empleados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prestamos_empleadosUpdateInput, prestamos_empleadosUncheckedUpdateInput>
  }


  /**
   * prestamos_empleados delete
   */
  export type prestamos_empleadosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
    /**
     * Filter which prestamos_empleados to delete.
     */
    where: prestamos_empleadosWhereUniqueInput
  }


  /**
   * prestamos_empleados deleteMany
   */
  export type prestamos_empleadosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_empleados to delete
     */
    where?: prestamos_empleadosWhereInput
  }


  /**
   * prestamos_empleados without action
   */
  export type prestamos_empleadosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados
     */
    select?: prestamos_empleadosSelect<ExtArgs> | null
  }



  /**
   * Model prestamos_empleados_cobro
   */


  export type AggregatePrestamos_empleados_cobro = {
    _count: Prestamos_empleados_cobroCountAggregateOutputType | null
    _avg: Prestamos_empleados_cobroAvgAggregateOutputType | null
    _sum: Prestamos_empleados_cobroSumAggregateOutputType | null
    _min: Prestamos_empleados_cobroMinAggregateOutputType | null
    _max: Prestamos_empleados_cobroMaxAggregateOutputType | null
  }

  export type Prestamos_empleados_cobroAvgAggregateOutputType = {
    idpago: number | null
    idprestamo: number | null
    cuota: number | null
    importe: number | null
  }

  export type Prestamos_empleados_cobroSumAggregateOutputType = {
    idpago: number | null
    idprestamo: number | null
    cuota: number | null
    importe: number | null
  }

  export type Prestamos_empleados_cobroMinAggregateOutputType = {
    idpago: number | null
    idprestamo: number | null
    cuota: number | null
    importe: number | null
    fecha_cobro: Date | null
    estado: boolean | null
    fecha_pago: Date | null
    operador: string | null
  }

  export type Prestamos_empleados_cobroMaxAggregateOutputType = {
    idpago: number | null
    idprestamo: number | null
    cuota: number | null
    importe: number | null
    fecha_cobro: Date | null
    estado: boolean | null
    fecha_pago: Date | null
    operador: string | null
  }

  export type Prestamos_empleados_cobroCountAggregateOutputType = {
    idpago: number
    idprestamo: number
    cuota: number
    importe: number
    fecha_cobro: number
    estado: number
    fecha_pago: number
    operador: number
    _all: number
  }


  export type Prestamos_empleados_cobroAvgAggregateInputType = {
    idpago?: true
    idprestamo?: true
    cuota?: true
    importe?: true
  }

  export type Prestamos_empleados_cobroSumAggregateInputType = {
    idpago?: true
    idprestamo?: true
    cuota?: true
    importe?: true
  }

  export type Prestamos_empleados_cobroMinAggregateInputType = {
    idpago?: true
    idprestamo?: true
    cuota?: true
    importe?: true
    fecha_cobro?: true
    estado?: true
    fecha_pago?: true
    operador?: true
  }

  export type Prestamos_empleados_cobroMaxAggregateInputType = {
    idpago?: true
    idprestamo?: true
    cuota?: true
    importe?: true
    fecha_cobro?: true
    estado?: true
    fecha_pago?: true
    operador?: true
  }

  export type Prestamos_empleados_cobroCountAggregateInputType = {
    idpago?: true
    idprestamo?: true
    cuota?: true
    importe?: true
    fecha_cobro?: true
    estado?: true
    fecha_pago?: true
    operador?: true
    _all?: true
  }

  export type Prestamos_empleados_cobroAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_empleados_cobro to aggregate.
     */
    where?: prestamos_empleados_cobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados_cobros to fetch.
     */
    orderBy?: prestamos_empleados_cobroOrderByWithRelationInput | prestamos_empleados_cobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prestamos_empleados_cobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados_cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados_cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prestamos_empleados_cobros
    **/
    _count?: true | Prestamos_empleados_cobroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prestamos_empleados_cobroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prestamos_empleados_cobroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prestamos_empleados_cobroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prestamos_empleados_cobroMaxAggregateInputType
  }

  export type GetPrestamos_empleados_cobroAggregateType<T extends Prestamos_empleados_cobroAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestamos_empleados_cobro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestamos_empleados_cobro[P]>
      : GetScalarType<T[P], AggregatePrestamos_empleados_cobro[P]>
  }




  export type prestamos_empleados_cobroGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: prestamos_empleados_cobroWhereInput
    orderBy?: prestamos_empleados_cobroOrderByWithAggregationInput | prestamos_empleados_cobroOrderByWithAggregationInput[]
    by: Prestamos_empleados_cobroScalarFieldEnum[] | Prestamos_empleados_cobroScalarFieldEnum
    having?: prestamos_empleados_cobroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prestamos_empleados_cobroCountAggregateInputType | true
    _avg?: Prestamos_empleados_cobroAvgAggregateInputType
    _sum?: Prestamos_empleados_cobroSumAggregateInputType
    _min?: Prestamos_empleados_cobroMinAggregateInputType
    _max?: Prestamos_empleados_cobroMaxAggregateInputType
  }


  export type Prestamos_empleados_cobroGroupByOutputType = {
    idpago: number
    idprestamo: number | null
    cuota: number | null
    importe: number | null
    fecha_cobro: Date | null
    estado: boolean | null
    fecha_pago: Date | null
    operador: string | null
    _count: Prestamos_empleados_cobroCountAggregateOutputType | null
    _avg: Prestamos_empleados_cobroAvgAggregateOutputType | null
    _sum: Prestamos_empleados_cobroSumAggregateOutputType | null
    _min: Prestamos_empleados_cobroMinAggregateOutputType | null
    _max: Prestamos_empleados_cobroMaxAggregateOutputType | null
  }

  type GetPrestamos_empleados_cobroGroupByPayload<T extends prestamos_empleados_cobroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prestamos_empleados_cobroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prestamos_empleados_cobroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prestamos_empleados_cobroGroupByOutputType[P]>
            : GetScalarType<T[P], Prestamos_empleados_cobroGroupByOutputType[P]>
        }
      >
    >


  export type prestamos_empleados_cobroSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpago?: boolean
    idprestamo?: boolean
    cuota?: boolean
    importe?: boolean
    fecha_cobro?: boolean
    estado?: boolean
    fecha_pago?: boolean
    operador?: boolean
  }, ExtArgs["result"]["prestamos_empleados_cobro"]>

  export type prestamos_empleados_cobroSelectScalar = {
    idpago?: boolean
    idprestamo?: boolean
    cuota?: boolean
    importe?: boolean
    fecha_cobro?: boolean
    estado?: boolean
    fecha_pago?: boolean
    operador?: boolean
  }


  type prestamos_empleados_cobroGetPayload<S extends boolean | null | undefined | prestamos_empleados_cobroArgs> = $Types.GetResult<prestamos_empleados_cobroPayload, S>

  type prestamos_empleados_cobroCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<prestamos_empleados_cobroFindManyArgs, 'select' | 'include'> & {
      select?: Prestamos_empleados_cobroCountAggregateInputType | true
    }

  export interface prestamos_empleados_cobroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prestamos_empleados_cobro'], meta: { name: 'prestamos_empleados_cobro' } }
    /**
     * Find zero or one Prestamos_empleados_cobro that matches the filter.
     * @param {prestamos_empleados_cobroFindUniqueArgs} args - Arguments to find a Prestamos_empleados_cobro
     * @example
     * // Get one Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prestamos_empleados_cobroFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, prestamos_empleados_cobroFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'prestamos_empleados_cobro'> extends True ? Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Prestamos_empleados_cobro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prestamos_empleados_cobroFindUniqueOrThrowArgs} args - Arguments to find a Prestamos_empleados_cobro
     * @example
     * // Get one Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prestamos_empleados_cobroFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleados_cobroFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Prestamos_empleados_cobro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroFindFirstArgs} args - Arguments to find a Prestamos_empleados_cobro
     * @example
     * // Get one Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prestamos_empleados_cobroFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, prestamos_empleados_cobroFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'prestamos_empleados_cobro'> extends True ? Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Prestamos_empleados_cobro that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroFindFirstOrThrowArgs} args - Arguments to find a Prestamos_empleados_cobro
     * @example
     * // Get one Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prestamos_empleados_cobroFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleados_cobroFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prestamos_empleados_cobros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestamos_empleados_cobros
     * const prestamos_empleados_cobros = await prisma.prestamos_empleados_cobro.findMany()
     * 
     * // Get first 10 Prestamos_empleados_cobros
     * const prestamos_empleados_cobros = await prisma.prestamos_empleados_cobro.findMany({ take: 10 })
     * 
     * // Only select the `idpago`
     * const prestamos_empleados_cobroWithIdpagoOnly = await prisma.prestamos_empleados_cobro.findMany({ select: { idpago: true } })
     * 
    **/
    findMany<T extends prestamos_empleados_cobroFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleados_cobroFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Prestamos_empleados_cobro.
     * @param {prestamos_empleados_cobroCreateArgs} args - Arguments to create a Prestamos_empleados_cobro.
     * @example
     * // Create one Prestamos_empleados_cobro
     * const Prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.create({
     *   data: {
     *     // ... data to create a Prestamos_empleados_cobro
     *   }
     * })
     * 
    **/
    create<T extends prestamos_empleados_cobroCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleados_cobroCreateArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prestamos_empleados_cobros.
     *     @param {prestamos_empleados_cobroCreateManyArgs} args - Arguments to create many Prestamos_empleados_cobros.
     *     @example
     *     // Create many Prestamos_empleados_cobros
     *     const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prestamos_empleados_cobroCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleados_cobroCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestamos_empleados_cobro.
     * @param {prestamos_empleados_cobroDeleteArgs} args - Arguments to delete one Prestamos_empleados_cobro.
     * @example
     * // Delete one Prestamos_empleados_cobro
     * const Prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.delete({
     *   where: {
     *     // ... filter to delete one Prestamos_empleados_cobro
     *   }
     * })
     * 
    **/
    delete<T extends prestamos_empleados_cobroDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleados_cobroDeleteArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Prestamos_empleados_cobro.
     * @param {prestamos_empleados_cobroUpdateArgs} args - Arguments to update one Prestamos_empleados_cobro.
     * @example
     * // Update one Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prestamos_empleados_cobroUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleados_cobroUpdateArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prestamos_empleados_cobros.
     * @param {prestamos_empleados_cobroDeleteManyArgs} args - Arguments to filter Prestamos_empleados_cobros to delete.
     * @example
     * // Delete a few Prestamos_empleados_cobros
     * const { count } = await prisma.prestamos_empleados_cobro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prestamos_empleados_cobroDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_empleados_cobroDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestamos_empleados_cobros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestamos_empleados_cobros
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prestamos_empleados_cobroUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleados_cobroUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestamos_empleados_cobro.
     * @param {prestamos_empleados_cobroUpsertArgs} args - Arguments to update or create a Prestamos_empleados_cobro.
     * @example
     * // Update or create a Prestamos_empleados_cobro
     * const prestamos_empleados_cobro = await prisma.prestamos_empleados_cobro.upsert({
     *   create: {
     *     // ... data to create a Prestamos_empleados_cobro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestamos_empleados_cobro we want to update
     *   }
     * })
    **/
    upsert<T extends prestamos_empleados_cobroUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_empleados_cobroUpsertArgs<ExtArgs>>
    ): Prisma__prestamos_empleados_cobroClient<$Types.GetResult<prestamos_empleados_cobroPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prestamos_empleados_cobros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroCountArgs} args - Arguments to filter Prestamos_empleados_cobros to count.
     * @example
     * // Count the number of Prestamos_empleados_cobros
     * const count = await prisma.prestamos_empleados_cobro.count({
     *   where: {
     *     // ... the filter for the Prestamos_empleados_cobros we want to count
     *   }
     * })
    **/
    count<T extends prestamos_empleados_cobroCountArgs>(
      args?: Subset<T, prestamos_empleados_cobroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prestamos_empleados_cobroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestamos_empleados_cobro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prestamos_empleados_cobroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prestamos_empleados_cobroAggregateArgs>(args: Subset<T, Prestamos_empleados_cobroAggregateArgs>): Prisma.PrismaPromise<GetPrestamos_empleados_cobroAggregateType<T>>

    /**
     * Group by Prestamos_empleados_cobro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_empleados_cobroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prestamos_empleados_cobroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prestamos_empleados_cobroGroupByArgs['orderBy'] }
        : { orderBy?: prestamos_empleados_cobroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prestamos_empleados_cobroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestamos_empleados_cobroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for prestamos_empleados_cobro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prestamos_empleados_cobroClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * prestamos_empleados_cobro base type for findUnique actions
   */
  export type prestamos_empleados_cobroFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados_cobro to fetch.
     */
    where: prestamos_empleados_cobroWhereUniqueInput
  }

  /**
   * prestamos_empleados_cobro findUnique
   */
  export interface prestamos_empleados_cobroFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_empleados_cobroFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_empleados_cobro findUniqueOrThrow
   */
  export type prestamos_empleados_cobroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados_cobro to fetch.
     */
    where: prestamos_empleados_cobroWhereUniqueInput
  }


  /**
   * prestamos_empleados_cobro base type for findFirst actions
   */
  export type prestamos_empleados_cobroFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados_cobro to fetch.
     */
    where?: prestamos_empleados_cobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados_cobros to fetch.
     */
    orderBy?: prestamos_empleados_cobroOrderByWithRelationInput | prestamos_empleados_cobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_empleados_cobros.
     */
    cursor?: prestamos_empleados_cobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados_cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados_cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_empleados_cobros.
     */
    distinct?: Prestamos_empleados_cobroScalarFieldEnum | Prestamos_empleados_cobroScalarFieldEnum[]
  }

  /**
   * prestamos_empleados_cobro findFirst
   */
  export interface prestamos_empleados_cobroFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_empleados_cobroFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_empleados_cobro findFirstOrThrow
   */
  export type prestamos_empleados_cobroFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados_cobro to fetch.
     */
    where?: prestamos_empleados_cobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados_cobros to fetch.
     */
    orderBy?: prestamos_empleados_cobroOrderByWithRelationInput | prestamos_empleados_cobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_empleados_cobros.
     */
    cursor?: prestamos_empleados_cobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados_cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados_cobros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_empleados_cobros.
     */
    distinct?: Prestamos_empleados_cobroScalarFieldEnum | Prestamos_empleados_cobroScalarFieldEnum[]
  }


  /**
   * prestamos_empleados_cobro findMany
   */
  export type prestamos_empleados_cobroFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_empleados_cobros to fetch.
     */
    where?: prestamos_empleados_cobroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_empleados_cobros to fetch.
     */
    orderBy?: prestamos_empleados_cobroOrderByWithRelationInput | prestamos_empleados_cobroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prestamos_empleados_cobros.
     */
    cursor?: prestamos_empleados_cobroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_empleados_cobros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_empleados_cobros.
     */
    skip?: number
    distinct?: Prestamos_empleados_cobroScalarFieldEnum | Prestamos_empleados_cobroScalarFieldEnum[]
  }


  /**
   * prestamos_empleados_cobro create
   */
  export type prestamos_empleados_cobroCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * The data needed to create a prestamos_empleados_cobro.
     */
    data?: XOR<prestamos_empleados_cobroCreateInput, prestamos_empleados_cobroUncheckedCreateInput>
  }


  /**
   * prestamos_empleados_cobro createMany
   */
  export type prestamos_empleados_cobroCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prestamos_empleados_cobros.
     */
    data: prestamos_empleados_cobroCreateManyInput | prestamos_empleados_cobroCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prestamos_empleados_cobro update
   */
  export type prestamos_empleados_cobroUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * The data needed to update a prestamos_empleados_cobro.
     */
    data: XOR<prestamos_empleados_cobroUpdateInput, prestamos_empleados_cobroUncheckedUpdateInput>
    /**
     * Choose, which prestamos_empleados_cobro to update.
     */
    where: prestamos_empleados_cobroWhereUniqueInput
  }


  /**
   * prestamos_empleados_cobro updateMany
   */
  export type prestamos_empleados_cobroUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prestamos_empleados_cobros.
     */
    data: XOR<prestamos_empleados_cobroUpdateManyMutationInput, prestamos_empleados_cobroUncheckedUpdateManyInput>
    /**
     * Filter which prestamos_empleados_cobros to update
     */
    where?: prestamos_empleados_cobroWhereInput
  }


  /**
   * prestamos_empleados_cobro upsert
   */
  export type prestamos_empleados_cobroUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * The filter to search for the prestamos_empleados_cobro to update in case it exists.
     */
    where: prestamos_empleados_cobroWhereUniqueInput
    /**
     * In case the prestamos_empleados_cobro found by the `where` argument doesn't exist, create a new prestamos_empleados_cobro with this data.
     */
    create: XOR<prestamos_empleados_cobroCreateInput, prestamos_empleados_cobroUncheckedCreateInput>
    /**
     * In case the prestamos_empleados_cobro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prestamos_empleados_cobroUpdateInput, prestamos_empleados_cobroUncheckedUpdateInput>
  }


  /**
   * prestamos_empleados_cobro delete
   */
  export type prestamos_empleados_cobroDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
    /**
     * Filter which prestamos_empleados_cobro to delete.
     */
    where: prestamos_empleados_cobroWhereUniqueInput
  }


  /**
   * prestamos_empleados_cobro deleteMany
   */
  export type prestamos_empleados_cobroDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_empleados_cobros to delete
     */
    where?: prestamos_empleados_cobroWhereInput
  }


  /**
   * prestamos_empleados_cobro without action
   */
  export type prestamos_empleados_cobroArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_empleados_cobro
     */
    select?: prestamos_empleados_cobroSelect<ExtArgs> | null
  }



  /**
   * Model produccion
   */


  export type AggregateProduccion = {
    _count: ProduccionCountAggregateOutputType | null
    _avg: ProduccionAvgAggregateOutputType | null
    _sum: ProduccionSumAggregateOutputType | null
    _min: ProduccionMinAggregateOutputType | null
    _max: ProduccionMaxAggregateOutputType | null
  }

  export type ProduccionAvgAggregateOutputType = {
    prod_ide: number | null
    prod_asesor: number | null
    prod_anio: number | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_cta_tar: number | null
    prod_semana: number | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_recibosis: number | null
  }

  export type ProduccionSumAggregateOutputType = {
    prod_ide: number | null
    prod_asesor: number | null
    prod_anio: number | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_cta_tar: bigint | null
    prod_semana: number | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_recibosis: number | null
  }

  export type ProduccionMinAggregateOutputType = {
    prod_ide: number | null
    prod_fechacarga: Date | null
    prod_fechaafi: Date | null
    prod_asesor: number | null
    prod_empre: string | null
    prod_mes: string | null
    prod_anio: number | null
    prod_apeafi: string | null
    prod_nomafi: string | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_plan: string | null
    prod_pago: string | null
    prod_cta_tar: bigint | null
    prod_obs: string | null
    prod_semana: number | null
    prod_estado: string | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_rendido: string | null
    prod_recibosis: number | null
    prod_fechren: Date | null
    prod_tel: string | null
  }

  export type ProduccionMaxAggregateOutputType = {
    prod_ide: number | null
    prod_fechacarga: Date | null
    prod_fechaafi: Date | null
    prod_asesor: number | null
    prod_empre: string | null
    prod_mes: string | null
    prod_anio: number | null
    prod_apeafi: string | null
    prod_nomafi: string | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_plan: string | null
    prod_pago: string | null
    prod_cta_tar: bigint | null
    prod_obs: string | null
    prod_semana: number | null
    prod_estado: string | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_rendido: string | null
    prod_recibosis: number | null
    prod_fechren: Date | null
    prod_tel: string | null
  }

  export type ProduccionCountAggregateOutputType = {
    prod_ide: number
    prod_fechacarga: number
    prod_fechaafi: number
    prod_asesor: number
    prod_empre: number
    prod_mes: number
    prod_anio: number
    prod_apeafi: number
    prod_nomafi: number
    prod_dniafi: number
    prod_local: number
    prod_recibo: number
    prod_monto: number
    prod_plan: number
    prod_pago: number
    prod_cta_tar: number
    prod_obs: number
    prod_semana: number
    prod_estado: number
    prod_cierre: number
    prod_afiliado: number
    prod_rendido: number
    prod_recibosis: number
    prod_fechren: number
    prod_tel: number
    _all: number
  }


  export type ProduccionAvgAggregateInputType = {
    prod_ide?: true
    prod_asesor?: true
    prod_anio?: true
    prod_dniafi?: true
    prod_local?: true
    prod_recibo?: true
    prod_monto?: true
    prod_cta_tar?: true
    prod_semana?: true
    prod_cierre?: true
    prod_afiliado?: true
    prod_recibosis?: true
  }

  export type ProduccionSumAggregateInputType = {
    prod_ide?: true
    prod_asesor?: true
    prod_anio?: true
    prod_dniafi?: true
    prod_local?: true
    prod_recibo?: true
    prod_monto?: true
    prod_cta_tar?: true
    prod_semana?: true
    prod_cierre?: true
    prod_afiliado?: true
    prod_recibosis?: true
  }

  export type ProduccionMinAggregateInputType = {
    prod_ide?: true
    prod_fechacarga?: true
    prod_fechaafi?: true
    prod_asesor?: true
    prod_empre?: true
    prod_mes?: true
    prod_anio?: true
    prod_apeafi?: true
    prod_nomafi?: true
    prod_dniafi?: true
    prod_local?: true
    prod_recibo?: true
    prod_monto?: true
    prod_plan?: true
    prod_pago?: true
    prod_cta_tar?: true
    prod_obs?: true
    prod_semana?: true
    prod_estado?: true
    prod_cierre?: true
    prod_afiliado?: true
    prod_rendido?: true
    prod_recibosis?: true
    prod_fechren?: true
    prod_tel?: true
  }

  export type ProduccionMaxAggregateInputType = {
    prod_ide?: true
    prod_fechacarga?: true
    prod_fechaafi?: true
    prod_asesor?: true
    prod_empre?: true
    prod_mes?: true
    prod_anio?: true
    prod_apeafi?: true
    prod_nomafi?: true
    prod_dniafi?: true
    prod_local?: true
    prod_recibo?: true
    prod_monto?: true
    prod_plan?: true
    prod_pago?: true
    prod_cta_tar?: true
    prod_obs?: true
    prod_semana?: true
    prod_estado?: true
    prod_cierre?: true
    prod_afiliado?: true
    prod_rendido?: true
    prod_recibosis?: true
    prod_fechren?: true
    prod_tel?: true
  }

  export type ProduccionCountAggregateInputType = {
    prod_ide?: true
    prod_fechacarga?: true
    prod_fechaafi?: true
    prod_asesor?: true
    prod_empre?: true
    prod_mes?: true
    prod_anio?: true
    prod_apeafi?: true
    prod_nomafi?: true
    prod_dniafi?: true
    prod_local?: true
    prod_recibo?: true
    prod_monto?: true
    prod_plan?: true
    prod_pago?: true
    prod_cta_tar?: true
    prod_obs?: true
    prod_semana?: true
    prod_estado?: true
    prod_cierre?: true
    prod_afiliado?: true
    prod_rendido?: true
    prod_recibosis?: true
    prod_fechren?: true
    prod_tel?: true
    _all?: true
  }

  export type ProduccionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produccion to aggregate.
     */
    where?: produccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produccions to fetch.
     */
    orderBy?: produccionOrderByWithRelationInput | produccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produccions
    **/
    _count?: true | ProduccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduccionMaxAggregateInputType
  }

  export type GetProduccionAggregateType<T extends ProduccionAggregateArgs> = {
        [P in keyof T & keyof AggregateProduccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduccion[P]>
      : GetScalarType<T[P], AggregateProduccion[P]>
  }




  export type produccionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: produccionWhereInput
    orderBy?: produccionOrderByWithAggregationInput | produccionOrderByWithAggregationInput[]
    by: ProduccionScalarFieldEnum[] | ProduccionScalarFieldEnum
    having?: produccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduccionCountAggregateInputType | true
    _avg?: ProduccionAvgAggregateInputType
    _sum?: ProduccionSumAggregateInputType
    _min?: ProduccionMinAggregateInputType
    _max?: ProduccionMaxAggregateInputType
  }


  export type ProduccionGroupByOutputType = {
    prod_ide: number
    prod_fechacarga: Date | null
    prod_fechaafi: Date | null
    prod_asesor: number | null
    prod_empre: string | null
    prod_mes: string | null
    prod_anio: number | null
    prod_apeafi: string | null
    prod_nomafi: string | null
    prod_dniafi: number | null
    prod_local: number | null
    prod_recibo: number | null
    prod_monto: number | null
    prod_plan: string | null
    prod_pago: string | null
    prod_cta_tar: bigint | null
    prod_obs: string | null
    prod_semana: number | null
    prod_estado: string | null
    prod_cierre: number | null
    prod_afiliado: number | null
    prod_rendido: string | null
    prod_recibosis: number | null
    prod_fechren: Date | null
    prod_tel: string | null
    _count: ProduccionCountAggregateOutputType | null
    _avg: ProduccionAvgAggregateOutputType | null
    _sum: ProduccionSumAggregateOutputType | null
    _min: ProduccionMinAggregateOutputType | null
    _max: ProduccionMaxAggregateOutputType | null
  }

  type GetProduccionGroupByPayload<T extends produccionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduccionGroupByOutputType[P]>
            : GetScalarType<T[P], ProduccionGroupByOutputType[P]>
        }
      >
    >


  export type produccionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prod_ide?: boolean
    prod_fechacarga?: boolean
    prod_fechaafi?: boolean
    prod_asesor?: boolean
    prod_empre?: boolean
    prod_mes?: boolean
    prod_anio?: boolean
    prod_apeafi?: boolean
    prod_nomafi?: boolean
    prod_dniafi?: boolean
    prod_local?: boolean
    prod_recibo?: boolean
    prod_monto?: boolean
    prod_plan?: boolean
    prod_pago?: boolean
    prod_cta_tar?: boolean
    prod_obs?: boolean
    prod_semana?: boolean
    prod_estado?: boolean
    prod_cierre?: boolean
    prod_afiliado?: boolean
    prod_rendido?: boolean
    prod_recibosis?: boolean
    prod_fechren?: boolean
    prod_tel?: boolean
  }, ExtArgs["result"]["produccion"]>

  export type produccionSelectScalar = {
    prod_ide?: boolean
    prod_fechacarga?: boolean
    prod_fechaafi?: boolean
    prod_asesor?: boolean
    prod_empre?: boolean
    prod_mes?: boolean
    prod_anio?: boolean
    prod_apeafi?: boolean
    prod_nomafi?: boolean
    prod_dniafi?: boolean
    prod_local?: boolean
    prod_recibo?: boolean
    prod_monto?: boolean
    prod_plan?: boolean
    prod_pago?: boolean
    prod_cta_tar?: boolean
    prod_obs?: boolean
    prod_semana?: boolean
    prod_estado?: boolean
    prod_cierre?: boolean
    prod_afiliado?: boolean
    prod_rendido?: boolean
    prod_recibosis?: boolean
    prod_fechren?: boolean
    prod_tel?: boolean
  }


  type produccionGetPayload<S extends boolean | null | undefined | produccionArgs> = $Types.GetResult<produccionPayload, S>

  type produccionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<produccionFindManyArgs, 'select' | 'include'> & {
      select?: ProduccionCountAggregateInputType | true
    }

  export interface produccionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produccion'], meta: { name: 'produccion' } }
    /**
     * Find zero or one Produccion that matches the filter.
     * @param {produccionFindUniqueArgs} args - Arguments to find a Produccion
     * @example
     * // Get one Produccion
     * const produccion = await prisma.produccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends produccionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, produccionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'produccion'> extends True ? Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Produccion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {produccionFindUniqueOrThrowArgs} args - Arguments to find a Produccion
     * @example
     * // Get one Produccion
     * const produccion = await prisma.produccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends produccionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produccionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Produccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionFindFirstArgs} args - Arguments to find a Produccion
     * @example
     * // Get one Produccion
     * const produccion = await prisma.produccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends produccionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, produccionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'produccion'> extends True ? Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Produccion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionFindFirstOrThrowArgs} args - Arguments to find a Produccion
     * @example
     * // Get one Produccion
     * const produccion = await prisma.produccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends produccionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, produccionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Produccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produccions
     * const produccions = await prisma.produccion.findMany()
     * 
     * // Get first 10 Produccions
     * const produccions = await prisma.produccion.findMany({ take: 10 })
     * 
     * // Only select the `prod_ide`
     * const produccionWithProd_ideOnly = await prisma.produccion.findMany({ select: { prod_ide: true } })
     * 
    **/
    findMany<T extends produccionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produccionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<produccionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Produccion.
     * @param {produccionCreateArgs} args - Arguments to create a Produccion.
     * @example
     * // Create one Produccion
     * const Produccion = await prisma.produccion.create({
     *   data: {
     *     // ... data to create a Produccion
     *   }
     * })
     * 
    **/
    create<T extends produccionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, produccionCreateArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Produccions.
     *     @param {produccionCreateManyArgs} args - Arguments to create many Produccions.
     *     @example
     *     // Create many Produccions
     *     const produccion = await prisma.produccion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends produccionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produccionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produccion.
     * @param {produccionDeleteArgs} args - Arguments to delete one Produccion.
     * @example
     * // Delete one Produccion
     * const Produccion = await prisma.produccion.delete({
     *   where: {
     *     // ... filter to delete one Produccion
     *   }
     * })
     * 
    **/
    delete<T extends produccionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, produccionDeleteArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Produccion.
     * @param {produccionUpdateArgs} args - Arguments to update one Produccion.
     * @example
     * // Update one Produccion
     * const produccion = await prisma.produccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends produccionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, produccionUpdateArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Produccions.
     * @param {produccionDeleteManyArgs} args - Arguments to filter Produccions to delete.
     * @example
     * // Delete a few Produccions
     * const { count } = await prisma.produccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends produccionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, produccionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produccions
     * const produccion = await prisma.produccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends produccionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, produccionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produccion.
     * @param {produccionUpsertArgs} args - Arguments to update or create a Produccion.
     * @example
     * // Update or create a Produccion
     * const produccion = await prisma.produccion.upsert({
     *   create: {
     *     // ... data to create a Produccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produccion we want to update
     *   }
     * })
    **/
    upsert<T extends produccionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, produccionUpsertArgs<ExtArgs>>
    ): Prisma__produccionClient<$Types.GetResult<produccionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Produccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionCountArgs} args - Arguments to filter Produccions to count.
     * @example
     * // Count the number of Produccions
     * const count = await prisma.produccion.count({
     *   where: {
     *     // ... the filter for the Produccions we want to count
     *   }
     * })
    **/
    count<T extends produccionCountArgs>(
      args?: Subset<T, produccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduccionAggregateArgs>(args: Subset<T, ProduccionAggregateArgs>): Prisma.PrismaPromise<GetProduccionAggregateType<T>>

    /**
     * Group by Produccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produccionGroupByArgs['orderBy'] }
        : { orderBy?: produccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduccionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for produccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__produccionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * produccion base type for findUnique actions
   */
  export type produccionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter, which produccion to fetch.
     */
    where: produccionWhereUniqueInput
  }

  /**
   * produccion findUnique
   */
  export interface produccionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends produccionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * produccion findUniqueOrThrow
   */
  export type produccionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter, which produccion to fetch.
     */
    where: produccionWhereUniqueInput
  }


  /**
   * produccion base type for findFirst actions
   */
  export type produccionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter, which produccion to fetch.
     */
    where?: produccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produccions to fetch.
     */
    orderBy?: produccionOrderByWithRelationInput | produccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produccions.
     */
    cursor?: produccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produccions.
     */
    distinct?: ProduccionScalarFieldEnum | ProduccionScalarFieldEnum[]
  }

  /**
   * produccion findFirst
   */
  export interface produccionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends produccionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * produccion findFirstOrThrow
   */
  export type produccionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter, which produccion to fetch.
     */
    where?: produccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produccions to fetch.
     */
    orderBy?: produccionOrderByWithRelationInput | produccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produccions.
     */
    cursor?: produccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produccions.
     */
    distinct?: ProduccionScalarFieldEnum | ProduccionScalarFieldEnum[]
  }


  /**
   * produccion findMany
   */
  export type produccionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter, which produccions to fetch.
     */
    where?: produccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produccions to fetch.
     */
    orderBy?: produccionOrderByWithRelationInput | produccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produccions.
     */
    cursor?: produccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produccions.
     */
    skip?: number
    distinct?: ProduccionScalarFieldEnum | ProduccionScalarFieldEnum[]
  }


  /**
   * produccion create
   */
  export type produccionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * The data needed to create a produccion.
     */
    data?: XOR<produccionCreateInput, produccionUncheckedCreateInput>
  }


  /**
   * produccion createMany
   */
  export type produccionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produccions.
     */
    data: produccionCreateManyInput | produccionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * produccion update
   */
  export type produccionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * The data needed to update a produccion.
     */
    data: XOR<produccionUpdateInput, produccionUncheckedUpdateInput>
    /**
     * Choose, which produccion to update.
     */
    where: produccionWhereUniqueInput
  }


  /**
   * produccion updateMany
   */
  export type produccionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produccions.
     */
    data: XOR<produccionUpdateManyMutationInput, produccionUncheckedUpdateManyInput>
    /**
     * Filter which produccions to update
     */
    where?: produccionWhereInput
  }


  /**
   * produccion upsert
   */
  export type produccionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * The filter to search for the produccion to update in case it exists.
     */
    where: produccionWhereUniqueInput
    /**
     * In case the produccion found by the `where` argument doesn't exist, create a new produccion with this data.
     */
    create: XOR<produccionCreateInput, produccionUncheckedCreateInput>
    /**
     * In case the produccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produccionUpdateInput, produccionUncheckedUpdateInput>
  }


  /**
   * produccion delete
   */
  export type produccionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
    /**
     * Filter which produccion to delete.
     */
    where: produccionWhereUniqueInput
  }


  /**
   * produccion deleteMany
   */
  export type produccionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which produccions to delete
     */
    where?: produccionWhereInput
  }


  /**
   * produccion without action
   */
  export type produccionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produccion
     */
    select?: produccionSelect<ExtArgs> | null
  }



  /**
   * Model registro_constancia_afiliacion
   */


  export type AggregateRegistro_constancia_afiliacion = {
    _count: Registro_constancia_afiliacionCountAggregateOutputType | null
    _avg: Registro_constancia_afiliacionAvgAggregateOutputType | null
    _sum: Registro_constancia_afiliacionSumAggregateOutputType | null
    _min: Registro_constancia_afiliacionMinAggregateOutputType | null
    _max: Registro_constancia_afiliacionMaxAggregateOutputType | null
  }

  export type Registro_constancia_afiliacionAvgAggregateOutputType = {
    idconstancia: number | null
    dni_extinto: number | null
    idservicio: number | null
  }

  export type Registro_constancia_afiliacionSumAggregateOutputType = {
    idconstancia: number | null
    dni_extinto: number | null
    idservicio: number | null
  }

  export type Registro_constancia_afiliacionMinAggregateOutputType = {
    idconstancia: number | null
    apellido_extinto: string | null
    nombre_extinto: string | null
    dni_extinto: number | null
    apellido_soli: string | null
    nombre_soli: string | null
    dni_soli: string | null
    lugar_presentacion: string | null
    fecha: Date | null
    operador: string | null
    idservicio: number | null
  }

  export type Registro_constancia_afiliacionMaxAggregateOutputType = {
    idconstancia: number | null
    apellido_extinto: string | null
    nombre_extinto: string | null
    dni_extinto: number | null
    apellido_soli: string | null
    nombre_soli: string | null
    dni_soli: string | null
    lugar_presentacion: string | null
    fecha: Date | null
    operador: string | null
    idservicio: number | null
  }

  export type Registro_constancia_afiliacionCountAggregateOutputType = {
    idconstancia: number
    apellido_extinto: number
    nombre_extinto: number
    dni_extinto: number
    apellido_soli: number
    nombre_soli: number
    dni_soli: number
    lugar_presentacion: number
    fecha: number
    operador: number
    idservicio: number
    _all: number
  }


  export type Registro_constancia_afiliacionAvgAggregateInputType = {
    idconstancia?: true
    dni_extinto?: true
    idservicio?: true
  }

  export type Registro_constancia_afiliacionSumAggregateInputType = {
    idconstancia?: true
    dni_extinto?: true
    idservicio?: true
  }

  export type Registro_constancia_afiliacionMinAggregateInputType = {
    idconstancia?: true
    apellido_extinto?: true
    nombre_extinto?: true
    dni_extinto?: true
    apellido_soli?: true
    nombre_soli?: true
    dni_soli?: true
    lugar_presentacion?: true
    fecha?: true
    operador?: true
    idservicio?: true
  }

  export type Registro_constancia_afiliacionMaxAggregateInputType = {
    idconstancia?: true
    apellido_extinto?: true
    nombre_extinto?: true
    dni_extinto?: true
    apellido_soli?: true
    nombre_soli?: true
    dni_soli?: true
    lugar_presentacion?: true
    fecha?: true
    operador?: true
    idservicio?: true
  }

  export type Registro_constancia_afiliacionCountAggregateInputType = {
    idconstancia?: true
    apellido_extinto?: true
    nombre_extinto?: true
    dni_extinto?: true
    apellido_soli?: true
    nombre_soli?: true
    dni_soli?: true
    lugar_presentacion?: true
    fecha?: true
    operador?: true
    idservicio?: true
    _all?: true
  }

  export type Registro_constancia_afiliacionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which registro_constancia_afiliacion to aggregate.
     */
    where?: registro_constancia_afiliacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registro_constancia_afiliacions to fetch.
     */
    orderBy?: registro_constancia_afiliacionOrderByWithRelationInput | registro_constancia_afiliacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: registro_constancia_afiliacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registro_constancia_afiliacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registro_constancia_afiliacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned registro_constancia_afiliacions
    **/
    _count?: true | Registro_constancia_afiliacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Registro_constancia_afiliacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Registro_constancia_afiliacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Registro_constancia_afiliacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Registro_constancia_afiliacionMaxAggregateInputType
  }

  export type GetRegistro_constancia_afiliacionAggregateType<T extends Registro_constancia_afiliacionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistro_constancia_afiliacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistro_constancia_afiliacion[P]>
      : GetScalarType<T[P], AggregateRegistro_constancia_afiliacion[P]>
  }




  export type registro_constancia_afiliacionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: registro_constancia_afiliacionWhereInput
    orderBy?: registro_constancia_afiliacionOrderByWithAggregationInput | registro_constancia_afiliacionOrderByWithAggregationInput[]
    by: Registro_constancia_afiliacionScalarFieldEnum[] | Registro_constancia_afiliacionScalarFieldEnum
    having?: registro_constancia_afiliacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Registro_constancia_afiliacionCountAggregateInputType | true
    _avg?: Registro_constancia_afiliacionAvgAggregateInputType
    _sum?: Registro_constancia_afiliacionSumAggregateInputType
    _min?: Registro_constancia_afiliacionMinAggregateInputType
    _max?: Registro_constancia_afiliacionMaxAggregateInputType
  }


  export type Registro_constancia_afiliacionGroupByOutputType = {
    idconstancia: number
    apellido_extinto: string | null
    nombre_extinto: string | null
    dni_extinto: number | null
    apellido_soli: string | null
    nombre_soli: string | null
    dni_soli: string | null
    lugar_presentacion: string | null
    fecha: Date | null
    operador: string | null
    idservicio: number | null
    _count: Registro_constancia_afiliacionCountAggregateOutputType | null
    _avg: Registro_constancia_afiliacionAvgAggregateOutputType | null
    _sum: Registro_constancia_afiliacionSumAggregateOutputType | null
    _min: Registro_constancia_afiliacionMinAggregateOutputType | null
    _max: Registro_constancia_afiliacionMaxAggregateOutputType | null
  }

  type GetRegistro_constancia_afiliacionGroupByPayload<T extends registro_constancia_afiliacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Registro_constancia_afiliacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Registro_constancia_afiliacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Registro_constancia_afiliacionGroupByOutputType[P]>
            : GetScalarType<T[P], Registro_constancia_afiliacionGroupByOutputType[P]>
        }
      >
    >


  export type registro_constancia_afiliacionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconstancia?: boolean
    apellido_extinto?: boolean
    nombre_extinto?: boolean
    dni_extinto?: boolean
    apellido_soli?: boolean
    nombre_soli?: boolean
    dni_soli?: boolean
    lugar_presentacion?: boolean
    fecha?: boolean
    operador?: boolean
    idservicio?: boolean
  }, ExtArgs["result"]["registro_constancia_afiliacion"]>

  export type registro_constancia_afiliacionSelectScalar = {
    idconstancia?: boolean
    apellido_extinto?: boolean
    nombre_extinto?: boolean
    dni_extinto?: boolean
    apellido_soli?: boolean
    nombre_soli?: boolean
    dni_soli?: boolean
    lugar_presentacion?: boolean
    fecha?: boolean
    operador?: boolean
    idservicio?: boolean
  }


  type registro_constancia_afiliacionGetPayload<S extends boolean | null | undefined | registro_constancia_afiliacionArgs> = $Types.GetResult<registro_constancia_afiliacionPayload, S>

  type registro_constancia_afiliacionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<registro_constancia_afiliacionFindManyArgs, 'select' | 'include'> & {
      select?: Registro_constancia_afiliacionCountAggregateInputType | true
    }

  export interface registro_constancia_afiliacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['registro_constancia_afiliacion'], meta: { name: 'registro_constancia_afiliacion' } }
    /**
     * Find zero or one Registro_constancia_afiliacion that matches the filter.
     * @param {registro_constancia_afiliacionFindUniqueArgs} args - Arguments to find a Registro_constancia_afiliacion
     * @example
     * // Get one Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends registro_constancia_afiliacionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, registro_constancia_afiliacionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'registro_constancia_afiliacion'> extends True ? Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Registro_constancia_afiliacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {registro_constancia_afiliacionFindUniqueOrThrowArgs} args - Arguments to find a Registro_constancia_afiliacion
     * @example
     * // Get one Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends registro_constancia_afiliacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, registro_constancia_afiliacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Registro_constancia_afiliacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionFindFirstArgs} args - Arguments to find a Registro_constancia_afiliacion
     * @example
     * // Get one Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends registro_constancia_afiliacionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, registro_constancia_afiliacionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'registro_constancia_afiliacion'> extends True ? Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Registro_constancia_afiliacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionFindFirstOrThrowArgs} args - Arguments to find a Registro_constancia_afiliacion
     * @example
     * // Get one Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends registro_constancia_afiliacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, registro_constancia_afiliacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Registro_constancia_afiliacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Registro_constancia_afiliacions
     * const registro_constancia_afiliacions = await prisma.registro_constancia_afiliacion.findMany()
     * 
     * // Get first 10 Registro_constancia_afiliacions
     * const registro_constancia_afiliacions = await prisma.registro_constancia_afiliacion.findMany({ take: 10 })
     * 
     * // Only select the `idconstancia`
     * const registro_constancia_afiliacionWithIdconstanciaOnly = await prisma.registro_constancia_afiliacion.findMany({ select: { idconstancia: true } })
     * 
    **/
    findMany<T extends registro_constancia_afiliacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registro_constancia_afiliacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Registro_constancia_afiliacion.
     * @param {registro_constancia_afiliacionCreateArgs} args - Arguments to create a Registro_constancia_afiliacion.
     * @example
     * // Create one Registro_constancia_afiliacion
     * const Registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.create({
     *   data: {
     *     // ... data to create a Registro_constancia_afiliacion
     *   }
     * })
     * 
    **/
    create<T extends registro_constancia_afiliacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, registro_constancia_afiliacionCreateArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Registro_constancia_afiliacions.
     *     @param {registro_constancia_afiliacionCreateManyArgs} args - Arguments to create many Registro_constancia_afiliacions.
     *     @example
     *     // Create many Registro_constancia_afiliacions
     *     const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends registro_constancia_afiliacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registro_constancia_afiliacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Registro_constancia_afiliacion.
     * @param {registro_constancia_afiliacionDeleteArgs} args - Arguments to delete one Registro_constancia_afiliacion.
     * @example
     * // Delete one Registro_constancia_afiliacion
     * const Registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.delete({
     *   where: {
     *     // ... filter to delete one Registro_constancia_afiliacion
     *   }
     * })
     * 
    **/
    delete<T extends registro_constancia_afiliacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, registro_constancia_afiliacionDeleteArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Registro_constancia_afiliacion.
     * @param {registro_constancia_afiliacionUpdateArgs} args - Arguments to update one Registro_constancia_afiliacion.
     * @example
     * // Update one Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends registro_constancia_afiliacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, registro_constancia_afiliacionUpdateArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Registro_constancia_afiliacions.
     * @param {registro_constancia_afiliacionDeleteManyArgs} args - Arguments to filter Registro_constancia_afiliacions to delete.
     * @example
     * // Delete a few Registro_constancia_afiliacions
     * const { count } = await prisma.registro_constancia_afiliacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends registro_constancia_afiliacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, registro_constancia_afiliacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Registro_constancia_afiliacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Registro_constancia_afiliacions
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends registro_constancia_afiliacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, registro_constancia_afiliacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Registro_constancia_afiliacion.
     * @param {registro_constancia_afiliacionUpsertArgs} args - Arguments to update or create a Registro_constancia_afiliacion.
     * @example
     * // Update or create a Registro_constancia_afiliacion
     * const registro_constancia_afiliacion = await prisma.registro_constancia_afiliacion.upsert({
     *   create: {
     *     // ... data to create a Registro_constancia_afiliacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Registro_constancia_afiliacion we want to update
     *   }
     * })
    **/
    upsert<T extends registro_constancia_afiliacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, registro_constancia_afiliacionUpsertArgs<ExtArgs>>
    ): Prisma__registro_constancia_afiliacionClient<$Types.GetResult<registro_constancia_afiliacionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Registro_constancia_afiliacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionCountArgs} args - Arguments to filter Registro_constancia_afiliacions to count.
     * @example
     * // Count the number of Registro_constancia_afiliacions
     * const count = await prisma.registro_constancia_afiliacion.count({
     *   where: {
     *     // ... the filter for the Registro_constancia_afiliacions we want to count
     *   }
     * })
    **/
    count<T extends registro_constancia_afiliacionCountArgs>(
      args?: Subset<T, registro_constancia_afiliacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Registro_constancia_afiliacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Registro_constancia_afiliacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Registro_constancia_afiliacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Registro_constancia_afiliacionAggregateArgs>(args: Subset<T, Registro_constancia_afiliacionAggregateArgs>): Prisma.PrismaPromise<GetRegistro_constancia_afiliacionAggregateType<T>>

    /**
     * Group by Registro_constancia_afiliacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {registro_constancia_afiliacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends registro_constancia_afiliacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: registro_constancia_afiliacionGroupByArgs['orderBy'] }
        : { orderBy?: registro_constancia_afiliacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, registro_constancia_afiliacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistro_constancia_afiliacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for registro_constancia_afiliacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__registro_constancia_afiliacionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * registro_constancia_afiliacion base type for findUnique actions
   */
  export type registro_constancia_afiliacionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter, which registro_constancia_afiliacion to fetch.
     */
    where: registro_constancia_afiliacionWhereUniqueInput
  }

  /**
   * registro_constancia_afiliacion findUnique
   */
  export interface registro_constancia_afiliacionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends registro_constancia_afiliacionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * registro_constancia_afiliacion findUniqueOrThrow
   */
  export type registro_constancia_afiliacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter, which registro_constancia_afiliacion to fetch.
     */
    where: registro_constancia_afiliacionWhereUniqueInput
  }


  /**
   * registro_constancia_afiliacion base type for findFirst actions
   */
  export type registro_constancia_afiliacionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter, which registro_constancia_afiliacion to fetch.
     */
    where?: registro_constancia_afiliacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registro_constancia_afiliacions to fetch.
     */
    orderBy?: registro_constancia_afiliacionOrderByWithRelationInput | registro_constancia_afiliacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for registro_constancia_afiliacions.
     */
    cursor?: registro_constancia_afiliacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registro_constancia_afiliacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registro_constancia_afiliacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of registro_constancia_afiliacions.
     */
    distinct?: Registro_constancia_afiliacionScalarFieldEnum | Registro_constancia_afiliacionScalarFieldEnum[]
  }

  /**
   * registro_constancia_afiliacion findFirst
   */
  export interface registro_constancia_afiliacionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends registro_constancia_afiliacionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * registro_constancia_afiliacion findFirstOrThrow
   */
  export type registro_constancia_afiliacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter, which registro_constancia_afiliacion to fetch.
     */
    where?: registro_constancia_afiliacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registro_constancia_afiliacions to fetch.
     */
    orderBy?: registro_constancia_afiliacionOrderByWithRelationInput | registro_constancia_afiliacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for registro_constancia_afiliacions.
     */
    cursor?: registro_constancia_afiliacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registro_constancia_afiliacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registro_constancia_afiliacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of registro_constancia_afiliacions.
     */
    distinct?: Registro_constancia_afiliacionScalarFieldEnum | Registro_constancia_afiliacionScalarFieldEnum[]
  }


  /**
   * registro_constancia_afiliacion findMany
   */
  export type registro_constancia_afiliacionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter, which registro_constancia_afiliacions to fetch.
     */
    where?: registro_constancia_afiliacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of registro_constancia_afiliacions to fetch.
     */
    orderBy?: registro_constancia_afiliacionOrderByWithRelationInput | registro_constancia_afiliacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing registro_constancia_afiliacions.
     */
    cursor?: registro_constancia_afiliacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` registro_constancia_afiliacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` registro_constancia_afiliacions.
     */
    skip?: number
    distinct?: Registro_constancia_afiliacionScalarFieldEnum | Registro_constancia_afiliacionScalarFieldEnum[]
  }


  /**
   * registro_constancia_afiliacion create
   */
  export type registro_constancia_afiliacionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * The data needed to create a registro_constancia_afiliacion.
     */
    data?: XOR<registro_constancia_afiliacionCreateInput, registro_constancia_afiliacionUncheckedCreateInput>
  }


  /**
   * registro_constancia_afiliacion createMany
   */
  export type registro_constancia_afiliacionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many registro_constancia_afiliacions.
     */
    data: registro_constancia_afiliacionCreateManyInput | registro_constancia_afiliacionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * registro_constancia_afiliacion update
   */
  export type registro_constancia_afiliacionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * The data needed to update a registro_constancia_afiliacion.
     */
    data: XOR<registro_constancia_afiliacionUpdateInput, registro_constancia_afiliacionUncheckedUpdateInput>
    /**
     * Choose, which registro_constancia_afiliacion to update.
     */
    where: registro_constancia_afiliacionWhereUniqueInput
  }


  /**
   * registro_constancia_afiliacion updateMany
   */
  export type registro_constancia_afiliacionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update registro_constancia_afiliacions.
     */
    data: XOR<registro_constancia_afiliacionUpdateManyMutationInput, registro_constancia_afiliacionUncheckedUpdateManyInput>
    /**
     * Filter which registro_constancia_afiliacions to update
     */
    where?: registro_constancia_afiliacionWhereInput
  }


  /**
   * registro_constancia_afiliacion upsert
   */
  export type registro_constancia_afiliacionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * The filter to search for the registro_constancia_afiliacion to update in case it exists.
     */
    where: registro_constancia_afiliacionWhereUniqueInput
    /**
     * In case the registro_constancia_afiliacion found by the `where` argument doesn't exist, create a new registro_constancia_afiliacion with this data.
     */
    create: XOR<registro_constancia_afiliacionCreateInput, registro_constancia_afiliacionUncheckedCreateInput>
    /**
     * In case the registro_constancia_afiliacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<registro_constancia_afiliacionUpdateInput, registro_constancia_afiliacionUncheckedUpdateInput>
  }


  /**
   * registro_constancia_afiliacion delete
   */
  export type registro_constancia_afiliacionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
    /**
     * Filter which registro_constancia_afiliacion to delete.
     */
    where: registro_constancia_afiliacionWhereUniqueInput
  }


  /**
   * registro_constancia_afiliacion deleteMany
   */
  export type registro_constancia_afiliacionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which registro_constancia_afiliacions to delete
     */
    where?: registro_constancia_afiliacionWhereInput
  }


  /**
   * registro_constancia_afiliacion without action
   */
  export type registro_constancia_afiliacionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the registro_constancia_afiliacion
     */
    select?: registro_constancia_afiliacionSelect<ExtArgs> | null
  }



  /**
   * Model rehabilitaciones
   */


  export type AggregateRehabilitaciones = {
    _count: RehabilitacionesCountAggregateOutputType | null
    _avg: RehabilitacionesAvgAggregateOutputType | null
    _sum: RehabilitacionesSumAggregateOutputType | null
    _min: RehabilitacionesMinAggregateOutputType | null
    _max: RehabilitacionesMaxAggregateOutputType | null
  }

  export type RehabilitacionesAvgAggregateOutputType = {
    idrehab: number | null
    cuotas: number | null
    dni: number | null
    idoperador: number | null
  }

  export type RehabilitacionesSumAggregateOutputType = {
    idrehab: number | null
    cuotas: number | null
    dni: number | null
    idoperador: number | null
  }

  export type RehabilitacionesMinAggregateOutputType = {
    idrehab: number | null
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
  }

  export type RehabilitacionesMaxAggregateOutputType = {
    idrehab: number | null
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
  }

  export type RehabilitacionesCountAggregateOutputType = {
    idrehab: number
    contrato: number
    apellido: number
    nombre: number
    operador: number
    vigencia: number
    fecha: number
    cuotas: number
    dni: number
    empresa: number
    idoperador: number
    _all: number
  }


  export type RehabilitacionesAvgAggregateInputType = {
    idrehab?: true
    cuotas?: true
    dni?: true
    idoperador?: true
  }

  export type RehabilitacionesSumAggregateInputType = {
    idrehab?: true
    cuotas?: true
    dni?: true
    idoperador?: true
  }

  export type RehabilitacionesMinAggregateInputType = {
    idrehab?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
  }

  export type RehabilitacionesMaxAggregateInputType = {
    idrehab?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
  }

  export type RehabilitacionesCountAggregateInputType = {
    idrehab?: true
    contrato?: true
    apellido?: true
    nombre?: true
    operador?: true
    vigencia?: true
    fecha?: true
    cuotas?: true
    dni?: true
    empresa?: true
    idoperador?: true
    _all?: true
  }

  export type RehabilitacionesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rehabilitaciones to aggregate.
     */
    where?: rehabilitacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rehabilitaciones to fetch.
     */
    orderBy?: rehabilitacionesOrderByWithRelationInput | rehabilitacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rehabilitacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rehabilitaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rehabilitaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rehabilitaciones
    **/
    _count?: true | RehabilitacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RehabilitacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RehabilitacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RehabilitacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RehabilitacionesMaxAggregateInputType
  }

  export type GetRehabilitacionesAggregateType<T extends RehabilitacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateRehabilitaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRehabilitaciones[P]>
      : GetScalarType<T[P], AggregateRehabilitaciones[P]>
  }




  export type rehabilitacionesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rehabilitacionesWhereInput
    orderBy?: rehabilitacionesOrderByWithAggregationInput | rehabilitacionesOrderByWithAggregationInput[]
    by: RehabilitacionesScalarFieldEnum[] | RehabilitacionesScalarFieldEnum
    having?: rehabilitacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RehabilitacionesCountAggregateInputType | true
    _avg?: RehabilitacionesAvgAggregateInputType
    _sum?: RehabilitacionesSumAggregateInputType
    _min?: RehabilitacionesMinAggregateInputType
    _max?: RehabilitacionesMaxAggregateInputType
  }


  export type RehabilitacionesGroupByOutputType = {
    idrehab: number
    contrato: string | null
    apellido: string | null
    nombre: string | null
    operador: string | null
    vigencia: Date | null
    fecha: Date | null
    cuotas: number | null
    dni: number | null
    empresa: string | null
    idoperador: number | null
    _count: RehabilitacionesCountAggregateOutputType | null
    _avg: RehabilitacionesAvgAggregateOutputType | null
    _sum: RehabilitacionesSumAggregateOutputType | null
    _min: RehabilitacionesMinAggregateOutputType | null
    _max: RehabilitacionesMaxAggregateOutputType | null
  }

  type GetRehabilitacionesGroupByPayload<T extends rehabilitacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RehabilitacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RehabilitacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RehabilitacionesGroupByOutputType[P]>
            : GetScalarType<T[P], RehabilitacionesGroupByOutputType[P]>
        }
      >
    >


  export type rehabilitacionesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idrehab?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    operador?: boolean
    vigencia?: boolean
    fecha?: boolean
    cuotas?: boolean
    dni?: boolean
    empresa?: boolean
    idoperador?: boolean
  }, ExtArgs["result"]["rehabilitaciones"]>

  export type rehabilitacionesSelectScalar = {
    idrehab?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    operador?: boolean
    vigencia?: boolean
    fecha?: boolean
    cuotas?: boolean
    dni?: boolean
    empresa?: boolean
    idoperador?: boolean
  }


  type rehabilitacionesGetPayload<S extends boolean | null | undefined | rehabilitacionesArgs> = $Types.GetResult<rehabilitacionesPayload, S>

  type rehabilitacionesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<rehabilitacionesFindManyArgs, 'select' | 'include'> & {
      select?: RehabilitacionesCountAggregateInputType | true
    }

  export interface rehabilitacionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rehabilitaciones'], meta: { name: 'rehabilitaciones' } }
    /**
     * Find zero or one Rehabilitaciones that matches the filter.
     * @param {rehabilitacionesFindUniqueArgs} args - Arguments to find a Rehabilitaciones
     * @example
     * // Get one Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rehabilitacionesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rehabilitacionesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rehabilitaciones'> extends True ? Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Rehabilitaciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rehabilitacionesFindUniqueOrThrowArgs} args - Arguments to find a Rehabilitaciones
     * @example
     * // Get one Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rehabilitacionesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rehabilitacionesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Rehabilitaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesFindFirstArgs} args - Arguments to find a Rehabilitaciones
     * @example
     * // Get one Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rehabilitacionesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rehabilitacionesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rehabilitaciones'> extends True ? Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Rehabilitaciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesFindFirstOrThrowArgs} args - Arguments to find a Rehabilitaciones
     * @example
     * // Get one Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rehabilitacionesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rehabilitacionesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Rehabilitaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findMany()
     * 
     * // Get first 10 Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.findMany({ take: 10 })
     * 
     * // Only select the `idrehab`
     * const rehabilitacionesWithIdrehabOnly = await prisma.rehabilitaciones.findMany({ select: { idrehab: true } })
     * 
    **/
    findMany<T extends rehabilitacionesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rehabilitacionesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Rehabilitaciones.
     * @param {rehabilitacionesCreateArgs} args - Arguments to create a Rehabilitaciones.
     * @example
     * // Create one Rehabilitaciones
     * const Rehabilitaciones = await prisma.rehabilitaciones.create({
     *   data: {
     *     // ... data to create a Rehabilitaciones
     *   }
     * })
     * 
    **/
    create<T extends rehabilitacionesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rehabilitacionesCreateArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Rehabilitaciones.
     *     @param {rehabilitacionesCreateManyArgs} args - Arguments to create many Rehabilitaciones.
     *     @example
     *     // Create many Rehabilitaciones
     *     const rehabilitaciones = await prisma.rehabilitaciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rehabilitacionesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rehabilitacionesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rehabilitaciones.
     * @param {rehabilitacionesDeleteArgs} args - Arguments to delete one Rehabilitaciones.
     * @example
     * // Delete one Rehabilitaciones
     * const Rehabilitaciones = await prisma.rehabilitaciones.delete({
     *   where: {
     *     // ... filter to delete one Rehabilitaciones
     *   }
     * })
     * 
    **/
    delete<T extends rehabilitacionesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rehabilitacionesDeleteArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Rehabilitaciones.
     * @param {rehabilitacionesUpdateArgs} args - Arguments to update one Rehabilitaciones.
     * @example
     * // Update one Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rehabilitacionesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rehabilitacionesUpdateArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Rehabilitaciones.
     * @param {rehabilitacionesDeleteManyArgs} args - Arguments to filter Rehabilitaciones to delete.
     * @example
     * // Delete a few Rehabilitaciones
     * const { count } = await prisma.rehabilitaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rehabilitacionesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rehabilitacionesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rehabilitaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rehabilitacionesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rehabilitacionesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rehabilitaciones.
     * @param {rehabilitacionesUpsertArgs} args - Arguments to update or create a Rehabilitaciones.
     * @example
     * // Update or create a Rehabilitaciones
     * const rehabilitaciones = await prisma.rehabilitaciones.upsert({
     *   create: {
     *     // ... data to create a Rehabilitaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rehabilitaciones we want to update
     *   }
     * })
    **/
    upsert<T extends rehabilitacionesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rehabilitacionesUpsertArgs<ExtArgs>>
    ): Prisma__rehabilitacionesClient<$Types.GetResult<rehabilitacionesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Rehabilitaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesCountArgs} args - Arguments to filter Rehabilitaciones to count.
     * @example
     * // Count the number of Rehabilitaciones
     * const count = await prisma.rehabilitaciones.count({
     *   where: {
     *     // ... the filter for the Rehabilitaciones we want to count
     *   }
     * })
    **/
    count<T extends rehabilitacionesCountArgs>(
      args?: Subset<T, rehabilitacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RehabilitacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rehabilitaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RehabilitacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RehabilitacionesAggregateArgs>(args: Subset<T, RehabilitacionesAggregateArgs>): Prisma.PrismaPromise<GetRehabilitacionesAggregateType<T>>

    /**
     * Group by Rehabilitaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rehabilitacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rehabilitacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rehabilitacionesGroupByArgs['orderBy'] }
        : { orderBy?: rehabilitacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rehabilitacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRehabilitacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for rehabilitaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rehabilitacionesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * rehabilitaciones base type for findUnique actions
   */
  export type rehabilitacionesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter, which rehabilitaciones to fetch.
     */
    where: rehabilitacionesWhereUniqueInput
  }

  /**
   * rehabilitaciones findUnique
   */
  export interface rehabilitacionesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rehabilitacionesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rehabilitaciones findUniqueOrThrow
   */
  export type rehabilitacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter, which rehabilitaciones to fetch.
     */
    where: rehabilitacionesWhereUniqueInput
  }


  /**
   * rehabilitaciones base type for findFirst actions
   */
  export type rehabilitacionesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter, which rehabilitaciones to fetch.
     */
    where?: rehabilitacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rehabilitaciones to fetch.
     */
    orderBy?: rehabilitacionesOrderByWithRelationInput | rehabilitacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rehabilitaciones.
     */
    cursor?: rehabilitacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rehabilitaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rehabilitaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rehabilitaciones.
     */
    distinct?: RehabilitacionesScalarFieldEnum | RehabilitacionesScalarFieldEnum[]
  }

  /**
   * rehabilitaciones findFirst
   */
  export interface rehabilitacionesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rehabilitacionesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rehabilitaciones findFirstOrThrow
   */
  export type rehabilitacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter, which rehabilitaciones to fetch.
     */
    where?: rehabilitacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rehabilitaciones to fetch.
     */
    orderBy?: rehabilitacionesOrderByWithRelationInput | rehabilitacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rehabilitaciones.
     */
    cursor?: rehabilitacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rehabilitaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rehabilitaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rehabilitaciones.
     */
    distinct?: RehabilitacionesScalarFieldEnum | RehabilitacionesScalarFieldEnum[]
  }


  /**
   * rehabilitaciones findMany
   */
  export type rehabilitacionesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter, which rehabilitaciones to fetch.
     */
    where?: rehabilitacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rehabilitaciones to fetch.
     */
    orderBy?: rehabilitacionesOrderByWithRelationInput | rehabilitacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rehabilitaciones.
     */
    cursor?: rehabilitacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rehabilitaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rehabilitaciones.
     */
    skip?: number
    distinct?: RehabilitacionesScalarFieldEnum | RehabilitacionesScalarFieldEnum[]
  }


  /**
   * rehabilitaciones create
   */
  export type rehabilitacionesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * The data needed to create a rehabilitaciones.
     */
    data?: XOR<rehabilitacionesCreateInput, rehabilitacionesUncheckedCreateInput>
  }


  /**
   * rehabilitaciones createMany
   */
  export type rehabilitacionesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rehabilitaciones.
     */
    data: rehabilitacionesCreateManyInput | rehabilitacionesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rehabilitaciones update
   */
  export type rehabilitacionesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * The data needed to update a rehabilitaciones.
     */
    data: XOR<rehabilitacionesUpdateInput, rehabilitacionesUncheckedUpdateInput>
    /**
     * Choose, which rehabilitaciones to update.
     */
    where: rehabilitacionesWhereUniqueInput
  }


  /**
   * rehabilitaciones updateMany
   */
  export type rehabilitacionesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rehabilitaciones.
     */
    data: XOR<rehabilitacionesUpdateManyMutationInput, rehabilitacionesUncheckedUpdateManyInput>
    /**
     * Filter which rehabilitaciones to update
     */
    where?: rehabilitacionesWhereInput
  }


  /**
   * rehabilitaciones upsert
   */
  export type rehabilitacionesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * The filter to search for the rehabilitaciones to update in case it exists.
     */
    where: rehabilitacionesWhereUniqueInput
    /**
     * In case the rehabilitaciones found by the `where` argument doesn't exist, create a new rehabilitaciones with this data.
     */
    create: XOR<rehabilitacionesCreateInput, rehabilitacionesUncheckedCreateInput>
    /**
     * In case the rehabilitaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rehabilitacionesUpdateInput, rehabilitacionesUncheckedUpdateInput>
  }


  /**
   * rehabilitaciones delete
   */
  export type rehabilitacionesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
    /**
     * Filter which rehabilitaciones to delete.
     */
    where: rehabilitacionesWhereUniqueInput
  }


  /**
   * rehabilitaciones deleteMany
   */
  export type rehabilitacionesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rehabilitaciones to delete
     */
    where?: rehabilitacionesWhereInput
  }


  /**
   * rehabilitaciones without action
   */
  export type rehabilitacionesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rehabilitaciones
     */
    select?: rehabilitacionesSelect<ExtArgs> | null
  }



  /**
   * Model rol_personal
   */


  export type AggregateRol_personal = {
    _count: Rol_personalCountAggregateOutputType | null
    _avg: Rol_personalAvgAggregateOutputType | null
    _sum: Rol_personalSumAggregateOutputType | null
    _min: Rol_personalMinAggregateOutputType | null
    _max: Rol_personalMaxAggregateOutputType | null
  }

  export type Rol_personalAvgAggregateOutputType = {
    idrol: number | null
  }

  export type Rol_personalSumAggregateOutputType = {
    idrol: number | null
  }

  export type Rol_personalMinAggregateOutputType = {
    idrol: number | null
    rol: string | null
  }

  export type Rol_personalMaxAggregateOutputType = {
    idrol: number | null
    rol: string | null
  }

  export type Rol_personalCountAggregateOutputType = {
    idrol: number
    rol: number
    _all: number
  }


  export type Rol_personalAvgAggregateInputType = {
    idrol?: true
  }

  export type Rol_personalSumAggregateInputType = {
    idrol?: true
  }

  export type Rol_personalMinAggregateInputType = {
    idrol?: true
    rol?: true
  }

  export type Rol_personalMaxAggregateInputType = {
    idrol?: true
    rol?: true
  }

  export type Rol_personalCountAggregateInputType = {
    idrol?: true
    rol?: true
    _all?: true
  }

  export type Rol_personalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rol_personal to aggregate.
     */
    where?: rol_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rol_personals to fetch.
     */
    orderBy?: rol_personalOrderByWithRelationInput | rol_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rol_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rol_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rol_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rol_personals
    **/
    _count?: true | Rol_personalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rol_personalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rol_personalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rol_personalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rol_personalMaxAggregateInputType
  }

  export type GetRol_personalAggregateType<T extends Rol_personalAggregateArgs> = {
        [P in keyof T & keyof AggregateRol_personal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol_personal[P]>
      : GetScalarType<T[P], AggregateRol_personal[P]>
  }




  export type rol_personalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rol_personalWhereInput
    orderBy?: rol_personalOrderByWithAggregationInput | rol_personalOrderByWithAggregationInput[]
    by: Rol_personalScalarFieldEnum[] | Rol_personalScalarFieldEnum
    having?: rol_personalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rol_personalCountAggregateInputType | true
    _avg?: Rol_personalAvgAggregateInputType
    _sum?: Rol_personalSumAggregateInputType
    _min?: Rol_personalMinAggregateInputType
    _max?: Rol_personalMaxAggregateInputType
  }


  export type Rol_personalGroupByOutputType = {
    idrol: number
    rol: string | null
    _count: Rol_personalCountAggregateOutputType | null
    _avg: Rol_personalAvgAggregateOutputType | null
    _sum: Rol_personalSumAggregateOutputType | null
    _min: Rol_personalMinAggregateOutputType | null
    _max: Rol_personalMaxAggregateOutputType | null
  }

  type GetRol_personalGroupByPayload<T extends rol_personalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rol_personalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rol_personalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rol_personalGroupByOutputType[P]>
            : GetScalarType<T[P], Rol_personalGroupByOutputType[P]>
        }
      >
    >


  export type rol_personalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idrol?: boolean
    rol?: boolean
  }, ExtArgs["result"]["rol_personal"]>

  export type rol_personalSelectScalar = {
    idrol?: boolean
    rol?: boolean
  }


  type rol_personalGetPayload<S extends boolean | null | undefined | rol_personalArgs> = $Types.GetResult<rol_personalPayload, S>

  type rol_personalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<rol_personalFindManyArgs, 'select' | 'include'> & {
      select?: Rol_personalCountAggregateInputType | true
    }

  export interface rol_personalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rol_personal'], meta: { name: 'rol_personal' } }
    /**
     * Find zero or one Rol_personal that matches the filter.
     * @param {rol_personalFindUniqueArgs} args - Arguments to find a Rol_personal
     * @example
     * // Get one Rol_personal
     * const rol_personal = await prisma.rol_personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rol_personalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rol_personalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rol_personal'> extends True ? Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Rol_personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rol_personalFindUniqueOrThrowArgs} args - Arguments to find a Rol_personal
     * @example
     * // Get one Rol_personal
     * const rol_personal = await prisma.rol_personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rol_personalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rol_personalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Rol_personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalFindFirstArgs} args - Arguments to find a Rol_personal
     * @example
     * // Get one Rol_personal
     * const rol_personal = await prisma.rol_personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rol_personalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rol_personalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rol_personal'> extends True ? Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Rol_personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalFindFirstOrThrowArgs} args - Arguments to find a Rol_personal
     * @example
     * // Get one Rol_personal
     * const rol_personal = await prisma.rol_personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rol_personalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rol_personalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Rol_personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rol_personals
     * const rol_personals = await prisma.rol_personal.findMany()
     * 
     * // Get first 10 Rol_personals
     * const rol_personals = await prisma.rol_personal.findMany({ take: 10 })
     * 
     * // Only select the `idrol`
     * const rol_personalWithIdrolOnly = await prisma.rol_personal.findMany({ select: { idrol: true } })
     * 
    **/
    findMany<T extends rol_personalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rol_personalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Rol_personal.
     * @param {rol_personalCreateArgs} args - Arguments to create a Rol_personal.
     * @example
     * // Create one Rol_personal
     * const Rol_personal = await prisma.rol_personal.create({
     *   data: {
     *     // ... data to create a Rol_personal
     *   }
     * })
     * 
    **/
    create<T extends rol_personalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rol_personalCreateArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Rol_personals.
     *     @param {rol_personalCreateManyArgs} args - Arguments to create many Rol_personals.
     *     @example
     *     // Create many Rol_personals
     *     const rol_personal = await prisma.rol_personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rol_personalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rol_personalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rol_personal.
     * @param {rol_personalDeleteArgs} args - Arguments to delete one Rol_personal.
     * @example
     * // Delete one Rol_personal
     * const Rol_personal = await prisma.rol_personal.delete({
     *   where: {
     *     // ... filter to delete one Rol_personal
     *   }
     * })
     * 
    **/
    delete<T extends rol_personalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rol_personalDeleteArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Rol_personal.
     * @param {rol_personalUpdateArgs} args - Arguments to update one Rol_personal.
     * @example
     * // Update one Rol_personal
     * const rol_personal = await prisma.rol_personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rol_personalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rol_personalUpdateArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Rol_personals.
     * @param {rol_personalDeleteManyArgs} args - Arguments to filter Rol_personals to delete.
     * @example
     * // Delete a few Rol_personals
     * const { count } = await prisma.rol_personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rol_personalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rol_personalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rol_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rol_personals
     * const rol_personal = await prisma.rol_personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rol_personalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rol_personalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol_personal.
     * @param {rol_personalUpsertArgs} args - Arguments to update or create a Rol_personal.
     * @example
     * // Update or create a Rol_personal
     * const rol_personal = await prisma.rol_personal.upsert({
     *   create: {
     *     // ... data to create a Rol_personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol_personal we want to update
     *   }
     * })
    **/
    upsert<T extends rol_personalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rol_personalUpsertArgs<ExtArgs>>
    ): Prisma__rol_personalClient<$Types.GetResult<rol_personalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Rol_personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalCountArgs} args - Arguments to filter Rol_personals to count.
     * @example
     * // Count the number of Rol_personals
     * const count = await prisma.rol_personal.count({
     *   where: {
     *     // ... the filter for the Rol_personals we want to count
     *   }
     * })
    **/
    count<T extends rol_personalCountArgs>(
      args?: Subset<T, rol_personalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rol_personalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rol_personalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rol_personalAggregateArgs>(args: Subset<T, Rol_personalAggregateArgs>): Prisma.PrismaPromise<GetRol_personalAggregateType<T>>

    /**
     * Group by Rol_personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rol_personalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rol_personalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rol_personalGroupByArgs['orderBy'] }
        : { orderBy?: rol_personalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rol_personalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRol_personalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for rol_personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rol_personalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * rol_personal base type for findUnique actions
   */
  export type rol_personalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter, which rol_personal to fetch.
     */
    where: rol_personalWhereUniqueInput
  }

  /**
   * rol_personal findUnique
   */
  export interface rol_personalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rol_personalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rol_personal findUniqueOrThrow
   */
  export type rol_personalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter, which rol_personal to fetch.
     */
    where: rol_personalWhereUniqueInput
  }


  /**
   * rol_personal base type for findFirst actions
   */
  export type rol_personalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter, which rol_personal to fetch.
     */
    where?: rol_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rol_personals to fetch.
     */
    orderBy?: rol_personalOrderByWithRelationInput | rol_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rol_personals.
     */
    cursor?: rol_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rol_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rol_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rol_personals.
     */
    distinct?: Rol_personalScalarFieldEnum | Rol_personalScalarFieldEnum[]
  }

  /**
   * rol_personal findFirst
   */
  export interface rol_personalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rol_personalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rol_personal findFirstOrThrow
   */
  export type rol_personalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter, which rol_personal to fetch.
     */
    where?: rol_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rol_personals to fetch.
     */
    orderBy?: rol_personalOrderByWithRelationInput | rol_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rol_personals.
     */
    cursor?: rol_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rol_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rol_personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rol_personals.
     */
    distinct?: Rol_personalScalarFieldEnum | Rol_personalScalarFieldEnum[]
  }


  /**
   * rol_personal findMany
   */
  export type rol_personalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter, which rol_personals to fetch.
     */
    where?: rol_personalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rol_personals to fetch.
     */
    orderBy?: rol_personalOrderByWithRelationInput | rol_personalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rol_personals.
     */
    cursor?: rol_personalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rol_personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rol_personals.
     */
    skip?: number
    distinct?: Rol_personalScalarFieldEnum | Rol_personalScalarFieldEnum[]
  }


  /**
   * rol_personal create
   */
  export type rol_personalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * The data needed to create a rol_personal.
     */
    data?: XOR<rol_personalCreateInput, rol_personalUncheckedCreateInput>
  }


  /**
   * rol_personal createMany
   */
  export type rol_personalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rol_personals.
     */
    data: rol_personalCreateManyInput | rol_personalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rol_personal update
   */
  export type rol_personalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * The data needed to update a rol_personal.
     */
    data: XOR<rol_personalUpdateInput, rol_personalUncheckedUpdateInput>
    /**
     * Choose, which rol_personal to update.
     */
    where: rol_personalWhereUniqueInput
  }


  /**
   * rol_personal updateMany
   */
  export type rol_personalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rol_personals.
     */
    data: XOR<rol_personalUpdateManyMutationInput, rol_personalUncheckedUpdateManyInput>
    /**
     * Filter which rol_personals to update
     */
    where?: rol_personalWhereInput
  }


  /**
   * rol_personal upsert
   */
  export type rol_personalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * The filter to search for the rol_personal to update in case it exists.
     */
    where: rol_personalWhereUniqueInput
    /**
     * In case the rol_personal found by the `where` argument doesn't exist, create a new rol_personal with this data.
     */
    create: XOR<rol_personalCreateInput, rol_personalUncheckedCreateInput>
    /**
     * In case the rol_personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rol_personalUpdateInput, rol_personalUncheckedUpdateInput>
  }


  /**
   * rol_personal delete
   */
  export type rol_personalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
    /**
     * Filter which rol_personal to delete.
     */
    where: rol_personalWhereUniqueInput
  }


  /**
   * rol_personal deleteMany
   */
  export type rol_personalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rol_personals to delete
     */
    where?: rol_personalWhereInput
  }


  /**
   * rol_personal without action
   */
  export type rol_personalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol_personal
     */
    select?: rol_personalSelect<ExtArgs> | null
  }



  /**
   * Model sucursal
   */


  export type AggregateSucursal = {
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  export type SucursalAvgAggregateOutputType = {
    idsucursal: number | null
  }

  export type SucursalSumAggregateOutputType = {
    idsucursal: number | null
  }

  export type SucursalMinAggregateOutputType = {
    idsucursal: number | null
    sucursal: string | null
    codigo: string | null
  }

  export type SucursalMaxAggregateOutputType = {
    idsucursal: number | null
    sucursal: string | null
    codigo: string | null
  }

  export type SucursalCountAggregateOutputType = {
    idsucursal: number
    sucursal: number
    codigo: number
    _all: number
  }


  export type SucursalAvgAggregateInputType = {
    idsucursal?: true
  }

  export type SucursalSumAggregateInputType = {
    idsucursal?: true
  }

  export type SucursalMinAggregateInputType = {
    idsucursal?: true
    sucursal?: true
    codigo?: true
  }

  export type SucursalMaxAggregateInputType = {
    idsucursal?: true
    sucursal?: true
    codigo?: true
  }

  export type SucursalCountAggregateInputType = {
    idsucursal?: true
    sucursal?: true
    codigo?: true
    _all?: true
  }

  export type SucursalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sucursal to aggregate.
     */
    where?: sucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sucursals to fetch.
     */
    orderBy?: sucursalOrderByWithRelationInput | sucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sucursals
    **/
    _count?: true | SucursalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SucursalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SucursalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SucursalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SucursalMaxAggregateInputType
  }

  export type GetSucursalAggregateType<T extends SucursalAggregateArgs> = {
        [P in keyof T & keyof AggregateSucursal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSucursal[P]>
      : GetScalarType<T[P], AggregateSucursal[P]>
  }




  export type sucursalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sucursalWhereInput
    orderBy?: sucursalOrderByWithAggregationInput | sucursalOrderByWithAggregationInput[]
    by: SucursalScalarFieldEnum[] | SucursalScalarFieldEnum
    having?: sucursalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SucursalCountAggregateInputType | true
    _avg?: SucursalAvgAggregateInputType
    _sum?: SucursalSumAggregateInputType
    _min?: SucursalMinAggregateInputType
    _max?: SucursalMaxAggregateInputType
  }


  export type SucursalGroupByOutputType = {
    idsucursal: number
    sucursal: string | null
    codigo: string | null
    _count: SucursalCountAggregateOutputType | null
    _avg: SucursalAvgAggregateOutputType | null
    _sum: SucursalSumAggregateOutputType | null
    _min: SucursalMinAggregateOutputType | null
    _max: SucursalMaxAggregateOutputType | null
  }

  type GetSucursalGroupByPayload<T extends sucursalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SucursalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SucursalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SucursalGroupByOutputType[P]>
            : GetScalarType<T[P], SucursalGroupByOutputType[P]>
        }
      >
    >


  export type sucursalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idsucursal?: boolean
    sucursal?: boolean
    codigo?: boolean
  }, ExtArgs["result"]["sucursal"]>

  export type sucursalSelectScalar = {
    idsucursal?: boolean
    sucursal?: boolean
    codigo?: boolean
  }


  type sucursalGetPayload<S extends boolean | null | undefined | sucursalArgs> = $Types.GetResult<sucursalPayload, S>

  type sucursalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sucursalFindManyArgs, 'select' | 'include'> & {
      select?: SucursalCountAggregateInputType | true
    }

  export interface sucursalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sucursal'], meta: { name: 'sucursal' } }
    /**
     * Find zero or one Sucursal that matches the filter.
     * @param {sucursalFindUniqueArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sucursalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sucursalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sucursal'> extends True ? Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Sucursal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sucursalFindUniqueOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sucursalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sucursalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Sucursal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalFindFirstArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sucursalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sucursalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sucursal'> extends True ? Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Sucursal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalFindFirstOrThrowArgs} args - Arguments to find a Sucursal
     * @example
     * // Get one Sucursal
     * const sucursal = await prisma.sucursal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sucursalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sucursalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sucursals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sucursals
     * const sucursals = await prisma.sucursal.findMany()
     * 
     * // Get first 10 Sucursals
     * const sucursals = await prisma.sucursal.findMany({ take: 10 })
     * 
     * // Only select the `idsucursal`
     * const sucursalWithIdsucursalOnly = await prisma.sucursal.findMany({ select: { idsucursal: true } })
     * 
    **/
    findMany<T extends sucursalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sucursalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Sucursal.
     * @param {sucursalCreateArgs} args - Arguments to create a Sucursal.
     * @example
     * // Create one Sucursal
     * const Sucursal = await prisma.sucursal.create({
     *   data: {
     *     // ... data to create a Sucursal
     *   }
     * })
     * 
    **/
    create<T extends sucursalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sucursalCreateArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sucursals.
     *     @param {sucursalCreateManyArgs} args - Arguments to create many Sucursals.
     *     @example
     *     // Create many Sucursals
     *     const sucursal = await prisma.sucursal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sucursalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sucursalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sucursal.
     * @param {sucursalDeleteArgs} args - Arguments to delete one Sucursal.
     * @example
     * // Delete one Sucursal
     * const Sucursal = await prisma.sucursal.delete({
     *   where: {
     *     // ... filter to delete one Sucursal
     *   }
     * })
     * 
    **/
    delete<T extends sucursalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sucursalDeleteArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Sucursal.
     * @param {sucursalUpdateArgs} args - Arguments to update one Sucursal.
     * @example
     * // Update one Sucursal
     * const sucursal = await prisma.sucursal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sucursalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sucursalUpdateArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sucursals.
     * @param {sucursalDeleteManyArgs} args - Arguments to filter Sucursals to delete.
     * @example
     * // Delete a few Sucursals
     * const { count } = await prisma.sucursal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sucursalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sucursalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sucursals
     * const sucursal = await prisma.sucursal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sucursalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sucursalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sucursal.
     * @param {sucursalUpsertArgs} args - Arguments to update or create a Sucursal.
     * @example
     * // Update or create a Sucursal
     * const sucursal = await prisma.sucursal.upsert({
     *   create: {
     *     // ... data to create a Sucursal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sucursal we want to update
     *   }
     * })
    **/
    upsert<T extends sucursalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sucursalUpsertArgs<ExtArgs>>
    ): Prisma__sucursalClient<$Types.GetResult<sucursalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sucursals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalCountArgs} args - Arguments to filter Sucursals to count.
     * @example
     * // Count the number of Sucursals
     * const count = await prisma.sucursal.count({
     *   where: {
     *     // ... the filter for the Sucursals we want to count
     *   }
     * })
    **/
    count<T extends sucursalCountArgs>(
      args?: Subset<T, sucursalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SucursalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SucursalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SucursalAggregateArgs>(args: Subset<T, SucursalAggregateArgs>): Prisma.PrismaPromise<GetSucursalAggregateType<T>>

    /**
     * Group by Sucursal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sucursalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sucursalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sucursalGroupByArgs['orderBy'] }
        : { orderBy?: sucursalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sucursalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSucursalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sucursal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sucursalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sucursal base type for findUnique actions
   */
  export type sucursalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter, which sucursal to fetch.
     */
    where: sucursalWhereUniqueInput
  }

  /**
   * sucursal findUnique
   */
  export interface sucursalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sucursalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sucursal findUniqueOrThrow
   */
  export type sucursalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter, which sucursal to fetch.
     */
    where: sucursalWhereUniqueInput
  }


  /**
   * sucursal base type for findFirst actions
   */
  export type sucursalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter, which sucursal to fetch.
     */
    where?: sucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sucursals to fetch.
     */
    orderBy?: sucursalOrderByWithRelationInput | sucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sucursals.
     */
    cursor?: sucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sucursals.
     */
    distinct?: SucursalScalarFieldEnum | SucursalScalarFieldEnum[]
  }

  /**
   * sucursal findFirst
   */
  export interface sucursalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sucursalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sucursal findFirstOrThrow
   */
  export type sucursalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter, which sucursal to fetch.
     */
    where?: sucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sucursals to fetch.
     */
    orderBy?: sucursalOrderByWithRelationInput | sucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sucursals.
     */
    cursor?: sucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sucursals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sucursals.
     */
    distinct?: SucursalScalarFieldEnum | SucursalScalarFieldEnum[]
  }


  /**
   * sucursal findMany
   */
  export type sucursalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter, which sucursals to fetch.
     */
    where?: sucursalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sucursals to fetch.
     */
    orderBy?: sucursalOrderByWithRelationInput | sucursalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sucursals.
     */
    cursor?: sucursalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sucursals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sucursals.
     */
    skip?: number
    distinct?: SucursalScalarFieldEnum | SucursalScalarFieldEnum[]
  }


  /**
   * sucursal create
   */
  export type sucursalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * The data needed to create a sucursal.
     */
    data?: XOR<sucursalCreateInput, sucursalUncheckedCreateInput>
  }


  /**
   * sucursal createMany
   */
  export type sucursalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sucursals.
     */
    data: sucursalCreateManyInput | sucursalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sucursal update
   */
  export type sucursalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * The data needed to update a sucursal.
     */
    data: XOR<sucursalUpdateInput, sucursalUncheckedUpdateInput>
    /**
     * Choose, which sucursal to update.
     */
    where: sucursalWhereUniqueInput
  }


  /**
   * sucursal updateMany
   */
  export type sucursalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sucursals.
     */
    data: XOR<sucursalUpdateManyMutationInput, sucursalUncheckedUpdateManyInput>
    /**
     * Filter which sucursals to update
     */
    where?: sucursalWhereInput
  }


  /**
   * sucursal upsert
   */
  export type sucursalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * The filter to search for the sucursal to update in case it exists.
     */
    where: sucursalWhereUniqueInput
    /**
     * In case the sucursal found by the `where` argument doesn't exist, create a new sucursal with this data.
     */
    create: XOR<sucursalCreateInput, sucursalUncheckedCreateInput>
    /**
     * In case the sucursal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sucursalUpdateInput, sucursalUncheckedUpdateInput>
  }


  /**
   * sucursal delete
   */
  export type sucursalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
    /**
     * Filter which sucursal to delete.
     */
    where: sucursalWhereUniqueInput
  }


  /**
   * sucursal deleteMany
   */
  export type sucursalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sucursals to delete
     */
    where?: sucursalWhereInput
  }


  /**
   * sucursal without action
   */
  export type sucursalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sucursal
     */
    select?: sucursalSelect<ExtArgs> | null
  }



  /**
   * Model sueldos
   */


  export type AggregateSueldos = {
    _count: SueldosCountAggregateOutputType | null
    _avg: SueldosAvgAggregateOutputType | null
    _sum: SueldosSumAggregateOutputType | null
    _min: SueldosMinAggregateOutputType | null
    _max: SueldosMaxAggregateOutputType | null
  }

  export type SueldosAvgAggregateOutputType = {
    sld_id: number | null
    sld_basico: number | null
    sld_basicoant: number | null
  }

  export type SueldosSumAggregateOutputType = {
    sld_id: number | null
    sld_basico: number | null
    sld_basicoant: number | null
  }

  export type SueldosMinAggregateOutputType = {
    sld_id: number | null
    sld_perfil: string | null
    sld_basico: number | null
    sld_basicoant: number | null
  }

  export type SueldosMaxAggregateOutputType = {
    sld_id: number | null
    sld_perfil: string | null
    sld_basico: number | null
    sld_basicoant: number | null
  }

  export type SueldosCountAggregateOutputType = {
    sld_id: number
    sld_perfil: number
    sld_basico: number
    sld_basicoant: number
    _all: number
  }


  export type SueldosAvgAggregateInputType = {
    sld_id?: true
    sld_basico?: true
    sld_basicoant?: true
  }

  export type SueldosSumAggregateInputType = {
    sld_id?: true
    sld_basico?: true
    sld_basicoant?: true
  }

  export type SueldosMinAggregateInputType = {
    sld_id?: true
    sld_perfil?: true
    sld_basico?: true
    sld_basicoant?: true
  }

  export type SueldosMaxAggregateInputType = {
    sld_id?: true
    sld_perfil?: true
    sld_basico?: true
    sld_basicoant?: true
  }

  export type SueldosCountAggregateInputType = {
    sld_id?: true
    sld_perfil?: true
    sld_basico?: true
    sld_basicoant?: true
    _all?: true
  }

  export type SueldosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sueldos to aggregate.
     */
    where?: sueldosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sueldos to fetch.
     */
    orderBy?: sueldosOrderByWithRelationInput | sueldosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sueldosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sueldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sueldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sueldos
    **/
    _count?: true | SueldosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SueldosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SueldosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SueldosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SueldosMaxAggregateInputType
  }

  export type GetSueldosAggregateType<T extends SueldosAggregateArgs> = {
        [P in keyof T & keyof AggregateSueldos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSueldos[P]>
      : GetScalarType<T[P], AggregateSueldos[P]>
  }




  export type sueldosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sueldosWhereInput
    orderBy?: sueldosOrderByWithAggregationInput | sueldosOrderByWithAggregationInput[]
    by: SueldosScalarFieldEnum[] | SueldosScalarFieldEnum
    having?: sueldosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SueldosCountAggregateInputType | true
    _avg?: SueldosAvgAggregateInputType
    _sum?: SueldosSumAggregateInputType
    _min?: SueldosMinAggregateInputType
    _max?: SueldosMaxAggregateInputType
  }


  export type SueldosGroupByOutputType = {
    sld_id: number
    sld_perfil: string | null
    sld_basico: number | null
    sld_basicoant: number | null
    _count: SueldosCountAggregateOutputType | null
    _avg: SueldosAvgAggregateOutputType | null
    _sum: SueldosSumAggregateOutputType | null
    _min: SueldosMinAggregateOutputType | null
    _max: SueldosMaxAggregateOutputType | null
  }

  type GetSueldosGroupByPayload<T extends sueldosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SueldosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SueldosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SueldosGroupByOutputType[P]>
            : GetScalarType<T[P], SueldosGroupByOutputType[P]>
        }
      >
    >


  export type sueldosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sld_id?: boolean
    sld_perfil?: boolean
    sld_basico?: boolean
    sld_basicoant?: boolean
  }, ExtArgs["result"]["sueldos"]>

  export type sueldosSelectScalar = {
    sld_id?: boolean
    sld_perfil?: boolean
    sld_basico?: boolean
    sld_basicoant?: boolean
  }


  type sueldosGetPayload<S extends boolean | null | undefined | sueldosArgs> = $Types.GetResult<sueldosPayload, S>

  type sueldosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sueldosFindManyArgs, 'select' | 'include'> & {
      select?: SueldosCountAggregateInputType | true
    }

  export interface sueldosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sueldos'], meta: { name: 'sueldos' } }
    /**
     * Find zero or one Sueldos that matches the filter.
     * @param {sueldosFindUniqueArgs} args - Arguments to find a Sueldos
     * @example
     * // Get one Sueldos
     * const sueldos = await prisma.sueldos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sueldosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sueldosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sueldos'> extends True ? Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Sueldos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sueldosFindUniqueOrThrowArgs} args - Arguments to find a Sueldos
     * @example
     * // Get one Sueldos
     * const sueldos = await prisma.sueldos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sueldosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sueldosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Sueldos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosFindFirstArgs} args - Arguments to find a Sueldos
     * @example
     * // Get one Sueldos
     * const sueldos = await prisma.sueldos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sueldosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sueldosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sueldos'> extends True ? Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Sueldos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosFindFirstOrThrowArgs} args - Arguments to find a Sueldos
     * @example
     * // Get one Sueldos
     * const sueldos = await prisma.sueldos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sueldosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sueldosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sueldos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sueldos
     * const sueldos = await prisma.sueldos.findMany()
     * 
     * // Get first 10 Sueldos
     * const sueldos = await prisma.sueldos.findMany({ take: 10 })
     * 
     * // Only select the `sld_id`
     * const sueldosWithSld_idOnly = await prisma.sueldos.findMany({ select: { sld_id: true } })
     * 
    **/
    findMany<T extends sueldosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sueldosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Sueldos.
     * @param {sueldosCreateArgs} args - Arguments to create a Sueldos.
     * @example
     * // Create one Sueldos
     * const Sueldos = await prisma.sueldos.create({
     *   data: {
     *     // ... data to create a Sueldos
     *   }
     * })
     * 
    **/
    create<T extends sueldosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sueldosCreateArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sueldos.
     *     @param {sueldosCreateManyArgs} args - Arguments to create many Sueldos.
     *     @example
     *     // Create many Sueldos
     *     const sueldos = await prisma.sueldos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sueldosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sueldosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sueldos.
     * @param {sueldosDeleteArgs} args - Arguments to delete one Sueldos.
     * @example
     * // Delete one Sueldos
     * const Sueldos = await prisma.sueldos.delete({
     *   where: {
     *     // ... filter to delete one Sueldos
     *   }
     * })
     * 
    **/
    delete<T extends sueldosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sueldosDeleteArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Sueldos.
     * @param {sueldosUpdateArgs} args - Arguments to update one Sueldos.
     * @example
     * // Update one Sueldos
     * const sueldos = await prisma.sueldos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sueldosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sueldosUpdateArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sueldos.
     * @param {sueldosDeleteManyArgs} args - Arguments to filter Sueldos to delete.
     * @example
     * // Delete a few Sueldos
     * const { count } = await prisma.sueldos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sueldosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sueldosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sueldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sueldos
     * const sueldos = await prisma.sueldos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sueldosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sueldosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sueldos.
     * @param {sueldosUpsertArgs} args - Arguments to update or create a Sueldos.
     * @example
     * // Update or create a Sueldos
     * const sueldos = await prisma.sueldos.upsert({
     *   create: {
     *     // ... data to create a Sueldos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sueldos we want to update
     *   }
     * })
    **/
    upsert<T extends sueldosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sueldosUpsertArgs<ExtArgs>>
    ): Prisma__sueldosClient<$Types.GetResult<sueldosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sueldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosCountArgs} args - Arguments to filter Sueldos to count.
     * @example
     * // Count the number of Sueldos
     * const count = await prisma.sueldos.count({
     *   where: {
     *     // ... the filter for the Sueldos we want to count
     *   }
     * })
    **/
    count<T extends sueldosCountArgs>(
      args?: Subset<T, sueldosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SueldosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sueldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SueldosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SueldosAggregateArgs>(args: Subset<T, SueldosAggregateArgs>): Prisma.PrismaPromise<GetSueldosAggregateType<T>>

    /**
     * Group by Sueldos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sueldosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sueldosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sueldosGroupByArgs['orderBy'] }
        : { orderBy?: sueldosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sueldosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSueldosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sueldos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sueldosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sueldos base type for findUnique actions
   */
  export type sueldosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter, which sueldos to fetch.
     */
    where: sueldosWhereUniqueInput
  }

  /**
   * sueldos findUnique
   */
  export interface sueldosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sueldosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sueldos findUniqueOrThrow
   */
  export type sueldosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter, which sueldos to fetch.
     */
    where: sueldosWhereUniqueInput
  }


  /**
   * sueldos base type for findFirst actions
   */
  export type sueldosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter, which sueldos to fetch.
     */
    where?: sueldosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sueldos to fetch.
     */
    orderBy?: sueldosOrderByWithRelationInput | sueldosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sueldos.
     */
    cursor?: sueldosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sueldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sueldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sueldos.
     */
    distinct?: SueldosScalarFieldEnum | SueldosScalarFieldEnum[]
  }

  /**
   * sueldos findFirst
   */
  export interface sueldosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sueldosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sueldos findFirstOrThrow
   */
  export type sueldosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter, which sueldos to fetch.
     */
    where?: sueldosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sueldos to fetch.
     */
    orderBy?: sueldosOrderByWithRelationInput | sueldosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sueldos.
     */
    cursor?: sueldosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sueldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sueldos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sueldos.
     */
    distinct?: SueldosScalarFieldEnum | SueldosScalarFieldEnum[]
  }


  /**
   * sueldos findMany
   */
  export type sueldosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter, which sueldos to fetch.
     */
    where?: sueldosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sueldos to fetch.
     */
    orderBy?: sueldosOrderByWithRelationInput | sueldosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sueldos.
     */
    cursor?: sueldosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sueldos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sueldos.
     */
    skip?: number
    distinct?: SueldosScalarFieldEnum | SueldosScalarFieldEnum[]
  }


  /**
   * sueldos create
   */
  export type sueldosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * The data needed to create a sueldos.
     */
    data?: XOR<sueldosCreateInput, sueldosUncheckedCreateInput>
  }


  /**
   * sueldos createMany
   */
  export type sueldosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sueldos.
     */
    data: sueldosCreateManyInput | sueldosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sueldos update
   */
  export type sueldosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * The data needed to update a sueldos.
     */
    data: XOR<sueldosUpdateInput, sueldosUncheckedUpdateInput>
    /**
     * Choose, which sueldos to update.
     */
    where: sueldosWhereUniqueInput
  }


  /**
   * sueldos updateMany
   */
  export type sueldosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sueldos.
     */
    data: XOR<sueldosUpdateManyMutationInput, sueldosUncheckedUpdateManyInput>
    /**
     * Filter which sueldos to update
     */
    where?: sueldosWhereInput
  }


  /**
   * sueldos upsert
   */
  export type sueldosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * The filter to search for the sueldos to update in case it exists.
     */
    where: sueldosWhereUniqueInput
    /**
     * In case the sueldos found by the `where` argument doesn't exist, create a new sueldos with this data.
     */
    create: XOR<sueldosCreateInput, sueldosUncheckedCreateInput>
    /**
     * In case the sueldos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sueldosUpdateInput, sueldosUncheckedUpdateInput>
  }


  /**
   * sueldos delete
   */
  export type sueldosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
    /**
     * Filter which sueldos to delete.
     */
    where: sueldosWhereUniqueInput
  }


  /**
   * sueldos deleteMany
   */
  export type sueldosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sueldos to delete
     */
    where?: sueldosWhereInput
  }


  /**
   * sueldos without action
   */
  export type sueldosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sueldos
     */
    select?: sueldosSelect<ExtArgs> | null
  }



  /**
   * Model tab_ef
   */


  export type AggregateTab_ef = {
    _count: Tab_efCountAggregateOutputType | null
    _avg: Tab_efAvgAggregateOutputType | null
    _sum: Tab_efSumAggregateOutputType | null
    _min: Tab_efMinAggregateOutputType | null
    _max: Tab_efMaxAggregateOutputType | null
  }

  export type Tab_efAvgAggregateOutputType = {
    allDay: number | null
    holiday: number | null
  }

  export type Tab_efSumAggregateOutputType = {
    allDay: number | null
    holiday: number | null
  }

  export type Tab_efMinAggregateOutputType = {
    id: string | null
    start: Date | null
    end: Date | null
    allDay: number | null
    holiday: number | null
    title: string | null
    user: string | null
    detail: string | null
  }

  export type Tab_efMaxAggregateOutputType = {
    id: string | null
    start: Date | null
    end: Date | null
    allDay: number | null
    holiday: number | null
    title: string | null
    user: string | null
    detail: string | null
  }

  export type Tab_efCountAggregateOutputType = {
    id: number
    start: number
    end: number
    allDay: number
    holiday: number
    title: number
    user: number
    detail: number
    _all: number
  }


  export type Tab_efAvgAggregateInputType = {
    allDay?: true
    holiday?: true
  }

  export type Tab_efSumAggregateInputType = {
    allDay?: true
    holiday?: true
  }

  export type Tab_efMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    holiday?: true
    title?: true
    user?: true
    detail?: true
  }

  export type Tab_efMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    holiday?: true
    title?: true
    user?: true
    detail?: true
  }

  export type Tab_efCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    holiday?: true
    title?: true
    user?: true
    detail?: true
    _all?: true
  }

  export type Tab_efAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tab_ef to aggregate.
     */
    where?: tab_efWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tab_efs to fetch.
     */
    orderBy?: tab_efOrderByWithRelationInput | tab_efOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tab_efWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tab_efs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tab_efs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tab_efs
    **/
    _count?: true | Tab_efCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tab_efAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tab_efSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tab_efMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tab_efMaxAggregateInputType
  }

  export type GetTab_efAggregateType<T extends Tab_efAggregateArgs> = {
        [P in keyof T & keyof AggregateTab_ef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTab_ef[P]>
      : GetScalarType<T[P], AggregateTab_ef[P]>
  }




  export type tab_efGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tab_efWhereInput
    orderBy?: tab_efOrderByWithAggregationInput | tab_efOrderByWithAggregationInput[]
    by: Tab_efScalarFieldEnum[] | Tab_efScalarFieldEnum
    having?: tab_efScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tab_efCountAggregateInputType | true
    _avg?: Tab_efAvgAggregateInputType
    _sum?: Tab_efSumAggregateInputType
    _min?: Tab_efMinAggregateInputType
    _max?: Tab_efMaxAggregateInputType
  }


  export type Tab_efGroupByOutputType = {
    id: string
    start: Date | null
    end: Date | null
    allDay: number | null
    holiday: number | null
    title: string | null
    user: string | null
    detail: string | null
    _count: Tab_efCountAggregateOutputType | null
    _avg: Tab_efAvgAggregateOutputType | null
    _sum: Tab_efSumAggregateOutputType | null
    _min: Tab_efMinAggregateOutputType | null
    _max: Tab_efMaxAggregateOutputType | null
  }

  type GetTab_efGroupByPayload<T extends tab_efGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tab_efGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tab_efGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tab_efGroupByOutputType[P]>
            : GetScalarType<T[P], Tab_efGroupByOutputType[P]>
        }
      >
    >


  export type tab_efSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    holiday?: boolean
    title?: boolean
    user?: boolean
    detail?: boolean
  }, ExtArgs["result"]["tab_ef"]>

  export type tab_efSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    holiday?: boolean
    title?: boolean
    user?: boolean
    detail?: boolean
  }


  type tab_efGetPayload<S extends boolean | null | undefined | tab_efArgs> = $Types.GetResult<tab_efPayload, S>

  type tab_efCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tab_efFindManyArgs, 'select' | 'include'> & {
      select?: Tab_efCountAggregateInputType | true
    }

  export interface tab_efDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tab_ef'], meta: { name: 'tab_ef' } }
    /**
     * Find zero or one Tab_ef that matches the filter.
     * @param {tab_efFindUniqueArgs} args - Arguments to find a Tab_ef
     * @example
     * // Get one Tab_ef
     * const tab_ef = await prisma.tab_ef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tab_efFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tab_efFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tab_ef'> extends True ? Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tab_ef that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tab_efFindUniqueOrThrowArgs} args - Arguments to find a Tab_ef
     * @example
     * // Get one Tab_ef
     * const tab_ef = await prisma.tab_ef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tab_efFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tab_efFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tab_ef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efFindFirstArgs} args - Arguments to find a Tab_ef
     * @example
     * // Get one Tab_ef
     * const tab_ef = await prisma.tab_ef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tab_efFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tab_efFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tab_ef'> extends True ? Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tab_ef that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efFindFirstOrThrowArgs} args - Arguments to find a Tab_ef
     * @example
     * // Get one Tab_ef
     * const tab_ef = await prisma.tab_ef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tab_efFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tab_efFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tab_efs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tab_efs
     * const tab_efs = await prisma.tab_ef.findMany()
     * 
     * // Get first 10 Tab_efs
     * const tab_efs = await prisma.tab_ef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tab_efWithIdOnly = await prisma.tab_ef.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tab_efFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tab_efFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tab_ef.
     * @param {tab_efCreateArgs} args - Arguments to create a Tab_ef.
     * @example
     * // Create one Tab_ef
     * const Tab_ef = await prisma.tab_ef.create({
     *   data: {
     *     // ... data to create a Tab_ef
     *   }
     * })
     * 
    **/
    create<T extends tab_efCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tab_efCreateArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tab_efs.
     *     @param {tab_efCreateManyArgs} args - Arguments to create many Tab_efs.
     *     @example
     *     // Create many Tab_efs
     *     const tab_ef = await prisma.tab_ef.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tab_efCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tab_efCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tab_ef.
     * @param {tab_efDeleteArgs} args - Arguments to delete one Tab_ef.
     * @example
     * // Delete one Tab_ef
     * const Tab_ef = await prisma.tab_ef.delete({
     *   where: {
     *     // ... filter to delete one Tab_ef
     *   }
     * })
     * 
    **/
    delete<T extends tab_efDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tab_efDeleteArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tab_ef.
     * @param {tab_efUpdateArgs} args - Arguments to update one Tab_ef.
     * @example
     * // Update one Tab_ef
     * const tab_ef = await prisma.tab_ef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tab_efUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tab_efUpdateArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tab_efs.
     * @param {tab_efDeleteManyArgs} args - Arguments to filter Tab_efs to delete.
     * @example
     * // Delete a few Tab_efs
     * const { count } = await prisma.tab_ef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tab_efDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tab_efDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tab_efs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tab_efs
     * const tab_ef = await prisma.tab_ef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tab_efUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tab_efUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tab_ef.
     * @param {tab_efUpsertArgs} args - Arguments to update or create a Tab_ef.
     * @example
     * // Update or create a Tab_ef
     * const tab_ef = await prisma.tab_ef.upsert({
     *   create: {
     *     // ... data to create a Tab_ef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tab_ef we want to update
     *   }
     * })
    **/
    upsert<T extends tab_efUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tab_efUpsertArgs<ExtArgs>>
    ): Prisma__tab_efClient<$Types.GetResult<tab_efPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tab_efs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efCountArgs} args - Arguments to filter Tab_efs to count.
     * @example
     * // Count the number of Tab_efs
     * const count = await prisma.tab_ef.count({
     *   where: {
     *     // ... the filter for the Tab_efs we want to count
     *   }
     * })
    **/
    count<T extends tab_efCountArgs>(
      args?: Subset<T, tab_efCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tab_efCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tab_ef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tab_efAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tab_efAggregateArgs>(args: Subset<T, Tab_efAggregateArgs>): Prisma.PrismaPromise<GetTab_efAggregateType<T>>

    /**
     * Group by Tab_ef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tab_efGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tab_efGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tab_efGroupByArgs['orderBy'] }
        : { orderBy?: tab_efGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tab_efGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTab_efGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tab_ef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tab_efClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tab_ef base type for findUnique actions
   */
  export type tab_efFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter, which tab_ef to fetch.
     */
    where: tab_efWhereUniqueInput
  }

  /**
   * tab_ef findUnique
   */
  export interface tab_efFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tab_efFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tab_ef findUniqueOrThrow
   */
  export type tab_efFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter, which tab_ef to fetch.
     */
    where: tab_efWhereUniqueInput
  }


  /**
   * tab_ef base type for findFirst actions
   */
  export type tab_efFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter, which tab_ef to fetch.
     */
    where?: tab_efWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tab_efs to fetch.
     */
    orderBy?: tab_efOrderByWithRelationInput | tab_efOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tab_efs.
     */
    cursor?: tab_efWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tab_efs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tab_efs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tab_efs.
     */
    distinct?: Tab_efScalarFieldEnum | Tab_efScalarFieldEnum[]
  }

  /**
   * tab_ef findFirst
   */
  export interface tab_efFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tab_efFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tab_ef findFirstOrThrow
   */
  export type tab_efFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter, which tab_ef to fetch.
     */
    where?: tab_efWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tab_efs to fetch.
     */
    orderBy?: tab_efOrderByWithRelationInput | tab_efOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tab_efs.
     */
    cursor?: tab_efWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tab_efs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tab_efs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tab_efs.
     */
    distinct?: Tab_efScalarFieldEnum | Tab_efScalarFieldEnum[]
  }


  /**
   * tab_ef findMany
   */
  export type tab_efFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter, which tab_efs to fetch.
     */
    where?: tab_efWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tab_efs to fetch.
     */
    orderBy?: tab_efOrderByWithRelationInput | tab_efOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tab_efs.
     */
    cursor?: tab_efWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tab_efs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tab_efs.
     */
    skip?: number
    distinct?: Tab_efScalarFieldEnum | Tab_efScalarFieldEnum[]
  }


  /**
   * tab_ef create
   */
  export type tab_efCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * The data needed to create a tab_ef.
     */
    data: XOR<tab_efCreateInput, tab_efUncheckedCreateInput>
  }


  /**
   * tab_ef createMany
   */
  export type tab_efCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tab_efs.
     */
    data: tab_efCreateManyInput | tab_efCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tab_ef update
   */
  export type tab_efUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * The data needed to update a tab_ef.
     */
    data: XOR<tab_efUpdateInput, tab_efUncheckedUpdateInput>
    /**
     * Choose, which tab_ef to update.
     */
    where: tab_efWhereUniqueInput
  }


  /**
   * tab_ef updateMany
   */
  export type tab_efUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tab_efs.
     */
    data: XOR<tab_efUpdateManyMutationInput, tab_efUncheckedUpdateManyInput>
    /**
     * Filter which tab_efs to update
     */
    where?: tab_efWhereInput
  }


  /**
   * tab_ef upsert
   */
  export type tab_efUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * The filter to search for the tab_ef to update in case it exists.
     */
    where: tab_efWhereUniqueInput
    /**
     * In case the tab_ef found by the `where` argument doesn't exist, create a new tab_ef with this data.
     */
    create: XOR<tab_efCreateInput, tab_efUncheckedCreateInput>
    /**
     * In case the tab_ef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tab_efUpdateInput, tab_efUncheckedUpdateInput>
  }


  /**
   * tab_ef delete
   */
  export type tab_efDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
    /**
     * Filter which tab_ef to delete.
     */
    where: tab_efWhereUniqueInput
  }


  /**
   * tab_ef deleteMany
   */
  export type tab_efDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tab_efs to delete
     */
    where?: tab_efWhereInput
  }


  /**
   * tab_ef without action
   */
  export type tab_efArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tab_ef
     */
    select?: tab_efSelect<ExtArgs> | null
  }



  /**
   * Model tablero_efectividad
   */


  export type AggregateTablero_efectividad = {
    _count: Tablero_efectividadCountAggregateOutputType | null
    _avg: Tablero_efectividadAvgAggregateOutputType | null
    _sum: Tablero_efectividadSumAggregateOutputType | null
    _min: Tablero_efectividadMinAggregateOutputType | null
    _max: Tablero_efectividadMaxAggregateOutputType | null
  }

  export type Tablero_efectividadAvgAggregateOutputType = {
    idregistro: number | null
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    por_aumento: number | null
  }

  export type Tablero_efectividadSumAggregateOutputType = {
    idregistro: number | null
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    por_aumento: number | null
  }

  export type Tablero_efectividadMinAggregateOutputType = {
    idregistro: number | null
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    aumento: boolean | null
    por_aumento: number | null
    feriado: boolean | null
  }

  export type Tablero_efectividadMaxAggregateOutputType = {
    idregistro: number | null
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    aumento: boolean | null
    por_aumento: number | null
    feriado: boolean | null
  }

  export type Tablero_efectividadCountAggregateOutputType = {
    idregistro: number
    ano: number
    mes: number
    dia: number
    efectividad: number
    aumento: number
    por_aumento: number
    feriado: number
    _all: number
  }


  export type Tablero_efectividadAvgAggregateInputType = {
    idregistro?: true
    ano?: true
    mes?: true
    dia?: true
    efectividad?: true
    por_aumento?: true
  }

  export type Tablero_efectividadSumAggregateInputType = {
    idregistro?: true
    ano?: true
    mes?: true
    dia?: true
    efectividad?: true
    por_aumento?: true
  }

  export type Tablero_efectividadMinAggregateInputType = {
    idregistro?: true
    ano?: true
    mes?: true
    dia?: true
    efectividad?: true
    aumento?: true
    por_aumento?: true
    feriado?: true
  }

  export type Tablero_efectividadMaxAggregateInputType = {
    idregistro?: true
    ano?: true
    mes?: true
    dia?: true
    efectividad?: true
    aumento?: true
    por_aumento?: true
    feriado?: true
  }

  export type Tablero_efectividadCountAggregateInputType = {
    idregistro?: true
    ano?: true
    mes?: true
    dia?: true
    efectividad?: true
    aumento?: true
    por_aumento?: true
    feriado?: true
    _all?: true
  }

  export type Tablero_efectividadAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tablero_efectividad to aggregate.
     */
    where?: tablero_efectividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablero_efectividads to fetch.
     */
    orderBy?: tablero_efectividadOrderByWithRelationInput | tablero_efectividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tablero_efectividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablero_efectividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablero_efectividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tablero_efectividads
    **/
    _count?: true | Tablero_efectividadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tablero_efectividadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tablero_efectividadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tablero_efectividadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tablero_efectividadMaxAggregateInputType
  }

  export type GetTablero_efectividadAggregateType<T extends Tablero_efectividadAggregateArgs> = {
        [P in keyof T & keyof AggregateTablero_efectividad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTablero_efectividad[P]>
      : GetScalarType<T[P], AggregateTablero_efectividad[P]>
  }




  export type tablero_efectividadGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tablero_efectividadWhereInput
    orderBy?: tablero_efectividadOrderByWithAggregationInput | tablero_efectividadOrderByWithAggregationInput[]
    by: Tablero_efectividadScalarFieldEnum[] | Tablero_efectividadScalarFieldEnum
    having?: tablero_efectividadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tablero_efectividadCountAggregateInputType | true
    _avg?: Tablero_efectividadAvgAggregateInputType
    _sum?: Tablero_efectividadSumAggregateInputType
    _min?: Tablero_efectividadMinAggregateInputType
    _max?: Tablero_efectividadMaxAggregateInputType
  }


  export type Tablero_efectividadGroupByOutputType = {
    idregistro: number
    ano: number | null
    mes: number | null
    dia: number | null
    efectividad: number | null
    aumento: boolean | null
    por_aumento: number | null
    feriado: boolean | null
    _count: Tablero_efectividadCountAggregateOutputType | null
    _avg: Tablero_efectividadAvgAggregateOutputType | null
    _sum: Tablero_efectividadSumAggregateOutputType | null
    _min: Tablero_efectividadMinAggregateOutputType | null
    _max: Tablero_efectividadMaxAggregateOutputType | null
  }

  type GetTablero_efectividadGroupByPayload<T extends tablero_efectividadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tablero_efectividadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tablero_efectividadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tablero_efectividadGroupByOutputType[P]>
            : GetScalarType<T[P], Tablero_efectividadGroupByOutputType[P]>
        }
      >
    >


  export type tablero_efectividadSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idregistro?: boolean
    ano?: boolean
    mes?: boolean
    dia?: boolean
    efectividad?: boolean
    aumento?: boolean
    por_aumento?: boolean
    feriado?: boolean
  }, ExtArgs["result"]["tablero_efectividad"]>

  export type tablero_efectividadSelectScalar = {
    idregistro?: boolean
    ano?: boolean
    mes?: boolean
    dia?: boolean
    efectividad?: boolean
    aumento?: boolean
    por_aumento?: boolean
    feriado?: boolean
  }


  type tablero_efectividadGetPayload<S extends boolean | null | undefined | tablero_efectividadArgs> = $Types.GetResult<tablero_efectividadPayload, S>

  type tablero_efectividadCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tablero_efectividadFindManyArgs, 'select' | 'include'> & {
      select?: Tablero_efectividadCountAggregateInputType | true
    }

  export interface tablero_efectividadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tablero_efectividad'], meta: { name: 'tablero_efectividad' } }
    /**
     * Find zero or one Tablero_efectividad that matches the filter.
     * @param {tablero_efectividadFindUniqueArgs} args - Arguments to find a Tablero_efectividad
     * @example
     * // Get one Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tablero_efectividadFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tablero_efectividadFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tablero_efectividad'> extends True ? Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tablero_efectividad that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tablero_efectividadFindUniqueOrThrowArgs} args - Arguments to find a Tablero_efectividad
     * @example
     * // Get one Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tablero_efectividadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tablero_efectividadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tablero_efectividad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadFindFirstArgs} args - Arguments to find a Tablero_efectividad
     * @example
     * // Get one Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tablero_efectividadFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tablero_efectividadFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tablero_efectividad'> extends True ? Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tablero_efectividad that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadFindFirstOrThrowArgs} args - Arguments to find a Tablero_efectividad
     * @example
     * // Get one Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tablero_efectividadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tablero_efectividadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tablero_efectividads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tablero_efectividads
     * const tablero_efectividads = await prisma.tablero_efectividad.findMany()
     * 
     * // Get first 10 Tablero_efectividads
     * const tablero_efectividads = await prisma.tablero_efectividad.findMany({ take: 10 })
     * 
     * // Only select the `idregistro`
     * const tablero_efectividadWithIdregistroOnly = await prisma.tablero_efectividad.findMany({ select: { idregistro: true } })
     * 
    **/
    findMany<T extends tablero_efectividadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablero_efectividadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tablero_efectividad.
     * @param {tablero_efectividadCreateArgs} args - Arguments to create a Tablero_efectividad.
     * @example
     * // Create one Tablero_efectividad
     * const Tablero_efectividad = await prisma.tablero_efectividad.create({
     *   data: {
     *     // ... data to create a Tablero_efectividad
     *   }
     * })
     * 
    **/
    create<T extends tablero_efectividadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tablero_efectividadCreateArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tablero_efectividads.
     *     @param {tablero_efectividadCreateManyArgs} args - Arguments to create many Tablero_efectividads.
     *     @example
     *     // Create many Tablero_efectividads
     *     const tablero_efectividad = await prisma.tablero_efectividad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tablero_efectividadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablero_efectividadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tablero_efectividad.
     * @param {tablero_efectividadDeleteArgs} args - Arguments to delete one Tablero_efectividad.
     * @example
     * // Delete one Tablero_efectividad
     * const Tablero_efectividad = await prisma.tablero_efectividad.delete({
     *   where: {
     *     // ... filter to delete one Tablero_efectividad
     *   }
     * })
     * 
    **/
    delete<T extends tablero_efectividadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tablero_efectividadDeleteArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tablero_efectividad.
     * @param {tablero_efectividadUpdateArgs} args - Arguments to update one Tablero_efectividad.
     * @example
     * // Update one Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tablero_efectividadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tablero_efectividadUpdateArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tablero_efectividads.
     * @param {tablero_efectividadDeleteManyArgs} args - Arguments to filter Tablero_efectividads to delete.
     * @example
     * // Delete a few Tablero_efectividads
     * const { count } = await prisma.tablero_efectividad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tablero_efectividadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tablero_efectividadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tablero_efectividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tablero_efectividads
     * const tablero_efectividad = await prisma.tablero_efectividad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tablero_efectividadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tablero_efectividadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tablero_efectividad.
     * @param {tablero_efectividadUpsertArgs} args - Arguments to update or create a Tablero_efectividad.
     * @example
     * // Update or create a Tablero_efectividad
     * const tablero_efectividad = await prisma.tablero_efectividad.upsert({
     *   create: {
     *     // ... data to create a Tablero_efectividad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tablero_efectividad we want to update
     *   }
     * })
    **/
    upsert<T extends tablero_efectividadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tablero_efectividadUpsertArgs<ExtArgs>>
    ): Prisma__tablero_efectividadClient<$Types.GetResult<tablero_efectividadPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tablero_efectividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadCountArgs} args - Arguments to filter Tablero_efectividads to count.
     * @example
     * // Count the number of Tablero_efectividads
     * const count = await prisma.tablero_efectividad.count({
     *   where: {
     *     // ... the filter for the Tablero_efectividads we want to count
     *   }
     * })
    **/
    count<T extends tablero_efectividadCountArgs>(
      args?: Subset<T, tablero_efectividadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tablero_efectividadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tablero_efectividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tablero_efectividadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tablero_efectividadAggregateArgs>(args: Subset<T, Tablero_efectividadAggregateArgs>): Prisma.PrismaPromise<GetTablero_efectividadAggregateType<T>>

    /**
     * Group by Tablero_efectividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tablero_efectividadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tablero_efectividadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tablero_efectividadGroupByArgs['orderBy'] }
        : { orderBy?: tablero_efectividadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tablero_efectividadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTablero_efectividadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tablero_efectividad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tablero_efectividadClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tablero_efectividad base type for findUnique actions
   */
  export type tablero_efectividadFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter, which tablero_efectividad to fetch.
     */
    where: tablero_efectividadWhereUniqueInput
  }

  /**
   * tablero_efectividad findUnique
   */
  export interface tablero_efectividadFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tablero_efectividadFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablero_efectividad findUniqueOrThrow
   */
  export type tablero_efectividadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter, which tablero_efectividad to fetch.
     */
    where: tablero_efectividadWhereUniqueInput
  }


  /**
   * tablero_efectividad base type for findFirst actions
   */
  export type tablero_efectividadFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter, which tablero_efectividad to fetch.
     */
    where?: tablero_efectividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablero_efectividads to fetch.
     */
    orderBy?: tablero_efectividadOrderByWithRelationInput | tablero_efectividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablero_efectividads.
     */
    cursor?: tablero_efectividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablero_efectividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablero_efectividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablero_efectividads.
     */
    distinct?: Tablero_efectividadScalarFieldEnum | Tablero_efectividadScalarFieldEnum[]
  }

  /**
   * tablero_efectividad findFirst
   */
  export interface tablero_efectividadFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tablero_efectividadFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablero_efectividad findFirstOrThrow
   */
  export type tablero_efectividadFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter, which tablero_efectividad to fetch.
     */
    where?: tablero_efectividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablero_efectividads to fetch.
     */
    orderBy?: tablero_efectividadOrderByWithRelationInput | tablero_efectividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablero_efectividads.
     */
    cursor?: tablero_efectividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablero_efectividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablero_efectividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablero_efectividads.
     */
    distinct?: Tablero_efectividadScalarFieldEnum | Tablero_efectividadScalarFieldEnum[]
  }


  /**
   * tablero_efectividad findMany
   */
  export type tablero_efectividadFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter, which tablero_efectividads to fetch.
     */
    where?: tablero_efectividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablero_efectividads to fetch.
     */
    orderBy?: tablero_efectividadOrderByWithRelationInput | tablero_efectividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tablero_efectividads.
     */
    cursor?: tablero_efectividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablero_efectividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablero_efectividads.
     */
    skip?: number
    distinct?: Tablero_efectividadScalarFieldEnum | Tablero_efectividadScalarFieldEnum[]
  }


  /**
   * tablero_efectividad create
   */
  export type tablero_efectividadCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * The data needed to create a tablero_efectividad.
     */
    data?: XOR<tablero_efectividadCreateInput, tablero_efectividadUncheckedCreateInput>
  }


  /**
   * tablero_efectividad createMany
   */
  export type tablero_efectividadCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tablero_efectividads.
     */
    data: tablero_efectividadCreateManyInput | tablero_efectividadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tablero_efectividad update
   */
  export type tablero_efectividadUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * The data needed to update a tablero_efectividad.
     */
    data: XOR<tablero_efectividadUpdateInput, tablero_efectividadUncheckedUpdateInput>
    /**
     * Choose, which tablero_efectividad to update.
     */
    where: tablero_efectividadWhereUniqueInput
  }


  /**
   * tablero_efectividad updateMany
   */
  export type tablero_efectividadUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tablero_efectividads.
     */
    data: XOR<tablero_efectividadUpdateManyMutationInput, tablero_efectividadUncheckedUpdateManyInput>
    /**
     * Filter which tablero_efectividads to update
     */
    where?: tablero_efectividadWhereInput
  }


  /**
   * tablero_efectividad upsert
   */
  export type tablero_efectividadUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * The filter to search for the tablero_efectividad to update in case it exists.
     */
    where: tablero_efectividadWhereUniqueInput
    /**
     * In case the tablero_efectividad found by the `where` argument doesn't exist, create a new tablero_efectividad with this data.
     */
    create: XOR<tablero_efectividadCreateInput, tablero_efectividadUncheckedCreateInput>
    /**
     * In case the tablero_efectividad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tablero_efectividadUpdateInput, tablero_efectividadUncheckedUpdateInput>
  }


  /**
   * tablero_efectividad delete
   */
  export type tablero_efectividadDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
    /**
     * Filter which tablero_efectividad to delete.
     */
    where: tablero_efectividadWhereUniqueInput
  }


  /**
   * tablero_efectividad deleteMany
   */
  export type tablero_efectividadDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tablero_efectividads to delete
     */
    where?: tablero_efectividadWhereInput
  }


  /**
   * tablero_efectividad without action
   */
  export type tablero_efectividadArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tablero_efectividad
     */
    select?: tablero_efectividadSelect<ExtArgs> | null
  }



  /**
   * Model tareas_sucursales
   */


  export type AggregateTareas_sucursales = {
    _count: Tareas_sucursalesCountAggregateOutputType | null
    _avg: Tareas_sucursalesAvgAggregateOutputType | null
    _sum: Tareas_sucursalesSumAggregateOutputType | null
    _min: Tareas_sucursalesMinAggregateOutputType | null
    _max: Tareas_sucursalesMaxAggregateOutputType | null
  }

  export type Tareas_sucursalesAvgAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type Tareas_sucursalesSumAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type Tareas_sucursalesMinAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
    priority: number | null
    sucursal: string | null
    operador: string | null
    leido: boolean | null
  }

  export type Tareas_sucursalesMaxAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
    priority: number | null
    sucursal: string | null
    operador: string | null
    leido: boolean | null
  }

  export type Tareas_sucursalesCountAggregateOutputType = {
    idevents: number
    title: number
    allDay: number
    start: number
    end: number
    priority: number
    sucursal: number
    operador: number
    leido: number
    _all: number
  }


  export type Tareas_sucursalesAvgAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type Tareas_sucursalesSumAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type Tareas_sucursalesMinAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    sucursal?: true
    operador?: true
    leido?: true
  }

  export type Tareas_sucursalesMaxAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    sucursal?: true
    operador?: true
    leido?: true
  }

  export type Tareas_sucursalesCountAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    sucursal?: true
    operador?: true
    leido?: true
    _all?: true
  }

  export type Tareas_sucursalesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas_sucursales to aggregate.
     */
    where?: tareas_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_sucursales to fetch.
     */
    orderBy?: tareas_sucursalesOrderByWithRelationInput | tareas_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareas_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas_sucursales
    **/
    _count?: true | Tareas_sucursalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tareas_sucursalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tareas_sucursalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tareas_sucursalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tareas_sucursalesMaxAggregateInputType
  }

  export type GetTareas_sucursalesAggregateType<T extends Tareas_sucursalesAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas_sucursales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas_sucursales[P]>
      : GetScalarType<T[P], AggregateTareas_sucursales[P]>
  }




  export type tareas_sucursalesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tareas_sucursalesWhereInput
    orderBy?: tareas_sucursalesOrderByWithAggregationInput | tareas_sucursalesOrderByWithAggregationInput[]
    by: Tareas_sucursalesScalarFieldEnum[] | Tareas_sucursalesScalarFieldEnum
    having?: tareas_sucursalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tareas_sucursalesCountAggregateInputType | true
    _avg?: Tareas_sucursalesAvgAggregateInputType
    _sum?: Tareas_sucursalesSumAggregateInputType
    _min?: Tareas_sucursalesMinAggregateInputType
    _max?: Tareas_sucursalesMaxAggregateInputType
  }


  export type Tareas_sucursalesGroupByOutputType = {
    idevents: number
    title: string | null
    allDay: number | null
    start: Date | null
    end: Date | null
    priority: number | null
    sucursal: string | null
    operador: string | null
    leido: boolean | null
    _count: Tareas_sucursalesCountAggregateOutputType | null
    _avg: Tareas_sucursalesAvgAggregateOutputType | null
    _sum: Tareas_sucursalesSumAggregateOutputType | null
    _min: Tareas_sucursalesMinAggregateOutputType | null
    _max: Tareas_sucursalesMaxAggregateOutputType | null
  }

  type GetTareas_sucursalesGroupByPayload<T extends tareas_sucursalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tareas_sucursalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tareas_sucursalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tareas_sucursalesGroupByOutputType[P]>
            : GetScalarType<T[P], Tareas_sucursalesGroupByOutputType[P]>
        }
      >
    >


  export type tareas_sucursalesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
    sucursal?: boolean
    operador?: boolean
    leido?: boolean
  }, ExtArgs["result"]["tareas_sucursales"]>

  export type tareas_sucursalesSelectScalar = {
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
    sucursal?: boolean
    operador?: boolean
    leido?: boolean
  }


  type tareas_sucursalesGetPayload<S extends boolean | null | undefined | tareas_sucursalesArgs> = $Types.GetResult<tareas_sucursalesPayload, S>

  type tareas_sucursalesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tareas_sucursalesFindManyArgs, 'select' | 'include'> & {
      select?: Tareas_sucursalesCountAggregateInputType | true
    }

  export interface tareas_sucursalesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tareas_sucursales'], meta: { name: 'tareas_sucursales' } }
    /**
     * Find zero or one Tareas_sucursales that matches the filter.
     * @param {tareas_sucursalesFindUniqueArgs} args - Arguments to find a Tareas_sucursales
     * @example
     * // Get one Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareas_sucursalesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareas_sucursalesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas_sucursales'> extends True ? Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tareas_sucursales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareas_sucursalesFindUniqueOrThrowArgs} args - Arguments to find a Tareas_sucursales
     * @example
     * // Get one Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareas_sucursalesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_sucursalesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tareas_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesFindFirstArgs} args - Arguments to find a Tareas_sucursales
     * @example
     * // Get one Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareas_sucursalesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareas_sucursalesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas_sucursales'> extends True ? Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tareas_sucursales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesFindFirstOrThrowArgs} args - Arguments to find a Tareas_sucursales
     * @example
     * // Get one Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareas_sucursalesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_sucursalesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tareas_sucursales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findMany()
     * 
     * // Get first 10 Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.findMany({ take: 10 })
     * 
     * // Only select the `idevents`
     * const tareas_sucursalesWithIdeventsOnly = await prisma.tareas_sucursales.findMany({ select: { idevents: true } })
     * 
    **/
    findMany<T extends tareas_sucursalesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_sucursalesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tareas_sucursales.
     * @param {tareas_sucursalesCreateArgs} args - Arguments to create a Tareas_sucursales.
     * @example
     * // Create one Tareas_sucursales
     * const Tareas_sucursales = await prisma.tareas_sucursales.create({
     *   data: {
     *     // ... data to create a Tareas_sucursales
     *   }
     * })
     * 
    **/
    create<T extends tareas_sucursalesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_sucursalesCreateArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tareas_sucursales.
     *     @param {tareas_sucursalesCreateManyArgs} args - Arguments to create many Tareas_sucursales.
     *     @example
     *     // Create many Tareas_sucursales
     *     const tareas_sucursales = await prisma.tareas_sucursales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareas_sucursalesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_sucursalesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas_sucursales.
     * @param {tareas_sucursalesDeleteArgs} args - Arguments to delete one Tareas_sucursales.
     * @example
     * // Delete one Tareas_sucursales
     * const Tareas_sucursales = await prisma.tareas_sucursales.delete({
     *   where: {
     *     // ... filter to delete one Tareas_sucursales
     *   }
     * })
     * 
    **/
    delete<T extends tareas_sucursalesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_sucursalesDeleteArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tareas_sucursales.
     * @param {tareas_sucursalesUpdateArgs} args - Arguments to update one Tareas_sucursales.
     * @example
     * // Update one Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareas_sucursalesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_sucursalesUpdateArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tareas_sucursales.
     * @param {tareas_sucursalesDeleteManyArgs} args - Arguments to filter Tareas_sucursales to delete.
     * @example
     * // Delete a few Tareas_sucursales
     * const { count } = await prisma.tareas_sucursales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareas_sucursalesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_sucursalesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareas_sucursalesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_sucursalesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas_sucursales.
     * @param {tareas_sucursalesUpsertArgs} args - Arguments to update or create a Tareas_sucursales.
     * @example
     * // Update or create a Tareas_sucursales
     * const tareas_sucursales = await prisma.tareas_sucursales.upsert({
     *   create: {
     *     // ... data to create a Tareas_sucursales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas_sucursales we want to update
     *   }
     * })
    **/
    upsert<T extends tareas_sucursalesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_sucursalesUpsertArgs<ExtArgs>>
    ): Prisma__tareas_sucursalesClient<$Types.GetResult<tareas_sucursalesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tareas_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesCountArgs} args - Arguments to filter Tareas_sucursales to count.
     * @example
     * // Count the number of Tareas_sucursales
     * const count = await prisma.tareas_sucursales.count({
     *   where: {
     *     // ... the filter for the Tareas_sucursales we want to count
     *   }
     * })
    **/
    count<T extends tareas_sucursalesCountArgs>(
      args?: Subset<T, tareas_sucursalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tareas_sucursalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tareas_sucursalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tareas_sucursalesAggregateArgs>(args: Subset<T, Tareas_sucursalesAggregateArgs>): Prisma.PrismaPromise<GetTareas_sucursalesAggregateType<T>>

    /**
     * Group by Tareas_sucursales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_sucursalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tareas_sucursalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tareas_sucursalesGroupByArgs['orderBy'] }
        : { orderBy?: tareas_sucursalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tareas_sucursalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareas_sucursalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas_sucursales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareas_sucursalesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas_sucursales base type for findUnique actions
   */
  export type tareas_sucursalesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_sucursales to fetch.
     */
    where: tareas_sucursalesWhereUniqueInput
  }

  /**
   * tareas_sucursales findUnique
   */
  export interface tareas_sucursalesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareas_sucursalesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_sucursales findUniqueOrThrow
   */
  export type tareas_sucursalesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_sucursales to fetch.
     */
    where: tareas_sucursalesWhereUniqueInput
  }


  /**
   * tareas_sucursales base type for findFirst actions
   */
  export type tareas_sucursalesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_sucursales to fetch.
     */
    where?: tareas_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_sucursales to fetch.
     */
    orderBy?: tareas_sucursalesOrderByWithRelationInput | tareas_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_sucursales.
     */
    cursor?: tareas_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_sucursales.
     */
    distinct?: Tareas_sucursalesScalarFieldEnum | Tareas_sucursalesScalarFieldEnum[]
  }

  /**
   * tareas_sucursales findFirst
   */
  export interface tareas_sucursalesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareas_sucursalesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_sucursales findFirstOrThrow
   */
  export type tareas_sucursalesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_sucursales to fetch.
     */
    where?: tareas_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_sucursales to fetch.
     */
    orderBy?: tareas_sucursalesOrderByWithRelationInput | tareas_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_sucursales.
     */
    cursor?: tareas_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_sucursales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_sucursales.
     */
    distinct?: Tareas_sucursalesScalarFieldEnum | Tareas_sucursalesScalarFieldEnum[]
  }


  /**
   * tareas_sucursales findMany
   */
  export type tareas_sucursalesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_sucursales to fetch.
     */
    where?: tareas_sucursalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_sucursales to fetch.
     */
    orderBy?: tareas_sucursalesOrderByWithRelationInput | tareas_sucursalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas_sucursales.
     */
    cursor?: tareas_sucursalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_sucursales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_sucursales.
     */
    skip?: number
    distinct?: Tareas_sucursalesScalarFieldEnum | Tareas_sucursalesScalarFieldEnum[]
  }


  /**
   * tareas_sucursales create
   */
  export type tareas_sucursalesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to create a tareas_sucursales.
     */
    data?: XOR<tareas_sucursalesCreateInput, tareas_sucursalesUncheckedCreateInput>
  }


  /**
   * tareas_sucursales createMany
   */
  export type tareas_sucursalesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tareas_sucursales.
     */
    data: tareas_sucursalesCreateManyInput | tareas_sucursalesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tareas_sucursales update
   */
  export type tareas_sucursalesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * The data needed to update a tareas_sucursales.
     */
    data: XOR<tareas_sucursalesUpdateInput, tareas_sucursalesUncheckedUpdateInput>
    /**
     * Choose, which tareas_sucursales to update.
     */
    where: tareas_sucursalesWhereUniqueInput
  }


  /**
   * tareas_sucursales updateMany
   */
  export type tareas_sucursalesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tareas_sucursales.
     */
    data: XOR<tareas_sucursalesUpdateManyMutationInput, tareas_sucursalesUncheckedUpdateManyInput>
    /**
     * Filter which tareas_sucursales to update
     */
    where?: tareas_sucursalesWhereInput
  }


  /**
   * tareas_sucursales upsert
   */
  export type tareas_sucursalesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * The filter to search for the tareas_sucursales to update in case it exists.
     */
    where: tareas_sucursalesWhereUniqueInput
    /**
     * In case the tareas_sucursales found by the `where` argument doesn't exist, create a new tareas_sucursales with this data.
     */
    create: XOR<tareas_sucursalesCreateInput, tareas_sucursalesUncheckedCreateInput>
    /**
     * In case the tareas_sucursales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareas_sucursalesUpdateInput, tareas_sucursalesUncheckedUpdateInput>
  }


  /**
   * tareas_sucursales delete
   */
  export type tareas_sucursalesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
    /**
     * Filter which tareas_sucursales to delete.
     */
    where: tareas_sucursalesWhereUniqueInput
  }


  /**
   * tareas_sucursales deleteMany
   */
  export type tareas_sucursalesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas_sucursales to delete
     */
    where?: tareas_sucursalesWhereInput
  }


  /**
   * tareas_sucursales without action
   */
  export type tareas_sucursalesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_sucursales
     */
    select?: tareas_sucursalesSelect<ExtArgs> | null
  }



  /**
   * Model tipo_contratos
   */


  export type AggregateTipo_contratos = {
    _count: Tipo_contratosCountAggregateOutputType | null
    _avg: Tipo_contratosAvgAggregateOutputType | null
    _sum: Tipo_contratosSumAggregateOutputType | null
    _min: Tipo_contratosMinAggregateOutputType | null
    _max: Tipo_contratosMaxAggregateOutputType | null
  }

  export type Tipo_contratosAvgAggregateOutputType = {
    idtipocontrato: number | null
  }

  export type Tipo_contratosSumAggregateOutputType = {
    idtipocontrato: number | null
  }

  export type Tipo_contratosMinAggregateOutputType = {
    idtipocontrato: number | null
    tipo_contrato: string | null
    url: string | null
  }

  export type Tipo_contratosMaxAggregateOutputType = {
    idtipocontrato: number | null
    tipo_contrato: string | null
    url: string | null
  }

  export type Tipo_contratosCountAggregateOutputType = {
    idtipocontrato: number
    tipo_contrato: number
    url: number
    _all: number
  }


  export type Tipo_contratosAvgAggregateInputType = {
    idtipocontrato?: true
  }

  export type Tipo_contratosSumAggregateInputType = {
    idtipocontrato?: true
  }

  export type Tipo_contratosMinAggregateInputType = {
    idtipocontrato?: true
    tipo_contrato?: true
    url?: true
  }

  export type Tipo_contratosMaxAggregateInputType = {
    idtipocontrato?: true
    tipo_contrato?: true
    url?: true
  }

  export type Tipo_contratosCountAggregateInputType = {
    idtipocontrato?: true
    tipo_contrato?: true
    url?: true
    _all?: true
  }

  export type Tipo_contratosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_contratos to aggregate.
     */
    where?: tipo_contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_contratos to fetch.
     */
    orderBy?: tipo_contratosOrderByWithRelationInput | tipo_contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_contratos
    **/
    _count?: true | Tipo_contratosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_contratosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_contratosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_contratosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_contratosMaxAggregateInputType
  }

  export type GetTipo_contratosAggregateType<T extends Tipo_contratosAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_contratos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_contratos[P]>
      : GetScalarType<T[P], AggregateTipo_contratos[P]>
  }




  export type tipo_contratosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tipo_contratosWhereInput
    orderBy?: tipo_contratosOrderByWithAggregationInput | tipo_contratosOrderByWithAggregationInput[]
    by: Tipo_contratosScalarFieldEnum[] | Tipo_contratosScalarFieldEnum
    having?: tipo_contratosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_contratosCountAggregateInputType | true
    _avg?: Tipo_contratosAvgAggregateInputType
    _sum?: Tipo_contratosSumAggregateInputType
    _min?: Tipo_contratosMinAggregateInputType
    _max?: Tipo_contratosMaxAggregateInputType
  }


  export type Tipo_contratosGroupByOutputType = {
    idtipocontrato: number
    tipo_contrato: string | null
    url: string | null
    _count: Tipo_contratosCountAggregateOutputType | null
    _avg: Tipo_contratosAvgAggregateOutputType | null
    _sum: Tipo_contratosSumAggregateOutputType | null
    _min: Tipo_contratosMinAggregateOutputType | null
    _max: Tipo_contratosMaxAggregateOutputType | null
  }

  type GetTipo_contratosGroupByPayload<T extends tipo_contratosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_contratosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_contratosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_contratosGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_contratosGroupByOutputType[P]>
        }
      >
    >


  export type tipo_contratosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtipocontrato?: boolean
    tipo_contrato?: boolean
    url?: boolean
  }, ExtArgs["result"]["tipo_contratos"]>

  export type tipo_contratosSelectScalar = {
    idtipocontrato?: boolean
    tipo_contrato?: boolean
    url?: boolean
  }


  type tipo_contratosGetPayload<S extends boolean | null | undefined | tipo_contratosArgs> = $Types.GetResult<tipo_contratosPayload, S>

  type tipo_contratosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tipo_contratosFindManyArgs, 'select' | 'include'> & {
      select?: Tipo_contratosCountAggregateInputType | true
    }

  export interface tipo_contratosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipo_contratos'], meta: { name: 'tipo_contratos' } }
    /**
     * Find zero or one Tipo_contratos that matches the filter.
     * @param {tipo_contratosFindUniqueArgs} args - Arguments to find a Tipo_contratos
     * @example
     * // Get one Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipo_contratosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tipo_contratosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tipo_contratos'> extends True ? Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tipo_contratos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipo_contratosFindUniqueOrThrowArgs} args - Arguments to find a Tipo_contratos
     * @example
     * // Get one Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipo_contratosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_contratosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tipo_contratos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosFindFirstArgs} args - Arguments to find a Tipo_contratos
     * @example
     * // Get one Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipo_contratosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tipo_contratosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tipo_contratos'> extends True ? Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tipo_contratos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosFindFirstOrThrowArgs} args - Arguments to find a Tipo_contratos
     * @example
     * // Get one Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipo_contratosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_contratosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tipo_contratos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findMany()
     * 
     * // Get first 10 Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.findMany({ take: 10 })
     * 
     * // Only select the `idtipocontrato`
     * const tipo_contratosWithIdtipocontratoOnly = await prisma.tipo_contratos.findMany({ select: { idtipocontrato: true } })
     * 
    **/
    findMany<T extends tipo_contratosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_contratosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tipo_contratos.
     * @param {tipo_contratosCreateArgs} args - Arguments to create a Tipo_contratos.
     * @example
     * // Create one Tipo_contratos
     * const Tipo_contratos = await prisma.tipo_contratos.create({
     *   data: {
     *     // ... data to create a Tipo_contratos
     *   }
     * })
     * 
    **/
    create<T extends tipo_contratosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_contratosCreateArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tipo_contratos.
     *     @param {tipo_contratosCreateManyArgs} args - Arguments to create many Tipo_contratos.
     *     @example
     *     // Create many Tipo_contratos
     *     const tipo_contratos = await prisma.tipo_contratos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipo_contratosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_contratosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_contratos.
     * @param {tipo_contratosDeleteArgs} args - Arguments to delete one Tipo_contratos.
     * @example
     * // Delete one Tipo_contratos
     * const Tipo_contratos = await prisma.tipo_contratos.delete({
     *   where: {
     *     // ... filter to delete one Tipo_contratos
     *   }
     * })
     * 
    **/
    delete<T extends tipo_contratosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_contratosDeleteArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tipo_contratos.
     * @param {tipo_contratosUpdateArgs} args - Arguments to update one Tipo_contratos.
     * @example
     * // Update one Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipo_contratosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_contratosUpdateArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tipo_contratos.
     * @param {tipo_contratosDeleteManyArgs} args - Arguments to filter Tipo_contratos to delete.
     * @example
     * // Delete a few Tipo_contratos
     * const { count } = await prisma.tipo_contratos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipo_contratosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_contratosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipo_contratosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_contratosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_contratos.
     * @param {tipo_contratosUpsertArgs} args - Arguments to update or create a Tipo_contratos.
     * @example
     * // Update or create a Tipo_contratos
     * const tipo_contratos = await prisma.tipo_contratos.upsert({
     *   create: {
     *     // ... data to create a Tipo_contratos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_contratos we want to update
     *   }
     * })
    **/
    upsert<T extends tipo_contratosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_contratosUpsertArgs<ExtArgs>>
    ): Prisma__tipo_contratosClient<$Types.GetResult<tipo_contratosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tipo_contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosCountArgs} args - Arguments to filter Tipo_contratos to count.
     * @example
     * // Count the number of Tipo_contratos
     * const count = await prisma.tipo_contratos.count({
     *   where: {
     *     // ... the filter for the Tipo_contratos we want to count
     *   }
     * })
    **/
    count<T extends tipo_contratosCountArgs>(
      args?: Subset<T, tipo_contratosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_contratosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_contratosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_contratosAggregateArgs>(args: Subset<T, Tipo_contratosAggregateArgs>): Prisma.PrismaPromise<GetTipo_contratosAggregateType<T>>

    /**
     * Group by Tipo_contratos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_contratosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipo_contratosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipo_contratosGroupByArgs['orderBy'] }
        : { orderBy?: tipo_contratosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipo_contratosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_contratosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_contratos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tipo_contratosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tipo_contratos base type for findUnique actions
   */
  export type tipo_contratosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter, which tipo_contratos to fetch.
     */
    where: tipo_contratosWhereUniqueInput
  }

  /**
   * tipo_contratos findUnique
   */
  export interface tipo_contratosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_contratosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_contratos findUniqueOrThrow
   */
  export type tipo_contratosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter, which tipo_contratos to fetch.
     */
    where: tipo_contratosWhereUniqueInput
  }


  /**
   * tipo_contratos base type for findFirst actions
   */
  export type tipo_contratosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter, which tipo_contratos to fetch.
     */
    where?: tipo_contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_contratos to fetch.
     */
    orderBy?: tipo_contratosOrderByWithRelationInput | tipo_contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_contratos.
     */
    cursor?: tipo_contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_contratos.
     */
    distinct?: Tipo_contratosScalarFieldEnum | Tipo_contratosScalarFieldEnum[]
  }

  /**
   * tipo_contratos findFirst
   */
  export interface tipo_contratosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_contratosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_contratos findFirstOrThrow
   */
  export type tipo_contratosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter, which tipo_contratos to fetch.
     */
    where?: tipo_contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_contratos to fetch.
     */
    orderBy?: tipo_contratosOrderByWithRelationInput | tipo_contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_contratos.
     */
    cursor?: tipo_contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_contratos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_contratos.
     */
    distinct?: Tipo_contratosScalarFieldEnum | Tipo_contratosScalarFieldEnum[]
  }


  /**
   * tipo_contratos findMany
   */
  export type tipo_contratosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter, which tipo_contratos to fetch.
     */
    where?: tipo_contratosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_contratos to fetch.
     */
    orderBy?: tipo_contratosOrderByWithRelationInput | tipo_contratosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_contratos.
     */
    cursor?: tipo_contratosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_contratos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_contratos.
     */
    skip?: number
    distinct?: Tipo_contratosScalarFieldEnum | Tipo_contratosScalarFieldEnum[]
  }


  /**
   * tipo_contratos create
   */
  export type tipo_contratosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * The data needed to create a tipo_contratos.
     */
    data?: XOR<tipo_contratosCreateInput, tipo_contratosUncheckedCreateInput>
  }


  /**
   * tipo_contratos createMany
   */
  export type tipo_contratosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipo_contratos.
     */
    data: tipo_contratosCreateManyInput | tipo_contratosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tipo_contratos update
   */
  export type tipo_contratosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * The data needed to update a tipo_contratos.
     */
    data: XOR<tipo_contratosUpdateInput, tipo_contratosUncheckedUpdateInput>
    /**
     * Choose, which tipo_contratos to update.
     */
    where: tipo_contratosWhereUniqueInput
  }


  /**
   * tipo_contratos updateMany
   */
  export type tipo_contratosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipo_contratos.
     */
    data: XOR<tipo_contratosUpdateManyMutationInput, tipo_contratosUncheckedUpdateManyInput>
    /**
     * Filter which tipo_contratos to update
     */
    where?: tipo_contratosWhereInput
  }


  /**
   * tipo_contratos upsert
   */
  export type tipo_contratosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * The filter to search for the tipo_contratos to update in case it exists.
     */
    where: tipo_contratosWhereUniqueInput
    /**
     * In case the tipo_contratos found by the `where` argument doesn't exist, create a new tipo_contratos with this data.
     */
    create: XOR<tipo_contratosCreateInput, tipo_contratosUncheckedCreateInput>
    /**
     * In case the tipo_contratos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_contratosUpdateInput, tipo_contratosUncheckedUpdateInput>
  }


  /**
   * tipo_contratos delete
   */
  export type tipo_contratosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
    /**
     * Filter which tipo_contratos to delete.
     */
    where: tipo_contratosWhereUniqueInput
  }


  /**
   * tipo_contratos deleteMany
   */
  export type tipo_contratosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_contratos to delete
     */
    where?: tipo_contratosWhereInput
  }


  /**
   * tipo_contratos without action
   */
  export type tipo_contratosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_contratos
     */
    select?: tipo_contratosSelect<ExtArgs> | null
  }



  /**
   * Model tipo_facturas
   */


  export type AggregateTipo_facturas = {
    _count: Tipo_facturasCountAggregateOutputType | null
    _avg: Tipo_facturasAvgAggregateOutputType | null
    _sum: Tipo_facturasSumAggregateOutputType | null
    _min: Tipo_facturasMinAggregateOutputType | null
    _max: Tipo_facturasMaxAggregateOutputType | null
  }

  export type Tipo_facturasAvgAggregateOutputType = {
    idfactura: number | null
  }

  export type Tipo_facturasSumAggregateOutputType = {
    idfactura: number | null
  }

  export type Tipo_facturasMinAggregateOutputType = {
    idfactura: number | null
    tipo_factura: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Tipo_facturasMaxAggregateOutputType = {
    idfactura: number | null
    tipo_factura: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type Tipo_facturasCountAggregateOutputType = {
    idfactura: number
    tipo_factura: number
    fecha: number
    estado: number
    _all: number
  }


  export type Tipo_facturasAvgAggregateInputType = {
    idfactura?: true
  }

  export type Tipo_facturasSumAggregateInputType = {
    idfactura?: true
  }

  export type Tipo_facturasMinAggregateInputType = {
    idfactura?: true
    tipo_factura?: true
    fecha?: true
    estado?: true
  }

  export type Tipo_facturasMaxAggregateInputType = {
    idfactura?: true
    tipo_factura?: true
    fecha?: true
    estado?: true
  }

  export type Tipo_facturasCountAggregateInputType = {
    idfactura?: true
    tipo_factura?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type Tipo_facturasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_facturas to aggregate.
     */
    where?: tipo_facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_facturas to fetch.
     */
    orderBy?: tipo_facturasOrderByWithRelationInput | tipo_facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_facturas
    **/
    _count?: true | Tipo_facturasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_facturasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_facturasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_facturasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_facturasMaxAggregateInputType
  }

  export type GetTipo_facturasAggregateType<T extends Tipo_facturasAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_facturas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_facturas[P]>
      : GetScalarType<T[P], AggregateTipo_facturas[P]>
  }




  export type tipo_facturasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tipo_facturasWhereInput
    orderBy?: tipo_facturasOrderByWithAggregationInput | tipo_facturasOrderByWithAggregationInput[]
    by: Tipo_facturasScalarFieldEnum[] | Tipo_facturasScalarFieldEnum
    having?: tipo_facturasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_facturasCountAggregateInputType | true
    _avg?: Tipo_facturasAvgAggregateInputType
    _sum?: Tipo_facturasSumAggregateInputType
    _min?: Tipo_facturasMinAggregateInputType
    _max?: Tipo_facturasMaxAggregateInputType
  }


  export type Tipo_facturasGroupByOutputType = {
    idfactura: number
    tipo_factura: string | null
    fecha: Date | null
    estado: boolean | null
    _count: Tipo_facturasCountAggregateOutputType | null
    _avg: Tipo_facturasAvgAggregateOutputType | null
    _sum: Tipo_facturasSumAggregateOutputType | null
    _min: Tipo_facturasMinAggregateOutputType | null
    _max: Tipo_facturasMaxAggregateOutputType | null
  }

  type GetTipo_facturasGroupByPayload<T extends tipo_facturasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_facturasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_facturasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_facturasGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_facturasGroupByOutputType[P]>
        }
      >
    >


  export type tipo_facturasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idfactura?: boolean
    tipo_factura?: boolean
    fecha?: boolean
    estado?: boolean
  }, ExtArgs["result"]["tipo_facturas"]>

  export type tipo_facturasSelectScalar = {
    idfactura?: boolean
    tipo_factura?: boolean
    fecha?: boolean
    estado?: boolean
  }


  type tipo_facturasGetPayload<S extends boolean | null | undefined | tipo_facturasArgs> = $Types.GetResult<tipo_facturasPayload, S>

  type tipo_facturasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tipo_facturasFindManyArgs, 'select' | 'include'> & {
      select?: Tipo_facturasCountAggregateInputType | true
    }

  export interface tipo_facturasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipo_facturas'], meta: { name: 'tipo_facturas' } }
    /**
     * Find zero or one Tipo_facturas that matches the filter.
     * @param {tipo_facturasFindUniqueArgs} args - Arguments to find a Tipo_facturas
     * @example
     * // Get one Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipo_facturasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tipo_facturasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tipo_facturas'> extends True ? Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tipo_facturas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipo_facturasFindUniqueOrThrowArgs} args - Arguments to find a Tipo_facturas
     * @example
     * // Get one Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipo_facturasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_facturasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tipo_facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasFindFirstArgs} args - Arguments to find a Tipo_facturas
     * @example
     * // Get one Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipo_facturasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tipo_facturasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tipo_facturas'> extends True ? Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tipo_facturas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasFindFirstOrThrowArgs} args - Arguments to find a Tipo_facturas
     * @example
     * // Get one Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipo_facturasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_facturasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tipo_facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findMany()
     * 
     * // Get first 10 Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.findMany({ take: 10 })
     * 
     * // Only select the `idfactura`
     * const tipo_facturasWithIdfacturaOnly = await prisma.tipo_facturas.findMany({ select: { idfactura: true } })
     * 
    **/
    findMany<T extends tipo_facturasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_facturasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tipo_facturas.
     * @param {tipo_facturasCreateArgs} args - Arguments to create a Tipo_facturas.
     * @example
     * // Create one Tipo_facturas
     * const Tipo_facturas = await prisma.tipo_facturas.create({
     *   data: {
     *     // ... data to create a Tipo_facturas
     *   }
     * })
     * 
    **/
    create<T extends tipo_facturasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_facturasCreateArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tipo_facturas.
     *     @param {tipo_facturasCreateManyArgs} args - Arguments to create many Tipo_facturas.
     *     @example
     *     // Create many Tipo_facturas
     *     const tipo_facturas = await prisma.tipo_facturas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipo_facturasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_facturasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_facturas.
     * @param {tipo_facturasDeleteArgs} args - Arguments to delete one Tipo_facturas.
     * @example
     * // Delete one Tipo_facturas
     * const Tipo_facturas = await prisma.tipo_facturas.delete({
     *   where: {
     *     // ... filter to delete one Tipo_facturas
     *   }
     * })
     * 
    **/
    delete<T extends tipo_facturasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_facturasDeleteArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tipo_facturas.
     * @param {tipo_facturasUpdateArgs} args - Arguments to update one Tipo_facturas.
     * @example
     * // Update one Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipo_facturasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_facturasUpdateArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tipo_facturas.
     * @param {tipo_facturasDeleteManyArgs} args - Arguments to filter Tipo_facturas to delete.
     * @example
     * // Delete a few Tipo_facturas
     * const { count } = await prisma.tipo_facturas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipo_facturasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_facturasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipo_facturasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_facturasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_facturas.
     * @param {tipo_facturasUpsertArgs} args - Arguments to update or create a Tipo_facturas.
     * @example
     * // Update or create a Tipo_facturas
     * const tipo_facturas = await prisma.tipo_facturas.upsert({
     *   create: {
     *     // ... data to create a Tipo_facturas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_facturas we want to update
     *   }
     * })
    **/
    upsert<T extends tipo_facturasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_facturasUpsertArgs<ExtArgs>>
    ): Prisma__tipo_facturasClient<$Types.GetResult<tipo_facturasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tipo_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasCountArgs} args - Arguments to filter Tipo_facturas to count.
     * @example
     * // Count the number of Tipo_facturas
     * const count = await prisma.tipo_facturas.count({
     *   where: {
     *     // ... the filter for the Tipo_facturas we want to count
     *   }
     * })
    **/
    count<T extends tipo_facturasCountArgs>(
      args?: Subset<T, tipo_facturasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_facturasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_facturasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_facturasAggregateArgs>(args: Subset<T, Tipo_facturasAggregateArgs>): Prisma.PrismaPromise<GetTipo_facturasAggregateType<T>>

    /**
     * Group by Tipo_facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_facturasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipo_facturasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipo_facturasGroupByArgs['orderBy'] }
        : { orderBy?: tipo_facturasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipo_facturasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_facturasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_facturas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tipo_facturasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tipo_facturas base type for findUnique actions
   */
  export type tipo_facturasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter, which tipo_facturas to fetch.
     */
    where: tipo_facturasWhereUniqueInput
  }

  /**
   * tipo_facturas findUnique
   */
  export interface tipo_facturasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_facturasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_facturas findUniqueOrThrow
   */
  export type tipo_facturasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter, which tipo_facturas to fetch.
     */
    where: tipo_facturasWhereUniqueInput
  }


  /**
   * tipo_facturas base type for findFirst actions
   */
  export type tipo_facturasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter, which tipo_facturas to fetch.
     */
    where?: tipo_facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_facturas to fetch.
     */
    orderBy?: tipo_facturasOrderByWithRelationInput | tipo_facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_facturas.
     */
    cursor?: tipo_facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_facturas.
     */
    distinct?: Tipo_facturasScalarFieldEnum | Tipo_facturasScalarFieldEnum[]
  }

  /**
   * tipo_facturas findFirst
   */
  export interface tipo_facturasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_facturasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_facturas findFirstOrThrow
   */
  export type tipo_facturasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter, which tipo_facturas to fetch.
     */
    where?: tipo_facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_facturas to fetch.
     */
    orderBy?: tipo_facturasOrderByWithRelationInput | tipo_facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_facturas.
     */
    cursor?: tipo_facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_facturas.
     */
    distinct?: Tipo_facturasScalarFieldEnum | Tipo_facturasScalarFieldEnum[]
  }


  /**
   * tipo_facturas findMany
   */
  export type tipo_facturasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter, which tipo_facturas to fetch.
     */
    where?: tipo_facturasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_facturas to fetch.
     */
    orderBy?: tipo_facturasOrderByWithRelationInput | tipo_facturasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_facturas.
     */
    cursor?: tipo_facturasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_facturas.
     */
    skip?: number
    distinct?: Tipo_facturasScalarFieldEnum | Tipo_facturasScalarFieldEnum[]
  }


  /**
   * tipo_facturas create
   */
  export type tipo_facturasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * The data needed to create a tipo_facturas.
     */
    data?: XOR<tipo_facturasCreateInput, tipo_facturasUncheckedCreateInput>
  }


  /**
   * tipo_facturas createMany
   */
  export type tipo_facturasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipo_facturas.
     */
    data: tipo_facturasCreateManyInput | tipo_facturasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tipo_facturas update
   */
  export type tipo_facturasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * The data needed to update a tipo_facturas.
     */
    data: XOR<tipo_facturasUpdateInput, tipo_facturasUncheckedUpdateInput>
    /**
     * Choose, which tipo_facturas to update.
     */
    where: tipo_facturasWhereUniqueInput
  }


  /**
   * tipo_facturas updateMany
   */
  export type tipo_facturasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipo_facturas.
     */
    data: XOR<tipo_facturasUpdateManyMutationInput, tipo_facturasUncheckedUpdateManyInput>
    /**
     * Filter which tipo_facturas to update
     */
    where?: tipo_facturasWhereInput
  }


  /**
   * tipo_facturas upsert
   */
  export type tipo_facturasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * The filter to search for the tipo_facturas to update in case it exists.
     */
    where: tipo_facturasWhereUniqueInput
    /**
     * In case the tipo_facturas found by the `where` argument doesn't exist, create a new tipo_facturas with this data.
     */
    create: XOR<tipo_facturasCreateInput, tipo_facturasUncheckedCreateInput>
    /**
     * In case the tipo_facturas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_facturasUpdateInput, tipo_facturasUncheckedUpdateInput>
  }


  /**
   * tipo_facturas delete
   */
  export type tipo_facturasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
    /**
     * Filter which tipo_facturas to delete.
     */
    where: tipo_facturasWhereUniqueInput
  }


  /**
   * tipo_facturas deleteMany
   */
  export type tipo_facturasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_facturas to delete
     */
    where?: tipo_facturasWhereInput
  }


  /**
   * tipo_facturas without action
   */
  export type tipo_facturasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_facturas
     */
    select?: tipo_facturasSelect<ExtArgs> | null
  }



  /**
   * Model turno_bajas
   */


  export type AggregateTurno_bajas = {
    _count: Turno_bajasCountAggregateOutputType | null
    _avg: Turno_bajasAvgAggregateOutputType | null
    _sum: Turno_bajasSumAggregateOutputType | null
    _min: Turno_bajasMinAggregateOutputType | null
    _max: Turno_bajasMaxAggregateOutputType | null
  }

  export type Turno_bajasAvgAggregateOutputType = {
    idturno: number | null
    contrato: number | null
    dni: number | null
    estado: number | null
  }

  export type Turno_bajasSumAggregateOutputType = {
    idturno: number | null
    contrato: number | null
    dni: number | null
    estado: number | null
  }

  export type Turno_bajasMinAggregateOutputType = {
    idturno: number | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    fecha_pedido: Date | null
    fecha_turno: Date | null
    motivo: string | null
    operador: string | null
    telefono: string | null
    movil: string | null
    fecha_atencion: Date | null
    estado: number | null
    empresa: string | null
    respuesta: string | null
    operador_atencion: string | null
    detalle: string | null
  }

  export type Turno_bajasMaxAggregateOutputType = {
    idturno: number | null
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    fecha_pedido: Date | null
    fecha_turno: Date | null
    motivo: string | null
    operador: string | null
    telefono: string | null
    movil: string | null
    fecha_atencion: Date | null
    estado: number | null
    empresa: string | null
    respuesta: string | null
    operador_atencion: string | null
    detalle: string | null
  }

  export type Turno_bajasCountAggregateOutputType = {
    idturno: number
    contrato: number
    apellido: number
    nombre: number
    dni: number
    fecha_pedido: number
    fecha_turno: number
    motivo: number
    operador: number
    telefono: number
    movil: number
    fecha_atencion: number
    estado: number
    empresa: number
    respuesta: number
    operador_atencion: number
    detalle: number
    _all: number
  }


  export type Turno_bajasAvgAggregateInputType = {
    idturno?: true
    contrato?: true
    dni?: true
    estado?: true
  }

  export type Turno_bajasSumAggregateInputType = {
    idturno?: true
    contrato?: true
    dni?: true
    estado?: true
  }

  export type Turno_bajasMinAggregateInputType = {
    idturno?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    fecha_pedido?: true
    fecha_turno?: true
    motivo?: true
    operador?: true
    telefono?: true
    movil?: true
    fecha_atencion?: true
    estado?: true
    empresa?: true
    respuesta?: true
    operador_atencion?: true
    detalle?: true
  }

  export type Turno_bajasMaxAggregateInputType = {
    idturno?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    fecha_pedido?: true
    fecha_turno?: true
    motivo?: true
    operador?: true
    telefono?: true
    movil?: true
    fecha_atencion?: true
    estado?: true
    empresa?: true
    respuesta?: true
    operador_atencion?: true
    detalle?: true
  }

  export type Turno_bajasCountAggregateInputType = {
    idturno?: true
    contrato?: true
    apellido?: true
    nombre?: true
    dni?: true
    fecha_pedido?: true
    fecha_turno?: true
    motivo?: true
    operador?: true
    telefono?: true
    movil?: true
    fecha_atencion?: true
    estado?: true
    empresa?: true
    respuesta?: true
    operador_atencion?: true
    detalle?: true
    _all?: true
  }

  export type Turno_bajasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which turno_bajas to aggregate.
     */
    where?: turno_bajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turno_bajas to fetch.
     */
    orderBy?: turno_bajasOrderByWithRelationInput | turno_bajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: turno_bajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turno_bajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turno_bajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned turno_bajas
    **/
    _count?: true | Turno_bajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Turno_bajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Turno_bajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Turno_bajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Turno_bajasMaxAggregateInputType
  }

  export type GetTurno_bajasAggregateType<T extends Turno_bajasAggregateArgs> = {
        [P in keyof T & keyof AggregateTurno_bajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurno_bajas[P]>
      : GetScalarType<T[P], AggregateTurno_bajas[P]>
  }




  export type turno_bajasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: turno_bajasWhereInput
    orderBy?: turno_bajasOrderByWithAggregationInput | turno_bajasOrderByWithAggregationInput[]
    by: Turno_bajasScalarFieldEnum[] | Turno_bajasScalarFieldEnum
    having?: turno_bajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Turno_bajasCountAggregateInputType | true
    _avg?: Turno_bajasAvgAggregateInputType
    _sum?: Turno_bajasSumAggregateInputType
    _min?: Turno_bajasMinAggregateInputType
    _max?: Turno_bajasMaxAggregateInputType
  }


  export type Turno_bajasGroupByOutputType = {
    idturno: number
    contrato: number | null
    apellido: string | null
    nombre: string | null
    dni: number | null
    fecha_pedido: Date | null
    fecha_turno: Date | null
    motivo: string | null
    operador: string | null
    telefono: string | null
    movil: string | null
    fecha_atencion: Date | null
    estado: number | null
    empresa: string | null
    respuesta: string | null
    operador_atencion: string | null
    detalle: string | null
    _count: Turno_bajasCountAggregateOutputType | null
    _avg: Turno_bajasAvgAggregateOutputType | null
    _sum: Turno_bajasSumAggregateOutputType | null
    _min: Turno_bajasMinAggregateOutputType | null
    _max: Turno_bajasMaxAggregateOutputType | null
  }

  type GetTurno_bajasGroupByPayload<T extends turno_bajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Turno_bajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Turno_bajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Turno_bajasGroupByOutputType[P]>
            : GetScalarType<T[P], Turno_bajasGroupByOutputType[P]>
        }
      >
    >


  export type turno_bajasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idturno?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    fecha_pedido?: boolean
    fecha_turno?: boolean
    motivo?: boolean
    operador?: boolean
    telefono?: boolean
    movil?: boolean
    fecha_atencion?: boolean
    estado?: boolean
    empresa?: boolean
    respuesta?: boolean
    operador_atencion?: boolean
    detalle?: boolean
  }, ExtArgs["result"]["turno_bajas"]>

  export type turno_bajasSelectScalar = {
    idturno?: boolean
    contrato?: boolean
    apellido?: boolean
    nombre?: boolean
    dni?: boolean
    fecha_pedido?: boolean
    fecha_turno?: boolean
    motivo?: boolean
    operador?: boolean
    telefono?: boolean
    movil?: boolean
    fecha_atencion?: boolean
    estado?: boolean
    empresa?: boolean
    respuesta?: boolean
    operador_atencion?: boolean
    detalle?: boolean
  }


  type turno_bajasGetPayload<S extends boolean | null | undefined | turno_bajasArgs> = $Types.GetResult<turno_bajasPayload, S>

  type turno_bajasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<turno_bajasFindManyArgs, 'select' | 'include'> & {
      select?: Turno_bajasCountAggregateInputType | true
    }

  export interface turno_bajasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['turno_bajas'], meta: { name: 'turno_bajas' } }
    /**
     * Find zero or one Turno_bajas that matches the filter.
     * @param {turno_bajasFindUniqueArgs} args - Arguments to find a Turno_bajas
     * @example
     * // Get one Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends turno_bajasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, turno_bajasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'turno_bajas'> extends True ? Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Turno_bajas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {turno_bajasFindUniqueOrThrowArgs} args - Arguments to find a Turno_bajas
     * @example
     * // Get one Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends turno_bajasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, turno_bajasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Turno_bajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasFindFirstArgs} args - Arguments to find a Turno_bajas
     * @example
     * // Get one Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends turno_bajasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, turno_bajasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'turno_bajas'> extends True ? Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Turno_bajas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasFindFirstOrThrowArgs} args - Arguments to find a Turno_bajas
     * @example
     * // Get one Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends turno_bajasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, turno_bajasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Turno_bajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findMany()
     * 
     * // Get first 10 Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.findMany({ take: 10 })
     * 
     * // Only select the `idturno`
     * const turno_bajasWithIdturnoOnly = await prisma.turno_bajas.findMany({ select: { idturno: true } })
     * 
    **/
    findMany<T extends turno_bajasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, turno_bajasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Turno_bajas.
     * @param {turno_bajasCreateArgs} args - Arguments to create a Turno_bajas.
     * @example
     * // Create one Turno_bajas
     * const Turno_bajas = await prisma.turno_bajas.create({
     *   data: {
     *     // ... data to create a Turno_bajas
     *   }
     * })
     * 
    **/
    create<T extends turno_bajasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, turno_bajasCreateArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Turno_bajas.
     *     @param {turno_bajasCreateManyArgs} args - Arguments to create many Turno_bajas.
     *     @example
     *     // Create many Turno_bajas
     *     const turno_bajas = await prisma.turno_bajas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends turno_bajasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, turno_bajasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Turno_bajas.
     * @param {turno_bajasDeleteArgs} args - Arguments to delete one Turno_bajas.
     * @example
     * // Delete one Turno_bajas
     * const Turno_bajas = await prisma.turno_bajas.delete({
     *   where: {
     *     // ... filter to delete one Turno_bajas
     *   }
     * })
     * 
    **/
    delete<T extends turno_bajasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, turno_bajasDeleteArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Turno_bajas.
     * @param {turno_bajasUpdateArgs} args - Arguments to update one Turno_bajas.
     * @example
     * // Update one Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends turno_bajasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, turno_bajasUpdateArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Turno_bajas.
     * @param {turno_bajasDeleteManyArgs} args - Arguments to filter Turno_bajas to delete.
     * @example
     * // Delete a few Turno_bajas
     * const { count } = await prisma.turno_bajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends turno_bajasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, turno_bajasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turno_bajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends turno_bajasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, turno_bajasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Turno_bajas.
     * @param {turno_bajasUpsertArgs} args - Arguments to update or create a Turno_bajas.
     * @example
     * // Update or create a Turno_bajas
     * const turno_bajas = await prisma.turno_bajas.upsert({
     *   create: {
     *     // ... data to create a Turno_bajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turno_bajas we want to update
     *   }
     * })
    **/
    upsert<T extends turno_bajasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, turno_bajasUpsertArgs<ExtArgs>>
    ): Prisma__turno_bajasClient<$Types.GetResult<turno_bajasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Turno_bajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasCountArgs} args - Arguments to filter Turno_bajas to count.
     * @example
     * // Count the number of Turno_bajas
     * const count = await prisma.turno_bajas.count({
     *   where: {
     *     // ... the filter for the Turno_bajas we want to count
     *   }
     * })
    **/
    count<T extends turno_bajasCountArgs>(
      args?: Subset<T, turno_bajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Turno_bajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turno_bajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Turno_bajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Turno_bajasAggregateArgs>(args: Subset<T, Turno_bajasAggregateArgs>): Prisma.PrismaPromise<GetTurno_bajasAggregateType<T>>

    /**
     * Group by Turno_bajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {turno_bajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends turno_bajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: turno_bajasGroupByArgs['orderBy'] }
        : { orderBy?: turno_bajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, turno_bajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTurno_bajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for turno_bajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__turno_bajasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * turno_bajas base type for findUnique actions
   */
  export type turno_bajasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter, which turno_bajas to fetch.
     */
    where: turno_bajasWhereUniqueInput
  }

  /**
   * turno_bajas findUnique
   */
  export interface turno_bajasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends turno_bajasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * turno_bajas findUniqueOrThrow
   */
  export type turno_bajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter, which turno_bajas to fetch.
     */
    where: turno_bajasWhereUniqueInput
  }


  /**
   * turno_bajas base type for findFirst actions
   */
  export type turno_bajasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter, which turno_bajas to fetch.
     */
    where?: turno_bajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turno_bajas to fetch.
     */
    orderBy?: turno_bajasOrderByWithRelationInput | turno_bajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turno_bajas.
     */
    cursor?: turno_bajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turno_bajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turno_bajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turno_bajas.
     */
    distinct?: Turno_bajasScalarFieldEnum | Turno_bajasScalarFieldEnum[]
  }

  /**
   * turno_bajas findFirst
   */
  export interface turno_bajasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends turno_bajasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * turno_bajas findFirstOrThrow
   */
  export type turno_bajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter, which turno_bajas to fetch.
     */
    where?: turno_bajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turno_bajas to fetch.
     */
    orderBy?: turno_bajasOrderByWithRelationInput | turno_bajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for turno_bajas.
     */
    cursor?: turno_bajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turno_bajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turno_bajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of turno_bajas.
     */
    distinct?: Turno_bajasScalarFieldEnum | Turno_bajasScalarFieldEnum[]
  }


  /**
   * turno_bajas findMany
   */
  export type turno_bajasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter, which turno_bajas to fetch.
     */
    where?: turno_bajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of turno_bajas to fetch.
     */
    orderBy?: turno_bajasOrderByWithRelationInput | turno_bajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing turno_bajas.
     */
    cursor?: turno_bajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` turno_bajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` turno_bajas.
     */
    skip?: number
    distinct?: Turno_bajasScalarFieldEnum | Turno_bajasScalarFieldEnum[]
  }


  /**
   * turno_bajas create
   */
  export type turno_bajasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * The data needed to create a turno_bajas.
     */
    data?: XOR<turno_bajasCreateInput, turno_bajasUncheckedCreateInput>
  }


  /**
   * turno_bajas createMany
   */
  export type turno_bajasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many turno_bajas.
     */
    data: turno_bajasCreateManyInput | turno_bajasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * turno_bajas update
   */
  export type turno_bajasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * The data needed to update a turno_bajas.
     */
    data: XOR<turno_bajasUpdateInput, turno_bajasUncheckedUpdateInput>
    /**
     * Choose, which turno_bajas to update.
     */
    where: turno_bajasWhereUniqueInput
  }


  /**
   * turno_bajas updateMany
   */
  export type turno_bajasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update turno_bajas.
     */
    data: XOR<turno_bajasUpdateManyMutationInput, turno_bajasUncheckedUpdateManyInput>
    /**
     * Filter which turno_bajas to update
     */
    where?: turno_bajasWhereInput
  }


  /**
   * turno_bajas upsert
   */
  export type turno_bajasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * The filter to search for the turno_bajas to update in case it exists.
     */
    where: turno_bajasWhereUniqueInput
    /**
     * In case the turno_bajas found by the `where` argument doesn't exist, create a new turno_bajas with this data.
     */
    create: XOR<turno_bajasCreateInput, turno_bajasUncheckedCreateInput>
    /**
     * In case the turno_bajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<turno_bajasUpdateInput, turno_bajasUncheckedUpdateInput>
  }


  /**
   * turno_bajas delete
   */
  export type turno_bajasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
    /**
     * Filter which turno_bajas to delete.
     */
    where: turno_bajasWhereUniqueInput
  }


  /**
   * turno_bajas deleteMany
   */
  export type turno_bajasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which turno_bajas to delete
     */
    where?: turno_bajasWhereInput
  }


  /**
   * turno_bajas without action
   */
  export type turno_bajasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the turno_bajas
     */
    select?: turno_bajasSelect<ExtArgs> | null
  }



  /**
   * Model vacaciones
   */


  export type AggregateVacaciones = {
    _count: VacacionesCountAggregateOutputType | null
    _avg: VacacionesAvgAggregateOutputType | null
    _sum: VacacionesSumAggregateOutputType | null
    _min: VacacionesMinAggregateOutputType | null
    _max: VacacionesMaxAggregateOutputType | null
  }

  export type VacacionesAvgAggregateOutputType = {
    allDay: number | null
    priority: number | null
  }

  export type VacacionesSumAggregateOutputType = {
    allDay: number | null
    priority: number | null
  }

  export type VacacionesMinAggregateOutputType = {
    id: string | null
    start: Date | null
    end: Date | null
    allDay: number | null
    priority: number | null
    title: string | null
    user: string | null
    detail: string | null
  }

  export type VacacionesMaxAggregateOutputType = {
    id: string | null
    start: Date | null
    end: Date | null
    allDay: number | null
    priority: number | null
    title: string | null
    user: string | null
    detail: string | null
  }

  export type VacacionesCountAggregateOutputType = {
    id: number
    start: number
    end: number
    allDay: number
    priority: number
    title: number
    user: number
    detail: number
    _all: number
  }


  export type VacacionesAvgAggregateInputType = {
    allDay?: true
    priority?: true
  }

  export type VacacionesSumAggregateInputType = {
    allDay?: true
    priority?: true
  }

  export type VacacionesMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    priority?: true
    title?: true
    user?: true
    detail?: true
  }

  export type VacacionesMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    priority?: true
    title?: true
    user?: true
    detail?: true
  }

  export type VacacionesCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    allDay?: true
    priority?: true
    title?: true
    user?: true
    detail?: true
    _all?: true
  }

  export type VacacionesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which vacaciones to aggregate.
     */
    where?: vacacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vacaciones to fetch.
     */
    orderBy?: vacacionesOrderByWithRelationInput | vacacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vacacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vacaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vacaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vacaciones
    **/
    _count?: true | VacacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VacacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VacacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VacacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VacacionesMaxAggregateInputType
  }

  export type GetVacacionesAggregateType<T extends VacacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateVacaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVacaciones[P]>
      : GetScalarType<T[P], AggregateVacaciones[P]>
  }




  export type vacacionesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: vacacionesWhereInput
    orderBy?: vacacionesOrderByWithAggregationInput | vacacionesOrderByWithAggregationInput[]
    by: VacacionesScalarFieldEnum[] | VacacionesScalarFieldEnum
    having?: vacacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VacacionesCountAggregateInputType | true
    _avg?: VacacionesAvgAggregateInputType
    _sum?: VacacionesSumAggregateInputType
    _min?: VacacionesMinAggregateInputType
    _max?: VacacionesMaxAggregateInputType
  }


  export type VacacionesGroupByOutputType = {
    id: string
    start: Date | null
    end: Date | null
    allDay: number | null
    priority: number | null
    title: string | null
    user: string | null
    detail: string | null
    _count: VacacionesCountAggregateOutputType | null
    _avg: VacacionesAvgAggregateOutputType | null
    _sum: VacacionesSumAggregateOutputType | null
    _min: VacacionesMinAggregateOutputType | null
    _max: VacacionesMaxAggregateOutputType | null
  }

  type GetVacacionesGroupByPayload<T extends vacacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VacacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VacacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VacacionesGroupByOutputType[P]>
            : GetScalarType<T[P], VacacionesGroupByOutputType[P]>
        }
      >
    >


  export type vacacionesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    priority?: boolean
    title?: boolean
    user?: boolean
    detail?: boolean
  }, ExtArgs["result"]["vacaciones"]>

  export type vacacionesSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    allDay?: boolean
    priority?: boolean
    title?: boolean
    user?: boolean
    detail?: boolean
  }


  type vacacionesGetPayload<S extends boolean | null | undefined | vacacionesArgs> = $Types.GetResult<vacacionesPayload, S>

  type vacacionesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<vacacionesFindManyArgs, 'select' | 'include'> & {
      select?: VacacionesCountAggregateInputType | true
    }

  export interface vacacionesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vacaciones'], meta: { name: 'vacaciones' } }
    /**
     * Find zero or one Vacaciones that matches the filter.
     * @param {vacacionesFindUniqueArgs} args - Arguments to find a Vacaciones
     * @example
     * // Get one Vacaciones
     * const vacaciones = await prisma.vacaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vacacionesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vacacionesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vacaciones'> extends True ? Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Vacaciones that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vacacionesFindUniqueOrThrowArgs} args - Arguments to find a Vacaciones
     * @example
     * // Get one Vacaciones
     * const vacaciones = await prisma.vacaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vacacionesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vacacionesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Vacaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesFindFirstArgs} args - Arguments to find a Vacaciones
     * @example
     * // Get one Vacaciones
     * const vacaciones = await prisma.vacaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vacacionesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vacacionesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vacaciones'> extends True ? Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Vacaciones that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesFindFirstOrThrowArgs} args - Arguments to find a Vacaciones
     * @example
     * // Get one Vacaciones
     * const vacaciones = await prisma.vacaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vacacionesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vacacionesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Vacaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vacaciones
     * const vacaciones = await prisma.vacaciones.findMany()
     * 
     * // Get first 10 Vacaciones
     * const vacaciones = await prisma.vacaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vacacionesWithIdOnly = await prisma.vacaciones.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vacacionesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vacacionesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Vacaciones.
     * @param {vacacionesCreateArgs} args - Arguments to create a Vacaciones.
     * @example
     * // Create one Vacaciones
     * const Vacaciones = await prisma.vacaciones.create({
     *   data: {
     *     // ... data to create a Vacaciones
     *   }
     * })
     * 
    **/
    create<T extends vacacionesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, vacacionesCreateArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Vacaciones.
     *     @param {vacacionesCreateManyArgs} args - Arguments to create many Vacaciones.
     *     @example
     *     // Create many Vacaciones
     *     const vacaciones = await prisma.vacaciones.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vacacionesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vacacionesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vacaciones.
     * @param {vacacionesDeleteArgs} args - Arguments to delete one Vacaciones.
     * @example
     * // Delete one Vacaciones
     * const Vacaciones = await prisma.vacaciones.delete({
     *   where: {
     *     // ... filter to delete one Vacaciones
     *   }
     * })
     * 
    **/
    delete<T extends vacacionesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, vacacionesDeleteArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Vacaciones.
     * @param {vacacionesUpdateArgs} args - Arguments to update one Vacaciones.
     * @example
     * // Update one Vacaciones
     * const vacaciones = await prisma.vacaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vacacionesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, vacacionesUpdateArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Vacaciones.
     * @param {vacacionesDeleteManyArgs} args - Arguments to filter Vacaciones to delete.
     * @example
     * // Delete a few Vacaciones
     * const { count } = await prisma.vacaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vacacionesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vacacionesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vacaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vacaciones
     * const vacaciones = await prisma.vacaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vacacionesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, vacacionesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vacaciones.
     * @param {vacacionesUpsertArgs} args - Arguments to update or create a Vacaciones.
     * @example
     * // Update or create a Vacaciones
     * const vacaciones = await prisma.vacaciones.upsert({
     *   create: {
     *     // ... data to create a Vacaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vacaciones we want to update
     *   }
     * })
    **/
    upsert<T extends vacacionesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, vacacionesUpsertArgs<ExtArgs>>
    ): Prisma__vacacionesClient<$Types.GetResult<vacacionesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Vacaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesCountArgs} args - Arguments to filter Vacaciones to count.
     * @example
     * // Count the number of Vacaciones
     * const count = await prisma.vacaciones.count({
     *   where: {
     *     // ... the filter for the Vacaciones we want to count
     *   }
     * })
    **/
    count<T extends vacacionesCountArgs>(
      args?: Subset<T, vacacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VacacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vacaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VacacionesAggregateArgs>(args: Subset<T, VacacionesAggregateArgs>): Prisma.PrismaPromise<GetVacacionesAggregateType<T>>

    /**
     * Group by Vacaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vacacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vacacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vacacionesGroupByArgs['orderBy'] }
        : { orderBy?: vacacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vacacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVacacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vacaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vacacionesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vacaciones base type for findUnique actions
   */
  export type vacacionesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter, which vacaciones to fetch.
     */
    where: vacacionesWhereUniqueInput
  }

  /**
   * vacaciones findUnique
   */
  export interface vacacionesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends vacacionesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vacaciones findUniqueOrThrow
   */
  export type vacacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter, which vacaciones to fetch.
     */
    where: vacacionesWhereUniqueInput
  }


  /**
   * vacaciones base type for findFirst actions
   */
  export type vacacionesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter, which vacaciones to fetch.
     */
    where?: vacacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vacaciones to fetch.
     */
    orderBy?: vacacionesOrderByWithRelationInput | vacacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vacaciones.
     */
    cursor?: vacacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vacaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vacaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vacaciones.
     */
    distinct?: VacacionesScalarFieldEnum | VacacionesScalarFieldEnum[]
  }

  /**
   * vacaciones findFirst
   */
  export interface vacacionesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends vacacionesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vacaciones findFirstOrThrow
   */
  export type vacacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter, which vacaciones to fetch.
     */
    where?: vacacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vacaciones to fetch.
     */
    orderBy?: vacacionesOrderByWithRelationInput | vacacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vacaciones.
     */
    cursor?: vacacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vacaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vacaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vacaciones.
     */
    distinct?: VacacionesScalarFieldEnum | VacacionesScalarFieldEnum[]
  }


  /**
   * vacaciones findMany
   */
  export type vacacionesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter, which vacaciones to fetch.
     */
    where?: vacacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vacaciones to fetch.
     */
    orderBy?: vacacionesOrderByWithRelationInput | vacacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vacaciones.
     */
    cursor?: vacacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vacaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vacaciones.
     */
    skip?: number
    distinct?: VacacionesScalarFieldEnum | VacacionesScalarFieldEnum[]
  }


  /**
   * vacaciones create
   */
  export type vacacionesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * The data needed to create a vacaciones.
     */
    data: XOR<vacacionesCreateInput, vacacionesUncheckedCreateInput>
  }


  /**
   * vacaciones createMany
   */
  export type vacacionesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vacaciones.
     */
    data: vacacionesCreateManyInput | vacacionesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * vacaciones update
   */
  export type vacacionesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * The data needed to update a vacaciones.
     */
    data: XOR<vacacionesUpdateInput, vacacionesUncheckedUpdateInput>
    /**
     * Choose, which vacaciones to update.
     */
    where: vacacionesWhereUniqueInput
  }


  /**
   * vacaciones updateMany
   */
  export type vacacionesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vacaciones.
     */
    data: XOR<vacacionesUpdateManyMutationInput, vacacionesUncheckedUpdateManyInput>
    /**
     * Filter which vacaciones to update
     */
    where?: vacacionesWhereInput
  }


  /**
   * vacaciones upsert
   */
  export type vacacionesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * The filter to search for the vacaciones to update in case it exists.
     */
    where: vacacionesWhereUniqueInput
    /**
     * In case the vacaciones found by the `where` argument doesn't exist, create a new vacaciones with this data.
     */
    create: XOR<vacacionesCreateInput, vacacionesUncheckedCreateInput>
    /**
     * In case the vacaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vacacionesUpdateInput, vacacionesUncheckedUpdateInput>
  }


  /**
   * vacaciones delete
   */
  export type vacacionesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
    /**
     * Filter which vacaciones to delete.
     */
    where: vacacionesWhereUniqueInput
  }


  /**
   * vacaciones deleteMany
   */
  export type vacacionesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which vacaciones to delete
     */
    where?: vacacionesWhereInput
  }


  /**
   * vacaciones without action
   */
  export type vacacionesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vacaciones
     */
    select?: vacacionesSelect<ExtArgs> | null
  }



  /**
   * Model motivos_atencion
   */


  export type AggregateMotivos_atencion = {
    _count: Motivos_atencionCountAggregateOutputType | null
    _avg: Motivos_atencionAvgAggregateOutputType | null
    _sum: Motivos_atencionSumAggregateOutputType | null
    _min: Motivos_atencionMinAggregateOutputType | null
    _max: Motivos_atencionMaxAggregateOutputType | null
  }

  export type Motivos_atencionAvgAggregateOutputType = {
    idmotivo: number | null
  }

  export type Motivos_atencionSumAggregateOutputType = {
    idmotivo: number | null
  }

  export type Motivos_atencionMinAggregateOutputType = {
    idmotivo: number | null
    motivo: string | null
    estado: boolean | null
  }

  export type Motivos_atencionMaxAggregateOutputType = {
    idmotivo: number | null
    motivo: string | null
    estado: boolean | null
  }

  export type Motivos_atencionCountAggregateOutputType = {
    idmotivo: number
    motivo: number
    estado: number
    _all: number
  }


  export type Motivos_atencionAvgAggregateInputType = {
    idmotivo?: true
  }

  export type Motivos_atencionSumAggregateInputType = {
    idmotivo?: true
  }

  export type Motivos_atencionMinAggregateInputType = {
    idmotivo?: true
    motivo?: true
    estado?: true
  }

  export type Motivos_atencionMaxAggregateInputType = {
    idmotivo?: true
    motivo?: true
    estado?: true
  }

  export type Motivos_atencionCountAggregateInputType = {
    idmotivo?: true
    motivo?: true
    estado?: true
    _all?: true
  }

  export type Motivos_atencionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which motivos_atencion to aggregate.
     */
    where?: motivos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motivos_atencions to fetch.
     */
    orderBy?: motivos_atencionOrderByWithRelationInput | motivos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: motivos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motivos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motivos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned motivos_atencions
    **/
    _count?: true | Motivos_atencionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Motivos_atencionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Motivos_atencionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Motivos_atencionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Motivos_atencionMaxAggregateInputType
  }

  export type GetMotivos_atencionAggregateType<T extends Motivos_atencionAggregateArgs> = {
        [P in keyof T & keyof AggregateMotivos_atencion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotivos_atencion[P]>
      : GetScalarType<T[P], AggregateMotivos_atencion[P]>
  }




  export type motivos_atencionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: motivos_atencionWhereInput
    orderBy?: motivos_atencionOrderByWithAggregationInput | motivos_atencionOrderByWithAggregationInput[]
    by: Motivos_atencionScalarFieldEnum[] | Motivos_atencionScalarFieldEnum
    having?: motivos_atencionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Motivos_atencionCountAggregateInputType | true
    _avg?: Motivos_atencionAvgAggregateInputType
    _sum?: Motivos_atencionSumAggregateInputType
    _min?: Motivos_atencionMinAggregateInputType
    _max?: Motivos_atencionMaxAggregateInputType
  }


  export type Motivos_atencionGroupByOutputType = {
    idmotivo: number
    motivo: string | null
    estado: boolean | null
    _count: Motivos_atencionCountAggregateOutputType | null
    _avg: Motivos_atencionAvgAggregateOutputType | null
    _sum: Motivos_atencionSumAggregateOutputType | null
    _min: Motivos_atencionMinAggregateOutputType | null
    _max: Motivos_atencionMaxAggregateOutputType | null
  }

  type GetMotivos_atencionGroupByPayload<T extends motivos_atencionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Motivos_atencionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Motivos_atencionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Motivos_atencionGroupByOutputType[P]>
            : GetScalarType<T[P], Motivos_atencionGroupByOutputType[P]>
        }
      >
    >


  export type motivos_atencionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idmotivo?: boolean
    motivo?: boolean
    estado?: boolean
  }, ExtArgs["result"]["motivos_atencion"]>

  export type motivos_atencionSelectScalar = {
    idmotivo?: boolean
    motivo?: boolean
    estado?: boolean
  }


  type motivos_atencionGetPayload<S extends boolean | null | undefined | motivos_atencionArgs> = $Types.GetResult<motivos_atencionPayload, S>

  type motivos_atencionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<motivos_atencionFindManyArgs, 'select' | 'include'> & {
      select?: Motivos_atencionCountAggregateInputType | true
    }

  export interface motivos_atencionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['motivos_atencion'], meta: { name: 'motivos_atencion' } }
    /**
     * Find zero or one Motivos_atencion that matches the filter.
     * @param {motivos_atencionFindUniqueArgs} args - Arguments to find a Motivos_atencion
     * @example
     * // Get one Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends motivos_atencionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, motivos_atencionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'motivos_atencion'> extends True ? Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Motivos_atencion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {motivos_atencionFindUniqueOrThrowArgs} args - Arguments to find a Motivos_atencion
     * @example
     * // Get one Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends motivos_atencionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motivos_atencionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Motivos_atencion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionFindFirstArgs} args - Arguments to find a Motivos_atencion
     * @example
     * // Get one Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends motivos_atencionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, motivos_atencionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'motivos_atencion'> extends True ? Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Motivos_atencion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionFindFirstOrThrowArgs} args - Arguments to find a Motivos_atencion
     * @example
     * // Get one Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends motivos_atencionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, motivos_atencionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Motivos_atencions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motivos_atencions
     * const motivos_atencions = await prisma.motivos_atencion.findMany()
     * 
     * // Get first 10 Motivos_atencions
     * const motivos_atencions = await prisma.motivos_atencion.findMany({ take: 10 })
     * 
     * // Only select the `idmotivo`
     * const motivos_atencionWithIdmotivoOnly = await prisma.motivos_atencion.findMany({ select: { idmotivo: true } })
     * 
    **/
    findMany<T extends motivos_atencionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motivos_atencionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Motivos_atencion.
     * @param {motivos_atencionCreateArgs} args - Arguments to create a Motivos_atencion.
     * @example
     * // Create one Motivos_atencion
     * const Motivos_atencion = await prisma.motivos_atencion.create({
     *   data: {
     *     // ... data to create a Motivos_atencion
     *   }
     * })
     * 
    **/
    create<T extends motivos_atencionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, motivos_atencionCreateArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Motivos_atencions.
     *     @param {motivos_atencionCreateManyArgs} args - Arguments to create many Motivos_atencions.
     *     @example
     *     // Create many Motivos_atencions
     *     const motivos_atencion = await prisma.motivos_atencion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends motivos_atencionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motivos_atencionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Motivos_atencion.
     * @param {motivos_atencionDeleteArgs} args - Arguments to delete one Motivos_atencion.
     * @example
     * // Delete one Motivos_atencion
     * const Motivos_atencion = await prisma.motivos_atencion.delete({
     *   where: {
     *     // ... filter to delete one Motivos_atencion
     *   }
     * })
     * 
    **/
    delete<T extends motivos_atencionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, motivos_atencionDeleteArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Motivos_atencion.
     * @param {motivos_atencionUpdateArgs} args - Arguments to update one Motivos_atencion.
     * @example
     * // Update one Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends motivos_atencionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, motivos_atencionUpdateArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Motivos_atencions.
     * @param {motivos_atencionDeleteManyArgs} args - Arguments to filter Motivos_atencions to delete.
     * @example
     * // Delete a few Motivos_atencions
     * const { count } = await prisma.motivos_atencion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends motivos_atencionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, motivos_atencionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivos_atencions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motivos_atencions
     * const motivos_atencion = await prisma.motivos_atencion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends motivos_atencionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, motivos_atencionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motivos_atencion.
     * @param {motivos_atencionUpsertArgs} args - Arguments to update or create a Motivos_atencion.
     * @example
     * // Update or create a Motivos_atencion
     * const motivos_atencion = await prisma.motivos_atencion.upsert({
     *   create: {
     *     // ... data to create a Motivos_atencion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motivos_atencion we want to update
     *   }
     * })
    **/
    upsert<T extends motivos_atencionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, motivos_atencionUpsertArgs<ExtArgs>>
    ): Prisma__motivos_atencionClient<$Types.GetResult<motivos_atencionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Motivos_atencions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionCountArgs} args - Arguments to filter Motivos_atencions to count.
     * @example
     * // Count the number of Motivos_atencions
     * const count = await prisma.motivos_atencion.count({
     *   where: {
     *     // ... the filter for the Motivos_atencions we want to count
     *   }
     * })
    **/
    count<T extends motivos_atencionCountArgs>(
      args?: Subset<T, motivos_atencionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Motivos_atencionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motivos_atencion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Motivos_atencionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Motivos_atencionAggregateArgs>(args: Subset<T, Motivos_atencionAggregateArgs>): Prisma.PrismaPromise<GetMotivos_atencionAggregateType<T>>

    /**
     * Group by Motivos_atencion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motivos_atencionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends motivos_atencionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: motivos_atencionGroupByArgs['orderBy'] }
        : { orderBy?: motivos_atencionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, motivos_atencionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotivos_atencionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for motivos_atencion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__motivos_atencionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * motivos_atencion base type for findUnique actions
   */
  export type motivos_atencionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which motivos_atencion to fetch.
     */
    where: motivos_atencionWhereUniqueInput
  }

  /**
   * motivos_atencion findUnique
   */
  export interface motivos_atencionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends motivos_atencionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * motivos_atencion findUniqueOrThrow
   */
  export type motivos_atencionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which motivos_atencion to fetch.
     */
    where: motivos_atencionWhereUniqueInput
  }


  /**
   * motivos_atencion base type for findFirst actions
   */
  export type motivos_atencionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which motivos_atencion to fetch.
     */
    where?: motivos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motivos_atencions to fetch.
     */
    orderBy?: motivos_atencionOrderByWithRelationInput | motivos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motivos_atencions.
     */
    cursor?: motivos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motivos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motivos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motivos_atencions.
     */
    distinct?: Motivos_atencionScalarFieldEnum | Motivos_atencionScalarFieldEnum[]
  }

  /**
   * motivos_atencion findFirst
   */
  export interface motivos_atencionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends motivos_atencionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * motivos_atencion findFirstOrThrow
   */
  export type motivos_atencionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which motivos_atencion to fetch.
     */
    where?: motivos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motivos_atencions to fetch.
     */
    orderBy?: motivos_atencionOrderByWithRelationInput | motivos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motivos_atencions.
     */
    cursor?: motivos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motivos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motivos_atencions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motivos_atencions.
     */
    distinct?: Motivos_atencionScalarFieldEnum | Motivos_atencionScalarFieldEnum[]
  }


  /**
   * motivos_atencion findMany
   */
  export type motivos_atencionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter, which motivos_atencions to fetch.
     */
    where?: motivos_atencionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motivos_atencions to fetch.
     */
    orderBy?: motivos_atencionOrderByWithRelationInput | motivos_atencionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing motivos_atencions.
     */
    cursor?: motivos_atencionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motivos_atencions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motivos_atencions.
     */
    skip?: number
    distinct?: Motivos_atencionScalarFieldEnum | Motivos_atencionScalarFieldEnum[]
  }


  /**
   * motivos_atencion create
   */
  export type motivos_atencionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * The data needed to create a motivos_atencion.
     */
    data?: XOR<motivos_atencionCreateInput, motivos_atencionUncheckedCreateInput>
  }


  /**
   * motivos_atencion createMany
   */
  export type motivos_atencionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many motivos_atencions.
     */
    data: motivos_atencionCreateManyInput | motivos_atencionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * motivos_atencion update
   */
  export type motivos_atencionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * The data needed to update a motivos_atencion.
     */
    data: XOR<motivos_atencionUpdateInput, motivos_atencionUncheckedUpdateInput>
    /**
     * Choose, which motivos_atencion to update.
     */
    where: motivos_atencionWhereUniqueInput
  }


  /**
   * motivos_atencion updateMany
   */
  export type motivos_atencionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update motivos_atencions.
     */
    data: XOR<motivos_atencionUpdateManyMutationInput, motivos_atencionUncheckedUpdateManyInput>
    /**
     * Filter which motivos_atencions to update
     */
    where?: motivos_atencionWhereInput
  }


  /**
   * motivos_atencion upsert
   */
  export type motivos_atencionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * The filter to search for the motivos_atencion to update in case it exists.
     */
    where: motivos_atencionWhereUniqueInput
    /**
     * In case the motivos_atencion found by the `where` argument doesn't exist, create a new motivos_atencion with this data.
     */
    create: XOR<motivos_atencionCreateInput, motivos_atencionUncheckedCreateInput>
    /**
     * In case the motivos_atencion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<motivos_atencionUpdateInput, motivos_atencionUncheckedUpdateInput>
  }


  /**
   * motivos_atencion delete
   */
  export type motivos_atencionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
    /**
     * Filter which motivos_atencion to delete.
     */
    where: motivos_atencionWhereUniqueInput
  }


  /**
   * motivos_atencion deleteMany
   */
  export type motivos_atencionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which motivos_atencions to delete
     */
    where?: motivos_atencionWhereInput
  }


  /**
   * motivos_atencion without action
   */
  export type motivos_atencionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the motivos_atencion
     */
    select?: motivos_atencionSelect<ExtArgs> | null
  }



  /**
   * Model prestamos_plan_cuotas
   */


  export type AggregatePrestamos_plan_cuotas = {
    _count: Prestamos_plan_cuotasCountAggregateOutputType | null
    _avg: Prestamos_plan_cuotasAvgAggregateOutputType | null
    _sum: Prestamos_plan_cuotasSumAggregateOutputType | null
    _min: Prestamos_plan_cuotasMinAggregateOutputType | null
    _max: Prestamos_plan_cuotasMaxAggregateOutputType | null
  }

  export type Prestamos_plan_cuotasAvgAggregateOutputType = {
    idplan: number | null
    plan_cuotas: number | null
  }

  export type Prestamos_plan_cuotasSumAggregateOutputType = {
    idplan: number | null
    plan_cuotas: number | null
  }

  export type Prestamos_plan_cuotasMinAggregateOutputType = {
    idplan: number | null
    plan_cuotas: number | null
    detalle: string | null
    estado: boolean | null
  }

  export type Prestamos_plan_cuotasMaxAggregateOutputType = {
    idplan: number | null
    plan_cuotas: number | null
    detalle: string | null
    estado: boolean | null
  }

  export type Prestamos_plan_cuotasCountAggregateOutputType = {
    idplan: number
    plan_cuotas: number
    detalle: number
    estado: number
    _all: number
  }


  export type Prestamos_plan_cuotasAvgAggregateInputType = {
    idplan?: true
    plan_cuotas?: true
  }

  export type Prestamos_plan_cuotasSumAggregateInputType = {
    idplan?: true
    plan_cuotas?: true
  }

  export type Prestamos_plan_cuotasMinAggregateInputType = {
    idplan?: true
    plan_cuotas?: true
    detalle?: true
    estado?: true
  }

  export type Prestamos_plan_cuotasMaxAggregateInputType = {
    idplan?: true
    plan_cuotas?: true
    detalle?: true
    estado?: true
  }

  export type Prestamos_plan_cuotasCountAggregateInputType = {
    idplan?: true
    plan_cuotas?: true
    detalle?: true
    estado?: true
    _all?: true
  }

  export type Prestamos_plan_cuotasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_plan_cuotas to aggregate.
     */
    where?: prestamos_plan_cuotasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_plan_cuotas to fetch.
     */
    orderBy?: prestamos_plan_cuotasOrderByWithRelationInput | prestamos_plan_cuotasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prestamos_plan_cuotasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_plan_cuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_plan_cuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prestamos_plan_cuotas
    **/
    _count?: true | Prestamos_plan_cuotasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prestamos_plan_cuotasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prestamos_plan_cuotasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prestamos_plan_cuotasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prestamos_plan_cuotasMaxAggregateInputType
  }

  export type GetPrestamos_plan_cuotasAggregateType<T extends Prestamos_plan_cuotasAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestamos_plan_cuotas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestamos_plan_cuotas[P]>
      : GetScalarType<T[P], AggregatePrestamos_plan_cuotas[P]>
  }




  export type prestamos_plan_cuotasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: prestamos_plan_cuotasWhereInput
    orderBy?: prestamos_plan_cuotasOrderByWithAggregationInput | prestamos_plan_cuotasOrderByWithAggregationInput[]
    by: Prestamos_plan_cuotasScalarFieldEnum[] | Prestamos_plan_cuotasScalarFieldEnum
    having?: prestamos_plan_cuotasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prestamos_plan_cuotasCountAggregateInputType | true
    _avg?: Prestamos_plan_cuotasAvgAggregateInputType
    _sum?: Prestamos_plan_cuotasSumAggregateInputType
    _min?: Prestamos_plan_cuotasMinAggregateInputType
    _max?: Prestamos_plan_cuotasMaxAggregateInputType
  }


  export type Prestamos_plan_cuotasGroupByOutputType = {
    idplan: number
    plan_cuotas: number | null
    detalle: string | null
    estado: boolean | null
    _count: Prestamos_plan_cuotasCountAggregateOutputType | null
    _avg: Prestamos_plan_cuotasAvgAggregateOutputType | null
    _sum: Prestamos_plan_cuotasSumAggregateOutputType | null
    _min: Prestamos_plan_cuotasMinAggregateOutputType | null
    _max: Prestamos_plan_cuotasMaxAggregateOutputType | null
  }

  type GetPrestamos_plan_cuotasGroupByPayload<T extends prestamos_plan_cuotasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prestamos_plan_cuotasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prestamos_plan_cuotasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prestamos_plan_cuotasGroupByOutputType[P]>
            : GetScalarType<T[P], Prestamos_plan_cuotasGroupByOutputType[P]>
        }
      >
    >


  export type prestamos_plan_cuotasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idplan?: boolean
    plan_cuotas?: boolean
    detalle?: boolean
    estado?: boolean
  }, ExtArgs["result"]["prestamos_plan_cuotas"]>

  export type prestamos_plan_cuotasSelectScalar = {
    idplan?: boolean
    plan_cuotas?: boolean
    detalle?: boolean
    estado?: boolean
  }


  type prestamos_plan_cuotasGetPayload<S extends boolean | null | undefined | prestamos_plan_cuotasArgs> = $Types.GetResult<prestamos_plan_cuotasPayload, S>

  type prestamos_plan_cuotasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<prestamos_plan_cuotasFindManyArgs, 'select' | 'include'> & {
      select?: Prestamos_plan_cuotasCountAggregateInputType | true
    }

  export interface prestamos_plan_cuotasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prestamos_plan_cuotas'], meta: { name: 'prestamos_plan_cuotas' } }
    /**
     * Find zero or one Prestamos_plan_cuotas that matches the filter.
     * @param {prestamos_plan_cuotasFindUniqueArgs} args - Arguments to find a Prestamos_plan_cuotas
     * @example
     * // Get one Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prestamos_plan_cuotasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, prestamos_plan_cuotasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'prestamos_plan_cuotas'> extends True ? Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Prestamos_plan_cuotas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prestamos_plan_cuotasFindUniqueOrThrowArgs} args - Arguments to find a Prestamos_plan_cuotas
     * @example
     * // Get one Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prestamos_plan_cuotasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_plan_cuotasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Prestamos_plan_cuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasFindFirstArgs} args - Arguments to find a Prestamos_plan_cuotas
     * @example
     * // Get one Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prestamos_plan_cuotasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, prestamos_plan_cuotasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'prestamos_plan_cuotas'> extends True ? Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Prestamos_plan_cuotas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasFindFirstOrThrowArgs} args - Arguments to find a Prestamos_plan_cuotas
     * @example
     * // Get one Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prestamos_plan_cuotasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_plan_cuotasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prestamos_plan_cuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findMany()
     * 
     * // Get first 10 Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.findMany({ take: 10 })
     * 
     * // Only select the `idplan`
     * const prestamos_plan_cuotasWithIdplanOnly = await prisma.prestamos_plan_cuotas.findMany({ select: { idplan: true } })
     * 
    **/
    findMany<T extends prestamos_plan_cuotasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_plan_cuotasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Prestamos_plan_cuotas.
     * @param {prestamos_plan_cuotasCreateArgs} args - Arguments to create a Prestamos_plan_cuotas.
     * @example
     * // Create one Prestamos_plan_cuotas
     * const Prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.create({
     *   data: {
     *     // ... data to create a Prestamos_plan_cuotas
     *   }
     * })
     * 
    **/
    create<T extends prestamos_plan_cuotasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_plan_cuotasCreateArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prestamos_plan_cuotas.
     *     @param {prestamos_plan_cuotasCreateManyArgs} args - Arguments to create many Prestamos_plan_cuotas.
     *     @example
     *     // Create many Prestamos_plan_cuotas
     *     const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prestamos_plan_cuotasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_plan_cuotasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestamos_plan_cuotas.
     * @param {prestamos_plan_cuotasDeleteArgs} args - Arguments to delete one Prestamos_plan_cuotas.
     * @example
     * // Delete one Prestamos_plan_cuotas
     * const Prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.delete({
     *   where: {
     *     // ... filter to delete one Prestamos_plan_cuotas
     *   }
     * })
     * 
    **/
    delete<T extends prestamos_plan_cuotasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_plan_cuotasDeleteArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Prestamos_plan_cuotas.
     * @param {prestamos_plan_cuotasUpdateArgs} args - Arguments to update one Prestamos_plan_cuotas.
     * @example
     * // Update one Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prestamos_plan_cuotasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_plan_cuotasUpdateArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prestamos_plan_cuotas.
     * @param {prestamos_plan_cuotasDeleteManyArgs} args - Arguments to filter Prestamos_plan_cuotas to delete.
     * @example
     * // Delete a few Prestamos_plan_cuotas
     * const { count } = await prisma.prestamos_plan_cuotas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prestamos_plan_cuotasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_plan_cuotasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestamos_plan_cuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prestamos_plan_cuotasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_plan_cuotasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestamos_plan_cuotas.
     * @param {prestamos_plan_cuotasUpsertArgs} args - Arguments to update or create a Prestamos_plan_cuotas.
     * @example
     * // Update or create a Prestamos_plan_cuotas
     * const prestamos_plan_cuotas = await prisma.prestamos_plan_cuotas.upsert({
     *   create: {
     *     // ... data to create a Prestamos_plan_cuotas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestamos_plan_cuotas we want to update
     *   }
     * })
    **/
    upsert<T extends prestamos_plan_cuotasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_plan_cuotasUpsertArgs<ExtArgs>>
    ): Prisma__prestamos_plan_cuotasClient<$Types.GetResult<prestamos_plan_cuotasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prestamos_plan_cuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasCountArgs} args - Arguments to filter Prestamos_plan_cuotas to count.
     * @example
     * // Count the number of Prestamos_plan_cuotas
     * const count = await prisma.prestamos_plan_cuotas.count({
     *   where: {
     *     // ... the filter for the Prestamos_plan_cuotas we want to count
     *   }
     * })
    **/
    count<T extends prestamos_plan_cuotasCountArgs>(
      args?: Subset<T, prestamos_plan_cuotasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prestamos_plan_cuotasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestamos_plan_cuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prestamos_plan_cuotasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prestamos_plan_cuotasAggregateArgs>(args: Subset<T, Prestamos_plan_cuotasAggregateArgs>): Prisma.PrismaPromise<GetPrestamos_plan_cuotasAggregateType<T>>

    /**
     * Group by Prestamos_plan_cuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_plan_cuotasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prestamos_plan_cuotasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prestamos_plan_cuotasGroupByArgs['orderBy'] }
        : { orderBy?: prestamos_plan_cuotasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prestamos_plan_cuotasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestamos_plan_cuotasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for prestamos_plan_cuotas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prestamos_plan_cuotasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * prestamos_plan_cuotas base type for findUnique actions
   */
  export type prestamos_plan_cuotasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_plan_cuotas to fetch.
     */
    where: prestamos_plan_cuotasWhereUniqueInput
  }

  /**
   * prestamos_plan_cuotas findUnique
   */
  export interface prestamos_plan_cuotasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_plan_cuotasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_plan_cuotas findUniqueOrThrow
   */
  export type prestamos_plan_cuotasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_plan_cuotas to fetch.
     */
    where: prestamos_plan_cuotasWhereUniqueInput
  }


  /**
   * prestamos_plan_cuotas base type for findFirst actions
   */
  export type prestamos_plan_cuotasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_plan_cuotas to fetch.
     */
    where?: prestamos_plan_cuotasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_plan_cuotas to fetch.
     */
    orderBy?: prestamos_plan_cuotasOrderByWithRelationInput | prestamos_plan_cuotasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_plan_cuotas.
     */
    cursor?: prestamos_plan_cuotasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_plan_cuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_plan_cuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_plan_cuotas.
     */
    distinct?: Prestamos_plan_cuotasScalarFieldEnum | Prestamos_plan_cuotasScalarFieldEnum[]
  }

  /**
   * prestamos_plan_cuotas findFirst
   */
  export interface prestamos_plan_cuotasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_plan_cuotasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_plan_cuotas findFirstOrThrow
   */
  export type prestamos_plan_cuotasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_plan_cuotas to fetch.
     */
    where?: prestamos_plan_cuotasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_plan_cuotas to fetch.
     */
    orderBy?: prestamos_plan_cuotasOrderByWithRelationInput | prestamos_plan_cuotasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_plan_cuotas.
     */
    cursor?: prestamos_plan_cuotasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_plan_cuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_plan_cuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_plan_cuotas.
     */
    distinct?: Prestamos_plan_cuotasScalarFieldEnum | Prestamos_plan_cuotasScalarFieldEnum[]
  }


  /**
   * prestamos_plan_cuotas findMany
   */
  export type prestamos_plan_cuotasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_plan_cuotas to fetch.
     */
    where?: prestamos_plan_cuotasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_plan_cuotas to fetch.
     */
    orderBy?: prestamos_plan_cuotasOrderByWithRelationInput | prestamos_plan_cuotasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prestamos_plan_cuotas.
     */
    cursor?: prestamos_plan_cuotasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_plan_cuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_plan_cuotas.
     */
    skip?: number
    distinct?: Prestamos_plan_cuotasScalarFieldEnum | Prestamos_plan_cuotasScalarFieldEnum[]
  }


  /**
   * prestamos_plan_cuotas create
   */
  export type prestamos_plan_cuotasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * The data needed to create a prestamos_plan_cuotas.
     */
    data?: XOR<prestamos_plan_cuotasCreateInput, prestamos_plan_cuotasUncheckedCreateInput>
  }


  /**
   * prestamos_plan_cuotas createMany
   */
  export type prestamos_plan_cuotasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prestamos_plan_cuotas.
     */
    data: prestamos_plan_cuotasCreateManyInput | prestamos_plan_cuotasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prestamos_plan_cuotas update
   */
  export type prestamos_plan_cuotasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * The data needed to update a prestamos_plan_cuotas.
     */
    data: XOR<prestamos_plan_cuotasUpdateInput, prestamos_plan_cuotasUncheckedUpdateInput>
    /**
     * Choose, which prestamos_plan_cuotas to update.
     */
    where: prestamos_plan_cuotasWhereUniqueInput
  }


  /**
   * prestamos_plan_cuotas updateMany
   */
  export type prestamos_plan_cuotasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prestamos_plan_cuotas.
     */
    data: XOR<prestamos_plan_cuotasUpdateManyMutationInput, prestamos_plan_cuotasUncheckedUpdateManyInput>
    /**
     * Filter which prestamos_plan_cuotas to update
     */
    where?: prestamos_plan_cuotasWhereInput
  }


  /**
   * prestamos_plan_cuotas upsert
   */
  export type prestamos_plan_cuotasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * The filter to search for the prestamos_plan_cuotas to update in case it exists.
     */
    where: prestamos_plan_cuotasWhereUniqueInput
    /**
     * In case the prestamos_plan_cuotas found by the `where` argument doesn't exist, create a new prestamos_plan_cuotas with this data.
     */
    create: XOR<prestamos_plan_cuotasCreateInput, prestamos_plan_cuotasUncheckedCreateInput>
    /**
     * In case the prestamos_plan_cuotas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prestamos_plan_cuotasUpdateInput, prestamos_plan_cuotasUncheckedUpdateInput>
  }


  /**
   * prestamos_plan_cuotas delete
   */
  export type prestamos_plan_cuotasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
    /**
     * Filter which prestamos_plan_cuotas to delete.
     */
    where: prestamos_plan_cuotasWhereUniqueInput
  }


  /**
   * prestamos_plan_cuotas deleteMany
   */
  export type prestamos_plan_cuotasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_plan_cuotas to delete
     */
    where?: prestamos_plan_cuotasWhereInput
  }


  /**
   * prestamos_plan_cuotas without action
   */
  export type prestamos_plan_cuotasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_plan_cuotas
     */
    select?: prestamos_plan_cuotasSelect<ExtArgs> | null
  }



  /**
   * Model prestamos_tasas
   */


  export type AggregatePrestamos_tasas = {
    _count: Prestamos_tasasCountAggregateOutputType | null
    _avg: Prestamos_tasasAvgAggregateOutputType | null
    _sum: Prestamos_tasasSumAggregateOutputType | null
    _min: Prestamos_tasasMinAggregateOutputType | null
    _max: Prestamos_tasasMaxAggregateOutputType | null
  }

  export type Prestamos_tasasAvgAggregateOutputType = {
    idtasa: number | null
    tasa: number | null
  }

  export type Prestamos_tasasSumAggregateOutputType = {
    idtasa: number | null
    tasa: number | null
  }

  export type Prestamos_tasasMinAggregateOutputType = {
    idtasa: number | null
    tasa: number | null
    plan: string | null
    tipo: string | null
    estado: boolean | null
  }

  export type Prestamos_tasasMaxAggregateOutputType = {
    idtasa: number | null
    tasa: number | null
    plan: string | null
    tipo: string | null
    estado: boolean | null
  }

  export type Prestamos_tasasCountAggregateOutputType = {
    idtasa: number
    tasa: number
    plan: number
    tipo: number
    estado: number
    _all: number
  }


  export type Prestamos_tasasAvgAggregateInputType = {
    idtasa?: true
    tasa?: true
  }

  export type Prestamos_tasasSumAggregateInputType = {
    idtasa?: true
    tasa?: true
  }

  export type Prestamos_tasasMinAggregateInputType = {
    idtasa?: true
    tasa?: true
    plan?: true
    tipo?: true
    estado?: true
  }

  export type Prestamos_tasasMaxAggregateInputType = {
    idtasa?: true
    tasa?: true
    plan?: true
    tipo?: true
    estado?: true
  }

  export type Prestamos_tasasCountAggregateInputType = {
    idtasa?: true
    tasa?: true
    plan?: true
    tipo?: true
    estado?: true
    _all?: true
  }

  export type Prestamos_tasasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_tasas to aggregate.
     */
    where?: prestamos_tasasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_tasas to fetch.
     */
    orderBy?: prestamos_tasasOrderByWithRelationInput | prestamos_tasasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prestamos_tasasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_tasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_tasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prestamos_tasas
    **/
    _count?: true | Prestamos_tasasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prestamos_tasasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prestamos_tasasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prestamos_tasasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prestamos_tasasMaxAggregateInputType
  }

  export type GetPrestamos_tasasAggregateType<T extends Prestamos_tasasAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestamos_tasas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestamos_tasas[P]>
      : GetScalarType<T[P], AggregatePrestamos_tasas[P]>
  }




  export type prestamos_tasasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: prestamos_tasasWhereInput
    orderBy?: prestamos_tasasOrderByWithAggregationInput | prestamos_tasasOrderByWithAggregationInput[]
    by: Prestamos_tasasScalarFieldEnum[] | Prestamos_tasasScalarFieldEnum
    having?: prestamos_tasasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prestamos_tasasCountAggregateInputType | true
    _avg?: Prestamos_tasasAvgAggregateInputType
    _sum?: Prestamos_tasasSumAggregateInputType
    _min?: Prestamos_tasasMinAggregateInputType
    _max?: Prestamos_tasasMaxAggregateInputType
  }


  export type Prestamos_tasasGroupByOutputType = {
    idtasa: number
    tasa: number | null
    plan: string | null
    tipo: string | null
    estado: boolean | null
    _count: Prestamos_tasasCountAggregateOutputType | null
    _avg: Prestamos_tasasAvgAggregateOutputType | null
    _sum: Prestamos_tasasSumAggregateOutputType | null
    _min: Prestamos_tasasMinAggregateOutputType | null
    _max: Prestamos_tasasMaxAggregateOutputType | null
  }

  type GetPrestamos_tasasGroupByPayload<T extends prestamos_tasasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prestamos_tasasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prestamos_tasasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prestamos_tasasGroupByOutputType[P]>
            : GetScalarType<T[P], Prestamos_tasasGroupByOutputType[P]>
        }
      >
    >


  export type prestamos_tasasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtasa?: boolean
    tasa?: boolean
    plan?: boolean
    tipo?: boolean
    estado?: boolean
  }, ExtArgs["result"]["prestamos_tasas"]>

  export type prestamos_tasasSelectScalar = {
    idtasa?: boolean
    tasa?: boolean
    plan?: boolean
    tipo?: boolean
    estado?: boolean
  }


  type prestamos_tasasGetPayload<S extends boolean | null | undefined | prestamos_tasasArgs> = $Types.GetResult<prestamos_tasasPayload, S>

  type prestamos_tasasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<prestamos_tasasFindManyArgs, 'select' | 'include'> & {
      select?: Prestamos_tasasCountAggregateInputType | true
    }

  export interface prestamos_tasasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prestamos_tasas'], meta: { name: 'prestamos_tasas' } }
    /**
     * Find zero or one Prestamos_tasas that matches the filter.
     * @param {prestamos_tasasFindUniqueArgs} args - Arguments to find a Prestamos_tasas
     * @example
     * // Get one Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends prestamos_tasasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, prestamos_tasasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'prestamos_tasas'> extends True ? Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Prestamos_tasas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {prestamos_tasasFindUniqueOrThrowArgs} args - Arguments to find a Prestamos_tasas
     * @example
     * // Get one Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends prestamos_tasasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_tasasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Prestamos_tasas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasFindFirstArgs} args - Arguments to find a Prestamos_tasas
     * @example
     * // Get one Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends prestamos_tasasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, prestamos_tasasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'prestamos_tasas'> extends True ? Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Prestamos_tasas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasFindFirstOrThrowArgs} args - Arguments to find a Prestamos_tasas
     * @example
     * // Get one Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends prestamos_tasasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_tasasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prestamos_tasas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findMany()
     * 
     * // Get first 10 Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.findMany({ take: 10 })
     * 
     * // Only select the `idtasa`
     * const prestamos_tasasWithIdtasaOnly = await prisma.prestamos_tasas.findMany({ select: { idtasa: true } })
     * 
    **/
    findMany<T extends prestamos_tasasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_tasasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Prestamos_tasas.
     * @param {prestamos_tasasCreateArgs} args - Arguments to create a Prestamos_tasas.
     * @example
     * // Create one Prestamos_tasas
     * const Prestamos_tasas = await prisma.prestamos_tasas.create({
     *   data: {
     *     // ... data to create a Prestamos_tasas
     *   }
     * })
     * 
    **/
    create<T extends prestamos_tasasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_tasasCreateArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prestamos_tasas.
     *     @param {prestamos_tasasCreateManyArgs} args - Arguments to create many Prestamos_tasas.
     *     @example
     *     // Create many Prestamos_tasas
     *     const prestamos_tasas = await prisma.prestamos_tasas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends prestamos_tasasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_tasasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prestamos_tasas.
     * @param {prestamos_tasasDeleteArgs} args - Arguments to delete one Prestamos_tasas.
     * @example
     * // Delete one Prestamos_tasas
     * const Prestamos_tasas = await prisma.prestamos_tasas.delete({
     *   where: {
     *     // ... filter to delete one Prestamos_tasas
     *   }
     * })
     * 
    **/
    delete<T extends prestamos_tasasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_tasasDeleteArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Prestamos_tasas.
     * @param {prestamos_tasasUpdateArgs} args - Arguments to update one Prestamos_tasas.
     * @example
     * // Update one Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prestamos_tasasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_tasasUpdateArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prestamos_tasas.
     * @param {prestamos_tasasDeleteManyArgs} args - Arguments to filter Prestamos_tasas to delete.
     * @example
     * // Delete a few Prestamos_tasas
     * const { count } = await prisma.prestamos_tasas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prestamos_tasasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, prestamos_tasasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestamos_tasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prestamos_tasasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_tasasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestamos_tasas.
     * @param {prestamos_tasasUpsertArgs} args - Arguments to update or create a Prestamos_tasas.
     * @example
     * // Update or create a Prestamos_tasas
     * const prestamos_tasas = await prisma.prestamos_tasas.upsert({
     *   create: {
     *     // ... data to create a Prestamos_tasas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestamos_tasas we want to update
     *   }
     * })
    **/
    upsert<T extends prestamos_tasasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, prestamos_tasasUpsertArgs<ExtArgs>>
    ): Prisma__prestamos_tasasClient<$Types.GetResult<prestamos_tasasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prestamos_tasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasCountArgs} args - Arguments to filter Prestamos_tasas to count.
     * @example
     * // Count the number of Prestamos_tasas
     * const count = await prisma.prestamos_tasas.count({
     *   where: {
     *     // ... the filter for the Prestamos_tasas we want to count
     *   }
     * })
    **/
    count<T extends prestamos_tasasCountArgs>(
      args?: Subset<T, prestamos_tasasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prestamos_tasasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestamos_tasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prestamos_tasasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prestamos_tasasAggregateArgs>(args: Subset<T, Prestamos_tasasAggregateArgs>): Prisma.PrismaPromise<GetPrestamos_tasasAggregateType<T>>

    /**
     * Group by Prestamos_tasas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prestamos_tasasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prestamos_tasasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prestamos_tasasGroupByArgs['orderBy'] }
        : { orderBy?: prestamos_tasasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prestamos_tasasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestamos_tasasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for prestamos_tasas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prestamos_tasasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * prestamos_tasas base type for findUnique actions
   */
  export type prestamos_tasasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_tasas to fetch.
     */
    where: prestamos_tasasWhereUniqueInput
  }

  /**
   * prestamos_tasas findUnique
   */
  export interface prestamos_tasasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_tasasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_tasas findUniqueOrThrow
   */
  export type prestamos_tasasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_tasas to fetch.
     */
    where: prestamos_tasasWhereUniqueInput
  }


  /**
   * prestamos_tasas base type for findFirst actions
   */
  export type prestamos_tasasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_tasas to fetch.
     */
    where?: prestamos_tasasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_tasas to fetch.
     */
    orderBy?: prestamos_tasasOrderByWithRelationInput | prestamos_tasasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_tasas.
     */
    cursor?: prestamos_tasasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_tasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_tasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_tasas.
     */
    distinct?: Prestamos_tasasScalarFieldEnum | Prestamos_tasasScalarFieldEnum[]
  }

  /**
   * prestamos_tasas findFirst
   */
  export interface prestamos_tasasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends prestamos_tasasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * prestamos_tasas findFirstOrThrow
   */
  export type prestamos_tasasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_tasas to fetch.
     */
    where?: prestamos_tasasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_tasas to fetch.
     */
    orderBy?: prestamos_tasasOrderByWithRelationInput | prestamos_tasasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prestamos_tasas.
     */
    cursor?: prestamos_tasasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_tasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_tasas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prestamos_tasas.
     */
    distinct?: Prestamos_tasasScalarFieldEnum | Prestamos_tasasScalarFieldEnum[]
  }


  /**
   * prestamos_tasas findMany
   */
  export type prestamos_tasasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter, which prestamos_tasas to fetch.
     */
    where?: prestamos_tasasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prestamos_tasas to fetch.
     */
    orderBy?: prestamos_tasasOrderByWithRelationInput | prestamos_tasasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prestamos_tasas.
     */
    cursor?: prestamos_tasasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prestamos_tasas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prestamos_tasas.
     */
    skip?: number
    distinct?: Prestamos_tasasScalarFieldEnum | Prestamos_tasasScalarFieldEnum[]
  }


  /**
   * prestamos_tasas create
   */
  export type prestamos_tasasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * The data needed to create a prestamos_tasas.
     */
    data?: XOR<prestamos_tasasCreateInput, prestamos_tasasUncheckedCreateInput>
  }


  /**
   * prestamos_tasas createMany
   */
  export type prestamos_tasasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prestamos_tasas.
     */
    data: prestamos_tasasCreateManyInput | prestamos_tasasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * prestamos_tasas update
   */
  export type prestamos_tasasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * The data needed to update a prestamos_tasas.
     */
    data: XOR<prestamos_tasasUpdateInput, prestamos_tasasUncheckedUpdateInput>
    /**
     * Choose, which prestamos_tasas to update.
     */
    where: prestamos_tasasWhereUniqueInput
  }


  /**
   * prestamos_tasas updateMany
   */
  export type prestamos_tasasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prestamos_tasas.
     */
    data: XOR<prestamos_tasasUpdateManyMutationInput, prestamos_tasasUncheckedUpdateManyInput>
    /**
     * Filter which prestamos_tasas to update
     */
    where?: prestamos_tasasWhereInput
  }


  /**
   * prestamos_tasas upsert
   */
  export type prestamos_tasasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * The filter to search for the prestamos_tasas to update in case it exists.
     */
    where: prestamos_tasasWhereUniqueInput
    /**
     * In case the prestamos_tasas found by the `where` argument doesn't exist, create a new prestamos_tasas with this data.
     */
    create: XOR<prestamos_tasasCreateInput, prestamos_tasasUncheckedCreateInput>
    /**
     * In case the prestamos_tasas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prestamos_tasasUpdateInput, prestamos_tasasUncheckedUpdateInput>
  }


  /**
   * prestamos_tasas delete
   */
  export type prestamos_tasasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
    /**
     * Filter which prestamos_tasas to delete.
     */
    where: prestamos_tasasWhereUniqueInput
  }


  /**
   * prestamos_tasas deleteMany
   */
  export type prestamos_tasasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which prestamos_tasas to delete
     */
    where?: prestamos_tasasWhereInput
  }


  /**
   * prestamos_tasas without action
   */
  export type prestamos_tasasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prestamos_tasas
     */
    select?: prestamos_tasasSelect<ExtArgs> | null
  }



  /**
   * Model certificado_estudiantes
   */


  export type AggregateCertificado_estudiantes = {
    _count: Certificado_estudiantesCountAggregateOutputType | null
    _avg: Certificado_estudiantesAvgAggregateOutputType | null
    _sum: Certificado_estudiantesSumAggregateOutputType | null
    _min: Certificado_estudiantesMinAggregateOutputType | null
    _max: Certificado_estudiantesMaxAggregateOutputType | null
  }

  export type Certificado_estudiantesAvgAggregateOutputType = {
    idcertificado: number | null
    contrato: number | null
  }

  export type Certificado_estudiantesSumAggregateOutputType = {
    idcertificado: number | null
    contrato: number | null
  }

  export type Certificado_estudiantesMinAggregateOutputType = {
    idcertificado: number | null
    contrato: number | null
    socio: string | null
    fecha: Date | null
    operador: string | null
    ncert: string | null
  }

  export type Certificado_estudiantesMaxAggregateOutputType = {
    idcertificado: number | null
    contrato: number | null
    socio: string | null
    fecha: Date | null
    operador: string | null
    ncert: string | null
  }

  export type Certificado_estudiantesCountAggregateOutputType = {
    idcertificado: number
    contrato: number
    socio: number
    fecha: number
    operador: number
    ncert: number
    _all: number
  }


  export type Certificado_estudiantesAvgAggregateInputType = {
    idcertificado?: true
    contrato?: true
  }

  export type Certificado_estudiantesSumAggregateInputType = {
    idcertificado?: true
    contrato?: true
  }

  export type Certificado_estudiantesMinAggregateInputType = {
    idcertificado?: true
    contrato?: true
    socio?: true
    fecha?: true
    operador?: true
    ncert?: true
  }

  export type Certificado_estudiantesMaxAggregateInputType = {
    idcertificado?: true
    contrato?: true
    socio?: true
    fecha?: true
    operador?: true
    ncert?: true
  }

  export type Certificado_estudiantesCountAggregateInputType = {
    idcertificado?: true
    contrato?: true
    socio?: true
    fecha?: true
    operador?: true
    ncert?: true
    _all?: true
  }

  export type Certificado_estudiantesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificado_estudiantes to aggregate.
     */
    where?: certificado_estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificado_estudiantes to fetch.
     */
    orderBy?: certificado_estudiantesOrderByWithRelationInput | certificado_estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificado_estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificado_estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificado_estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificado_estudiantes
    **/
    _count?: true | Certificado_estudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Certificado_estudiantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Certificado_estudiantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Certificado_estudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Certificado_estudiantesMaxAggregateInputType
  }

  export type GetCertificado_estudiantesAggregateType<T extends Certificado_estudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificado_estudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificado_estudiantes[P]>
      : GetScalarType<T[P], AggregateCertificado_estudiantes[P]>
  }




  export type certificado_estudiantesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: certificado_estudiantesWhereInput
    orderBy?: certificado_estudiantesOrderByWithAggregationInput | certificado_estudiantesOrderByWithAggregationInput[]
    by: Certificado_estudiantesScalarFieldEnum[] | Certificado_estudiantesScalarFieldEnum
    having?: certificado_estudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Certificado_estudiantesCountAggregateInputType | true
    _avg?: Certificado_estudiantesAvgAggregateInputType
    _sum?: Certificado_estudiantesSumAggregateInputType
    _min?: Certificado_estudiantesMinAggregateInputType
    _max?: Certificado_estudiantesMaxAggregateInputType
  }


  export type Certificado_estudiantesGroupByOutputType = {
    idcertificado: number
    contrato: number | null
    socio: string | null
    fecha: Date | null
    operador: string | null
    ncert: string | null
    _count: Certificado_estudiantesCountAggregateOutputType | null
    _avg: Certificado_estudiantesAvgAggregateOutputType | null
    _sum: Certificado_estudiantesSumAggregateOutputType | null
    _min: Certificado_estudiantesMinAggregateOutputType | null
    _max: Certificado_estudiantesMaxAggregateOutputType | null
  }

  type GetCertificado_estudiantesGroupByPayload<T extends certificado_estudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Certificado_estudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Certificado_estudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Certificado_estudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], Certificado_estudiantesGroupByOutputType[P]>
        }
      >
    >


  export type certificado_estudiantesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcertificado?: boolean
    contrato?: boolean
    socio?: boolean
    fecha?: boolean
    operador?: boolean
    ncert?: boolean
  }, ExtArgs["result"]["certificado_estudiantes"]>

  export type certificado_estudiantesSelectScalar = {
    idcertificado?: boolean
    contrato?: boolean
    socio?: boolean
    fecha?: boolean
    operador?: boolean
    ncert?: boolean
  }


  type certificado_estudiantesGetPayload<S extends boolean | null | undefined | certificado_estudiantesArgs> = $Types.GetResult<certificado_estudiantesPayload, S>

  type certificado_estudiantesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<certificado_estudiantesFindManyArgs, 'select' | 'include'> & {
      select?: Certificado_estudiantesCountAggregateInputType | true
    }

  export interface certificado_estudiantesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificado_estudiantes'], meta: { name: 'certificado_estudiantes' } }
    /**
     * Find zero or one Certificado_estudiantes that matches the filter.
     * @param {certificado_estudiantesFindUniqueArgs} args - Arguments to find a Certificado_estudiantes
     * @example
     * // Get one Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends certificado_estudiantesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, certificado_estudiantesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'certificado_estudiantes'> extends True ? Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Certificado_estudiantes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {certificado_estudiantesFindUniqueOrThrowArgs} args - Arguments to find a Certificado_estudiantes
     * @example
     * // Get one Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends certificado_estudiantesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, certificado_estudiantesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Certificado_estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesFindFirstArgs} args - Arguments to find a Certificado_estudiantes
     * @example
     * // Get one Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends certificado_estudiantesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, certificado_estudiantesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'certificado_estudiantes'> extends True ? Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Certificado_estudiantes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesFindFirstOrThrowArgs} args - Arguments to find a Certificado_estudiantes
     * @example
     * // Get one Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends certificado_estudiantesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, certificado_estudiantesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Certificado_estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findMany()
     * 
     * // Get first 10 Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.findMany({ take: 10 })
     * 
     * // Only select the `idcertificado`
     * const certificado_estudiantesWithIdcertificadoOnly = await prisma.certificado_estudiantes.findMany({ select: { idcertificado: true } })
     * 
    **/
    findMany<T extends certificado_estudiantesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certificado_estudiantesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Certificado_estudiantes.
     * @param {certificado_estudiantesCreateArgs} args - Arguments to create a Certificado_estudiantes.
     * @example
     * // Create one Certificado_estudiantes
     * const Certificado_estudiantes = await prisma.certificado_estudiantes.create({
     *   data: {
     *     // ... data to create a Certificado_estudiantes
     *   }
     * })
     * 
    **/
    create<T extends certificado_estudiantesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, certificado_estudiantesCreateArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Certificado_estudiantes.
     *     @param {certificado_estudiantesCreateManyArgs} args - Arguments to create many Certificado_estudiantes.
     *     @example
     *     // Create many Certificado_estudiantes
     *     const certificado_estudiantes = await prisma.certificado_estudiantes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends certificado_estudiantesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certificado_estudiantesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certificado_estudiantes.
     * @param {certificado_estudiantesDeleteArgs} args - Arguments to delete one Certificado_estudiantes.
     * @example
     * // Delete one Certificado_estudiantes
     * const Certificado_estudiantes = await prisma.certificado_estudiantes.delete({
     *   where: {
     *     // ... filter to delete one Certificado_estudiantes
     *   }
     * })
     * 
    **/
    delete<T extends certificado_estudiantesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, certificado_estudiantesDeleteArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Certificado_estudiantes.
     * @param {certificado_estudiantesUpdateArgs} args - Arguments to update one Certificado_estudiantes.
     * @example
     * // Update one Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends certificado_estudiantesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, certificado_estudiantesUpdateArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Certificado_estudiantes.
     * @param {certificado_estudiantesDeleteManyArgs} args - Arguments to filter Certificado_estudiantes to delete.
     * @example
     * // Delete a few Certificado_estudiantes
     * const { count } = await prisma.certificado_estudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends certificado_estudiantesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, certificado_estudiantesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificado_estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends certificado_estudiantesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, certificado_estudiantesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificado_estudiantes.
     * @param {certificado_estudiantesUpsertArgs} args - Arguments to update or create a Certificado_estudiantes.
     * @example
     * // Update or create a Certificado_estudiantes
     * const certificado_estudiantes = await prisma.certificado_estudiantes.upsert({
     *   create: {
     *     // ... data to create a Certificado_estudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificado_estudiantes we want to update
     *   }
     * })
    **/
    upsert<T extends certificado_estudiantesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, certificado_estudiantesUpsertArgs<ExtArgs>>
    ): Prisma__certificado_estudiantesClient<$Types.GetResult<certificado_estudiantesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Certificado_estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesCountArgs} args - Arguments to filter Certificado_estudiantes to count.
     * @example
     * // Count the number of Certificado_estudiantes
     * const count = await prisma.certificado_estudiantes.count({
     *   where: {
     *     // ... the filter for the Certificado_estudiantes we want to count
     *   }
     * })
    **/
    count<T extends certificado_estudiantesCountArgs>(
      args?: Subset<T, certificado_estudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Certificado_estudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificado_estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Certificado_estudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Certificado_estudiantesAggregateArgs>(args: Subset<T, Certificado_estudiantesAggregateArgs>): Prisma.PrismaPromise<GetCertificado_estudiantesAggregateType<T>>

    /**
     * Group by Certificado_estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificado_estudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificado_estudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificado_estudiantesGroupByArgs['orderBy'] }
        : { orderBy?: certificado_estudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificado_estudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificado_estudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for certificado_estudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__certificado_estudiantesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * certificado_estudiantes base type for findUnique actions
   */
  export type certificado_estudiantesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter, which certificado_estudiantes to fetch.
     */
    where: certificado_estudiantesWhereUniqueInput
  }

  /**
   * certificado_estudiantes findUnique
   */
  export interface certificado_estudiantesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends certificado_estudiantesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * certificado_estudiantes findUniqueOrThrow
   */
  export type certificado_estudiantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter, which certificado_estudiantes to fetch.
     */
    where: certificado_estudiantesWhereUniqueInput
  }


  /**
   * certificado_estudiantes base type for findFirst actions
   */
  export type certificado_estudiantesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter, which certificado_estudiantes to fetch.
     */
    where?: certificado_estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificado_estudiantes to fetch.
     */
    orderBy?: certificado_estudiantesOrderByWithRelationInput | certificado_estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificado_estudiantes.
     */
    cursor?: certificado_estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificado_estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificado_estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificado_estudiantes.
     */
    distinct?: Certificado_estudiantesScalarFieldEnum | Certificado_estudiantesScalarFieldEnum[]
  }

  /**
   * certificado_estudiantes findFirst
   */
  export interface certificado_estudiantesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends certificado_estudiantesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * certificado_estudiantes findFirstOrThrow
   */
  export type certificado_estudiantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter, which certificado_estudiantes to fetch.
     */
    where?: certificado_estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificado_estudiantes to fetch.
     */
    orderBy?: certificado_estudiantesOrderByWithRelationInput | certificado_estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificado_estudiantes.
     */
    cursor?: certificado_estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificado_estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificado_estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificado_estudiantes.
     */
    distinct?: Certificado_estudiantesScalarFieldEnum | Certificado_estudiantesScalarFieldEnum[]
  }


  /**
   * certificado_estudiantes findMany
   */
  export type certificado_estudiantesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter, which certificado_estudiantes to fetch.
     */
    where?: certificado_estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificado_estudiantes to fetch.
     */
    orderBy?: certificado_estudiantesOrderByWithRelationInput | certificado_estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificado_estudiantes.
     */
    cursor?: certificado_estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificado_estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificado_estudiantes.
     */
    skip?: number
    distinct?: Certificado_estudiantesScalarFieldEnum | Certificado_estudiantesScalarFieldEnum[]
  }


  /**
   * certificado_estudiantes create
   */
  export type certificado_estudiantesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * The data needed to create a certificado_estudiantes.
     */
    data?: XOR<certificado_estudiantesCreateInput, certificado_estudiantesUncheckedCreateInput>
  }


  /**
   * certificado_estudiantes createMany
   */
  export type certificado_estudiantesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificado_estudiantes.
     */
    data: certificado_estudiantesCreateManyInput | certificado_estudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * certificado_estudiantes update
   */
  export type certificado_estudiantesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * The data needed to update a certificado_estudiantes.
     */
    data: XOR<certificado_estudiantesUpdateInput, certificado_estudiantesUncheckedUpdateInput>
    /**
     * Choose, which certificado_estudiantes to update.
     */
    where: certificado_estudiantesWhereUniqueInput
  }


  /**
   * certificado_estudiantes updateMany
   */
  export type certificado_estudiantesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificado_estudiantes.
     */
    data: XOR<certificado_estudiantesUpdateManyMutationInput, certificado_estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which certificado_estudiantes to update
     */
    where?: certificado_estudiantesWhereInput
  }


  /**
   * certificado_estudiantes upsert
   */
  export type certificado_estudiantesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * The filter to search for the certificado_estudiantes to update in case it exists.
     */
    where: certificado_estudiantesWhereUniqueInput
    /**
     * In case the certificado_estudiantes found by the `where` argument doesn't exist, create a new certificado_estudiantes with this data.
     */
    create: XOR<certificado_estudiantesCreateInput, certificado_estudiantesUncheckedCreateInput>
    /**
     * In case the certificado_estudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificado_estudiantesUpdateInput, certificado_estudiantesUncheckedUpdateInput>
  }


  /**
   * certificado_estudiantes delete
   */
  export type certificado_estudiantesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
    /**
     * Filter which certificado_estudiantes to delete.
     */
    where: certificado_estudiantesWhereUniqueInput
  }


  /**
   * certificado_estudiantes deleteMany
   */
  export type certificado_estudiantesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificado_estudiantes to delete
     */
    where?: certificado_estudiantesWhereInput
  }


  /**
   * certificado_estudiantes without action
   */
  export type certificado_estudiantesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificado_estudiantes
     */
    select?: certificado_estudiantesSelect<ExtArgs> | null
  }



  /**
   * Model cartera
   */


  export type AggregateCartera = {
    _count: CarteraCountAggregateOutputType | null
    _avg: CarteraAvgAggregateOutputType | null
    _sum: CarteraSumAggregateOutputType | null
    _min: CarteraMinAggregateOutputType | null
    _max: CarteraMaxAggregateOutputType | null
  }

  export type CarteraAvgAggregateOutputType = {
    contrato: number | null
    grupo: number | null
    adhs: number | null
    zona: number | null
    cuota: number | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number | null
  }

  export type CarteraSumAggregateOutputType = {
    contrato: number | null
    grupo: number | null
    adhs: number | null
    zona: number | null
    cuota: number | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number | null
  }

  export type CarteraMinAggregateOutputType = {
    contrato: number | null
    socio: string | null
    alta: Date | null
    grupo: number | null
    adhs: number | null
    plan: string | null
    sub_plan: string | null
    zona: number | null
    cuota: number | null
    empresa: string | null
    sucursal: string | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number | null
  }

  export type CarteraMaxAggregateOutputType = {
    contrato: number | null
    socio: string | null
    alta: Date | null
    grupo: number | null
    adhs: number | null
    plan: string | null
    sub_plan: string | null
    zona: number | null
    cuota: number | null
    empresa: string | null
    sucursal: string | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number | null
  }

  export type CarteraCountAggregateOutputType = {
    contrato: number
    socio: number
    alta: number
    grupo: number
    adhs: number
    plan: number
    sub_plan: number
    zona: number
    cuota: number
    empresa: number
    sucursal: number
    deuda: number
    mes: number
    ano: number
    idcartera: number
    _all: number
  }


  export type CarteraAvgAggregateInputType = {
    contrato?: true
    grupo?: true
    adhs?: true
    zona?: true
    cuota?: true
    deuda?: true
    mes?: true
    ano?: true
    idcartera?: true
  }

  export type CarteraSumAggregateInputType = {
    contrato?: true
    grupo?: true
    adhs?: true
    zona?: true
    cuota?: true
    deuda?: true
    mes?: true
    ano?: true
    idcartera?: true
  }

  export type CarteraMinAggregateInputType = {
    contrato?: true
    socio?: true
    alta?: true
    grupo?: true
    adhs?: true
    plan?: true
    sub_plan?: true
    zona?: true
    cuota?: true
    empresa?: true
    sucursal?: true
    deuda?: true
    mes?: true
    ano?: true
    idcartera?: true
  }

  export type CarteraMaxAggregateInputType = {
    contrato?: true
    socio?: true
    alta?: true
    grupo?: true
    adhs?: true
    plan?: true
    sub_plan?: true
    zona?: true
    cuota?: true
    empresa?: true
    sucursal?: true
    deuda?: true
    mes?: true
    ano?: true
    idcartera?: true
  }

  export type CarteraCountAggregateInputType = {
    contrato?: true
    socio?: true
    alta?: true
    grupo?: true
    adhs?: true
    plan?: true
    sub_plan?: true
    zona?: true
    cuota?: true
    empresa?: true
    sucursal?: true
    deuda?: true
    mes?: true
    ano?: true
    idcartera?: true
    _all?: true
  }

  export type CarteraAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which cartera to aggregate.
     */
    where?: carteraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteras to fetch.
     */
    orderBy?: carteraOrderByWithRelationInput | carteraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: carteraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carteras
    **/
    _count?: true | CarteraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteraMaxAggregateInputType
  }

  export type GetCarteraAggregateType<T extends CarteraAggregateArgs> = {
        [P in keyof T & keyof AggregateCartera]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartera[P]>
      : GetScalarType<T[P], AggregateCartera[P]>
  }




  export type carteraGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: carteraWhereInput
    orderBy?: carteraOrderByWithAggregationInput | carteraOrderByWithAggregationInput[]
    by: CarteraScalarFieldEnum[] | CarteraScalarFieldEnum
    having?: carteraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteraCountAggregateInputType | true
    _avg?: CarteraAvgAggregateInputType
    _sum?: CarteraSumAggregateInputType
    _min?: CarteraMinAggregateInputType
    _max?: CarteraMaxAggregateInputType
  }


  export type CarteraGroupByOutputType = {
    contrato: number | null
    socio: string | null
    alta: Date | null
    grupo: number | null
    adhs: number | null
    plan: string | null
    sub_plan: string | null
    zona: number | null
    cuota: number | null
    empresa: string | null
    sucursal: string | null
    deuda: number | null
    mes: number | null
    ano: number | null
    idcartera: number
    _count: CarteraCountAggregateOutputType | null
    _avg: CarteraAvgAggregateOutputType | null
    _sum: CarteraSumAggregateOutputType | null
    _min: CarteraMinAggregateOutputType | null
    _max: CarteraMaxAggregateOutputType | null
  }

  type GetCarteraGroupByPayload<T extends carteraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarteraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteraGroupByOutputType[P]>
            : GetScalarType<T[P], CarteraGroupByOutputType[P]>
        }
      >
    >


  export type carteraSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contrato?: boolean
    socio?: boolean
    alta?: boolean
    grupo?: boolean
    adhs?: boolean
    plan?: boolean
    sub_plan?: boolean
    zona?: boolean
    cuota?: boolean
    empresa?: boolean
    sucursal?: boolean
    deuda?: boolean
    mes?: boolean
    ano?: boolean
    idcartera?: boolean
  }, ExtArgs["result"]["cartera"]>

  export type carteraSelectScalar = {
    contrato?: boolean
    socio?: boolean
    alta?: boolean
    grupo?: boolean
    adhs?: boolean
    plan?: boolean
    sub_plan?: boolean
    zona?: boolean
    cuota?: boolean
    empresa?: boolean
    sucursal?: boolean
    deuda?: boolean
    mes?: boolean
    ano?: boolean
    idcartera?: boolean
  }


  type carteraGetPayload<S extends boolean | null | undefined | carteraArgs> = $Types.GetResult<carteraPayload, S>

  type carteraCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<carteraFindManyArgs, 'select' | 'include'> & {
      select?: CarteraCountAggregateInputType | true
    }

  export interface carteraDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cartera'], meta: { name: 'cartera' } }
    /**
     * Find zero or one Cartera that matches the filter.
     * @param {carteraFindUniqueArgs} args - Arguments to find a Cartera
     * @example
     * // Get one Cartera
     * const cartera = await prisma.cartera.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carteraFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, carteraFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cartera'> extends True ? Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Cartera that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {carteraFindUniqueOrThrowArgs} args - Arguments to find a Cartera
     * @example
     * // Get one Cartera
     * const cartera = await prisma.cartera.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carteraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, carteraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Cartera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraFindFirstArgs} args - Arguments to find a Cartera
     * @example
     * // Get one Cartera
     * const cartera = await prisma.cartera.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carteraFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, carteraFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cartera'> extends True ? Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Cartera that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraFindFirstOrThrowArgs} args - Arguments to find a Cartera
     * @example
     * // Get one Cartera
     * const cartera = await prisma.cartera.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carteraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, carteraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Carteras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteras
     * const carteras = await prisma.cartera.findMany()
     * 
     * // Get first 10 Carteras
     * const carteras = await prisma.cartera.findMany({ take: 10 })
     * 
     * // Only select the `contrato`
     * const carteraWithContratoOnly = await prisma.cartera.findMany({ select: { contrato: true } })
     * 
    **/
    findMany<T extends carteraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carteraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<carteraPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Cartera.
     * @param {carteraCreateArgs} args - Arguments to create a Cartera.
     * @example
     * // Create one Cartera
     * const Cartera = await prisma.cartera.create({
     *   data: {
     *     // ... data to create a Cartera
     *   }
     * })
     * 
    **/
    create<T extends carteraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, carteraCreateArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Carteras.
     *     @param {carteraCreateManyArgs} args - Arguments to create many Carteras.
     *     @example
     *     // Create many Carteras
     *     const cartera = await prisma.cartera.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carteraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carteraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cartera.
     * @param {carteraDeleteArgs} args - Arguments to delete one Cartera.
     * @example
     * // Delete one Cartera
     * const Cartera = await prisma.cartera.delete({
     *   where: {
     *     // ... filter to delete one Cartera
     *   }
     * })
     * 
    **/
    delete<T extends carteraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, carteraDeleteArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Cartera.
     * @param {carteraUpdateArgs} args - Arguments to update one Cartera.
     * @example
     * // Update one Cartera
     * const cartera = await prisma.cartera.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carteraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, carteraUpdateArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Carteras.
     * @param {carteraDeleteManyArgs} args - Arguments to filter Carteras to delete.
     * @example
     * // Delete a few Carteras
     * const { count } = await prisma.cartera.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carteraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, carteraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteras
     * const cartera = await prisma.cartera.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carteraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, carteraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cartera.
     * @param {carteraUpsertArgs} args - Arguments to update or create a Cartera.
     * @example
     * // Update or create a Cartera
     * const cartera = await prisma.cartera.upsert({
     *   create: {
     *     // ... data to create a Cartera
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cartera we want to update
     *   }
     * })
    **/
    upsert<T extends carteraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, carteraUpsertArgs<ExtArgs>>
    ): Prisma__carteraClient<$Types.GetResult<carteraPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Carteras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraCountArgs} args - Arguments to filter Carteras to count.
     * @example
     * // Count the number of Carteras
     * const count = await prisma.cartera.count({
     *   where: {
     *     // ... the filter for the Carteras we want to count
     *   }
     * })
    **/
    count<T extends carteraCountArgs>(
      args?: Subset<T, carteraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cartera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteraAggregateArgs>(args: Subset<T, CarteraAggregateArgs>): Prisma.PrismaPromise<GetCarteraAggregateType<T>>

    /**
     * Group by Cartera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends carteraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: carteraGroupByArgs['orderBy'] }
        : { orderBy?: carteraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, carteraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cartera.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__carteraClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cartera base type for findUnique actions
   */
  export type carteraFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter, which cartera to fetch.
     */
    where: carteraWhereUniqueInput
  }

  /**
   * cartera findUnique
   */
  export interface carteraFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends carteraFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cartera findUniqueOrThrow
   */
  export type carteraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter, which cartera to fetch.
     */
    where: carteraWhereUniqueInput
  }


  /**
   * cartera base type for findFirst actions
   */
  export type carteraFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter, which cartera to fetch.
     */
    where?: carteraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteras to fetch.
     */
    orderBy?: carteraOrderByWithRelationInput | carteraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteras.
     */
    cursor?: carteraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteras.
     */
    distinct?: CarteraScalarFieldEnum | CarteraScalarFieldEnum[]
  }

  /**
   * cartera findFirst
   */
  export interface carteraFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends carteraFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cartera findFirstOrThrow
   */
  export type carteraFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter, which cartera to fetch.
     */
    where?: carteraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteras to fetch.
     */
    orderBy?: carteraOrderByWithRelationInput | carteraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteras.
     */
    cursor?: carteraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteras.
     */
    distinct?: CarteraScalarFieldEnum | CarteraScalarFieldEnum[]
  }


  /**
   * cartera findMany
   */
  export type carteraFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter, which carteras to fetch.
     */
    where?: carteraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteras to fetch.
     */
    orderBy?: carteraOrderByWithRelationInput | carteraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carteras.
     */
    cursor?: carteraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteras.
     */
    skip?: number
    distinct?: CarteraScalarFieldEnum | CarteraScalarFieldEnum[]
  }


  /**
   * cartera create
   */
  export type carteraCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * The data needed to create a cartera.
     */
    data?: XOR<carteraCreateInput, carteraUncheckedCreateInput>
  }


  /**
   * cartera createMany
   */
  export type carteraCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carteras.
     */
    data: carteraCreateManyInput | carteraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cartera update
   */
  export type carteraUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * The data needed to update a cartera.
     */
    data: XOR<carteraUpdateInput, carteraUncheckedUpdateInput>
    /**
     * Choose, which cartera to update.
     */
    where: carteraWhereUniqueInput
  }


  /**
   * cartera updateMany
   */
  export type carteraUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carteras.
     */
    data: XOR<carteraUpdateManyMutationInput, carteraUncheckedUpdateManyInput>
    /**
     * Filter which carteras to update
     */
    where?: carteraWhereInput
  }


  /**
   * cartera upsert
   */
  export type carteraUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * The filter to search for the cartera to update in case it exists.
     */
    where: carteraWhereUniqueInput
    /**
     * In case the cartera found by the `where` argument doesn't exist, create a new cartera with this data.
     */
    create: XOR<carteraCreateInput, carteraUncheckedCreateInput>
    /**
     * In case the cartera was found with the provided `where` argument, update it with this data.
     */
    update: XOR<carteraUpdateInput, carteraUncheckedUpdateInput>
  }


  /**
   * cartera delete
   */
  export type carteraDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
    /**
     * Filter which cartera to delete.
     */
    where: carteraWhereUniqueInput
  }


  /**
   * cartera deleteMany
   */
  export type carteraDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which carteras to delete
     */
    where?: carteraWhereInput
  }


  /**
   * cartera without action
   */
  export type carteraArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartera
     */
    select?: carteraSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Alta_novellScalarFieldEnum: {
    idnovell: 'idnovell',
    fecha_recepcion: 'fecha_recepcion',
    servicio: 'servicio',
    monto: 'monto',
    monto_letra: 'monto_letra',
    anticipo: 'anticipo',
    gastos_adm: 'gastos_adm',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    estcivil_sol: 'estcivil_sol',
    fecha_nac_sol: 'fecha_nac_sol',
    dom_sol: 'dom_sol',
    domnum_sol: 'domnum_sol',
    piso_sol: 'piso_sol',
    barrio_sol: 'barrio_sol',
    localidad_sol: 'localidad_sol',
    codpostal_sol: 'codpostal_sol',
    telefono_sol: 'telefono_sol',
    movil_sol: 'movil_sol',
    apellido_ben: 'apellido_ben',
    nombre_ben: 'nombre_ben',
    dni_ben: 'dni_ben',
    estcivil_ben: 'estcivil_ben',
    fecha_nac_ben: 'fecha_nac_ben',
    dom_ben: 'dom_ben',
    domnum_ben: 'domnum_ben',
    piso_ben: 'piso_ben',
    barrio_ben: 'barrio_ben',
    localidad_ben: 'localidad_ben',
    codpostal_ben: 'codpostal_ben',
    telefono_ben: 'telefono_ben',
    movil_ben: 'movil_ben',
    operador: 'operador',
    cuotas: 'cuotas',
    nacionalidad_sol: 'nacionalidad_sol',
    nacionalidad_ben: 'nacionalidad_ben',
    anticipo_letra: 'anticipo_letra',
    cuotasaldo: 'cuotasaldo',
    cuotasaldo_letra: 'cuotasaldo_letra',
    cuota_mantenimiento: 'cuota_mantenimiento'
  };

  export type Alta_novellScalarFieldEnum = (typeof Alta_novellScalarFieldEnum)[keyof typeof Alta_novellScalarFieldEnum]


  export const Caja_sucursalesScalarFieldEnum: {
    idcaja: 'idcaja',
    fecha_carga: 'fecha_carga',
    sucursal: 'sucursal',
    ingresos: 'ingresos',
    egresos: 'egresos',
    saldo: 'saldo',
    operador_carga: 'operador_carga',
    empresa: 'empresa'
  };

  export type Caja_sucursalesScalarFieldEnum = (typeof Caja_sucursalesScalarFieldEnum)[keyof typeof Caja_sucursalesScalarFieldEnum]


  export const CampanacasosScalarFieldEnum: {
    idcaso: 'idcaso',
    idcampana: 'idcampana',
    fechacampana: 'fechacampana',
    mes: 'mes',
    ano: 'ano',
    sucursal: 'sucursal',
    contrato: 'contrato',
    apellido: 'apellido',
    nombre: 'nombre',
    dni: 'dni',
    telefono: 'telefono',
    movil: 'movil',
    calle: 'calle',
    nro_calle: 'nro_calle',
    barrio: 'barrio',
    localidad: 'localidad',
    cuota: 'cuota',
    cuotasadeudadas: 'cuotasadeudadas',
    montoadeudado: 'montoadeudado',
    estadocaso: 'estadocaso',
    accion: 'accion',
    edad: 'edad',
    adherentes: 'adherentes',
    alta: 'alta',
    vigencia: 'vigencia'
  };

  export type CampanacasosScalarFieldEnum = (typeof CampanacasosScalarFieldEnum)[keyof typeof CampanacasosScalarFieldEnum]


  export const CampanasScalarFieldEnum: {
    idcampana: 'idcampana',
    descripcion: 'descripcion',
    operador: 'operador',
    fecha: 'fecha',
    empresa: 'empresa',
    sucursal: 'sucursal'
  };

  export type CampanasScalarFieldEnum = (typeof CampanasScalarFieldEnum)[keyof typeof CampanasScalarFieldEnum]


  export const CampanatemporalScalarFieldEnum: {
    SUCURSAL: 'SUCURSAL',
    CONTRATO: 'CONTRATO',
    NRO_DOC: 'NRO_DOC',
    APELLIDOS: 'APELLIDOS',
    NOMBRES: 'NOMBRES',
    ALTA: 'ALTA',
    VIGENCIA: 'VIGENCIA',
    CALLE: 'CALLE',
    NRO_CALLE: 'NRO_CALLE',
    BARRIO: 'BARRIO',
    LOCALIDAD: 'LOCALIDAD',
    GRUPO: 'GRUPO',
    ZONA: 'ZONA',
    TELEFONO: 'TELEFONO',
    MOVIL: 'MOVIL',
    EDAD: 'EDAD',
    MES: 'MES',
    ANO: 'ANO',
    IMPORTE: 'IMPORTE',
    operador: 'operador',
    estado: 'estado',
    idcaso: 'idcaso',
    observacion: 'observacion',
    fecha: 'fecha',
    fecha_observacion: 'fecha_observacion',
    accion: 'accion'
  };

  export type CampanatemporalScalarFieldEnum = (typeof CampanatemporalScalarFieldEnum)[keyof typeof CampanatemporalScalarFieldEnum]


  export const Capital_prestamoScalarFieldEnum: {
    idcapital: 'idcapital',
    capital: 'capital',
    fecha: 'fecha',
    estado: 'estado',
    autorizacion: 'autorizacion'
  };

  export type Capital_prestamoScalarFieldEnum = (typeof Capital_prestamoScalarFieldEnum)[keyof typeof Capital_prestamoScalarFieldEnum]


  export const Capital_prestamo_empleadosScalarFieldEnum: {
    idcapital: 'idcapital',
    capital: 'capital',
    fecha: 'fecha',
    estado: 'estado',
    autorizacion: 'autorizacion'
  };

  export type Capital_prestamo_empleadosScalarFieldEnum = (typeof Capital_prestamo_empleadosScalarFieldEnum)[keyof typeof Capital_prestamo_empleadosScalarFieldEnum]


  export const Categoria_obsequioScalarFieldEnum: {
    idcategoria: 'idcategoria',
    categoria: 'categoria',
    observacion: 'observacion'
  };

  export type Categoria_obsequioScalarFieldEnum = (typeof Categoria_obsequioScalarFieldEnum)[keyof typeof Categoria_obsequioScalarFieldEnum]


  export const ContratosScalarFieldEnum: {
    idcontrato: 'idcontrato',
    locatario1: 'locatario1',
    dni1: 'dni1',
    domicilio1: 'domicilio1',
    locatario2: 'locatario2',
    dni2: 'dni2',
    domicilio2: 'domicilio2',
    monto: 'monto',
    fecha_inicio: 'fecha_inicio',
    duracion: 'duracion',
    locador: 'locador',
    operador: 'operador',
    local: 'local',
    uf: 'uf'
  };

  export type ContratosScalarFieldEnum = (typeof ContratosScalarFieldEnum)[keyof typeof ContratosScalarFieldEnum]


  export const Convenio_deudaScalarFieldEnum: {
    idconvdeuda: 'idconvdeuda',
    contrato: 'contrato',
    apellido: 'apellido',
    nombre: 'nombre',
    operador: 'operador',
    vigencia: 'vigencia',
    fecha: 'fecha',
    cuotas: 'cuotas',
    dni: 'dni',
    empresa: 'empresa',
    idoperador: 'idoperador',
    vencimiento1: 'vencimiento1',
    importe1: 'importe1',
    vencimiento2: 'vencimiento2',
    importe2: 'importe2',
    deuda: 'deuda',
    bonificacion: 'bonificacion',
    saldo: 'saldo'
  };

  export type Convenio_deudaScalarFieldEnum = (typeof Convenio_deudaScalarFieldEnum)[keyof typeof Convenio_deudaScalarFieldEnum]


  export const DatosScalarFieldEnum: {
    iddato: 'iddato',
    apellido: 'apellido',
    nombre: 'nombre',
    edad: 'edad',
    telefono: 'telefono',
    celular: 'celular',
    cobertura: 'cobertura',
    grupo_familiar: 'grupo_familiar',
    observacion: 'observacion',
    operador: 'operador',
    domicilio: 'domicilio',
    fecha: 'fecha'
  };

  export type DatosScalarFieldEnum = (typeof DatosScalarFieldEnum)[keyof typeof DatosScalarFieldEnum]


  export const Datos_atencionScalarFieldEnum: {
    iddatos: 'iddatos',
    apellido: 'apellido',
    nombre: 'nombre',
    dni: 'dni',
    telefono: 'telefono',
    parentezco: 'parentezco',
    motivo: 'motivo',
    operador: 'operador',
    operadoratencion: 'operadoratencion',
    fecha: 'fecha'
  };

  export type Datos_atencionScalarFieldEnum = (typeof Datos_atencionScalarFieldEnum)[keyof typeof Datos_atencionScalarFieldEnum]


  export const Detalle_orden_pagoScalarFieldEnum: {
    iddetallepago: 'iddetallepago',
    norden: 'norden',
    nconsulta: 'nconsulta',
    sucursal: 'sucursal',
    prestador: 'prestador',
    importe: 'importe',
    operador_carga: 'operador_carga',
    fecha: 'fecha'
  };

  export type Detalle_orden_pagoScalarFieldEnum = (typeof Detalle_orden_pagoScalarFieldEnum)[keyof typeof Detalle_orden_pagoScalarFieldEnum]


  export const EmpresasScalarFieldEnum: {
    idempresa: 'idempresa',
    empresa: 'empresa',
    cuit: 'cuit'
  };

  export type EmpresasScalarFieldEnum = (typeof EmpresasScalarFieldEnum)[keyof typeof EmpresasScalarFieldEnum]


  export const EventosScalarFieldEnum: {
    idevents: 'idevents',
    title: 'title',
    allDay: 'allDay',
    start: 'start',
    end: 'end'
  };

  export type EventosScalarFieldEnum = (typeof EventosScalarFieldEnum)[keyof typeof EventosScalarFieldEnum]


  export const Fabricante_ataudScalarFieldEnum: {
    idfabricante: 'idfabricante',
    fabricante: 'fabricante'
  };

  export type Fabricante_ataudScalarFieldEnum = (typeof Fabricante_ataudScalarFieldEnum)[keyof typeof Fabricante_ataudScalarFieldEnum]


  export const GestioncasoScalarFieldEnum: {
    idgestion: 'idgestion',
    idcaso: 'idcaso',
    contrato: 'contrato',
    operador: 'operador',
    accion: 'accion',
    observacion: 'observacion',
    fechaaccion: 'fechaaccion',
    nuevaaccion: 'nuevaaccion',
    fechanuevaaccion: 'fechanuevaaccion',
    realizado: 'realizado',
    observacion_nuevaaccion: 'observacion_nuevaaccion'
  };

  export type GestioncasoScalarFieldEnum = (typeof GestioncasoScalarFieldEnum)[keyof typeof GestioncasoScalarFieldEnum]


  export const Historial_accionesScalarFieldEnum: {
    idhistorial: 'idhistorial',
    operador: 'operador',
    fecha: 'fecha',
    accion: 'accion'
  };

  export type Historial_accionesScalarFieldEnum = (typeof Historial_accionesScalarFieldEnum)[keyof typeof Historial_accionesScalarFieldEnum]


  export const Historial_aprobacion_prestamosScalarFieldEnum: {
    idaprobacion: 'idaprobacion',
    operador: 'operador',
    idprestamo: 'idprestamo',
    fecha: 'fecha',
    contrato: 'contrato',
    afiliado: 'afiliado',
    productor: 'productor'
  };

  export type Historial_aprobacion_prestamosScalarFieldEnum = (typeof Historial_aprobacion_prestamosScalarFieldEnum)[keyof typeof Historial_aprobacion_prestamosScalarFieldEnum]


  export const Historial_liquidacionesScalarFieldEnum: {
    idliquidacion: 'idliquidacion',
    operador: 'operador',
    fecha: 'fecha',
    mes: 'mes',
    ano: 'ano',
    cobranza: 'cobranza',
    total: 'total',
    comision: 'comision',
    entidad: 'entidad'
  };

  export type Historial_liquidacionesScalarFieldEnum = (typeof Historial_liquidacionesScalarFieldEnum)[keyof typeof Historial_liquidacionesScalarFieldEnum]


  export const Intereses_tarjetasScalarFieldEnum: {
    idplan: 'idplan',
    plan_cuota: 'plan_cuota',
    interes: 'interes',
    tarjeta: 'tarjeta',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type Intereses_tarjetasScalarFieldEnum = (typeof Intereses_tarjetasScalarFieldEnum)[keyof typeof Intereses_tarjetasScalarFieldEnum]


  export const Legajo_virtualScalarFieldEnum: {
    idlegajo: 'idlegajo',
    contrato: 'contrato',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa',
    tipoarchivo: 'tipoarchivo'
  };

  export type Legajo_virtualScalarFieldEnum = (typeof Legajo_virtualScalarFieldEnum)[keyof typeof Legajo_virtualScalarFieldEnum]


  export const Legajo_virtual_cajasScalarFieldEnum: {
    idlegajo: 'idlegajo',
    idcaja: 'idcaja',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida'
  };

  export type Legajo_virtual_cajasScalarFieldEnum = (typeof Legajo_virtual_cajasScalarFieldEnum)[keyof typeof Legajo_virtual_cajasScalarFieldEnum]


  export const Legajo_virtual_ordenesScalarFieldEnum: {
    idlegajo: 'idlegajo',
    idorden: 'idorden',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa'
  };

  export type Legajo_virtual_ordenesScalarFieldEnum = (typeof Legajo_virtual_ordenesScalarFieldEnum)[keyof typeof Legajo_virtual_ordenesScalarFieldEnum]


  export const Legajo_virtual_personalScalarFieldEnum: {
    idlegajo: 'idlegajo',
    idpersonal: 'idpersonal',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida'
  };

  export type Legajo_virtual_personalScalarFieldEnum = (typeof Legajo_virtual_personalScalarFieldEnum)[keyof typeof Legajo_virtual_personalScalarFieldEnum]


  export const Legajo_virtual_prestamosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    contrato: 'contrato',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa',
    cod_ptm_leg: 'cod_ptm_leg'
  };

  export type Legajo_virtual_prestamosScalarFieldEnum = (typeof Legajo_virtual_prestamosScalarFieldEnum)[keyof typeof Legajo_virtual_prestamosScalarFieldEnum]


  export const LocadorScalarFieldEnum: {
    dni: 'dni',
    apellido: 'apellido',
    nombre: 'nombre',
    domicilio: 'domicilio',
    barrio: 'barrio',
    localidad: 'localidad',
    provincia: 'provincia'
  };

  export type LocadorScalarFieldEnum = (typeof LocadorScalarFieldEnum)[keyof typeof LocadorScalarFieldEnum]


  export const MailsScalarFieldEnum: {
    idmail: 'idmail',
    fecha: 'fecha',
    envia: 'envia',
    recibe: 'recibe',
    descrip: 'descrip',
    codmail: 'codmail',
    asunto: 'asunto',
    leido: 'leido',
    fecha_leido: 'fecha_leido',
    url_caja: 'url_caja'
  };

  export type MailsScalarFieldEnum = (typeof MailsScalarFieldEnum)[keyof typeof MailsScalarFieldEnum]


  export const Mails_adjuntosScalarFieldEnum: {
    idadjunto: 'idadjunto',
    codmail: 'codmail',
    adjunto: 'adjunto',
    tipo: 'tipo'
  };

  export type Mails_adjuntosScalarFieldEnum = (typeof Mails_adjuntosScalarFieldEnum)[keyof typeof Mails_adjuntosScalarFieldEnum]


  export const MbanconvScalarFieldEnum: {
    id_mora: 'id_mora',
    tipo: 'tipo',
    mora: 'mora',
    fichas: 'fichas',
    morarec: 'morarec',
    fichasrec: 'fichasrec',
    mes: 'mes',
    ano: 'ano'
  };

  export type MbanconvScalarFieldEnum = (typeof MbanconvScalarFieldEnum)[keyof typeof MbanconvScalarFieldEnum]


  export const Movimiento_caja_sucursalesScalarFieldEnum: {
    idmovimiento: 'idmovimiento',
    fecha_carga: 'fecha_carga',
    fecha_movimiento: 'fecha_movimiento',
    sucursal: 'sucursal',
    concepto: 'concepto',
    movimiento: 'movimiento',
    importe: 'importe',
    operador_carga: 'operador_carga',
    idcaja: 'idcaja',
    empresa: 'empresa'
  };

  export type Movimiento_caja_sucursalesScalarFieldEnum = (typeof Movimiento_caja_sucursalesScalarFieldEnum)[keyof typeof Movimiento_caja_sucursalesScalarFieldEnum]


  export const NoticiaScalarFieldEnum: {
    idnoticia: 'idnoticia',
    fecha: 'fecha',
    noticia: 'noticia',
    operador: 'operador',
    perfil: 'perfil'
  };

  export type NoticiaScalarFieldEnum = (typeof NoticiaScalarFieldEnum)[keyof typeof NoticiaScalarFieldEnum]


  export const NovedadesScalarFieldEnum: {
    idnovedades: 'idnovedades',
    novedad: 'novedad',
    fecha: 'fecha',
    operador: 'operador',
    estado: 'estado'
  };

  export type NovedadesScalarFieldEnum = (typeof NovedadesScalarFieldEnum)[keyof typeof NovedadesScalarFieldEnum]


  export const ObsequiosScalarFieldEnum: {
    idobsequio: 'idobsequio',
    producto: 'producto',
    marca: 'marca',
    categoria: 'categoria',
    precio: 'precio',
    stock: 'stock',
    operador: 'operador',
    fecha: 'fecha',
    observacion: 'observacion',
    fecha_reposicion: 'fecha_reposicion',
    operador_rep: 'operador_rep'
  };

  export type ObsequiosScalarFieldEnum = (typeof ObsequiosScalarFieldEnum)[keyof typeof ObsequiosScalarFieldEnum]


  export const Openia_keysScalarFieldEnum: {
    idkey: 'idkey',
    key: 'key',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type Openia_keysScalarFieldEnum = (typeof Openia_keysScalarFieldEnum)[keyof typeof Openia_keysScalarFieldEnum]


  export const OperadorScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    usuario: 'usuario',
    contrasena: 'contrasena',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    puestom: 'puestom',
    perfil: 'perfil',
    estado: 'estado',
    puestow: 'puestow',
    codigo: 'codigo',
    medicos: 'medicos',
    sucursal: 'sucursal',
    prestamos: 'prestamos',
    ordenpago: 'ordenpago',
    clubwerchow: 'clubwerchow',
    ventas: 'ventas',
    administracion: 'administracion',
    campanas: 'campanas',
    socios: 'socios',
    sepelio: 'sepelio'
  };

  export type OperadorScalarFieldEnum = (typeof OperadorScalarFieldEnum)[keyof typeof OperadorScalarFieldEnum]


  export const Ordenes_pagoScalarFieldEnum: {
    idorden: 'idorden',
    fecha: 'fecha',
    proveedor: 'proveedor',
    cuit_cuil: 'cuit_cuil',
    total: 'total',
    operador_carga: 'operador_carga',
    autorizado: 'autorizado',
    operador_autorizacion: 'operador_autorizacion',
    fecha_autorizacion: 'fecha_autorizacion',
    norden: 'norden',
    observacion: 'observacion',
    nombre: 'nombre',
    tipo_orden: 'tipo_orden',
    nfactura: 'nfactura',
    tipo_factura: 'tipo_factura',
    fecha_pago: 'fecha_pago',
    pagado: 'pagado',
    estado: 'estado'
  };

  export type Ordenes_pagoScalarFieldEnum = (typeof Ordenes_pagoScalarFieldEnum)[keyof typeof Ordenes_pagoScalarFieldEnum]


  export const PersonalScalarFieldEnum: {
    idpersonal: 'idpersonal',
    apellido: 'apellido',
    nombre: 'nombre',
    dni: 'dni',
    alta: 'alta',
    rol: 'rol',
    legajo: 'legajo',
    baja: 'baja'
  };

  export type PersonalScalarFieldEnum = (typeof PersonalScalarFieldEnum)[keyof typeof PersonalScalarFieldEnum]


  export const Plan_cuentasScalarFieldEnum: {
    idcuenta: 'idcuenta',
    idempresa: 'idempresa',
    codigo: 'codigo',
    descripcion: 'descripcion',
    asiento: 'asiento',
    tipo: 'tipo'
  };

  export type Plan_cuentasScalarFieldEnum = (typeof Plan_cuentasScalarFieldEnum)[keyof typeof Plan_cuentasScalarFieldEnum]


  export const Plan_cuentas_xScalarFieldEnum: {
    idcuenta: 'idcuenta',
    idempresa: 'idempresa',
    codigo: 'codigo',
    descripcion: 'descripcion',
    asiento: 'asiento',
    tipo: 'tipo'
  };

  export type Plan_cuentas_xScalarFieldEnum = (typeof Plan_cuentas_xScalarFieldEnum)[keyof typeof Plan_cuentas_xScalarFieldEnum]


  export const Plan_detalleScalarFieldEnum: {
    id_plandetalle: 'id_plandetalle',
    detalle: 'detalle',
    cuota: 'cuota',
    sub_ext: 'sub_ext',
    vigencia: 'vigencia',
    id_plan: 'id_plan'
  };

  export type Plan_detalleScalarFieldEnum = (typeof Plan_detalleScalarFieldEnum)[keyof typeof Plan_detalleScalarFieldEnum]


  export const Plan_precioScalarFieldEnum: {
    id_plan: 'id_plan',
    plan: 'plan',
    tipo_plan: 'tipo_plan',
    codigo: 'codigo'
  };

  export type Plan_precioScalarFieldEnum = (typeof Plan_precioScalarFieldEnum)[keyof typeof Plan_precioScalarFieldEnum]


  export const Porcentaje_liqScalarFieldEnum: {
    porcliq_id: 'porcliq_id',
    porcliq_nombre: 'porcliq_nombre',
    porcliq_descrip: 'porcliq_descrip',
    porcliq_cuotas: 'porcliq_cuotas',
    porcliq_porcentaje: 'porcliq_porcentaje'
  };

  export type Porcentaje_liqScalarFieldEnum = (typeof Porcentaje_liqScalarFieldEnum)[keyof typeof Porcentaje_liqScalarFieldEnum]


  export const Prestamos_empleadosScalarFieldEnum: {
    idprestamo: 'idprestamo',
    empleado: 'empleado',
    fecha_solicitud: 'fecha_solicitud',
    capital: 'capital',
    plan_cuotas: 'plan_cuotas',
    cuota_mensual: 'cuota_mensual',
    capital_dev: 'capital_dev',
    inicia: 'inicia',
    termina: 'termina',
    estado: 'estado',
    capinoaut: 'capinoaut'
  };

  export type Prestamos_empleadosScalarFieldEnum = (typeof Prestamos_empleadosScalarFieldEnum)[keyof typeof Prestamos_empleadosScalarFieldEnum]


  export const Prestamos_empleados_cobroScalarFieldEnum: {
    idpago: 'idpago',
    idprestamo: 'idprestamo',
    cuota: 'cuota',
    importe: 'importe',
    fecha_cobro: 'fecha_cobro',
    estado: 'estado',
    fecha_pago: 'fecha_pago',
    operador: 'operador'
  };

  export type Prestamos_empleados_cobroScalarFieldEnum = (typeof Prestamos_empleados_cobroScalarFieldEnum)[keyof typeof Prestamos_empleados_cobroScalarFieldEnum]


  export const ProduccionScalarFieldEnum: {
    prod_ide: 'prod_ide',
    prod_fechacarga: 'prod_fechacarga',
    prod_fechaafi: 'prod_fechaafi',
    prod_asesor: 'prod_asesor',
    prod_empre: 'prod_empre',
    prod_mes: 'prod_mes',
    prod_anio: 'prod_anio',
    prod_apeafi: 'prod_apeafi',
    prod_nomafi: 'prod_nomafi',
    prod_dniafi: 'prod_dniafi',
    prod_local: 'prod_local',
    prod_recibo: 'prod_recibo',
    prod_monto: 'prod_monto',
    prod_plan: 'prod_plan',
    prod_pago: 'prod_pago',
    prod_cta_tar: 'prod_cta_tar',
    prod_obs: 'prod_obs',
    prod_semana: 'prod_semana',
    prod_estado: 'prod_estado',
    prod_cierre: 'prod_cierre',
    prod_afiliado: 'prod_afiliado',
    prod_rendido: 'prod_rendido',
    prod_recibosis: 'prod_recibosis',
    prod_fechren: 'prod_fechren',
    prod_tel: 'prod_tel'
  };

  export type ProduccionScalarFieldEnum = (typeof ProduccionScalarFieldEnum)[keyof typeof ProduccionScalarFieldEnum]


  export const Registro_constancia_afiliacionScalarFieldEnum: {
    idconstancia: 'idconstancia',
    apellido_extinto: 'apellido_extinto',
    nombre_extinto: 'nombre_extinto',
    dni_extinto: 'dni_extinto',
    apellido_soli: 'apellido_soli',
    nombre_soli: 'nombre_soli',
    dni_soli: 'dni_soli',
    lugar_presentacion: 'lugar_presentacion',
    fecha: 'fecha',
    operador: 'operador',
    idservicio: 'idservicio'
  };

  export type Registro_constancia_afiliacionScalarFieldEnum = (typeof Registro_constancia_afiliacionScalarFieldEnum)[keyof typeof Registro_constancia_afiliacionScalarFieldEnum]


  export const RehabilitacionesScalarFieldEnum: {
    idrehab: 'idrehab',
    contrato: 'contrato',
    apellido: 'apellido',
    nombre: 'nombre',
    operador: 'operador',
    vigencia: 'vigencia',
    fecha: 'fecha',
    cuotas: 'cuotas',
    dni: 'dni',
    empresa: 'empresa',
    idoperador: 'idoperador'
  };

  export type RehabilitacionesScalarFieldEnum = (typeof RehabilitacionesScalarFieldEnum)[keyof typeof RehabilitacionesScalarFieldEnum]


  export const Rol_personalScalarFieldEnum: {
    idrol: 'idrol',
    rol: 'rol'
  };

  export type Rol_personalScalarFieldEnum = (typeof Rol_personalScalarFieldEnum)[keyof typeof Rol_personalScalarFieldEnum]


  export const SucursalScalarFieldEnum: {
    idsucursal: 'idsucursal',
    sucursal: 'sucursal',
    codigo: 'codigo'
  };

  export type SucursalScalarFieldEnum = (typeof SucursalScalarFieldEnum)[keyof typeof SucursalScalarFieldEnum]


  export const SueldosScalarFieldEnum: {
    sld_id: 'sld_id',
    sld_perfil: 'sld_perfil',
    sld_basico: 'sld_basico',
    sld_basicoant: 'sld_basicoant'
  };

  export type SueldosScalarFieldEnum = (typeof SueldosScalarFieldEnum)[keyof typeof SueldosScalarFieldEnum]


  export const Tab_efScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    allDay: 'allDay',
    holiday: 'holiday',
    title: 'title',
    user: 'user',
    detail: 'detail'
  };

  export type Tab_efScalarFieldEnum = (typeof Tab_efScalarFieldEnum)[keyof typeof Tab_efScalarFieldEnum]


  export const Tablero_efectividadScalarFieldEnum: {
    idregistro: 'idregistro',
    ano: 'ano',
    mes: 'mes',
    dia: 'dia',
    efectividad: 'efectividad',
    aumento: 'aumento',
    por_aumento: 'por_aumento',
    feriado: 'feriado'
  };

  export type Tablero_efectividadScalarFieldEnum = (typeof Tablero_efectividadScalarFieldEnum)[keyof typeof Tablero_efectividadScalarFieldEnum]


  export const Tareas_sucursalesScalarFieldEnum: {
    idevents: 'idevents',
    title: 'title',
    allDay: 'allDay',
    start: 'start',
    end: 'end',
    priority: 'priority',
    sucursal: 'sucursal',
    operador: 'operador',
    leido: 'leido'
  };

  export type Tareas_sucursalesScalarFieldEnum = (typeof Tareas_sucursalesScalarFieldEnum)[keyof typeof Tareas_sucursalesScalarFieldEnum]


  export const Tipo_contratosScalarFieldEnum: {
    idtipocontrato: 'idtipocontrato',
    tipo_contrato: 'tipo_contrato',
    url: 'url'
  };

  export type Tipo_contratosScalarFieldEnum = (typeof Tipo_contratosScalarFieldEnum)[keyof typeof Tipo_contratosScalarFieldEnum]


  export const Tipo_facturasScalarFieldEnum: {
    idfactura: 'idfactura',
    tipo_factura: 'tipo_factura',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type Tipo_facturasScalarFieldEnum = (typeof Tipo_facturasScalarFieldEnum)[keyof typeof Tipo_facturasScalarFieldEnum]


  export const Turno_bajasScalarFieldEnum: {
    idturno: 'idturno',
    contrato: 'contrato',
    apellido: 'apellido',
    nombre: 'nombre',
    dni: 'dni',
    fecha_pedido: 'fecha_pedido',
    fecha_turno: 'fecha_turno',
    motivo: 'motivo',
    operador: 'operador',
    telefono: 'telefono',
    movil: 'movil',
    fecha_atencion: 'fecha_atencion',
    estado: 'estado',
    empresa: 'empresa',
    respuesta: 'respuesta',
    operador_atencion: 'operador_atencion',
    detalle: 'detalle'
  };

  export type Turno_bajasScalarFieldEnum = (typeof Turno_bajasScalarFieldEnum)[keyof typeof Turno_bajasScalarFieldEnum]


  export const VacacionesScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    allDay: 'allDay',
    priority: 'priority',
    title: 'title',
    user: 'user',
    detail: 'detail'
  };

  export type VacacionesScalarFieldEnum = (typeof VacacionesScalarFieldEnum)[keyof typeof VacacionesScalarFieldEnum]


  export const Motivos_atencionScalarFieldEnum: {
    idmotivo: 'idmotivo',
    motivo: 'motivo',
    estado: 'estado'
  };

  export type Motivos_atencionScalarFieldEnum = (typeof Motivos_atencionScalarFieldEnum)[keyof typeof Motivos_atencionScalarFieldEnum]


  export const Prestamos_plan_cuotasScalarFieldEnum: {
    idplan: 'idplan',
    plan_cuotas: 'plan_cuotas',
    detalle: 'detalle',
    estado: 'estado'
  };

  export type Prestamos_plan_cuotasScalarFieldEnum = (typeof Prestamos_plan_cuotasScalarFieldEnum)[keyof typeof Prestamos_plan_cuotasScalarFieldEnum]


  export const Prestamos_tasasScalarFieldEnum: {
    idtasa: 'idtasa',
    tasa: 'tasa',
    plan: 'plan',
    tipo: 'tipo',
    estado: 'estado'
  };

  export type Prestamos_tasasScalarFieldEnum = (typeof Prestamos_tasasScalarFieldEnum)[keyof typeof Prestamos_tasasScalarFieldEnum]


  export const Certificado_estudiantesScalarFieldEnum: {
    idcertificado: 'idcertificado',
    contrato: 'contrato',
    socio: 'socio',
    fecha: 'fecha',
    operador: 'operador',
    ncert: 'ncert'
  };

  export type Certificado_estudiantesScalarFieldEnum = (typeof Certificado_estudiantesScalarFieldEnum)[keyof typeof Certificado_estudiantesScalarFieldEnum]


  export const CarteraScalarFieldEnum: {
    contrato: 'contrato',
    socio: 'socio',
    alta: 'alta',
    grupo: 'grupo',
    adhs: 'adhs',
    plan: 'plan',
    sub_plan: 'sub_plan',
    zona: 'zona',
    cuota: 'cuota',
    empresa: 'empresa',
    sucursal: 'sucursal',
    deuda: 'deuda',
    mes: 'mes',
    ano: 'ano',
    idcartera: 'idcartera'
  };

  export type CarteraScalarFieldEnum = (typeof CarteraScalarFieldEnum)[keyof typeof CarteraScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type alta_novellWhereInput = {
    AND?: alta_novellWhereInput | alta_novellWhereInput[]
    OR?: alta_novellWhereInput[]
    NOT?: alta_novellWhereInput | alta_novellWhereInput[]
    idnovell?: IntFilter | number
    fecha_recepcion?: DateTimeNullableFilter | Date | string | null
    servicio?: StringNullableFilter | string | null
    monto?: IntNullableFilter | number | null
    monto_letra?: StringNullableFilter | string | null
    anticipo?: IntNullableFilter | number | null
    gastos_adm?: IntNullableFilter | number | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    estcivil_sol?: StringNullableFilter | string | null
    fecha_nac_sol?: DateTimeNullableFilter | Date | string | null
    dom_sol?: StringNullableFilter | string | null
    domnum_sol?: IntNullableFilter | number | null
    piso_sol?: StringNullableFilter | string | null
    barrio_sol?: StringNullableFilter | string | null
    localidad_sol?: StringNullableFilter | string | null
    codpostal_sol?: IntNullableFilter | number | null
    telefono_sol?: StringNullableFilter | string | null
    movil_sol?: StringNullableFilter | string | null
    apellido_ben?: StringNullableFilter | string | null
    nombre_ben?: StringNullableFilter | string | null
    dni_ben?: IntNullableFilter | number | null
    estcivil_ben?: StringNullableFilter | string | null
    fecha_nac_ben?: DateTimeNullableFilter | Date | string | null
    dom_ben?: StringNullableFilter | string | null
    domnum_ben?: IntNullableFilter | number | null
    piso_ben?: StringNullableFilter | string | null
    barrio_ben?: StringNullableFilter | string | null
    localidad_ben?: StringNullableFilter | string | null
    codpostal_ben?: IntNullableFilter | number | null
    telefono_ben?: StringNullableFilter | string | null
    movil_ben?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    cuotas?: IntNullableFilter | number | null
    nacionalidad_sol?: StringNullableFilter | string | null
    nacionalidad_ben?: StringNullableFilter | string | null
    anticipo_letra?: StringNullableFilter | string | null
    cuotasaldo?: IntNullableFilter | number | null
    cuotasaldo_letra?: StringNullableFilter | string | null
    cuota_mantenimiento?: IntNullableFilter | number | null
  }

  export type alta_novellOrderByWithRelationInput = {
    idnovell?: SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    servicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    monto_letra?: SortOrderInput | SortOrder
    anticipo?: SortOrderInput | SortOrder
    gastos_adm?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    estcivil_sol?: SortOrderInput | SortOrder
    fecha_nac_sol?: SortOrderInput | SortOrder
    dom_sol?: SortOrderInput | SortOrder
    domnum_sol?: SortOrderInput | SortOrder
    piso_sol?: SortOrderInput | SortOrder
    barrio_sol?: SortOrderInput | SortOrder
    localidad_sol?: SortOrderInput | SortOrder
    codpostal_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    movil_sol?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    dni_ben?: SortOrderInput | SortOrder
    estcivil_ben?: SortOrderInput | SortOrder
    fecha_nac_ben?: SortOrderInput | SortOrder
    dom_ben?: SortOrderInput | SortOrder
    domnum_ben?: SortOrderInput | SortOrder
    piso_ben?: SortOrderInput | SortOrder
    barrio_ben?: SortOrderInput | SortOrder
    localidad_ben?: SortOrderInput | SortOrder
    codpostal_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    movil_ben?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    nacionalidad_sol?: SortOrderInput | SortOrder
    nacionalidad_ben?: SortOrderInput | SortOrder
    anticipo_letra?: SortOrderInput | SortOrder
    cuotasaldo?: SortOrderInput | SortOrder
    cuotasaldo_letra?: SortOrderInput | SortOrder
    cuota_mantenimiento?: SortOrderInput | SortOrder
  }

  export type alta_novellWhereUniqueInput = {
    idnovell?: number
  }

  export type alta_novellOrderByWithAggregationInput = {
    idnovell?: SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    servicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    monto_letra?: SortOrderInput | SortOrder
    anticipo?: SortOrderInput | SortOrder
    gastos_adm?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    estcivil_sol?: SortOrderInput | SortOrder
    fecha_nac_sol?: SortOrderInput | SortOrder
    dom_sol?: SortOrderInput | SortOrder
    domnum_sol?: SortOrderInput | SortOrder
    piso_sol?: SortOrderInput | SortOrder
    barrio_sol?: SortOrderInput | SortOrder
    localidad_sol?: SortOrderInput | SortOrder
    codpostal_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    movil_sol?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    dni_ben?: SortOrderInput | SortOrder
    estcivil_ben?: SortOrderInput | SortOrder
    fecha_nac_ben?: SortOrderInput | SortOrder
    dom_ben?: SortOrderInput | SortOrder
    domnum_ben?: SortOrderInput | SortOrder
    piso_ben?: SortOrderInput | SortOrder
    barrio_ben?: SortOrderInput | SortOrder
    localidad_ben?: SortOrderInput | SortOrder
    codpostal_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    movil_ben?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    nacionalidad_sol?: SortOrderInput | SortOrder
    nacionalidad_ben?: SortOrderInput | SortOrder
    anticipo_letra?: SortOrderInput | SortOrder
    cuotasaldo?: SortOrderInput | SortOrder
    cuotasaldo_letra?: SortOrderInput | SortOrder
    cuota_mantenimiento?: SortOrderInput | SortOrder
    _count?: alta_novellCountOrderByAggregateInput
    _avg?: alta_novellAvgOrderByAggregateInput
    _max?: alta_novellMaxOrderByAggregateInput
    _min?: alta_novellMinOrderByAggregateInput
    _sum?: alta_novellSumOrderByAggregateInput
  }

  export type alta_novellScalarWhereWithAggregatesInput = {
    AND?: alta_novellScalarWhereWithAggregatesInput | alta_novellScalarWhereWithAggregatesInput[]
    OR?: alta_novellScalarWhereWithAggregatesInput[]
    NOT?: alta_novellScalarWhereWithAggregatesInput | alta_novellScalarWhereWithAggregatesInput[]
    idnovell?: IntWithAggregatesFilter | number
    fecha_recepcion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    servicio?: StringNullableWithAggregatesFilter | string | null
    monto?: IntNullableWithAggregatesFilter | number | null
    monto_letra?: StringNullableWithAggregatesFilter | string | null
    anticipo?: IntNullableWithAggregatesFilter | number | null
    gastos_adm?: IntNullableWithAggregatesFilter | number | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    estcivil_sol?: StringNullableWithAggregatesFilter | string | null
    fecha_nac_sol?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dom_sol?: StringNullableWithAggregatesFilter | string | null
    domnum_sol?: IntNullableWithAggregatesFilter | number | null
    piso_sol?: StringNullableWithAggregatesFilter | string | null
    barrio_sol?: StringNullableWithAggregatesFilter | string | null
    localidad_sol?: StringNullableWithAggregatesFilter | string | null
    codpostal_sol?: IntNullableWithAggregatesFilter | number | null
    telefono_sol?: StringNullableWithAggregatesFilter | string | null
    movil_sol?: StringNullableWithAggregatesFilter | string | null
    apellido_ben?: StringNullableWithAggregatesFilter | string | null
    nombre_ben?: StringNullableWithAggregatesFilter | string | null
    dni_ben?: IntNullableWithAggregatesFilter | number | null
    estcivil_ben?: StringNullableWithAggregatesFilter | string | null
    fecha_nac_ben?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dom_ben?: StringNullableWithAggregatesFilter | string | null
    domnum_ben?: IntNullableWithAggregatesFilter | number | null
    piso_ben?: StringNullableWithAggregatesFilter | string | null
    barrio_ben?: StringNullableWithAggregatesFilter | string | null
    localidad_ben?: StringNullableWithAggregatesFilter | string | null
    codpostal_ben?: IntNullableWithAggregatesFilter | number | null
    telefono_ben?: StringNullableWithAggregatesFilter | string | null
    movil_ben?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    cuotas?: IntNullableWithAggregatesFilter | number | null
    nacionalidad_sol?: StringNullableWithAggregatesFilter | string | null
    nacionalidad_ben?: StringNullableWithAggregatesFilter | string | null
    anticipo_letra?: StringNullableWithAggregatesFilter | string | null
    cuotasaldo?: IntNullableWithAggregatesFilter | number | null
    cuotasaldo_letra?: StringNullableWithAggregatesFilter | string | null
    cuota_mantenimiento?: IntNullableWithAggregatesFilter | number | null
  }

  export type caja_sucursalesWhereInput = {
    AND?: caja_sucursalesWhereInput | caja_sucursalesWhereInput[]
    OR?: caja_sucursalesWhereInput[]
    NOT?: caja_sucursalesWhereInput | caja_sucursalesWhereInput[]
    idcaja?: IntFilter | number
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    sucursal?: StringNullableFilter | string | null
    ingresos?: FloatNullableFilter | number | null
    egresos?: FloatNullableFilter | number | null
    saldo?: FloatNullableFilter | number | null
    operador_carga?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
  }

  export type caja_sucursalesOrderByWithRelationInput = {
    idcaja?: SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    ingresos?: SortOrderInput | SortOrder
    egresos?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
  }

  export type caja_sucursalesWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_sucursalesOrderByWithAggregationInput = {
    idcaja?: SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    ingresos?: SortOrderInput | SortOrder
    egresos?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    _count?: caja_sucursalesCountOrderByAggregateInput
    _avg?: caja_sucursalesAvgOrderByAggregateInput
    _max?: caja_sucursalesMaxOrderByAggregateInput
    _min?: caja_sucursalesMinOrderByAggregateInput
    _sum?: caja_sucursalesSumOrderByAggregateInput
  }

  export type caja_sucursalesScalarWhereWithAggregatesInput = {
    AND?: caja_sucursalesScalarWhereWithAggregatesInput | caja_sucursalesScalarWhereWithAggregatesInput[]
    OR?: caja_sucursalesScalarWhereWithAggregatesInput[]
    NOT?: caja_sucursalesScalarWhereWithAggregatesInput | caja_sucursalesScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    ingresos?: FloatNullableWithAggregatesFilter | number | null
    egresos?: FloatNullableWithAggregatesFilter | number | null
    saldo?: FloatNullableWithAggregatesFilter | number | null
    operador_carga?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type campanacasosWhereInput = {
    AND?: campanacasosWhereInput | campanacasosWhereInput[]
    OR?: campanacasosWhereInput[]
    NOT?: campanacasosWhereInput | campanacasosWhereInput[]
    idcaso?: IntFilter | number
    idcampana?: IntNullableFilter | number | null
    fechacampana?: DateTimeNullableFilter | Date | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    sucursal?: StringNullableFilter | string | null
    contrato?: IntNullableFilter | number | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    telefono?: StringNullableFilter | string | null
    movil?: StringNullableFilter | string | null
    calle?: StringNullableFilter | string | null
    nro_calle?: IntNullableFilter | number | null
    barrio?: StringNullableFilter | string | null
    localidad?: StringNullableFilter | string | null
    cuota?: IntNullableFilter | number | null
    cuotasadeudadas?: IntNullableFilter | number | null
    montoadeudado?: IntNullableFilter | number | null
    estadocaso?: BoolNullableFilter | boolean | null
    accion?: IntNullableFilter | number | null
    edad?: IntNullableFilter | number | null
    adherentes?: IntNullableFilter | number | null
    alta?: DateTimeNullableFilter | Date | string | null
    vigencia?: DateTimeNullableFilter | Date | string | null
  }

  export type campanacasosOrderByWithRelationInput = {
    idcaso?: SortOrder
    idcampana?: SortOrderInput | SortOrder
    fechacampana?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    calle?: SortOrderInput | SortOrder
    nro_calle?: SortOrderInput | SortOrder
    barrio?: SortOrderInput | SortOrder
    localidad?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    cuotasadeudadas?: SortOrderInput | SortOrder
    montoadeudado?: SortOrderInput | SortOrder
    estadocaso?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    adherentes?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
  }

  export type campanacasosWhereUniqueInput = {
    idcaso?: number
  }

  export type campanacasosOrderByWithAggregationInput = {
    idcaso?: SortOrder
    idcampana?: SortOrderInput | SortOrder
    fechacampana?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    calle?: SortOrderInput | SortOrder
    nro_calle?: SortOrderInput | SortOrder
    barrio?: SortOrderInput | SortOrder
    localidad?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    cuotasadeudadas?: SortOrderInput | SortOrder
    montoadeudado?: SortOrderInput | SortOrder
    estadocaso?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    adherentes?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    _count?: campanacasosCountOrderByAggregateInput
    _avg?: campanacasosAvgOrderByAggregateInput
    _max?: campanacasosMaxOrderByAggregateInput
    _min?: campanacasosMinOrderByAggregateInput
    _sum?: campanacasosSumOrderByAggregateInput
  }

  export type campanacasosScalarWhereWithAggregatesInput = {
    AND?: campanacasosScalarWhereWithAggregatesInput | campanacasosScalarWhereWithAggregatesInput[]
    OR?: campanacasosScalarWhereWithAggregatesInput[]
    NOT?: campanacasosScalarWhereWithAggregatesInput | campanacasosScalarWhereWithAggregatesInput[]
    idcaso?: IntWithAggregatesFilter | number
    idcampana?: IntNullableWithAggregatesFilter | number | null
    fechacampana?: DateTimeNullableWithAggregatesFilter | Date | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    telefono?: StringNullableWithAggregatesFilter | string | null
    movil?: StringNullableWithAggregatesFilter | string | null
    calle?: StringNullableWithAggregatesFilter | string | null
    nro_calle?: IntNullableWithAggregatesFilter | number | null
    barrio?: StringNullableWithAggregatesFilter | string | null
    localidad?: StringNullableWithAggregatesFilter | string | null
    cuota?: IntNullableWithAggregatesFilter | number | null
    cuotasadeudadas?: IntNullableWithAggregatesFilter | number | null
    montoadeudado?: IntNullableWithAggregatesFilter | number | null
    estadocaso?: BoolNullableWithAggregatesFilter | boolean | null
    accion?: IntNullableWithAggregatesFilter | number | null
    edad?: IntNullableWithAggregatesFilter | number | null
    adherentes?: IntNullableWithAggregatesFilter | number | null
    alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type campanasWhereInput = {
    AND?: campanasWhereInput | campanasWhereInput[]
    OR?: campanasWhereInput[]
    NOT?: campanasWhereInput | campanasWhereInput[]
    idcampana?: IntFilter | number
    descripcion?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
  }

  export type campanasOrderByWithRelationInput = {
    idcampana?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
  }

  export type campanasWhereUniqueInput = {
    idcampana?: number
  }

  export type campanasOrderByWithAggregationInput = {
    idcampana?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    _count?: campanasCountOrderByAggregateInput
    _avg?: campanasAvgOrderByAggregateInput
    _max?: campanasMaxOrderByAggregateInput
    _min?: campanasMinOrderByAggregateInput
    _sum?: campanasSumOrderByAggregateInput
  }

  export type campanasScalarWhereWithAggregatesInput = {
    AND?: campanasScalarWhereWithAggregatesInput | campanasScalarWhereWithAggregatesInput[]
    OR?: campanasScalarWhereWithAggregatesInput[]
    NOT?: campanasScalarWhereWithAggregatesInput | campanasScalarWhereWithAggregatesInput[]
    idcampana?: IntWithAggregatesFilter | number
    descripcion?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
  }

  export type campanatemporalWhereInput = {
    AND?: campanatemporalWhereInput | campanatemporalWhereInput[]
    OR?: campanatemporalWhereInput[]
    NOT?: campanatemporalWhereInput | campanatemporalWhereInput[]
    SUCURSAL?: StringNullableFilter | string | null
    CONTRATO?: IntFilter | number
    NRO_DOC?: IntNullableFilter | number | null
    APELLIDOS?: StringNullableFilter | string | null
    NOMBRES?: StringNullableFilter | string | null
    ALTA?: DateTimeNullableFilter | Date | string | null
    VIGENCIA?: DateTimeNullableFilter | Date | string | null
    CALLE?: StringNullableFilter | string | null
    NRO_CALLE?: IntNullableFilter | number | null
    BARRIO?: StringNullableFilter | string | null
    LOCALIDAD?: StringNullableFilter | string | null
    GRUPO?: IntNullableFilter | number | null
    ZONA?: IntNullableFilter | number | null
    TELEFONO?: StringNullableFilter | string | null
    MOVIL?: StringNullableFilter | string | null
    EDAD?: IntNullableFilter | number | null
    MES?: IntNullableFilter | number | null
    ANO?: IntNullableFilter | number | null
    IMPORTE?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    idcaso?: IntFilter | number
    observacion?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    fecha_observacion?: StringNullableFilter | string | null
    accion?: StringNullableFilter | string | null
  }

  export type campanatemporalOrderByWithRelationInput = {
    SUCURSAL?: SortOrderInput | SortOrder
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrderInput | SortOrder
    APELLIDOS?: SortOrderInput | SortOrder
    NOMBRES?: SortOrderInput | SortOrder
    ALTA?: SortOrderInput | SortOrder
    VIGENCIA?: SortOrderInput | SortOrder
    CALLE?: SortOrderInput | SortOrder
    NRO_CALLE?: SortOrderInput | SortOrder
    BARRIO?: SortOrderInput | SortOrder
    LOCALIDAD?: SortOrderInput | SortOrder
    GRUPO?: SortOrderInput | SortOrder
    ZONA?: SortOrderInput | SortOrder
    TELEFONO?: SortOrderInput | SortOrder
    MOVIL?: SortOrderInput | SortOrder
    EDAD?: SortOrderInput | SortOrder
    MES?: SortOrderInput | SortOrder
    ANO?: SortOrderInput | SortOrder
    IMPORTE?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idcaso?: SortOrder
    observacion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    fecha_observacion?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
  }

  export type campanatemporalWhereUniqueInput = {
    idcaso?: number
  }

  export type campanatemporalOrderByWithAggregationInput = {
    SUCURSAL?: SortOrderInput | SortOrder
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrderInput | SortOrder
    APELLIDOS?: SortOrderInput | SortOrder
    NOMBRES?: SortOrderInput | SortOrder
    ALTA?: SortOrderInput | SortOrder
    VIGENCIA?: SortOrderInput | SortOrder
    CALLE?: SortOrderInput | SortOrder
    NRO_CALLE?: SortOrderInput | SortOrder
    BARRIO?: SortOrderInput | SortOrder
    LOCALIDAD?: SortOrderInput | SortOrder
    GRUPO?: SortOrderInput | SortOrder
    ZONA?: SortOrderInput | SortOrder
    TELEFONO?: SortOrderInput | SortOrder
    MOVIL?: SortOrderInput | SortOrder
    EDAD?: SortOrderInput | SortOrder
    MES?: SortOrderInput | SortOrder
    ANO?: SortOrderInput | SortOrder
    IMPORTE?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idcaso?: SortOrder
    observacion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    fecha_observacion?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    _count?: campanatemporalCountOrderByAggregateInput
    _avg?: campanatemporalAvgOrderByAggregateInput
    _max?: campanatemporalMaxOrderByAggregateInput
    _min?: campanatemporalMinOrderByAggregateInput
    _sum?: campanatemporalSumOrderByAggregateInput
  }

  export type campanatemporalScalarWhereWithAggregatesInput = {
    AND?: campanatemporalScalarWhereWithAggregatesInput | campanatemporalScalarWhereWithAggregatesInput[]
    OR?: campanatemporalScalarWhereWithAggregatesInput[]
    NOT?: campanatemporalScalarWhereWithAggregatesInput | campanatemporalScalarWhereWithAggregatesInput[]
    SUCURSAL?: StringNullableWithAggregatesFilter | string | null
    CONTRATO?: IntWithAggregatesFilter | number
    NRO_DOC?: IntNullableWithAggregatesFilter | number | null
    APELLIDOS?: StringNullableWithAggregatesFilter | string | null
    NOMBRES?: StringNullableWithAggregatesFilter | string | null
    ALTA?: DateTimeNullableWithAggregatesFilter | Date | string | null
    VIGENCIA?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CALLE?: StringNullableWithAggregatesFilter | string | null
    NRO_CALLE?: IntNullableWithAggregatesFilter | number | null
    BARRIO?: StringNullableWithAggregatesFilter | string | null
    LOCALIDAD?: StringNullableWithAggregatesFilter | string | null
    GRUPO?: IntNullableWithAggregatesFilter | number | null
    ZONA?: IntNullableWithAggregatesFilter | number | null
    TELEFONO?: StringNullableWithAggregatesFilter | string | null
    MOVIL?: StringNullableWithAggregatesFilter | string | null
    EDAD?: IntNullableWithAggregatesFilter | number | null
    MES?: IntNullableWithAggregatesFilter | number | null
    ANO?: IntNullableWithAggregatesFilter | number | null
    IMPORTE?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    idcaso?: IntWithAggregatesFilter | number
    observacion?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    fecha_observacion?: StringNullableWithAggregatesFilter | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
  }

  export type capital_prestamoWhereInput = {
    AND?: capital_prestamoWhereInput | capital_prestamoWhereInput[]
    OR?: capital_prestamoWhereInput[]
    NOT?: capital_prestamoWhereInput | capital_prestamoWhereInput[]
    idcapital?: IntFilter | number
    capital?: FloatNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
    autorizacion?: BoolNullableFilter | boolean | null
  }

  export type capital_prestamoOrderByWithRelationInput = {
    idcapital?: SortOrder
    capital?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    autorizacion?: SortOrderInput | SortOrder
  }

  export type capital_prestamoWhereUniqueInput = {
    idcapital?: number
  }

  export type capital_prestamoOrderByWithAggregationInput = {
    idcapital?: SortOrder
    capital?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    autorizacion?: SortOrderInput | SortOrder
    _count?: capital_prestamoCountOrderByAggregateInput
    _avg?: capital_prestamoAvgOrderByAggregateInput
    _max?: capital_prestamoMaxOrderByAggregateInput
    _min?: capital_prestamoMinOrderByAggregateInput
    _sum?: capital_prestamoSumOrderByAggregateInput
  }

  export type capital_prestamoScalarWhereWithAggregatesInput = {
    AND?: capital_prestamoScalarWhereWithAggregatesInput | capital_prestamoScalarWhereWithAggregatesInput[]
    OR?: capital_prestamoScalarWhereWithAggregatesInput[]
    NOT?: capital_prestamoScalarWhereWithAggregatesInput | capital_prestamoScalarWhereWithAggregatesInput[]
    idcapital?: IntWithAggregatesFilter | number
    capital?: FloatNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    autorizacion?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type capital_prestamo_empleadosWhereInput = {
    AND?: capital_prestamo_empleadosWhereInput | capital_prestamo_empleadosWhereInput[]
    OR?: capital_prestamo_empleadosWhereInput[]
    NOT?: capital_prestamo_empleadosWhereInput | capital_prestamo_empleadosWhereInput[]
    idcapital?: IntFilter | number
    capital?: FloatNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
    autorizacion?: BoolNullableFilter | boolean | null
  }

  export type capital_prestamo_empleadosOrderByWithRelationInput = {
    idcapital?: SortOrder
    capital?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    autorizacion?: SortOrderInput | SortOrder
  }

  export type capital_prestamo_empleadosWhereUniqueInput = {
    idcapital?: number
  }

  export type capital_prestamo_empleadosOrderByWithAggregationInput = {
    idcapital?: SortOrder
    capital?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    autorizacion?: SortOrderInput | SortOrder
    _count?: capital_prestamo_empleadosCountOrderByAggregateInput
    _avg?: capital_prestamo_empleadosAvgOrderByAggregateInput
    _max?: capital_prestamo_empleadosMaxOrderByAggregateInput
    _min?: capital_prestamo_empleadosMinOrderByAggregateInput
    _sum?: capital_prestamo_empleadosSumOrderByAggregateInput
  }

  export type capital_prestamo_empleadosScalarWhereWithAggregatesInput = {
    AND?: capital_prestamo_empleadosScalarWhereWithAggregatesInput | capital_prestamo_empleadosScalarWhereWithAggregatesInput[]
    OR?: capital_prestamo_empleadosScalarWhereWithAggregatesInput[]
    NOT?: capital_prestamo_empleadosScalarWhereWithAggregatesInput | capital_prestamo_empleadosScalarWhereWithAggregatesInput[]
    idcapital?: IntWithAggregatesFilter | number
    capital?: FloatNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    autorizacion?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type categoria_obsequioWhereInput = {
    AND?: categoria_obsequioWhereInput | categoria_obsequioWhereInput[]
    OR?: categoria_obsequioWhereInput[]
    NOT?: categoria_obsequioWhereInput | categoria_obsequioWhereInput[]
    idcategoria?: IntFilter | number
    categoria?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type categoria_obsequioOrderByWithRelationInput = {
    idcategoria?: SortOrder
    categoria?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
  }

  export type categoria_obsequioWhereUniqueInput = {
    idcategoria?: number
  }

  export type categoria_obsequioOrderByWithAggregationInput = {
    idcategoria?: SortOrder
    categoria?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    _count?: categoria_obsequioCountOrderByAggregateInput
    _avg?: categoria_obsequioAvgOrderByAggregateInput
    _max?: categoria_obsequioMaxOrderByAggregateInput
    _min?: categoria_obsequioMinOrderByAggregateInput
    _sum?: categoria_obsequioSumOrderByAggregateInput
  }

  export type categoria_obsequioScalarWhereWithAggregatesInput = {
    AND?: categoria_obsequioScalarWhereWithAggregatesInput | categoria_obsequioScalarWhereWithAggregatesInput[]
    OR?: categoria_obsequioScalarWhereWithAggregatesInput[]
    NOT?: categoria_obsequioScalarWhereWithAggregatesInput | categoria_obsequioScalarWhereWithAggregatesInput[]
    idcategoria?: IntWithAggregatesFilter | number
    categoria?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type contratosWhereInput = {
    AND?: contratosWhereInput | contratosWhereInput[]
    OR?: contratosWhereInput[]
    NOT?: contratosWhereInput | contratosWhereInput[]
    idcontrato?: IntFilter | number
    locatario1?: StringNullableFilter | string | null
    dni1?: IntNullableFilter | number | null
    domicilio1?: StringNullableFilter | string | null
    locatario2?: StringNullableFilter | string | null
    dni2?: IntNullableFilter | number | null
    domicilio2?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    fecha_inicio?: DateTimeNullableFilter | Date | string | null
    duracion?: IntNullableFilter | number | null
    locador?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    local?: StringNullableFilter | string | null
    uf?: StringNullableFilter | string | null
  }

  export type contratosOrderByWithRelationInput = {
    idcontrato?: SortOrder
    locatario1?: SortOrderInput | SortOrder
    dni1?: SortOrderInput | SortOrder
    domicilio1?: SortOrderInput | SortOrder
    locatario2?: SortOrderInput | SortOrder
    dni2?: SortOrderInput | SortOrder
    domicilio2?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    locador?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    local?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
  }

  export type contratosWhereUniqueInput = {
    idcontrato?: number
  }

  export type contratosOrderByWithAggregationInput = {
    idcontrato?: SortOrder
    locatario1?: SortOrderInput | SortOrder
    dni1?: SortOrderInput | SortOrder
    domicilio1?: SortOrderInput | SortOrder
    locatario2?: SortOrderInput | SortOrder
    dni2?: SortOrderInput | SortOrder
    domicilio2?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    locador?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    local?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    _count?: contratosCountOrderByAggregateInput
    _avg?: contratosAvgOrderByAggregateInput
    _max?: contratosMaxOrderByAggregateInput
    _min?: contratosMinOrderByAggregateInput
    _sum?: contratosSumOrderByAggregateInput
  }

  export type contratosScalarWhereWithAggregatesInput = {
    AND?: contratosScalarWhereWithAggregatesInput | contratosScalarWhereWithAggregatesInput[]
    OR?: contratosScalarWhereWithAggregatesInput[]
    NOT?: contratosScalarWhereWithAggregatesInput | contratosScalarWhereWithAggregatesInput[]
    idcontrato?: IntWithAggregatesFilter | number
    locatario1?: StringNullableWithAggregatesFilter | string | null
    dni1?: IntNullableWithAggregatesFilter | number | null
    domicilio1?: StringNullableWithAggregatesFilter | string | null
    locatario2?: StringNullableWithAggregatesFilter | string | null
    dni2?: IntNullableWithAggregatesFilter | number | null
    domicilio2?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    fecha_inicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    duracion?: IntNullableWithAggregatesFilter | number | null
    locador?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    local?: StringNullableWithAggregatesFilter | string | null
    uf?: StringNullableWithAggregatesFilter | string | null
  }

  export type convenio_deudaWhereInput = {
    AND?: convenio_deudaWhereInput | convenio_deudaWhereInput[]
    OR?: convenio_deudaWhereInput[]
    NOT?: convenio_deudaWhereInput | convenio_deudaWhereInput[]
    idconvdeuda?: IntFilter | number
    contrato?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    vigencia?: DateTimeNullableFilter | Date | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    cuotas?: IntNullableFilter | number | null
    dni?: IntNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    idoperador?: IntNullableFilter | number | null
    vencimiento1?: DateTimeNullableFilter | Date | string | null
    importe1?: IntNullableFilter | number | null
    vencimiento2?: DateTimeNullableFilter | Date | string | null
    importe2?: IntNullableFilter | number | null
    deuda?: IntNullableFilter | number | null
    bonificacion?: IntNullableFilter | number | null
    saldo?: IntNullableFilter | number | null
  }

  export type convenio_deudaOrderByWithRelationInput = {
    idconvdeuda?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    idoperador?: SortOrderInput | SortOrder
    vencimiento1?: SortOrderInput | SortOrder
    importe1?: SortOrderInput | SortOrder
    vencimiento2?: SortOrderInput | SortOrder
    importe2?: SortOrderInput | SortOrder
    deuda?: SortOrderInput | SortOrder
    bonificacion?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
  }

  export type convenio_deudaWhereUniqueInput = {
    idconvdeuda?: number
  }

  export type convenio_deudaOrderByWithAggregationInput = {
    idconvdeuda?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    idoperador?: SortOrderInput | SortOrder
    vencimiento1?: SortOrderInput | SortOrder
    importe1?: SortOrderInput | SortOrder
    vencimiento2?: SortOrderInput | SortOrder
    importe2?: SortOrderInput | SortOrder
    deuda?: SortOrderInput | SortOrder
    bonificacion?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    _count?: convenio_deudaCountOrderByAggregateInput
    _avg?: convenio_deudaAvgOrderByAggregateInput
    _max?: convenio_deudaMaxOrderByAggregateInput
    _min?: convenio_deudaMinOrderByAggregateInput
    _sum?: convenio_deudaSumOrderByAggregateInput
  }

  export type convenio_deudaScalarWhereWithAggregatesInput = {
    AND?: convenio_deudaScalarWhereWithAggregatesInput | convenio_deudaScalarWhereWithAggregatesInput[]
    OR?: convenio_deudaScalarWhereWithAggregatesInput[]
    NOT?: convenio_deudaScalarWhereWithAggregatesInput | convenio_deudaScalarWhereWithAggregatesInput[]
    idconvdeuda?: IntWithAggregatesFilter | number
    contrato?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cuotas?: IntNullableWithAggregatesFilter | number | null
    dni?: IntNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    idoperador?: IntNullableWithAggregatesFilter | number | null
    vencimiento1?: DateTimeNullableWithAggregatesFilter | Date | string | null
    importe1?: IntNullableWithAggregatesFilter | number | null
    vencimiento2?: DateTimeNullableWithAggregatesFilter | Date | string | null
    importe2?: IntNullableWithAggregatesFilter | number | null
    deuda?: IntNullableWithAggregatesFilter | number | null
    bonificacion?: IntNullableWithAggregatesFilter | number | null
    saldo?: IntNullableWithAggregatesFilter | number | null
  }

  export type datosWhereInput = {
    AND?: datosWhereInput | datosWhereInput[]
    OR?: datosWhereInput[]
    NOT?: datosWhereInput | datosWhereInput[]
    iddato?: IntFilter | number
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    edad?: IntNullableFilter | number | null
    telefono?: BigIntNullableFilter | bigint | number | null
    celular?: IntNullableFilter | number | null
    cobertura?: StringNullableFilter | string | null
    grupo_familiar?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    domicilio?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
  }

  export type datosOrderByWithRelationInput = {
    iddato?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    grupo_familiar?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type datosWhereUniqueInput = {
    iddato?: number
  }

  export type datosOrderByWithAggregationInput = {
    iddato?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    grupo_familiar?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: datosCountOrderByAggregateInput
    _avg?: datosAvgOrderByAggregateInput
    _max?: datosMaxOrderByAggregateInput
    _min?: datosMinOrderByAggregateInput
    _sum?: datosSumOrderByAggregateInput
  }

  export type datosScalarWhereWithAggregatesInput = {
    AND?: datosScalarWhereWithAggregatesInput | datosScalarWhereWithAggregatesInput[]
    OR?: datosScalarWhereWithAggregatesInput[]
    NOT?: datosScalarWhereWithAggregatesInput | datosScalarWhereWithAggregatesInput[]
    iddato?: IntWithAggregatesFilter | number
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    edad?: IntNullableWithAggregatesFilter | number | null
    telefono?: BigIntNullableWithAggregatesFilter | bigint | number | null
    celular?: IntNullableWithAggregatesFilter | number | null
    cobertura?: StringNullableWithAggregatesFilter | string | null
    grupo_familiar?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    domicilio?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type datos_atencionWhereInput = {
    AND?: datos_atencionWhereInput | datos_atencionWhereInput[]
    OR?: datos_atencionWhereInput[]
    NOT?: datos_atencionWhereInput | datos_atencionWhereInput[]
    iddatos?: IntFilter | number
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    telefono?: IntNullableFilter | number | null
    parentezco?: StringNullableFilter | string | null
    motivo?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    operadoratencion?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
  }

  export type datos_atencionOrderByWithRelationInput = {
    iddatos?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    operadoratencion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type datos_atencionWhereUniqueInput = {
    iddatos?: number
  }

  export type datos_atencionOrderByWithAggregationInput = {
    iddatos?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    operadoratencion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: datos_atencionCountOrderByAggregateInput
    _avg?: datos_atencionAvgOrderByAggregateInput
    _max?: datos_atencionMaxOrderByAggregateInput
    _min?: datos_atencionMinOrderByAggregateInput
    _sum?: datos_atencionSumOrderByAggregateInput
  }

  export type datos_atencionScalarWhereWithAggregatesInput = {
    AND?: datos_atencionScalarWhereWithAggregatesInput | datos_atencionScalarWhereWithAggregatesInput[]
    OR?: datos_atencionScalarWhereWithAggregatesInput[]
    NOT?: datos_atencionScalarWhereWithAggregatesInput | datos_atencionScalarWhereWithAggregatesInput[]
    iddatos?: IntWithAggregatesFilter | number
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    operadoratencion?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type detalle_orden_pagoWhereInput = {
    AND?: detalle_orden_pagoWhereInput | detalle_orden_pagoWhereInput[]
    OR?: detalle_orden_pagoWhereInput[]
    NOT?: detalle_orden_pagoWhereInput | detalle_orden_pagoWhereInput[]
    iddetallepago?: IntFilter | number
    norden?: StringNullableFilter | string | null
    nconsulta?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
    prestador?: StringNullableFilter | string | null
    importe?: StringNullableFilter | string | null
    operador_carga?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
  }

  export type detalle_orden_pagoOrderByWithRelationInput = {
    iddetallepago?: SortOrder
    norden?: SortOrderInput | SortOrder
    nconsulta?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    prestador?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type detalle_orden_pagoWhereUniqueInput = {
    iddetallepago?: number
  }

  export type detalle_orden_pagoOrderByWithAggregationInput = {
    iddetallepago?: SortOrder
    norden?: SortOrderInput | SortOrder
    nconsulta?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    prestador?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: detalle_orden_pagoCountOrderByAggregateInput
    _avg?: detalle_orden_pagoAvgOrderByAggregateInput
    _max?: detalle_orden_pagoMaxOrderByAggregateInput
    _min?: detalle_orden_pagoMinOrderByAggregateInput
    _sum?: detalle_orden_pagoSumOrderByAggregateInput
  }

  export type detalle_orden_pagoScalarWhereWithAggregatesInput = {
    AND?: detalle_orden_pagoScalarWhereWithAggregatesInput | detalle_orden_pagoScalarWhereWithAggregatesInput[]
    OR?: detalle_orden_pagoScalarWhereWithAggregatesInput[]
    NOT?: detalle_orden_pagoScalarWhereWithAggregatesInput | detalle_orden_pagoScalarWhereWithAggregatesInput[]
    iddetallepago?: IntWithAggregatesFilter | number
    norden?: StringNullableWithAggregatesFilter | string | null
    nconsulta?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    prestador?: StringNullableWithAggregatesFilter | string | null
    importe?: StringNullableWithAggregatesFilter | string | null
    operador_carga?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type empresasWhereInput = {
    AND?: empresasWhereInput | empresasWhereInput[]
    OR?: empresasWhereInput[]
    NOT?: empresasWhereInput | empresasWhereInput[]
    idempresa?: IntFilter | number
    empresa?: StringNullableFilter | string | null
    cuit?: StringNullableFilter | string | null
  }

  export type empresasOrderByWithRelationInput = {
    idempresa?: SortOrder
    empresa?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
  }

  export type empresasWhereUniqueInput = {
    idempresa?: number
  }

  export type empresasOrderByWithAggregationInput = {
    idempresa?: SortOrder
    empresa?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    _count?: empresasCountOrderByAggregateInput
    _avg?: empresasAvgOrderByAggregateInput
    _max?: empresasMaxOrderByAggregateInput
    _min?: empresasMinOrderByAggregateInput
    _sum?: empresasSumOrderByAggregateInput
  }

  export type empresasScalarWhereWithAggregatesInput = {
    AND?: empresasScalarWhereWithAggregatesInput | empresasScalarWhereWithAggregatesInput[]
    OR?: empresasScalarWhereWithAggregatesInput[]
    NOT?: empresasScalarWhereWithAggregatesInput | empresasScalarWhereWithAggregatesInput[]
    idempresa?: IntWithAggregatesFilter | number
    empresa?: StringNullableWithAggregatesFilter | string | null
    cuit?: StringNullableWithAggregatesFilter | string | null
  }

  export type eventosWhereInput = {
    AND?: eventosWhereInput | eventosWhereInput[]
    OR?: eventosWhereInput[]
    NOT?: eventosWhereInput | eventosWhereInput[]
    idevents?: IntFilter | number
    title?: StringNullableFilter | string | null
    allDay?: IntNullableFilter | number | null
    start?: DateTimeNullableFilter | Date | string | null
    end?: DateTimeNullableFilter | Date | string | null
  }

  export type eventosOrderByWithRelationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
  }

  export type eventosWhereUniqueInput = {
    idevents?: number
  }

  export type eventosOrderByWithAggregationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    _count?: eventosCountOrderByAggregateInput
    _avg?: eventosAvgOrderByAggregateInput
    _max?: eventosMaxOrderByAggregateInput
    _min?: eventosMinOrderByAggregateInput
    _sum?: eventosSumOrderByAggregateInput
  }

  export type eventosScalarWhereWithAggregatesInput = {
    AND?: eventosScalarWhereWithAggregatesInput | eventosScalarWhereWithAggregatesInput[]
    OR?: eventosScalarWhereWithAggregatesInput[]
    NOT?: eventosScalarWhereWithAggregatesInput | eventosScalarWhereWithAggregatesInput[]
    idevents?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    start?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type fabricante_ataudWhereInput = {
    AND?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    OR?: fabricante_ataudWhereInput[]
    NOT?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    idfabricante?: IntFilter | number
    fabricante?: StringNullableFilter | string | null
  }

  export type fabricante_ataudOrderByWithRelationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
  }

  export type fabricante_ataudWhereUniqueInput = {
    idfabricante?: number
  }

  export type fabricante_ataudOrderByWithAggregationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
    _count?: fabricante_ataudCountOrderByAggregateInput
    _avg?: fabricante_ataudAvgOrderByAggregateInput
    _max?: fabricante_ataudMaxOrderByAggregateInput
    _min?: fabricante_ataudMinOrderByAggregateInput
    _sum?: fabricante_ataudSumOrderByAggregateInput
  }

  export type fabricante_ataudScalarWhereWithAggregatesInput = {
    AND?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    OR?: fabricante_ataudScalarWhereWithAggregatesInput[]
    NOT?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    idfabricante?: IntWithAggregatesFilter | number
    fabricante?: StringNullableWithAggregatesFilter | string | null
  }

  export type gestioncasoWhereInput = {
    AND?: gestioncasoWhereInput | gestioncasoWhereInput[]
    OR?: gestioncasoWhereInput[]
    NOT?: gestioncasoWhereInput | gestioncasoWhereInput[]
    idgestion?: IntFilter | number
    idcaso?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    accion?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
    fechaaccion?: StringNullableFilter | string | null
    nuevaaccion?: StringNullableFilter | string | null
    fechanuevaaccion?: StringNullableFilter | string | null
    realizado?: BoolNullableFilter | boolean | null
    observacion_nuevaaccion?: StringNullableFilter | string | null
  }

  export type gestioncasoOrderByWithRelationInput = {
    idgestion?: SortOrder
    idcaso?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    fechaaccion?: SortOrderInput | SortOrder
    nuevaaccion?: SortOrderInput | SortOrder
    fechanuevaaccion?: SortOrderInput | SortOrder
    realizado?: SortOrderInput | SortOrder
    observacion_nuevaaccion?: SortOrderInput | SortOrder
  }

  export type gestioncasoWhereUniqueInput = {
    idgestion?: number
  }

  export type gestioncasoOrderByWithAggregationInput = {
    idgestion?: SortOrder
    idcaso?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    fechaaccion?: SortOrderInput | SortOrder
    nuevaaccion?: SortOrderInput | SortOrder
    fechanuevaaccion?: SortOrderInput | SortOrder
    realizado?: SortOrderInput | SortOrder
    observacion_nuevaaccion?: SortOrderInput | SortOrder
    _count?: gestioncasoCountOrderByAggregateInput
    _avg?: gestioncasoAvgOrderByAggregateInput
    _max?: gestioncasoMaxOrderByAggregateInput
    _min?: gestioncasoMinOrderByAggregateInput
    _sum?: gestioncasoSumOrderByAggregateInput
  }

  export type gestioncasoScalarWhereWithAggregatesInput = {
    AND?: gestioncasoScalarWhereWithAggregatesInput | gestioncasoScalarWhereWithAggregatesInput[]
    OR?: gestioncasoScalarWhereWithAggregatesInput[]
    NOT?: gestioncasoScalarWhereWithAggregatesInput | gestioncasoScalarWhereWithAggregatesInput[]
    idgestion?: IntWithAggregatesFilter | number
    idcaso?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
    fechaaccion?: StringNullableWithAggregatesFilter | string | null
    nuevaaccion?: StringNullableWithAggregatesFilter | string | null
    fechanuevaaccion?: StringNullableWithAggregatesFilter | string | null
    realizado?: BoolNullableWithAggregatesFilter | boolean | null
    observacion_nuevaaccion?: StringNullableWithAggregatesFilter | string | null
  }

  export type historial_accionesWhereInput = {
    AND?: historial_accionesWhereInput | historial_accionesWhereInput[]
    OR?: historial_accionesWhereInput[]
    NOT?: historial_accionesWhereInput | historial_accionesWhereInput[]
    idhistorial?: IntFilter | number
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    accion?: StringNullableFilter | string | null
  }

  export type historial_accionesOrderByWithRelationInput = {
    idhistorial?: SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
  }

  export type historial_accionesWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_accionesOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    _count?: historial_accionesCountOrderByAggregateInput
    _avg?: historial_accionesAvgOrderByAggregateInput
    _max?: historial_accionesMaxOrderByAggregateInput
    _min?: historial_accionesMinOrderByAggregateInput
    _sum?: historial_accionesSumOrderByAggregateInput
  }

  export type historial_accionesScalarWhereWithAggregatesInput = {
    AND?: historial_accionesScalarWhereWithAggregatesInput | historial_accionesScalarWhereWithAggregatesInput[]
    OR?: historial_accionesScalarWhereWithAggregatesInput[]
    NOT?: historial_accionesScalarWhereWithAggregatesInput | historial_accionesScalarWhereWithAggregatesInput[]
    idhistorial?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
  }

  export type historial_aprobacion_prestamosWhereInput = {
    AND?: historial_aprobacion_prestamosWhereInput | historial_aprobacion_prestamosWhereInput[]
    OR?: historial_aprobacion_prestamosWhereInput[]
    NOT?: historial_aprobacion_prestamosWhereInput | historial_aprobacion_prestamosWhereInput[]
    idaprobacion?: IntFilter | number
    operador?: StringNullableFilter | string | null
    idprestamo?: IntNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    contrato?: IntNullableFilter | number | null
    afiliado?: StringNullableFilter | string | null
    productor?: IntNullableFilter | number | null
  }

  export type historial_aprobacion_prestamosOrderByWithRelationInput = {
    idaprobacion?: SortOrder
    operador?: SortOrderInput | SortOrder
    idprestamo?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    afiliado?: SortOrderInput | SortOrder
    productor?: SortOrderInput | SortOrder
  }

  export type historial_aprobacion_prestamosWhereUniqueInput = {
    idaprobacion?: number
  }

  export type historial_aprobacion_prestamosOrderByWithAggregationInput = {
    idaprobacion?: SortOrder
    operador?: SortOrderInput | SortOrder
    idprestamo?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    afiliado?: SortOrderInput | SortOrder
    productor?: SortOrderInput | SortOrder
    _count?: historial_aprobacion_prestamosCountOrderByAggregateInput
    _avg?: historial_aprobacion_prestamosAvgOrderByAggregateInput
    _max?: historial_aprobacion_prestamosMaxOrderByAggregateInput
    _min?: historial_aprobacion_prestamosMinOrderByAggregateInput
    _sum?: historial_aprobacion_prestamosSumOrderByAggregateInput
  }

  export type historial_aprobacion_prestamosScalarWhereWithAggregatesInput = {
    AND?: historial_aprobacion_prestamosScalarWhereWithAggregatesInput | historial_aprobacion_prestamosScalarWhereWithAggregatesInput[]
    OR?: historial_aprobacion_prestamosScalarWhereWithAggregatesInput[]
    NOT?: historial_aprobacion_prestamosScalarWhereWithAggregatesInput | historial_aprobacion_prestamosScalarWhereWithAggregatesInput[]
    idaprobacion?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    idprestamo?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    afiliado?: StringNullableWithAggregatesFilter | string | null
    productor?: IntNullableWithAggregatesFilter | number | null
  }

  export type historial_liquidacionesWhereInput = {
    AND?: historial_liquidacionesWhereInput | historial_liquidacionesWhereInput[]
    OR?: historial_liquidacionesWhereInput[]
    NOT?: historial_liquidacionesWhereInput | historial_liquidacionesWhereInput[]
    idliquidacion?: IntFilter | number
    operador?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    cobranza?: FloatNullableFilter | number | null
    total?: FloatNullableFilter | number | null
    comision?: FloatNullableFilter | number | null
    entidad?: StringNullableFilter | string | null
  }

  export type historial_liquidacionesOrderByWithRelationInput = {
    idliquidacion?: SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    cobranza?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    entidad?: SortOrderInput | SortOrder
  }

  export type historial_liquidacionesWhereUniqueInput = {
    idliquidacion?: number
  }

  export type historial_liquidacionesOrderByWithAggregationInput = {
    idliquidacion?: SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    cobranza?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    entidad?: SortOrderInput | SortOrder
    _count?: historial_liquidacionesCountOrderByAggregateInput
    _avg?: historial_liquidacionesAvgOrderByAggregateInput
    _max?: historial_liquidacionesMaxOrderByAggregateInput
    _min?: historial_liquidacionesMinOrderByAggregateInput
    _sum?: historial_liquidacionesSumOrderByAggregateInput
  }

  export type historial_liquidacionesScalarWhereWithAggregatesInput = {
    AND?: historial_liquidacionesScalarWhereWithAggregatesInput | historial_liquidacionesScalarWhereWithAggregatesInput[]
    OR?: historial_liquidacionesScalarWhereWithAggregatesInput[]
    NOT?: historial_liquidacionesScalarWhereWithAggregatesInput | historial_liquidacionesScalarWhereWithAggregatesInput[]
    idliquidacion?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    cobranza?: FloatNullableWithAggregatesFilter | number | null
    total?: FloatNullableWithAggregatesFilter | number | null
    comision?: FloatNullableWithAggregatesFilter | number | null
    entidad?: StringNullableWithAggregatesFilter | string | null
  }

  export type intereses_tarjetasWhereInput = {
    AND?: intereses_tarjetasWhereInput | intereses_tarjetasWhereInput[]
    OR?: intereses_tarjetasWhereInput[]
    NOT?: intereses_tarjetasWhereInput | intereses_tarjetasWhereInput[]
    idplan?: IntFilter | number
    plan_cuota?: IntNullableFilter | number | null
    interes?: FloatNullableFilter | number | null
    tarjeta?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type intereses_tarjetasOrderByWithRelationInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    tarjeta?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type intereses_tarjetasWhereUniqueInput = {
    idplan?: number
  }

  export type intereses_tarjetasOrderByWithAggregationInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    interes?: SortOrderInput | SortOrder
    tarjeta?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: intereses_tarjetasCountOrderByAggregateInput
    _avg?: intereses_tarjetasAvgOrderByAggregateInput
    _max?: intereses_tarjetasMaxOrderByAggregateInput
    _min?: intereses_tarjetasMinOrderByAggregateInput
    _sum?: intereses_tarjetasSumOrderByAggregateInput
  }

  export type intereses_tarjetasScalarWhereWithAggregatesInput = {
    AND?: intereses_tarjetasScalarWhereWithAggregatesInput | intereses_tarjetasScalarWhereWithAggregatesInput[]
    OR?: intereses_tarjetasScalarWhereWithAggregatesInput[]
    NOT?: intereses_tarjetasScalarWhereWithAggregatesInput | intereses_tarjetasScalarWhereWithAggregatesInput[]
    idplan?: IntWithAggregatesFilter | number
    plan_cuota?: IntNullableWithAggregatesFilter | number | null
    interes?: FloatNullableWithAggregatesFilter | number | null
    tarjeta?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type legajo_virtualWhereInput = {
    AND?: legajo_virtualWhereInput | legajo_virtualWhereInput[]
    OR?: legajo_virtualWhereInput[]
    NOT?: legajo_virtualWhereInput | legajo_virtualWhereInput[]
    idlegajo?: IntFilter | number
    contrato?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
    tipoarchivo?: StringNullableFilter | string | null
  }

  export type legajo_virtualOrderByWithRelationInput = {
    idlegajo?: SortOrder
    contrato?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipoarchivo?: SortOrderInput | SortOrder
  }

  export type legajo_virtualWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtualOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    contrato?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipoarchivo?: SortOrderInput | SortOrder
    _count?: legajo_virtualCountOrderByAggregateInput
    _avg?: legajo_virtualAvgOrderByAggregateInput
    _max?: legajo_virtualMaxOrderByAggregateInput
    _min?: legajo_virtualMinOrderByAggregateInput
    _sum?: legajo_virtualSumOrderByAggregateInput
  }

  export type legajo_virtualScalarWhereWithAggregatesInput = {
    AND?: legajo_virtualScalarWhereWithAggregatesInput | legajo_virtualScalarWhereWithAggregatesInput[]
    OR?: legajo_virtualScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtualScalarWhereWithAggregatesInput | legajo_virtualScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    contrato?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    tipoarchivo?: StringNullableWithAggregatesFilter | string | null
  }

  export type legajo_virtual_cajasWhereInput = {
    AND?: legajo_virtual_cajasWhereInput | legajo_virtual_cajasWhereInput[]
    OR?: legajo_virtual_cajasWhereInput[]
    NOT?: legajo_virtual_cajasWhereInput | legajo_virtual_cajasWhereInput[]
    idlegajo?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
  }

  export type legajo_virtual_cajasOrderByWithRelationInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_cajasWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_cajasOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    _count?: legajo_virtual_cajasCountOrderByAggregateInput
    _avg?: legajo_virtual_cajasAvgOrderByAggregateInput
    _max?: legajo_virtual_cajasMaxOrderByAggregateInput
    _min?: legajo_virtual_cajasMinOrderByAggregateInput
    _sum?: legajo_virtual_cajasSumOrderByAggregateInput
  }

  export type legajo_virtual_cajasScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_cajasScalarWhereWithAggregatesInput | legajo_virtual_cajasScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_cajasScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_cajasScalarWhereWithAggregatesInput | legajo_virtual_cajasScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type legajo_virtual_ordenesWhereInput = {
    AND?: legajo_virtual_ordenesWhereInput | legajo_virtual_ordenesWhereInput[]
    OR?: legajo_virtual_ordenesWhereInput[]
    NOT?: legajo_virtual_ordenesWhereInput | legajo_virtual_ordenesWhereInput[]
    idlegajo?: IntFilter | number
    idorden?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
  }

  export type legajo_virtual_ordenesOrderByWithRelationInput = {
    idlegajo?: SortOrder
    idorden?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_ordenesWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_ordenesOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    idorden?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    _count?: legajo_virtual_ordenesCountOrderByAggregateInput
    _avg?: legajo_virtual_ordenesAvgOrderByAggregateInput
    _max?: legajo_virtual_ordenesMaxOrderByAggregateInput
    _min?: legajo_virtual_ordenesMinOrderByAggregateInput
    _sum?: legajo_virtual_ordenesSumOrderByAggregateInput
  }

  export type legajo_virtual_ordenesScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_ordenesScalarWhereWithAggregatesInput | legajo_virtual_ordenesScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_ordenesScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_ordenesScalarWhereWithAggregatesInput | legajo_virtual_ordenesScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    idorden?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type legajo_virtual_personalWhereInput = {
    AND?: legajo_virtual_personalWhereInput | legajo_virtual_personalWhereInput[]
    OR?: legajo_virtual_personalWhereInput[]
    NOT?: legajo_virtual_personalWhereInput | legajo_virtual_personalWhereInput[]
    idlegajo?: IntFilter | number
    idpersonal?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
  }

  export type legajo_virtual_personalOrderByWithRelationInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_personalWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_personalOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    _count?: legajo_virtual_personalCountOrderByAggregateInput
    _avg?: legajo_virtual_personalAvgOrderByAggregateInput
    _max?: legajo_virtual_personalMaxOrderByAggregateInput
    _min?: legajo_virtual_personalMinOrderByAggregateInput
    _sum?: legajo_virtual_personalSumOrderByAggregateInput
  }

  export type legajo_virtual_personalScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_personalScalarWhereWithAggregatesInput | legajo_virtual_personalScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_personalScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_personalScalarWhereWithAggregatesInput | legajo_virtual_personalScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    idpersonal?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type legajo_virtual_prestamosWhereInput = {
    AND?: legajo_virtual_prestamosWhereInput | legajo_virtual_prestamosWhereInput[]
    OR?: legajo_virtual_prestamosWhereInput[]
    NOT?: legajo_virtual_prestamosWhereInput | legajo_virtual_prestamosWhereInput[]
    idlegajo?: IntFilter | number
    contrato?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
    cod_ptm_leg?: StringNullableFilter | string | null
  }

  export type legajo_virtual_prestamosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    contrato?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    cod_ptm_leg?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_prestamosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_prestamosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    contrato?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    cod_ptm_leg?: SortOrderInput | SortOrder
    _count?: legajo_virtual_prestamosCountOrderByAggregateInput
    _avg?: legajo_virtual_prestamosAvgOrderByAggregateInput
    _max?: legajo_virtual_prestamosMaxOrderByAggregateInput
    _min?: legajo_virtual_prestamosMinOrderByAggregateInput
    _sum?: legajo_virtual_prestamosSumOrderByAggregateInput
  }

  export type legajo_virtual_prestamosScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_prestamosScalarWhereWithAggregatesInput | legajo_virtual_prestamosScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_prestamosScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_prestamosScalarWhereWithAggregatesInput | legajo_virtual_prestamosScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    contrato?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    cod_ptm_leg?: StringNullableWithAggregatesFilter | string | null
  }

  export type locadorWhereInput = {
    AND?: locadorWhereInput | locadorWhereInput[]
    OR?: locadorWhereInput[]
    NOT?: locadorWhereInput | locadorWhereInput[]
    dni?: IntFilter | number
    apellido?: StringFilter | string
    nombre?: StringFilter | string
    domicilio?: StringFilter | string
    barrio?: StringNullableFilter | string | null
    localidad?: StringFilter | string
    provincia?: StringFilter | string
  }

  export type locadorOrderByWithRelationInput = {
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrderInput | SortOrder
    localidad?: SortOrder
    provincia?: SortOrder
  }

  export type locadorWhereUniqueInput = {
    dni?: number
  }

  export type locadorOrderByWithAggregationInput = {
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrderInput | SortOrder
    localidad?: SortOrder
    provincia?: SortOrder
    _count?: locadorCountOrderByAggregateInput
    _avg?: locadorAvgOrderByAggregateInput
    _max?: locadorMaxOrderByAggregateInput
    _min?: locadorMinOrderByAggregateInput
    _sum?: locadorSumOrderByAggregateInput
  }

  export type locadorScalarWhereWithAggregatesInput = {
    AND?: locadorScalarWhereWithAggregatesInput | locadorScalarWhereWithAggregatesInput[]
    OR?: locadorScalarWhereWithAggregatesInput[]
    NOT?: locadorScalarWhereWithAggregatesInput | locadorScalarWhereWithAggregatesInput[]
    dni?: IntWithAggregatesFilter | number
    apellido?: StringWithAggregatesFilter | string
    nombre?: StringWithAggregatesFilter | string
    domicilio?: StringWithAggregatesFilter | string
    barrio?: StringNullableWithAggregatesFilter | string | null
    localidad?: StringWithAggregatesFilter | string
    provincia?: StringWithAggregatesFilter | string
  }

  export type mailsWhereInput = {
    AND?: mailsWhereInput | mailsWhereInput[]
    OR?: mailsWhereInput[]
    NOT?: mailsWhereInput | mailsWhereInput[]
    idmail?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    envia?: StringNullableFilter | string | null
    recibe?: StringNullableFilter | string | null
    descrip?: StringNullableFilter | string | null
    codmail?: StringNullableFilter | string | null
    asunto?: StringNullableFilter | string | null
    leido?: BoolNullableFilter | boolean | null
    fecha_leido?: DateTimeNullableFilter | Date | string | null
    url_caja?: StringNullableFilter | string | null
  }

  export type mailsOrderByWithRelationInput = {
    idmail?: SortOrder
    fecha?: SortOrderInput | SortOrder
    envia?: SortOrderInput | SortOrder
    recibe?: SortOrderInput | SortOrder
    descrip?: SortOrderInput | SortOrder
    codmail?: SortOrderInput | SortOrder
    asunto?: SortOrderInput | SortOrder
    leido?: SortOrderInput | SortOrder
    fecha_leido?: SortOrderInput | SortOrder
    url_caja?: SortOrderInput | SortOrder
  }

  export type mailsWhereUniqueInput = {
    idmail?: number
  }

  export type mailsOrderByWithAggregationInput = {
    idmail?: SortOrder
    fecha?: SortOrderInput | SortOrder
    envia?: SortOrderInput | SortOrder
    recibe?: SortOrderInput | SortOrder
    descrip?: SortOrderInput | SortOrder
    codmail?: SortOrderInput | SortOrder
    asunto?: SortOrderInput | SortOrder
    leido?: SortOrderInput | SortOrder
    fecha_leido?: SortOrderInput | SortOrder
    url_caja?: SortOrderInput | SortOrder
    _count?: mailsCountOrderByAggregateInput
    _avg?: mailsAvgOrderByAggregateInput
    _max?: mailsMaxOrderByAggregateInput
    _min?: mailsMinOrderByAggregateInput
    _sum?: mailsSumOrderByAggregateInput
  }

  export type mailsScalarWhereWithAggregatesInput = {
    AND?: mailsScalarWhereWithAggregatesInput | mailsScalarWhereWithAggregatesInput[]
    OR?: mailsScalarWhereWithAggregatesInput[]
    NOT?: mailsScalarWhereWithAggregatesInput | mailsScalarWhereWithAggregatesInput[]
    idmail?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    envia?: StringNullableWithAggregatesFilter | string | null
    recibe?: StringNullableWithAggregatesFilter | string | null
    descrip?: StringNullableWithAggregatesFilter | string | null
    codmail?: StringNullableWithAggregatesFilter | string | null
    asunto?: StringNullableWithAggregatesFilter | string | null
    leido?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_leido?: DateTimeNullableWithAggregatesFilter | Date | string | null
    url_caja?: StringNullableWithAggregatesFilter | string | null
  }

  export type mails_adjuntosWhereInput = {
    AND?: mails_adjuntosWhereInput | mails_adjuntosWhereInput[]
    OR?: mails_adjuntosWhereInput[]
    NOT?: mails_adjuntosWhereInput | mails_adjuntosWhereInput[]
    idadjunto?: IntFilter | number
    codmail?: StringNullableFilter | string | null
    adjunto?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
  }

  export type mails_adjuntosOrderByWithRelationInput = {
    idadjunto?: SortOrder
    codmail?: SortOrderInput | SortOrder
    adjunto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type mails_adjuntosWhereUniqueInput = {
    idadjunto?: number
  }

  export type mails_adjuntosOrderByWithAggregationInput = {
    idadjunto?: SortOrder
    codmail?: SortOrderInput | SortOrder
    adjunto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: mails_adjuntosCountOrderByAggregateInput
    _avg?: mails_adjuntosAvgOrderByAggregateInput
    _max?: mails_adjuntosMaxOrderByAggregateInput
    _min?: mails_adjuntosMinOrderByAggregateInput
    _sum?: mails_adjuntosSumOrderByAggregateInput
  }

  export type mails_adjuntosScalarWhereWithAggregatesInput = {
    AND?: mails_adjuntosScalarWhereWithAggregatesInput | mails_adjuntosScalarWhereWithAggregatesInput[]
    OR?: mails_adjuntosScalarWhereWithAggregatesInput[]
    NOT?: mails_adjuntosScalarWhereWithAggregatesInput | mails_adjuntosScalarWhereWithAggregatesInput[]
    idadjunto?: IntWithAggregatesFilter | number
    codmail?: StringNullableWithAggregatesFilter | string | null
    adjunto?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type mbanconvWhereInput = {
    AND?: mbanconvWhereInput | mbanconvWhereInput[]
    OR?: mbanconvWhereInput[]
    NOT?: mbanconvWhereInput | mbanconvWhereInput[]
    id_mora?: IntFilter | number
    tipo?: StringNullableFilter | string | null
    mora?: IntNullableFilter | number | null
    fichas?: IntNullableFilter | number | null
    morarec?: IntNullableFilter | number | null
    fichasrec?: IntNullableFilter | number | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
  }

  export type mbanconvOrderByWithRelationInput = {
    id_mora?: SortOrder
    tipo?: SortOrderInput | SortOrder
    mora?: SortOrderInput | SortOrder
    fichas?: SortOrderInput | SortOrder
    morarec?: SortOrderInput | SortOrder
    fichasrec?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
  }

  export type mbanconvWhereUniqueInput = {
    id_mora?: number
  }

  export type mbanconvOrderByWithAggregationInput = {
    id_mora?: SortOrder
    tipo?: SortOrderInput | SortOrder
    mora?: SortOrderInput | SortOrder
    fichas?: SortOrderInput | SortOrder
    morarec?: SortOrderInput | SortOrder
    fichasrec?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    _count?: mbanconvCountOrderByAggregateInput
    _avg?: mbanconvAvgOrderByAggregateInput
    _max?: mbanconvMaxOrderByAggregateInput
    _min?: mbanconvMinOrderByAggregateInput
    _sum?: mbanconvSumOrderByAggregateInput
  }

  export type mbanconvScalarWhereWithAggregatesInput = {
    AND?: mbanconvScalarWhereWithAggregatesInput | mbanconvScalarWhereWithAggregatesInput[]
    OR?: mbanconvScalarWhereWithAggregatesInput[]
    NOT?: mbanconvScalarWhereWithAggregatesInput | mbanconvScalarWhereWithAggregatesInput[]
    id_mora?: IntWithAggregatesFilter | number
    tipo?: StringNullableWithAggregatesFilter | string | null
    mora?: IntNullableWithAggregatesFilter | number | null
    fichas?: IntNullableWithAggregatesFilter | number | null
    morarec?: IntNullableWithAggregatesFilter | number | null
    fichasrec?: IntNullableWithAggregatesFilter | number | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
  }

  export type movimiento_caja_sucursalesWhereInput = {
    AND?: movimiento_caja_sucursalesWhereInput | movimiento_caja_sucursalesWhereInput[]
    OR?: movimiento_caja_sucursalesWhereInput[]
    NOT?: movimiento_caja_sucursalesWhereInput | movimiento_caja_sucursalesWhereInput[]
    idmovimiento?: IntFilter | number
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    fecha_movimiento?: DateTimeNullableFilter | Date | string | null
    sucursal?: StringNullableFilter | string | null
    concepto?: StringNullableFilter | string | null
    movimiento?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
    operador_carga?: StringNullableFilter | string | null
    idcaja?: IntNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
  }

  export type movimiento_caja_sucursalesOrderByWithRelationInput = {
    idmovimiento?: SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    movimiento?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    idcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
  }

  export type movimiento_caja_sucursalesWhereUniqueInput = {
    idmovimiento?: number
  }

  export type movimiento_caja_sucursalesOrderByWithAggregationInput = {
    idmovimiento?: SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    fecha_movimiento?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    movimiento?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    idcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    _count?: movimiento_caja_sucursalesCountOrderByAggregateInput
    _avg?: movimiento_caja_sucursalesAvgOrderByAggregateInput
    _max?: movimiento_caja_sucursalesMaxOrderByAggregateInput
    _min?: movimiento_caja_sucursalesMinOrderByAggregateInput
    _sum?: movimiento_caja_sucursalesSumOrderByAggregateInput
  }

  export type movimiento_caja_sucursalesScalarWhereWithAggregatesInput = {
    AND?: movimiento_caja_sucursalesScalarWhereWithAggregatesInput | movimiento_caja_sucursalesScalarWhereWithAggregatesInput[]
    OR?: movimiento_caja_sucursalesScalarWhereWithAggregatesInput[]
    NOT?: movimiento_caja_sucursalesScalarWhereWithAggregatesInput | movimiento_caja_sucursalesScalarWhereWithAggregatesInput[]
    idmovimiento?: IntWithAggregatesFilter | number
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha_movimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    movimiento?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    operador_carga?: StringNullableWithAggregatesFilter | string | null
    idcaja?: IntNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type noticiaWhereInput = {
    AND?: noticiaWhereInput | noticiaWhereInput[]
    OR?: noticiaWhereInput[]
    NOT?: noticiaWhereInput | noticiaWhereInput[]
    idnoticia?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    noticia?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    perfil?: IntNullableFilter | number | null
  }

  export type noticiaOrderByWithRelationInput = {
    idnoticia?: SortOrder
    fecha?: SortOrderInput | SortOrder
    noticia?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    perfil?: SortOrderInput | SortOrder
  }

  export type noticiaWhereUniqueInput = {
    idnoticia?: number
  }

  export type noticiaOrderByWithAggregationInput = {
    idnoticia?: SortOrder
    fecha?: SortOrderInput | SortOrder
    noticia?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    perfil?: SortOrderInput | SortOrder
    _count?: noticiaCountOrderByAggregateInput
    _avg?: noticiaAvgOrderByAggregateInput
    _max?: noticiaMaxOrderByAggregateInput
    _min?: noticiaMinOrderByAggregateInput
    _sum?: noticiaSumOrderByAggregateInput
  }

  export type noticiaScalarWhereWithAggregatesInput = {
    AND?: noticiaScalarWhereWithAggregatesInput | noticiaScalarWhereWithAggregatesInput[]
    OR?: noticiaScalarWhereWithAggregatesInput[]
    NOT?: noticiaScalarWhereWithAggregatesInput | noticiaScalarWhereWithAggregatesInput[]
    idnoticia?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    noticia?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    perfil?: IntNullableWithAggregatesFilter | number | null
  }

  export type novedadesWhereInput = {
    AND?: novedadesWhereInput | novedadesWhereInput[]
    OR?: novedadesWhereInput[]
    NOT?: novedadesWhereInput | novedadesWhereInput[]
    idnovedades?: IntFilter | number
    novedad?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type novedadesOrderByWithRelationInput = {
    idnovedades?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type novedadesWhereUniqueInput = {
    idnovedades?: number
  }

  export type novedadesOrderByWithAggregationInput = {
    idnovedades?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: novedadesCountOrderByAggregateInput
    _avg?: novedadesAvgOrderByAggregateInput
    _max?: novedadesMaxOrderByAggregateInput
    _min?: novedadesMinOrderByAggregateInput
    _sum?: novedadesSumOrderByAggregateInput
  }

  export type novedadesScalarWhereWithAggregatesInput = {
    AND?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    OR?: novedadesScalarWhereWithAggregatesInput[]
    NOT?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    idnovedades?: IntWithAggregatesFilter | number
    novedad?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type obsequiosWhereInput = {
    AND?: obsequiosWhereInput | obsequiosWhereInput[]
    OR?: obsequiosWhereInput[]
    NOT?: obsequiosWhereInput | obsequiosWhereInput[]
    idobsequio?: IntFilter | number
    producto?: StringNullableFilter | string | null
    marca?: StringNullableFilter | string | null
    categoria?: StringNullableFilter | string | null
    precio?: FloatNullableFilter | number | null
    stock?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
    fecha_reposicion?: StringNullableFilter | string | null
    operador_rep?: StringNullableFilter | string | null
  }

  export type obsequiosOrderByWithRelationInput = {
    idobsequio?: SortOrder
    producto?: SortOrderInput | SortOrder
    marca?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    operador_rep?: SortOrderInput | SortOrder
  }

  export type obsequiosWhereUniqueInput = {
    idobsequio?: number
  }

  export type obsequiosOrderByWithAggregationInput = {
    idobsequio?: SortOrder
    producto?: SortOrderInput | SortOrder
    marca?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    operador_rep?: SortOrderInput | SortOrder
    _count?: obsequiosCountOrderByAggregateInput
    _avg?: obsequiosAvgOrderByAggregateInput
    _max?: obsequiosMaxOrderByAggregateInput
    _min?: obsequiosMinOrderByAggregateInput
    _sum?: obsequiosSumOrderByAggregateInput
  }

  export type obsequiosScalarWhereWithAggregatesInput = {
    AND?: obsequiosScalarWhereWithAggregatesInput | obsequiosScalarWhereWithAggregatesInput[]
    OR?: obsequiosScalarWhereWithAggregatesInput[]
    NOT?: obsequiosScalarWhereWithAggregatesInput | obsequiosScalarWhereWithAggregatesInput[]
    idobsequio?: IntWithAggregatesFilter | number
    producto?: StringNullableWithAggregatesFilter | string | null
    marca?: StringNullableWithAggregatesFilter | string | null
    categoria?: StringNullableWithAggregatesFilter | string | null
    precio?: FloatNullableWithAggregatesFilter | number | null
    stock?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
    fecha_reposicion?: StringNullableWithAggregatesFilter | string | null
    operador_rep?: StringNullableWithAggregatesFilter | string | null
  }

  export type openia_keysWhereInput = {
    AND?: openia_keysWhereInput | openia_keysWhereInput[]
    OR?: openia_keysWhereInput[]
    NOT?: openia_keysWhereInput | openia_keysWhereInput[]
    idkey?: IntFilter | number
    key?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type openia_keysOrderByWithRelationInput = {
    idkey?: SortOrder
    key?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type openia_keysWhereUniqueInput = {
    idkey?: number
  }

  export type openia_keysOrderByWithAggregationInput = {
    idkey?: SortOrder
    key?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: openia_keysCountOrderByAggregateInput
    _avg?: openia_keysAvgOrderByAggregateInput
    _max?: openia_keysMaxOrderByAggregateInput
    _min?: openia_keysMinOrderByAggregateInput
    _sum?: openia_keysSumOrderByAggregateInput
  }

  export type openia_keysScalarWhereWithAggregatesInput = {
    AND?: openia_keysScalarWhereWithAggregatesInput | openia_keysScalarWhereWithAggregatesInput[]
    OR?: openia_keysScalarWhereWithAggregatesInput[]
    NOT?: openia_keysScalarWhereWithAggregatesInput | openia_keysScalarWhereWithAggregatesInput[]
    idkey?: IntWithAggregatesFilter | number
    key?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type operadorWhereInput = {
    AND?: operadorWhereInput | operadorWhereInput[]
    OR?: operadorWhereInput[]
    NOT?: operadorWhereInput | operadorWhereInput[]
    id?: IntFilter | number
    nombre?: StringFilter | string
    apellido?: StringFilter | string
    usuario?: StringFilter | string
    contrasena?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    puestom?: IntNullableFilter | number | null
    perfil?: IntNullableFilter | number | null
    estado?: BoolNullableFilter | boolean | null
    puestow?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    medicos?: BoolNullableFilter | boolean | null
    sucursal?: StringNullableFilter | string | null
    prestamos?: BoolNullableFilter | boolean | null
    ordenpago?: BoolNullableFilter | boolean | null
    clubwerchow?: BoolNullableFilter | boolean | null
    ventas?: BoolNullableFilter | boolean | null
    administracion?: BoolNullableFilter | boolean | null
    campanas?: BoolNullableFilter | boolean | null
    socios?: BoolNullableFilter | boolean | null
    sepelio?: BoolNullableFilter | boolean | null
  }

  export type operadorOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    puestom?: SortOrderInput | SortOrder
    perfil?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    puestow?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    medicos?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    prestamos?: SortOrderInput | SortOrder
    ordenpago?: SortOrderInput | SortOrder
    clubwerchow?: SortOrderInput | SortOrder
    ventas?: SortOrderInput | SortOrder
    administracion?: SortOrderInput | SortOrder
    campanas?: SortOrderInput | SortOrder
    socios?: SortOrderInput | SortOrder
    sepelio?: SortOrderInput | SortOrder
  }

  export type operadorWhereUniqueInput = {
    id?: number
  }

  export type operadorOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    puestom?: SortOrderInput | SortOrder
    perfil?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    puestow?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    medicos?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    prestamos?: SortOrderInput | SortOrder
    ordenpago?: SortOrderInput | SortOrder
    clubwerchow?: SortOrderInput | SortOrder
    ventas?: SortOrderInput | SortOrder
    administracion?: SortOrderInput | SortOrder
    campanas?: SortOrderInput | SortOrder
    socios?: SortOrderInput | SortOrder
    sepelio?: SortOrderInput | SortOrder
    _count?: operadorCountOrderByAggregateInput
    _avg?: operadorAvgOrderByAggregateInput
    _max?: operadorMaxOrderByAggregateInput
    _min?: operadorMinOrderByAggregateInput
    _sum?: operadorSumOrderByAggregateInput
  }

  export type operadorScalarWhereWithAggregatesInput = {
    AND?: operadorScalarWhereWithAggregatesInput | operadorScalarWhereWithAggregatesInput[]
    OR?: operadorScalarWhereWithAggregatesInput[]
    NOT?: operadorScalarWhereWithAggregatesInput | operadorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    apellido?: StringWithAggregatesFilter | string
    usuario?: StringWithAggregatesFilter | string
    contrasena?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    puestom?: IntNullableWithAggregatesFilter | number | null
    perfil?: IntNullableWithAggregatesFilter | number | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    puestow?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    medicos?: BoolNullableWithAggregatesFilter | boolean | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    prestamos?: BoolNullableWithAggregatesFilter | boolean | null
    ordenpago?: BoolNullableWithAggregatesFilter | boolean | null
    clubwerchow?: BoolNullableWithAggregatesFilter | boolean | null
    ventas?: BoolNullableWithAggregatesFilter | boolean | null
    administracion?: BoolNullableWithAggregatesFilter | boolean | null
    campanas?: BoolNullableWithAggregatesFilter | boolean | null
    socios?: BoolNullableWithAggregatesFilter | boolean | null
    sepelio?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ordenes_pagoWhereInput = {
    AND?: ordenes_pagoWhereInput | ordenes_pagoWhereInput[]
    OR?: ordenes_pagoWhereInput[]
    NOT?: ordenes_pagoWhereInput | ordenes_pagoWhereInput[]
    idorden?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    proveedor?: StringNullableFilter | string | null
    cuit_cuil?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    operador_carga?: StringNullableFilter | string | null
    autorizado?: BoolNullableFilter | boolean | null
    operador_autorizacion?: StringNullableFilter | string | null
    fecha_autorizacion?: DateTimeNullableFilter | Date | string | null
    norden?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    tipo_orden?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    tipo_factura?: StringNullableFilter | string | null
    fecha_pago?: DateTimeNullableFilter | Date | string | null
    pagado?: BoolNullableFilter | boolean | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type ordenes_pagoOrderByWithRelationInput = {
    idorden?: SortOrder
    fecha?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    cuit_cuil?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    autorizado?: SortOrderInput | SortOrder
    operador_autorizacion?: SortOrderInput | SortOrder
    fecha_autorizacion?: SortOrderInput | SortOrder
    norden?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo_orden?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    tipo_factura?: SortOrderInput | SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    pagado?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type ordenes_pagoWhereUniqueInput = {
    idorden?: number
  }

  export type ordenes_pagoOrderByWithAggregationInput = {
    idorden?: SortOrder
    fecha?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    cuit_cuil?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    operador_carga?: SortOrderInput | SortOrder
    autorizado?: SortOrderInput | SortOrder
    operador_autorizacion?: SortOrderInput | SortOrder
    fecha_autorizacion?: SortOrderInput | SortOrder
    norden?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo_orden?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    tipo_factura?: SortOrderInput | SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    pagado?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: ordenes_pagoCountOrderByAggregateInput
    _avg?: ordenes_pagoAvgOrderByAggregateInput
    _max?: ordenes_pagoMaxOrderByAggregateInput
    _min?: ordenes_pagoMinOrderByAggregateInput
    _sum?: ordenes_pagoSumOrderByAggregateInput
  }

  export type ordenes_pagoScalarWhereWithAggregatesInput = {
    AND?: ordenes_pagoScalarWhereWithAggregatesInput | ordenes_pagoScalarWhereWithAggregatesInput[]
    OR?: ordenes_pagoScalarWhereWithAggregatesInput[]
    NOT?: ordenes_pagoScalarWhereWithAggregatesInput | ordenes_pagoScalarWhereWithAggregatesInput[]
    idorden?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    cuit_cuil?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    operador_carga?: StringNullableWithAggregatesFilter | string | null
    autorizado?: BoolNullableWithAggregatesFilter | boolean | null
    operador_autorizacion?: StringNullableWithAggregatesFilter | string | null
    fecha_autorizacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    norden?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    tipo_orden?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    tipo_factura?: StringNullableWithAggregatesFilter | string | null
    fecha_pago?: DateTimeNullableWithAggregatesFilter | Date | string | null
    pagado?: BoolNullableWithAggregatesFilter | boolean | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type personalWhereInput = {
    AND?: personalWhereInput | personalWhereInput[]
    OR?: personalWhereInput[]
    NOT?: personalWhereInput | personalWhereInput[]
    idpersonal?: IntFilter | number
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    alta?: DateTimeNullableFilter | Date | string | null
    rol?: StringNullableFilter | string | null
    legajo?: StringNullableFilter | string | null
    baja?: DateTimeNullableFilter | Date | string | null
  }

  export type personalOrderByWithRelationInput = {
    idpersonal?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    rol?: SortOrderInput | SortOrder
    legajo?: SortOrderInput | SortOrder
    baja?: SortOrderInput | SortOrder
  }

  export type personalWhereUniqueInput = {
    idpersonal?: number
  }

  export type personalOrderByWithAggregationInput = {
    idpersonal?: SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    rol?: SortOrderInput | SortOrder
    legajo?: SortOrderInput | SortOrder
    baja?: SortOrderInput | SortOrder
    _count?: personalCountOrderByAggregateInput
    _avg?: personalAvgOrderByAggregateInput
    _max?: personalMaxOrderByAggregateInput
    _min?: personalMinOrderByAggregateInput
    _sum?: personalSumOrderByAggregateInput
  }

  export type personalScalarWhereWithAggregatesInput = {
    AND?: personalScalarWhereWithAggregatesInput | personalScalarWhereWithAggregatesInput[]
    OR?: personalScalarWhereWithAggregatesInput[]
    NOT?: personalScalarWhereWithAggregatesInput | personalScalarWhereWithAggregatesInput[]
    idpersonal?: IntWithAggregatesFilter | number
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    rol?: StringNullableWithAggregatesFilter | string | null
    legajo?: StringNullableWithAggregatesFilter | string | null
    baja?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type plan_cuentasWhereInput = {
    AND?: plan_cuentasWhereInput | plan_cuentasWhereInput[]
    OR?: plan_cuentasWhereInput[]
    NOT?: plan_cuentasWhereInput | plan_cuentasWhereInput[]
    idcuenta?: IntFilter | number
    idempresa?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    asiento?: IntNullableFilter | number | null
    tipo?: StringNullableFilter | string | null
  }

  export type plan_cuentasOrderByWithRelationInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    asiento?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type plan_cuentasWhereUniqueInput = {
    idcuenta?: number
  }

  export type plan_cuentasOrderByWithAggregationInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    asiento?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: plan_cuentasCountOrderByAggregateInput
    _avg?: plan_cuentasAvgOrderByAggregateInput
    _max?: plan_cuentasMaxOrderByAggregateInput
    _min?: plan_cuentasMinOrderByAggregateInput
    _sum?: plan_cuentasSumOrderByAggregateInput
  }

  export type plan_cuentasScalarWhereWithAggregatesInput = {
    AND?: plan_cuentasScalarWhereWithAggregatesInput | plan_cuentasScalarWhereWithAggregatesInput[]
    OR?: plan_cuentasScalarWhereWithAggregatesInput[]
    NOT?: plan_cuentasScalarWhereWithAggregatesInput | plan_cuentasScalarWhereWithAggregatesInput[]
    idcuenta?: IntWithAggregatesFilter | number
    idempresa?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    asiento?: IntNullableWithAggregatesFilter | number | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type plan_cuentas_xWhereInput = {
    AND?: plan_cuentas_xWhereInput | plan_cuentas_xWhereInput[]
    OR?: plan_cuentas_xWhereInput[]
    NOT?: plan_cuentas_xWhereInput | plan_cuentas_xWhereInput[]
    idcuenta?: IntFilter | number
    idempresa?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    descripcion?: StringNullableFilter | string | null
    asiento?: IntNullableFilter | number | null
    tipo?: StringNullableFilter | string | null
  }

  export type plan_cuentas_xOrderByWithRelationInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    asiento?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type plan_cuentas_xWhereUniqueInput = {
    idcuenta?: number
  }

  export type plan_cuentas_xOrderByWithAggregationInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    asiento?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: plan_cuentas_xCountOrderByAggregateInput
    _avg?: plan_cuentas_xAvgOrderByAggregateInput
    _max?: plan_cuentas_xMaxOrderByAggregateInput
    _min?: plan_cuentas_xMinOrderByAggregateInput
    _sum?: plan_cuentas_xSumOrderByAggregateInput
  }

  export type plan_cuentas_xScalarWhereWithAggregatesInput = {
    AND?: plan_cuentas_xScalarWhereWithAggregatesInput | plan_cuentas_xScalarWhereWithAggregatesInput[]
    OR?: plan_cuentas_xScalarWhereWithAggregatesInput[]
    NOT?: plan_cuentas_xScalarWhereWithAggregatesInput | plan_cuentas_xScalarWhereWithAggregatesInput[]
    idcuenta?: IntWithAggregatesFilter | number
    idempresa?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    asiento?: IntNullableWithAggregatesFilter | number | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type plan_detalleWhereInput = {
    AND?: plan_detalleWhereInput | plan_detalleWhereInput[]
    OR?: plan_detalleWhereInput[]
    NOT?: plan_detalleWhereInput | plan_detalleWhereInput[]
    id_plandetalle?: IntFilter | number
    detalle?: StringNullableFilter | string | null
    cuota?: IntNullableFilter | number | null
    sub_ext?: BoolNullableFilter | boolean | null
    vigencia?: StringNullableFilter | string | null
    id_plan?: IntNullableFilter | number | null
  }

  export type plan_detalleOrderByWithRelationInput = {
    id_plandetalle?: SortOrder
    detalle?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    sub_ext?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    id_plan?: SortOrderInput | SortOrder
  }

  export type plan_detalleWhereUniqueInput = {
    id_plandetalle?: number
  }

  export type plan_detalleOrderByWithAggregationInput = {
    id_plandetalle?: SortOrder
    detalle?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    sub_ext?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    id_plan?: SortOrderInput | SortOrder
    _count?: plan_detalleCountOrderByAggregateInput
    _avg?: plan_detalleAvgOrderByAggregateInput
    _max?: plan_detalleMaxOrderByAggregateInput
    _min?: plan_detalleMinOrderByAggregateInput
    _sum?: plan_detalleSumOrderByAggregateInput
  }

  export type plan_detalleScalarWhereWithAggregatesInput = {
    AND?: plan_detalleScalarWhereWithAggregatesInput | plan_detalleScalarWhereWithAggregatesInput[]
    OR?: plan_detalleScalarWhereWithAggregatesInput[]
    NOT?: plan_detalleScalarWhereWithAggregatesInput | plan_detalleScalarWhereWithAggregatesInput[]
    id_plandetalle?: IntWithAggregatesFilter | number
    detalle?: StringNullableWithAggregatesFilter | string | null
    cuota?: IntNullableWithAggregatesFilter | number | null
    sub_ext?: BoolNullableWithAggregatesFilter | boolean | null
    vigencia?: StringNullableWithAggregatesFilter | string | null
    id_plan?: IntNullableWithAggregatesFilter | number | null
  }

  export type plan_precioWhereInput = {
    AND?: plan_precioWhereInput | plan_precioWhereInput[]
    OR?: plan_precioWhereInput[]
    NOT?: plan_precioWhereInput | plan_precioWhereInput[]
    id_plan?: IntFilter | number
    plan?: StringNullableFilter | string | null
    tipo_plan?: StringNullableFilter | string | null
    codigo?: StringNullableFilter | string | null
  }

  export type plan_precioOrderByWithRelationInput = {
    id_plan?: SortOrder
    plan?: SortOrderInput | SortOrder
    tipo_plan?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
  }

  export type plan_precioWhereUniqueInput = {
    id_plan?: number
  }

  export type plan_precioOrderByWithAggregationInput = {
    id_plan?: SortOrder
    plan?: SortOrderInput | SortOrder
    tipo_plan?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    _count?: plan_precioCountOrderByAggregateInput
    _avg?: plan_precioAvgOrderByAggregateInput
    _max?: plan_precioMaxOrderByAggregateInput
    _min?: plan_precioMinOrderByAggregateInput
    _sum?: plan_precioSumOrderByAggregateInput
  }

  export type plan_precioScalarWhereWithAggregatesInput = {
    AND?: plan_precioScalarWhereWithAggregatesInput | plan_precioScalarWhereWithAggregatesInput[]
    OR?: plan_precioScalarWhereWithAggregatesInput[]
    NOT?: plan_precioScalarWhereWithAggregatesInput | plan_precioScalarWhereWithAggregatesInput[]
    id_plan?: IntWithAggregatesFilter | number
    plan?: StringNullableWithAggregatesFilter | string | null
    tipo_plan?: StringNullableWithAggregatesFilter | string | null
    codigo?: StringNullableWithAggregatesFilter | string | null
  }

  export type porcentaje_liqWhereInput = {
    AND?: porcentaje_liqWhereInput | porcentaje_liqWhereInput[]
    OR?: porcentaje_liqWhereInput[]
    NOT?: porcentaje_liqWhereInput | porcentaje_liqWhereInput[]
    porcliq_id?: IntFilter | number
    porcliq_nombre?: StringNullableFilter | string | null
    porcliq_descrip?: StringNullableFilter | string | null
    porcliq_cuotas?: IntNullableFilter | number | null
    porcliq_porcentaje?: IntNullableFilter | number | null
  }

  export type porcentaje_liqOrderByWithRelationInput = {
    porcliq_id?: SortOrder
    porcliq_nombre?: SortOrderInput | SortOrder
    porcliq_descrip?: SortOrderInput | SortOrder
    porcliq_cuotas?: SortOrderInput | SortOrder
    porcliq_porcentaje?: SortOrderInput | SortOrder
  }

  export type porcentaje_liqWhereUniqueInput = {
    porcliq_id?: number
  }

  export type porcentaje_liqOrderByWithAggregationInput = {
    porcliq_id?: SortOrder
    porcliq_nombre?: SortOrderInput | SortOrder
    porcliq_descrip?: SortOrderInput | SortOrder
    porcliq_cuotas?: SortOrderInput | SortOrder
    porcliq_porcentaje?: SortOrderInput | SortOrder
    _count?: porcentaje_liqCountOrderByAggregateInput
    _avg?: porcentaje_liqAvgOrderByAggregateInput
    _max?: porcentaje_liqMaxOrderByAggregateInput
    _min?: porcentaje_liqMinOrderByAggregateInput
    _sum?: porcentaje_liqSumOrderByAggregateInput
  }

  export type porcentaje_liqScalarWhereWithAggregatesInput = {
    AND?: porcentaje_liqScalarWhereWithAggregatesInput | porcentaje_liqScalarWhereWithAggregatesInput[]
    OR?: porcentaje_liqScalarWhereWithAggregatesInput[]
    NOT?: porcentaje_liqScalarWhereWithAggregatesInput | porcentaje_liqScalarWhereWithAggregatesInput[]
    porcliq_id?: IntWithAggregatesFilter | number
    porcliq_nombre?: StringNullableWithAggregatesFilter | string | null
    porcliq_descrip?: StringNullableWithAggregatesFilter | string | null
    porcliq_cuotas?: IntNullableWithAggregatesFilter | number | null
    porcliq_porcentaje?: IntNullableWithAggregatesFilter | number | null
  }

  export type prestamos_empleadosWhereInput = {
    AND?: prestamos_empleadosWhereInput | prestamos_empleadosWhereInput[]
    OR?: prestamos_empleadosWhereInput[]
    NOT?: prestamos_empleadosWhereInput | prestamos_empleadosWhereInput[]
    idprestamo?: IntFilter | number
    empleado?: StringNullableFilter | string | null
    fecha_solicitud?: DateTimeNullableFilter | Date | string | null
    capital?: FloatNullableFilter | number | null
    plan_cuotas?: IntNullableFilter | number | null
    cuota_mensual?: FloatNullableFilter | number | null
    capital_dev?: FloatNullableFilter | number | null
    inicia?: StringNullableFilter | string | null
    termina?: StringNullableFilter | string | null
    estado?: StringNullableFilter | string | null
    capinoaut?: BoolNullableFilter | boolean | null
  }

  export type prestamos_empleadosOrderByWithRelationInput = {
    idprestamo?: SortOrder
    empleado?: SortOrderInput | SortOrder
    fecha_solicitud?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    plan_cuotas?: SortOrderInput | SortOrder
    cuota_mensual?: SortOrderInput | SortOrder
    capital_dev?: SortOrderInput | SortOrder
    inicia?: SortOrderInput | SortOrder
    termina?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    capinoaut?: SortOrderInput | SortOrder
  }

  export type prestamos_empleadosWhereUniqueInput = {
    idprestamo?: number
  }

  export type prestamos_empleadosOrderByWithAggregationInput = {
    idprestamo?: SortOrder
    empleado?: SortOrderInput | SortOrder
    fecha_solicitud?: SortOrderInput | SortOrder
    capital?: SortOrderInput | SortOrder
    plan_cuotas?: SortOrderInput | SortOrder
    cuota_mensual?: SortOrderInput | SortOrder
    capital_dev?: SortOrderInput | SortOrder
    inicia?: SortOrderInput | SortOrder
    termina?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    capinoaut?: SortOrderInput | SortOrder
    _count?: prestamos_empleadosCountOrderByAggregateInput
    _avg?: prestamos_empleadosAvgOrderByAggregateInput
    _max?: prestamos_empleadosMaxOrderByAggregateInput
    _min?: prestamos_empleadosMinOrderByAggregateInput
    _sum?: prestamos_empleadosSumOrderByAggregateInput
  }

  export type prestamos_empleadosScalarWhereWithAggregatesInput = {
    AND?: prestamos_empleadosScalarWhereWithAggregatesInput | prestamos_empleadosScalarWhereWithAggregatesInput[]
    OR?: prestamos_empleadosScalarWhereWithAggregatesInput[]
    NOT?: prestamos_empleadosScalarWhereWithAggregatesInput | prestamos_empleadosScalarWhereWithAggregatesInput[]
    idprestamo?: IntWithAggregatesFilter | number
    empleado?: StringNullableWithAggregatesFilter | string | null
    fecha_solicitud?: DateTimeNullableWithAggregatesFilter | Date | string | null
    capital?: FloatNullableWithAggregatesFilter | number | null
    plan_cuotas?: IntNullableWithAggregatesFilter | number | null
    cuota_mensual?: FloatNullableWithAggregatesFilter | number | null
    capital_dev?: FloatNullableWithAggregatesFilter | number | null
    inicia?: StringNullableWithAggregatesFilter | string | null
    termina?: StringNullableWithAggregatesFilter | string | null
    estado?: StringNullableWithAggregatesFilter | string | null
    capinoaut?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type prestamos_empleados_cobroWhereInput = {
    AND?: prestamos_empleados_cobroWhereInput | prestamos_empleados_cobroWhereInput[]
    OR?: prestamos_empleados_cobroWhereInput[]
    NOT?: prestamos_empleados_cobroWhereInput | prestamos_empleados_cobroWhereInput[]
    idpago?: IntFilter | number
    idprestamo?: IntNullableFilter | number | null
    cuota?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    fecha_cobro?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
    fecha_pago?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type prestamos_empleados_cobroOrderByWithRelationInput = {
    idpago?: SortOrder
    idprestamo?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    fecha_cobro?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type prestamos_empleados_cobroWhereUniqueInput = {
    idpago?: number
  }

  export type prestamos_empleados_cobroOrderByWithAggregationInput = {
    idpago?: SortOrder
    idprestamo?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    fecha_cobro?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: prestamos_empleados_cobroCountOrderByAggregateInput
    _avg?: prestamos_empleados_cobroAvgOrderByAggregateInput
    _max?: prestamos_empleados_cobroMaxOrderByAggregateInput
    _min?: prestamos_empleados_cobroMinOrderByAggregateInput
    _sum?: prestamos_empleados_cobroSumOrderByAggregateInput
  }

  export type prestamos_empleados_cobroScalarWhereWithAggregatesInput = {
    AND?: prestamos_empleados_cobroScalarWhereWithAggregatesInput | prestamos_empleados_cobroScalarWhereWithAggregatesInput[]
    OR?: prestamos_empleados_cobroScalarWhereWithAggregatesInput[]
    NOT?: prestamos_empleados_cobroScalarWhereWithAggregatesInput | prestamos_empleados_cobroScalarWhereWithAggregatesInput[]
    idpago?: IntWithAggregatesFilter | number
    idprestamo?: IntNullableWithAggregatesFilter | number | null
    cuota?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    fecha_cobro?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_pago?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type produccionWhereInput = {
    AND?: produccionWhereInput | produccionWhereInput[]
    OR?: produccionWhereInput[]
    NOT?: produccionWhereInput | produccionWhereInput[]
    prod_ide?: IntFilter | number
    prod_fechacarga?: DateTimeNullableFilter | Date | string | null
    prod_fechaafi?: DateTimeNullableFilter | Date | string | null
    prod_asesor?: IntNullableFilter | number | null
    prod_empre?: StringNullableFilter | string | null
    prod_mes?: StringNullableFilter | string | null
    prod_anio?: IntNullableFilter | number | null
    prod_apeafi?: StringNullableFilter | string | null
    prod_nomafi?: StringNullableFilter | string | null
    prod_dniafi?: IntNullableFilter | number | null
    prod_local?: IntNullableFilter | number | null
    prod_recibo?: IntNullableFilter | number | null
    prod_monto?: FloatNullableFilter | number | null
    prod_plan?: StringNullableFilter | string | null
    prod_pago?: StringNullableFilter | string | null
    prod_cta_tar?: BigIntNullableFilter | bigint | number | null
    prod_obs?: StringNullableFilter | string | null
    prod_semana?: IntNullableFilter | number | null
    prod_estado?: StringNullableFilter | string | null
    prod_cierre?: IntNullableFilter | number | null
    prod_afiliado?: IntNullableFilter | number | null
    prod_rendido?: StringNullableFilter | string | null
    prod_recibosis?: IntNullableFilter | number | null
    prod_fechren?: DateTimeNullableFilter | Date | string | null
    prod_tel?: StringNullableFilter | string | null
  }

  export type produccionOrderByWithRelationInput = {
    prod_ide?: SortOrder
    prod_fechacarga?: SortOrderInput | SortOrder
    prod_fechaafi?: SortOrderInput | SortOrder
    prod_asesor?: SortOrderInput | SortOrder
    prod_empre?: SortOrderInput | SortOrder
    prod_mes?: SortOrderInput | SortOrder
    prod_anio?: SortOrderInput | SortOrder
    prod_apeafi?: SortOrderInput | SortOrder
    prod_nomafi?: SortOrderInput | SortOrder
    prod_dniafi?: SortOrderInput | SortOrder
    prod_local?: SortOrderInput | SortOrder
    prod_recibo?: SortOrderInput | SortOrder
    prod_monto?: SortOrderInput | SortOrder
    prod_plan?: SortOrderInput | SortOrder
    prod_pago?: SortOrderInput | SortOrder
    prod_cta_tar?: SortOrderInput | SortOrder
    prod_obs?: SortOrderInput | SortOrder
    prod_semana?: SortOrderInput | SortOrder
    prod_estado?: SortOrderInput | SortOrder
    prod_cierre?: SortOrderInput | SortOrder
    prod_afiliado?: SortOrderInput | SortOrder
    prod_rendido?: SortOrderInput | SortOrder
    prod_recibosis?: SortOrderInput | SortOrder
    prod_fechren?: SortOrderInput | SortOrder
    prod_tel?: SortOrderInput | SortOrder
  }

  export type produccionWhereUniqueInput = {
    prod_ide?: number
  }

  export type produccionOrderByWithAggregationInput = {
    prod_ide?: SortOrder
    prod_fechacarga?: SortOrderInput | SortOrder
    prod_fechaafi?: SortOrderInput | SortOrder
    prod_asesor?: SortOrderInput | SortOrder
    prod_empre?: SortOrderInput | SortOrder
    prod_mes?: SortOrderInput | SortOrder
    prod_anio?: SortOrderInput | SortOrder
    prod_apeafi?: SortOrderInput | SortOrder
    prod_nomafi?: SortOrderInput | SortOrder
    prod_dniafi?: SortOrderInput | SortOrder
    prod_local?: SortOrderInput | SortOrder
    prod_recibo?: SortOrderInput | SortOrder
    prod_monto?: SortOrderInput | SortOrder
    prod_plan?: SortOrderInput | SortOrder
    prod_pago?: SortOrderInput | SortOrder
    prod_cta_tar?: SortOrderInput | SortOrder
    prod_obs?: SortOrderInput | SortOrder
    prod_semana?: SortOrderInput | SortOrder
    prod_estado?: SortOrderInput | SortOrder
    prod_cierre?: SortOrderInput | SortOrder
    prod_afiliado?: SortOrderInput | SortOrder
    prod_rendido?: SortOrderInput | SortOrder
    prod_recibosis?: SortOrderInput | SortOrder
    prod_fechren?: SortOrderInput | SortOrder
    prod_tel?: SortOrderInput | SortOrder
    _count?: produccionCountOrderByAggregateInput
    _avg?: produccionAvgOrderByAggregateInput
    _max?: produccionMaxOrderByAggregateInput
    _min?: produccionMinOrderByAggregateInput
    _sum?: produccionSumOrderByAggregateInput
  }

  export type produccionScalarWhereWithAggregatesInput = {
    AND?: produccionScalarWhereWithAggregatesInput | produccionScalarWhereWithAggregatesInput[]
    OR?: produccionScalarWhereWithAggregatesInput[]
    NOT?: produccionScalarWhereWithAggregatesInput | produccionScalarWhereWithAggregatesInput[]
    prod_ide?: IntWithAggregatesFilter | number
    prod_fechacarga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    prod_fechaafi?: DateTimeNullableWithAggregatesFilter | Date | string | null
    prod_asesor?: IntNullableWithAggregatesFilter | number | null
    prod_empre?: StringNullableWithAggregatesFilter | string | null
    prod_mes?: StringNullableWithAggregatesFilter | string | null
    prod_anio?: IntNullableWithAggregatesFilter | number | null
    prod_apeafi?: StringNullableWithAggregatesFilter | string | null
    prod_nomafi?: StringNullableWithAggregatesFilter | string | null
    prod_dniafi?: IntNullableWithAggregatesFilter | number | null
    prod_local?: IntNullableWithAggregatesFilter | number | null
    prod_recibo?: IntNullableWithAggregatesFilter | number | null
    prod_monto?: FloatNullableWithAggregatesFilter | number | null
    prod_plan?: StringNullableWithAggregatesFilter | string | null
    prod_pago?: StringNullableWithAggregatesFilter | string | null
    prod_cta_tar?: BigIntNullableWithAggregatesFilter | bigint | number | null
    prod_obs?: StringNullableWithAggregatesFilter | string | null
    prod_semana?: IntNullableWithAggregatesFilter | number | null
    prod_estado?: StringNullableWithAggregatesFilter | string | null
    prod_cierre?: IntNullableWithAggregatesFilter | number | null
    prod_afiliado?: IntNullableWithAggregatesFilter | number | null
    prod_rendido?: StringNullableWithAggregatesFilter | string | null
    prod_recibosis?: IntNullableWithAggregatesFilter | number | null
    prod_fechren?: DateTimeNullableWithAggregatesFilter | Date | string | null
    prod_tel?: StringNullableWithAggregatesFilter | string | null
  }

  export type registro_constancia_afiliacionWhereInput = {
    AND?: registro_constancia_afiliacionWhereInput | registro_constancia_afiliacionWhereInput[]
    OR?: registro_constancia_afiliacionWhereInput[]
    NOT?: registro_constancia_afiliacionWhereInput | registro_constancia_afiliacionWhereInput[]
    idconstancia?: IntFilter | number
    apellido_extinto?: StringNullableFilter | string | null
    nombre_extinto?: StringNullableFilter | string | null
    dni_extinto?: IntNullableFilter | number | null
    apellido_soli?: StringNullableFilter | string | null
    nombre_soli?: StringNullableFilter | string | null
    dni_soli?: StringNullableFilter | string | null
    lugar_presentacion?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    idservicio?: IntNullableFilter | number | null
  }

  export type registro_constancia_afiliacionOrderByWithRelationInput = {
    idconstancia?: SortOrder
    apellido_extinto?: SortOrderInput | SortOrder
    nombre_extinto?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    apellido_soli?: SortOrderInput | SortOrder
    nombre_soli?: SortOrderInput | SortOrder
    dni_soli?: SortOrderInput | SortOrder
    lugar_presentacion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
  }

  export type registro_constancia_afiliacionWhereUniqueInput = {
    idconstancia?: number
  }

  export type registro_constancia_afiliacionOrderByWithAggregationInput = {
    idconstancia?: SortOrder
    apellido_extinto?: SortOrderInput | SortOrder
    nombre_extinto?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    apellido_soli?: SortOrderInput | SortOrder
    nombre_soli?: SortOrderInput | SortOrder
    dni_soli?: SortOrderInput | SortOrder
    lugar_presentacion?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    _count?: registro_constancia_afiliacionCountOrderByAggregateInput
    _avg?: registro_constancia_afiliacionAvgOrderByAggregateInput
    _max?: registro_constancia_afiliacionMaxOrderByAggregateInput
    _min?: registro_constancia_afiliacionMinOrderByAggregateInput
    _sum?: registro_constancia_afiliacionSumOrderByAggregateInput
  }

  export type registro_constancia_afiliacionScalarWhereWithAggregatesInput = {
    AND?: registro_constancia_afiliacionScalarWhereWithAggregatesInput | registro_constancia_afiliacionScalarWhereWithAggregatesInput[]
    OR?: registro_constancia_afiliacionScalarWhereWithAggregatesInput[]
    NOT?: registro_constancia_afiliacionScalarWhereWithAggregatesInput | registro_constancia_afiliacionScalarWhereWithAggregatesInput[]
    idconstancia?: IntWithAggregatesFilter | number
    apellido_extinto?: StringNullableWithAggregatesFilter | string | null
    nombre_extinto?: StringNullableWithAggregatesFilter | string | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    apellido_soli?: StringNullableWithAggregatesFilter | string | null
    nombre_soli?: StringNullableWithAggregatesFilter | string | null
    dni_soli?: StringNullableWithAggregatesFilter | string | null
    lugar_presentacion?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
  }

  export type rehabilitacionesWhereInput = {
    AND?: rehabilitacionesWhereInput | rehabilitacionesWhereInput[]
    OR?: rehabilitacionesWhereInput[]
    NOT?: rehabilitacionesWhereInput | rehabilitacionesWhereInput[]
    idrehab?: IntFilter | number
    contrato?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    vigencia?: DateTimeNullableFilter | Date | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    cuotas?: IntNullableFilter | number | null
    dni?: IntNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    idoperador?: IntNullableFilter | number | null
  }

  export type rehabilitacionesOrderByWithRelationInput = {
    idrehab?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    idoperador?: SortOrderInput | SortOrder
  }

  export type rehabilitacionesWhereUniqueInput = {
    idrehab?: number
  }

  export type rehabilitacionesOrderByWithAggregationInput = {
    idrehab?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    vigencia?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    idoperador?: SortOrderInput | SortOrder
    _count?: rehabilitacionesCountOrderByAggregateInput
    _avg?: rehabilitacionesAvgOrderByAggregateInput
    _max?: rehabilitacionesMaxOrderByAggregateInput
    _min?: rehabilitacionesMinOrderByAggregateInput
    _sum?: rehabilitacionesSumOrderByAggregateInput
  }

  export type rehabilitacionesScalarWhereWithAggregatesInput = {
    AND?: rehabilitacionesScalarWhereWithAggregatesInput | rehabilitacionesScalarWhereWithAggregatesInput[]
    OR?: rehabilitacionesScalarWhereWithAggregatesInput[]
    NOT?: rehabilitacionesScalarWhereWithAggregatesInput | rehabilitacionesScalarWhereWithAggregatesInput[]
    idrehab?: IntWithAggregatesFilter | number
    contrato?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cuotas?: IntNullableWithAggregatesFilter | number | null
    dni?: IntNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    idoperador?: IntNullableWithAggregatesFilter | number | null
  }

  export type rol_personalWhereInput = {
    AND?: rol_personalWhereInput | rol_personalWhereInput[]
    OR?: rol_personalWhereInput[]
    NOT?: rol_personalWhereInput | rol_personalWhereInput[]
    idrol?: IntFilter | number
    rol?: StringNullableFilter | string | null
  }

  export type rol_personalOrderByWithRelationInput = {
    idrol?: SortOrder
    rol?: SortOrderInput | SortOrder
  }

  export type rol_personalWhereUniqueInput = {
    idrol?: number
  }

  export type rol_personalOrderByWithAggregationInput = {
    idrol?: SortOrder
    rol?: SortOrderInput | SortOrder
    _count?: rol_personalCountOrderByAggregateInput
    _avg?: rol_personalAvgOrderByAggregateInput
    _max?: rol_personalMaxOrderByAggregateInput
    _min?: rol_personalMinOrderByAggregateInput
    _sum?: rol_personalSumOrderByAggregateInput
  }

  export type rol_personalScalarWhereWithAggregatesInput = {
    AND?: rol_personalScalarWhereWithAggregatesInput | rol_personalScalarWhereWithAggregatesInput[]
    OR?: rol_personalScalarWhereWithAggregatesInput[]
    NOT?: rol_personalScalarWhereWithAggregatesInput | rol_personalScalarWhereWithAggregatesInput[]
    idrol?: IntWithAggregatesFilter | number
    rol?: StringNullableWithAggregatesFilter | string | null
  }

  export type sucursalWhereInput = {
    AND?: sucursalWhereInput | sucursalWhereInput[]
    OR?: sucursalWhereInput[]
    NOT?: sucursalWhereInput | sucursalWhereInput[]
    idsucursal?: IntFilter | number
    sucursal?: StringNullableFilter | string | null
    codigo?: StringNullableFilter | string | null
  }

  export type sucursalOrderByWithRelationInput = {
    idsucursal?: SortOrder
    sucursal?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
  }

  export type sucursalWhereUniqueInput = {
    idsucursal?: number
  }

  export type sucursalOrderByWithAggregationInput = {
    idsucursal?: SortOrder
    sucursal?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    _count?: sucursalCountOrderByAggregateInput
    _avg?: sucursalAvgOrderByAggregateInput
    _max?: sucursalMaxOrderByAggregateInput
    _min?: sucursalMinOrderByAggregateInput
    _sum?: sucursalSumOrderByAggregateInput
  }

  export type sucursalScalarWhereWithAggregatesInput = {
    AND?: sucursalScalarWhereWithAggregatesInput | sucursalScalarWhereWithAggregatesInput[]
    OR?: sucursalScalarWhereWithAggregatesInput[]
    NOT?: sucursalScalarWhereWithAggregatesInput | sucursalScalarWhereWithAggregatesInput[]
    idsucursal?: IntWithAggregatesFilter | number
    sucursal?: StringNullableWithAggregatesFilter | string | null
    codigo?: StringNullableWithAggregatesFilter | string | null
  }

  export type sueldosWhereInput = {
    AND?: sueldosWhereInput | sueldosWhereInput[]
    OR?: sueldosWhereInput[]
    NOT?: sueldosWhereInput | sueldosWhereInput[]
    sld_id?: IntFilter | number
    sld_perfil?: StringNullableFilter | string | null
    sld_basico?: FloatNullableFilter | number | null
    sld_basicoant?: FloatNullableFilter | number | null
  }

  export type sueldosOrderByWithRelationInput = {
    sld_id?: SortOrder
    sld_perfil?: SortOrderInput | SortOrder
    sld_basico?: SortOrderInput | SortOrder
    sld_basicoant?: SortOrderInput | SortOrder
  }

  export type sueldosWhereUniqueInput = {
    sld_id?: number
  }

  export type sueldosOrderByWithAggregationInput = {
    sld_id?: SortOrder
    sld_perfil?: SortOrderInput | SortOrder
    sld_basico?: SortOrderInput | SortOrder
    sld_basicoant?: SortOrderInput | SortOrder
    _count?: sueldosCountOrderByAggregateInput
    _avg?: sueldosAvgOrderByAggregateInput
    _max?: sueldosMaxOrderByAggregateInput
    _min?: sueldosMinOrderByAggregateInput
    _sum?: sueldosSumOrderByAggregateInput
  }

  export type sueldosScalarWhereWithAggregatesInput = {
    AND?: sueldosScalarWhereWithAggregatesInput | sueldosScalarWhereWithAggregatesInput[]
    OR?: sueldosScalarWhereWithAggregatesInput[]
    NOT?: sueldosScalarWhereWithAggregatesInput | sueldosScalarWhereWithAggregatesInput[]
    sld_id?: IntWithAggregatesFilter | number
    sld_perfil?: StringNullableWithAggregatesFilter | string | null
    sld_basico?: FloatNullableWithAggregatesFilter | number | null
    sld_basicoant?: FloatNullableWithAggregatesFilter | number | null
  }

  export type tab_efWhereInput = {
    AND?: tab_efWhereInput | tab_efWhereInput[]
    OR?: tab_efWhereInput[]
    NOT?: tab_efWhereInput | tab_efWhereInput[]
    id?: StringFilter | string
    start?: DateTimeNullableFilter | Date | string | null
    end?: DateTimeNullableFilter | Date | string | null
    allDay?: IntNullableFilter | number | null
    holiday?: IntNullableFilter | number | null
    title?: StringNullableFilter | string | null
    user?: StringNullableFilter | string | null
    detail?: StringNullableFilter | string | null
  }

  export type tab_efOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    holiday?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
  }

  export type tab_efWhereUniqueInput = {
    id?: string
  }

  export type tab_efOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    holiday?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    _count?: tab_efCountOrderByAggregateInput
    _avg?: tab_efAvgOrderByAggregateInput
    _max?: tab_efMaxOrderByAggregateInput
    _min?: tab_efMinOrderByAggregateInput
    _sum?: tab_efSumOrderByAggregateInput
  }

  export type tab_efScalarWhereWithAggregatesInput = {
    AND?: tab_efScalarWhereWithAggregatesInput | tab_efScalarWhereWithAggregatesInput[]
    OR?: tab_efScalarWhereWithAggregatesInput[]
    NOT?: tab_efScalarWhereWithAggregatesInput | tab_efScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    start?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    holiday?: IntNullableWithAggregatesFilter | number | null
    title?: StringNullableWithAggregatesFilter | string | null
    user?: StringNullableWithAggregatesFilter | string | null
    detail?: StringNullableWithAggregatesFilter | string | null
  }

  export type tablero_efectividadWhereInput = {
    AND?: tablero_efectividadWhereInput | tablero_efectividadWhereInput[]
    OR?: tablero_efectividadWhereInput[]
    NOT?: tablero_efectividadWhereInput | tablero_efectividadWhereInput[]
    idregistro?: IntFilter | number
    ano?: IntNullableFilter | number | null
    mes?: IntNullableFilter | number | null
    dia?: IntNullableFilter | number | null
    efectividad?: FloatNullableFilter | number | null
    aumento?: BoolNullableFilter | boolean | null
    por_aumento?: FloatNullableFilter | number | null
    feriado?: BoolNullableFilter | boolean | null
  }

  export type tablero_efectividadOrderByWithRelationInput = {
    idregistro?: SortOrder
    ano?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    dia?: SortOrderInput | SortOrder
    efectividad?: SortOrderInput | SortOrder
    aumento?: SortOrderInput | SortOrder
    por_aumento?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
  }

  export type tablero_efectividadWhereUniqueInput = {
    idregistro?: number
  }

  export type tablero_efectividadOrderByWithAggregationInput = {
    idregistro?: SortOrder
    ano?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    dia?: SortOrderInput | SortOrder
    efectividad?: SortOrderInput | SortOrder
    aumento?: SortOrderInput | SortOrder
    por_aumento?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    _count?: tablero_efectividadCountOrderByAggregateInput
    _avg?: tablero_efectividadAvgOrderByAggregateInput
    _max?: tablero_efectividadMaxOrderByAggregateInput
    _min?: tablero_efectividadMinOrderByAggregateInput
    _sum?: tablero_efectividadSumOrderByAggregateInput
  }

  export type tablero_efectividadScalarWhereWithAggregatesInput = {
    AND?: tablero_efectividadScalarWhereWithAggregatesInput | tablero_efectividadScalarWhereWithAggregatesInput[]
    OR?: tablero_efectividadScalarWhereWithAggregatesInput[]
    NOT?: tablero_efectividadScalarWhereWithAggregatesInput | tablero_efectividadScalarWhereWithAggregatesInput[]
    idregistro?: IntWithAggregatesFilter | number
    ano?: IntNullableWithAggregatesFilter | number | null
    mes?: IntNullableWithAggregatesFilter | number | null
    dia?: IntNullableWithAggregatesFilter | number | null
    efectividad?: FloatNullableWithAggregatesFilter | number | null
    aumento?: BoolNullableWithAggregatesFilter | boolean | null
    por_aumento?: FloatNullableWithAggregatesFilter | number | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type tareas_sucursalesWhereInput = {
    AND?: tareas_sucursalesWhereInput | tareas_sucursalesWhereInput[]
    OR?: tareas_sucursalesWhereInput[]
    NOT?: tareas_sucursalesWhereInput | tareas_sucursalesWhereInput[]
    idevents?: IntFilter | number
    title?: StringNullableFilter | string | null
    allDay?: IntNullableFilter | number | null
    start?: DateTimeNullableFilter | Date | string | null
    end?: DateTimeNullableFilter | Date | string | null
    priority?: IntNullableFilter | number | null
    sucursal?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    leido?: BoolNullableFilter | boolean | null
  }

  export type tareas_sucursalesOrderByWithRelationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    leido?: SortOrderInput | SortOrder
  }

  export type tareas_sucursalesWhereUniqueInput = {
    idevents?: number
  }

  export type tareas_sucursalesOrderByWithAggregationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    leido?: SortOrderInput | SortOrder
    _count?: tareas_sucursalesCountOrderByAggregateInput
    _avg?: tareas_sucursalesAvgOrderByAggregateInput
    _max?: tareas_sucursalesMaxOrderByAggregateInput
    _min?: tareas_sucursalesMinOrderByAggregateInput
    _sum?: tareas_sucursalesSumOrderByAggregateInput
  }

  export type tareas_sucursalesScalarWhereWithAggregatesInput = {
    AND?: tareas_sucursalesScalarWhereWithAggregatesInput | tareas_sucursalesScalarWhereWithAggregatesInput[]
    OR?: tareas_sucursalesScalarWhereWithAggregatesInput[]
    NOT?: tareas_sucursalesScalarWhereWithAggregatesInput | tareas_sucursalesScalarWhereWithAggregatesInput[]
    idevents?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    start?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
    priority?: IntNullableWithAggregatesFilter | number | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    leido?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type tipo_contratosWhereInput = {
    AND?: tipo_contratosWhereInput | tipo_contratosWhereInput[]
    OR?: tipo_contratosWhereInput[]
    NOT?: tipo_contratosWhereInput | tipo_contratosWhereInput[]
    idtipocontrato?: IntFilter | number
    tipo_contrato?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
  }

  export type tipo_contratosOrderByWithRelationInput = {
    idtipocontrato?: SortOrder
    tipo_contrato?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type tipo_contratosWhereUniqueInput = {
    idtipocontrato?: number
  }

  export type tipo_contratosOrderByWithAggregationInput = {
    idtipocontrato?: SortOrder
    tipo_contrato?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    _count?: tipo_contratosCountOrderByAggregateInput
    _avg?: tipo_contratosAvgOrderByAggregateInput
    _max?: tipo_contratosMaxOrderByAggregateInput
    _min?: tipo_contratosMinOrderByAggregateInput
    _sum?: tipo_contratosSumOrderByAggregateInput
  }

  export type tipo_contratosScalarWhereWithAggregatesInput = {
    AND?: tipo_contratosScalarWhereWithAggregatesInput | tipo_contratosScalarWhereWithAggregatesInput[]
    OR?: tipo_contratosScalarWhereWithAggregatesInput[]
    NOT?: tipo_contratosScalarWhereWithAggregatesInput | tipo_contratosScalarWhereWithAggregatesInput[]
    idtipocontrato?: IntWithAggregatesFilter | number
    tipo_contrato?: StringNullableWithAggregatesFilter | string | null
    url?: StringNullableWithAggregatesFilter | string | null
  }

  export type tipo_facturasWhereInput = {
    AND?: tipo_facturasWhereInput | tipo_facturasWhereInput[]
    OR?: tipo_facturasWhereInput[]
    NOT?: tipo_facturasWhereInput | tipo_facturasWhereInput[]
    idfactura?: IntFilter | number
    tipo_factura?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type tipo_facturasOrderByWithRelationInput = {
    idfactura?: SortOrder
    tipo_factura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type tipo_facturasWhereUniqueInput = {
    idfactura?: number
  }

  export type tipo_facturasOrderByWithAggregationInput = {
    idfactura?: SortOrder
    tipo_factura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: tipo_facturasCountOrderByAggregateInput
    _avg?: tipo_facturasAvgOrderByAggregateInput
    _max?: tipo_facturasMaxOrderByAggregateInput
    _min?: tipo_facturasMinOrderByAggregateInput
    _sum?: tipo_facturasSumOrderByAggregateInput
  }

  export type tipo_facturasScalarWhereWithAggregatesInput = {
    AND?: tipo_facturasScalarWhereWithAggregatesInput | tipo_facturasScalarWhereWithAggregatesInput[]
    OR?: tipo_facturasScalarWhereWithAggregatesInput[]
    NOT?: tipo_facturasScalarWhereWithAggregatesInput | tipo_facturasScalarWhereWithAggregatesInput[]
    idfactura?: IntWithAggregatesFilter | number
    tipo_factura?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type turno_bajasWhereInput = {
    AND?: turno_bajasWhereInput | turno_bajasWhereInput[]
    OR?: turno_bajasWhereInput[]
    NOT?: turno_bajasWhereInput | turno_bajasWhereInput[]
    idturno?: IntFilter | number
    contrato?: IntNullableFilter | number | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    fecha_pedido?: DateTimeNullableFilter | Date | string | null
    fecha_turno?: DateTimeNullableFilter | Date | string | null
    motivo?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    telefono?: StringNullableFilter | string | null
    movil?: StringNullableFilter | string | null
    fecha_atencion?: DateTimeNullableFilter | Date | string | null
    estado?: IntNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    respuesta?: StringNullableFilter | string | null
    operador_atencion?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
  }

  export type turno_bajasOrderByWithRelationInput = {
    idturno?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha_pedido?: SortOrderInput | SortOrder
    fecha_turno?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    fecha_atencion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    respuesta?: SortOrderInput | SortOrder
    operador_atencion?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
  }

  export type turno_bajasWhereUniqueInput = {
    idturno?: number
  }

  export type turno_bajasOrderByWithAggregationInput = {
    idturno?: SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha_pedido?: SortOrderInput | SortOrder
    fecha_turno?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    fecha_atencion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    respuesta?: SortOrderInput | SortOrder
    operador_atencion?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    _count?: turno_bajasCountOrderByAggregateInput
    _avg?: turno_bajasAvgOrderByAggregateInput
    _max?: turno_bajasMaxOrderByAggregateInput
    _min?: turno_bajasMinOrderByAggregateInput
    _sum?: turno_bajasSumOrderByAggregateInput
  }

  export type turno_bajasScalarWhereWithAggregatesInput = {
    AND?: turno_bajasScalarWhereWithAggregatesInput | turno_bajasScalarWhereWithAggregatesInput[]
    OR?: turno_bajasScalarWhereWithAggregatesInput[]
    NOT?: turno_bajasScalarWhereWithAggregatesInput | turno_bajasScalarWhereWithAggregatesInput[]
    idturno?: IntWithAggregatesFilter | number
    contrato?: IntNullableWithAggregatesFilter | number | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    fecha_pedido?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha_turno?: DateTimeNullableWithAggregatesFilter | Date | string | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    telefono?: StringNullableWithAggregatesFilter | string | null
    movil?: StringNullableWithAggregatesFilter | string | null
    fecha_atencion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    estado?: IntNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    respuesta?: StringNullableWithAggregatesFilter | string | null
    operador_atencion?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
  }

  export type vacacionesWhereInput = {
    AND?: vacacionesWhereInput | vacacionesWhereInput[]
    OR?: vacacionesWhereInput[]
    NOT?: vacacionesWhereInput | vacacionesWhereInput[]
    id?: StringFilter | string
    start?: DateTimeNullableFilter | Date | string | null
    end?: DateTimeNullableFilter | Date | string | null
    allDay?: IntNullableFilter | number | null
    priority?: IntNullableFilter | number | null
    title?: StringNullableFilter | string | null
    user?: StringNullableFilter | string | null
    detail?: StringNullableFilter | string | null
  }

  export type vacacionesOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
  }

  export type vacacionesWhereUniqueInput = {
    id?: string
  }

  export type vacacionesOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    _count?: vacacionesCountOrderByAggregateInput
    _avg?: vacacionesAvgOrderByAggregateInput
    _max?: vacacionesMaxOrderByAggregateInput
    _min?: vacacionesMinOrderByAggregateInput
    _sum?: vacacionesSumOrderByAggregateInput
  }

  export type vacacionesScalarWhereWithAggregatesInput = {
    AND?: vacacionesScalarWhereWithAggregatesInput | vacacionesScalarWhereWithAggregatesInput[]
    OR?: vacacionesScalarWhereWithAggregatesInput[]
    NOT?: vacacionesScalarWhereWithAggregatesInput | vacacionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    start?: DateTimeNullableWithAggregatesFilter | Date | string | null
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    priority?: IntNullableWithAggregatesFilter | number | null
    title?: StringNullableWithAggregatesFilter | string | null
    user?: StringNullableWithAggregatesFilter | string | null
    detail?: StringNullableWithAggregatesFilter | string | null
  }

  export type motivos_atencionWhereInput = {
    AND?: motivos_atencionWhereInput | motivos_atencionWhereInput[]
    OR?: motivos_atencionWhereInput[]
    NOT?: motivos_atencionWhereInput | motivos_atencionWhereInput[]
    idmotivo?: IntFilter | number
    motivo?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type motivos_atencionOrderByWithRelationInput = {
    idmotivo?: SortOrder
    motivo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type motivos_atencionWhereUniqueInput = {
    idmotivo?: number
  }

  export type motivos_atencionOrderByWithAggregationInput = {
    idmotivo?: SortOrder
    motivo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: motivos_atencionCountOrderByAggregateInput
    _avg?: motivos_atencionAvgOrderByAggregateInput
    _max?: motivos_atencionMaxOrderByAggregateInput
    _min?: motivos_atencionMinOrderByAggregateInput
    _sum?: motivos_atencionSumOrderByAggregateInput
  }

  export type motivos_atencionScalarWhereWithAggregatesInput = {
    AND?: motivos_atencionScalarWhereWithAggregatesInput | motivos_atencionScalarWhereWithAggregatesInput[]
    OR?: motivos_atencionScalarWhereWithAggregatesInput[]
    NOT?: motivos_atencionScalarWhereWithAggregatesInput | motivos_atencionScalarWhereWithAggregatesInput[]
    idmotivo?: IntWithAggregatesFilter | number
    motivo?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type prestamos_plan_cuotasWhereInput = {
    AND?: prestamos_plan_cuotasWhereInput | prestamos_plan_cuotasWhereInput[]
    OR?: prestamos_plan_cuotasWhereInput[]
    NOT?: prestamos_plan_cuotasWhereInput | prestamos_plan_cuotasWhereInput[]
    idplan?: IntFilter | number
    plan_cuotas?: IntNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type prestamos_plan_cuotasOrderByWithRelationInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type prestamos_plan_cuotasWhereUniqueInput = {
    idplan?: number
  }

  export type prestamos_plan_cuotasOrderByWithAggregationInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: prestamos_plan_cuotasCountOrderByAggregateInput
    _avg?: prestamos_plan_cuotasAvgOrderByAggregateInput
    _max?: prestamos_plan_cuotasMaxOrderByAggregateInput
    _min?: prestamos_plan_cuotasMinOrderByAggregateInput
    _sum?: prestamos_plan_cuotasSumOrderByAggregateInput
  }

  export type prestamos_plan_cuotasScalarWhereWithAggregatesInput = {
    AND?: prestamos_plan_cuotasScalarWhereWithAggregatesInput | prestamos_plan_cuotasScalarWhereWithAggregatesInput[]
    OR?: prestamos_plan_cuotasScalarWhereWithAggregatesInput[]
    NOT?: prestamos_plan_cuotasScalarWhereWithAggregatesInput | prestamos_plan_cuotasScalarWhereWithAggregatesInput[]
    idplan?: IntWithAggregatesFilter | number
    plan_cuotas?: IntNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type prestamos_tasasWhereInput = {
    AND?: prestamos_tasasWhereInput | prestamos_tasasWhereInput[]
    OR?: prestamos_tasasWhereInput[]
    NOT?: prestamos_tasasWhereInput | prestamos_tasasWhereInput[]
    idtasa?: IntFilter | number
    tasa?: IntNullableFilter | number | null
    plan?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type prestamos_tasasOrderByWithRelationInput = {
    idtasa?: SortOrder
    tasa?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type prestamos_tasasWhereUniqueInput = {
    idtasa?: number
  }

  export type prestamos_tasasOrderByWithAggregationInput = {
    idtasa?: SortOrder
    tasa?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: prestamos_tasasCountOrderByAggregateInput
    _avg?: prestamos_tasasAvgOrderByAggregateInput
    _max?: prestamos_tasasMaxOrderByAggregateInput
    _min?: prestamos_tasasMinOrderByAggregateInput
    _sum?: prestamos_tasasSumOrderByAggregateInput
  }

  export type prestamos_tasasScalarWhereWithAggregatesInput = {
    AND?: prestamos_tasasScalarWhereWithAggregatesInput | prestamos_tasasScalarWhereWithAggregatesInput[]
    OR?: prestamos_tasasScalarWhereWithAggregatesInput[]
    NOT?: prestamos_tasasScalarWhereWithAggregatesInput | prestamos_tasasScalarWhereWithAggregatesInput[]
    idtasa?: IntWithAggregatesFilter | number
    tasa?: IntNullableWithAggregatesFilter | number | null
    plan?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type certificado_estudiantesWhereInput = {
    AND?: certificado_estudiantesWhereInput | certificado_estudiantesWhereInput[]
    OR?: certificado_estudiantesWhereInput[]
    NOT?: certificado_estudiantesWhereInput | certificado_estudiantesWhereInput[]
    idcertificado?: IntFilter | number
    contrato?: IntNullableFilter | number | null
    socio?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    ncert?: StringNullableFilter | string | null
  }

  export type certificado_estudiantesOrderByWithRelationInput = {
    idcertificado?: SortOrder
    contrato?: SortOrderInput | SortOrder
    socio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ncert?: SortOrderInput | SortOrder
  }

  export type certificado_estudiantesWhereUniqueInput = {
    idcertificado?: number
  }

  export type certificado_estudiantesOrderByWithAggregationInput = {
    idcertificado?: SortOrder
    contrato?: SortOrderInput | SortOrder
    socio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ncert?: SortOrderInput | SortOrder
    _count?: certificado_estudiantesCountOrderByAggregateInput
    _avg?: certificado_estudiantesAvgOrderByAggregateInput
    _max?: certificado_estudiantesMaxOrderByAggregateInput
    _min?: certificado_estudiantesMinOrderByAggregateInput
    _sum?: certificado_estudiantesSumOrderByAggregateInput
  }

  export type certificado_estudiantesScalarWhereWithAggregatesInput = {
    AND?: certificado_estudiantesScalarWhereWithAggregatesInput | certificado_estudiantesScalarWhereWithAggregatesInput[]
    OR?: certificado_estudiantesScalarWhereWithAggregatesInput[]
    NOT?: certificado_estudiantesScalarWhereWithAggregatesInput | certificado_estudiantesScalarWhereWithAggregatesInput[]
    idcertificado?: IntWithAggregatesFilter | number
    contrato?: IntNullableWithAggregatesFilter | number | null
    socio?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    ncert?: StringNullableWithAggregatesFilter | string | null
  }

  export type carteraWhereInput = {
    AND?: carteraWhereInput | carteraWhereInput[]
    OR?: carteraWhereInput[]
    NOT?: carteraWhereInput | carteraWhereInput[]
    contrato?: IntNullableFilter | number | null
    socio?: StringNullableFilter | string | null
    alta?: DateTimeNullableFilter | Date | string | null
    grupo?: IntNullableFilter | number | null
    adhs?: IntNullableFilter | number | null
    plan?: StringNullableFilter | string | null
    sub_plan?: StringNullableFilter | string | null
    zona?: IntNullableFilter | number | null
    cuota?: FloatNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
    deuda?: IntNullableFilter | number | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    idcartera?: IntFilter | number
  }

  export type carteraOrderByWithRelationInput = {
    contrato?: SortOrderInput | SortOrder
    socio?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    grupo?: SortOrderInput | SortOrder
    adhs?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    sub_plan?: SortOrderInput | SortOrder
    zona?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    deuda?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    idcartera?: SortOrder
  }

  export type carteraWhereUniqueInput = {
    contrato?: number
    idcartera?: number
  }

  export type carteraOrderByWithAggregationInput = {
    contrato?: SortOrderInput | SortOrder
    socio?: SortOrderInput | SortOrder
    alta?: SortOrderInput | SortOrder
    grupo?: SortOrderInput | SortOrder
    adhs?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    sub_plan?: SortOrderInput | SortOrder
    zona?: SortOrderInput | SortOrder
    cuota?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    deuda?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    idcartera?: SortOrder
    _count?: carteraCountOrderByAggregateInput
    _avg?: carteraAvgOrderByAggregateInput
    _max?: carteraMaxOrderByAggregateInput
    _min?: carteraMinOrderByAggregateInput
    _sum?: carteraSumOrderByAggregateInput
  }

  export type carteraScalarWhereWithAggregatesInput = {
    AND?: carteraScalarWhereWithAggregatesInput | carteraScalarWhereWithAggregatesInput[]
    OR?: carteraScalarWhereWithAggregatesInput[]
    NOT?: carteraScalarWhereWithAggregatesInput | carteraScalarWhereWithAggregatesInput[]
    contrato?: IntNullableWithAggregatesFilter | number | null
    socio?: StringNullableWithAggregatesFilter | string | null
    alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    grupo?: IntNullableWithAggregatesFilter | number | null
    adhs?: IntNullableWithAggregatesFilter | number | null
    plan?: StringNullableWithAggregatesFilter | string | null
    sub_plan?: StringNullableWithAggregatesFilter | string | null
    zona?: IntNullableWithAggregatesFilter | number | null
    cuota?: FloatNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    deuda?: IntNullableWithAggregatesFilter | number | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    idcartera?: IntWithAggregatesFilter | number
  }

  export type alta_novellCreateInput = {
    fecha_recepcion?: Date | string | null
    servicio?: string | null
    monto?: number | null
    monto_letra?: string | null
    anticipo?: number | null
    gastos_adm?: number | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    estcivil_sol?: string | null
    fecha_nac_sol?: Date | string | null
    dom_sol?: string | null
    domnum_sol?: number | null
    piso_sol?: string | null
    barrio_sol?: string | null
    localidad_sol?: string | null
    codpostal_sol?: number | null
    telefono_sol?: string | null
    movil_sol?: string | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    dni_ben?: number | null
    estcivil_ben?: string | null
    fecha_nac_ben?: Date | string | null
    dom_ben?: string | null
    domnum_ben?: number | null
    piso_ben?: string | null
    barrio_ben?: string | null
    localidad_ben?: string | null
    codpostal_ben?: number | null
    telefono_ben?: string | null
    movil_ben?: string | null
    operador?: string | null
    cuotas?: number | null
    nacionalidad_sol?: string | null
    nacionalidad_ben?: string | null
    anticipo_letra?: string | null
    cuotasaldo?: number | null
    cuotasaldo_letra?: string | null
    cuota_mantenimiento?: number | null
  }

  export type alta_novellUncheckedCreateInput = {
    idnovell?: number
    fecha_recepcion?: Date | string | null
    servicio?: string | null
    monto?: number | null
    monto_letra?: string | null
    anticipo?: number | null
    gastos_adm?: number | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    estcivil_sol?: string | null
    fecha_nac_sol?: Date | string | null
    dom_sol?: string | null
    domnum_sol?: number | null
    piso_sol?: string | null
    barrio_sol?: string | null
    localidad_sol?: string | null
    codpostal_sol?: number | null
    telefono_sol?: string | null
    movil_sol?: string | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    dni_ben?: number | null
    estcivil_ben?: string | null
    fecha_nac_ben?: Date | string | null
    dom_ben?: string | null
    domnum_ben?: number | null
    piso_ben?: string | null
    barrio_ben?: string | null
    localidad_ben?: string | null
    codpostal_ben?: number | null
    telefono_ben?: string | null
    movil_ben?: string | null
    operador?: string | null
    cuotas?: number | null
    nacionalidad_sol?: string | null
    nacionalidad_ben?: string | null
    anticipo_letra?: string | null
    cuotasaldo?: number | null
    cuotasaldo_letra?: string | null
    cuota_mantenimiento?: number | null
  }

  export type alta_novellUpdateInput = {
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    monto_letra?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo?: NullableIntFieldUpdateOperationsInput | number | null
    gastos_adm?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_sol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_sol?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_sol?: NullableIntFieldUpdateOperationsInput | number | null
    piso_sol?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_sol?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    movil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    dni_ben?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_ben?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_ben?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_ben?: NullableIntFieldUpdateOperationsInput | number | null
    piso_ben?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_ben?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_ben?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    movil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    nacionalidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuotasaldo?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasaldo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuota_mantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alta_novellUncheckedUpdateInput = {
    idnovell?: IntFieldUpdateOperationsInput | number
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    monto_letra?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo?: NullableIntFieldUpdateOperationsInput | number | null
    gastos_adm?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_sol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_sol?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_sol?: NullableIntFieldUpdateOperationsInput | number | null
    piso_sol?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_sol?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    movil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    dni_ben?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_ben?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_ben?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_ben?: NullableIntFieldUpdateOperationsInput | number | null
    piso_ben?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_ben?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_ben?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    movil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    nacionalidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuotasaldo?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasaldo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuota_mantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alta_novellCreateManyInput = {
    idnovell?: number
    fecha_recepcion?: Date | string | null
    servicio?: string | null
    monto?: number | null
    monto_letra?: string | null
    anticipo?: number | null
    gastos_adm?: number | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    estcivil_sol?: string | null
    fecha_nac_sol?: Date | string | null
    dom_sol?: string | null
    domnum_sol?: number | null
    piso_sol?: string | null
    barrio_sol?: string | null
    localidad_sol?: string | null
    codpostal_sol?: number | null
    telefono_sol?: string | null
    movil_sol?: string | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    dni_ben?: number | null
    estcivil_ben?: string | null
    fecha_nac_ben?: Date | string | null
    dom_ben?: string | null
    domnum_ben?: number | null
    piso_ben?: string | null
    barrio_ben?: string | null
    localidad_ben?: string | null
    codpostal_ben?: number | null
    telefono_ben?: string | null
    movil_ben?: string | null
    operador?: string | null
    cuotas?: number | null
    nacionalidad_sol?: string | null
    nacionalidad_ben?: string | null
    anticipo_letra?: string | null
    cuotasaldo?: number | null
    cuotasaldo_letra?: string | null
    cuota_mantenimiento?: number | null
  }

  export type alta_novellUpdateManyMutationInput = {
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    monto_letra?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo?: NullableIntFieldUpdateOperationsInput | number | null
    gastos_adm?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_sol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_sol?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_sol?: NullableIntFieldUpdateOperationsInput | number | null
    piso_sol?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_sol?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    movil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    dni_ben?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_ben?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_ben?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_ben?: NullableIntFieldUpdateOperationsInput | number | null
    piso_ben?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_ben?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_ben?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    movil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    nacionalidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuotasaldo?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasaldo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuota_mantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alta_novellUncheckedUpdateManyInput = {
    idnovell?: IntFieldUpdateOperationsInput | number
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableIntFieldUpdateOperationsInput | number | null
    monto_letra?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo?: NullableIntFieldUpdateOperationsInput | number | null
    gastos_adm?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_sol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_sol?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_sol?: NullableIntFieldUpdateOperationsInput | number | null
    piso_sol?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_sol?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    movil_sol?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    dni_ben?: NullableIntFieldUpdateOperationsInput | number | null
    estcivil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac_ben?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dom_ben?: NullableStringFieldUpdateOperationsInput | string | null
    domnum_ben?: NullableIntFieldUpdateOperationsInput | number | null
    piso_ben?: NullableStringFieldUpdateOperationsInput | string | null
    barrio_ben?: NullableStringFieldUpdateOperationsInput | string | null
    localidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    codpostal_ben?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    movil_ben?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    nacionalidad_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidad_ben?: NullableStringFieldUpdateOperationsInput | string | null
    anticipo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuotasaldo?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasaldo_letra?: NullableStringFieldUpdateOperationsInput | string | null
    cuota_mantenimiento?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type caja_sucursalesCreateInput = {
    fecha_carga?: Date | string | null
    sucursal?: string | null
    ingresos?: number | null
    egresos?: number | null
    saldo?: number | null
    operador_carga?: string | null
    empresa?: string | null
  }

  export type caja_sucursalesUncheckedCreateInput = {
    idcaja?: number
    fecha_carga?: Date | string | null
    sucursal?: string | null
    ingresos?: number | null
    egresos?: number | null
    saldo?: number | null
    operador_carga?: string | null
    empresa?: string | null
  }

  export type caja_sucursalesUpdateInput = {
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    ingresos?: NullableFloatFieldUpdateOperationsInput | number | null
    egresos?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sucursalesUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    ingresos?: NullableFloatFieldUpdateOperationsInput | number | null
    egresos?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sucursalesCreateManyInput = {
    idcaja?: number
    fecha_carga?: Date | string | null
    sucursal?: string | null
    ingresos?: number | null
    egresos?: number | null
    saldo?: number | null
    operador_carga?: string | null
    empresa?: string | null
  }

  export type caja_sucursalesUpdateManyMutationInput = {
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    ingresos?: NullableFloatFieldUpdateOperationsInput | number | null
    egresos?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sucursalesUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    ingresos?: NullableFloatFieldUpdateOperationsInput | number | null
    egresos?: NullableFloatFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanacasosCreateInput = {
    idcampana?: number | null
    fechacampana?: Date | string | null
    mes?: number | null
    ano?: number | null
    sucursal?: string | null
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: string | null
    movil?: string | null
    calle?: string | null
    nro_calle?: number | null
    barrio?: string | null
    localidad?: string | null
    cuota?: number | null
    cuotasadeudadas?: number | null
    montoadeudado?: number | null
    estadocaso?: boolean | null
    accion?: number | null
    edad?: number | null
    adherentes?: number | null
    alta?: Date | string | null
    vigencia?: Date | string | null
  }

  export type campanacasosUncheckedCreateInput = {
    idcaso?: number
    idcampana?: number | null
    fechacampana?: Date | string | null
    mes?: number | null
    ano?: number | null
    sucursal?: string | null
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: string | null
    movil?: string | null
    calle?: string | null
    nro_calle?: number | null
    barrio?: string | null
    localidad?: string | null
    cuota?: number | null
    cuotasadeudadas?: number | null
    montoadeudado?: number | null
    estadocaso?: boolean | null
    accion?: number | null
    edad?: number | null
    adherentes?: number | null
    alta?: Date | string | null
    vigencia?: Date | string | null
  }

  export type campanacasosUpdateInput = {
    idcampana?: NullableIntFieldUpdateOperationsInput | number | null
    fechacampana?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    nro_calle?: NullableIntFieldUpdateOperationsInput | number | null
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasadeudadas?: NullableIntFieldUpdateOperationsInput | number | null
    montoadeudado?: NullableIntFieldUpdateOperationsInput | number | null
    estadocaso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accion?: NullableIntFieldUpdateOperationsInput | number | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    adherentes?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanacasosUncheckedUpdateInput = {
    idcaso?: IntFieldUpdateOperationsInput | number
    idcampana?: NullableIntFieldUpdateOperationsInput | number | null
    fechacampana?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    nro_calle?: NullableIntFieldUpdateOperationsInput | number | null
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasadeudadas?: NullableIntFieldUpdateOperationsInput | number | null
    montoadeudado?: NullableIntFieldUpdateOperationsInput | number | null
    estadocaso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accion?: NullableIntFieldUpdateOperationsInput | number | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    adherentes?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanacasosCreateManyInput = {
    idcaso?: number
    idcampana?: number | null
    fechacampana?: Date | string | null
    mes?: number | null
    ano?: number | null
    sucursal?: string | null
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: string | null
    movil?: string | null
    calle?: string | null
    nro_calle?: number | null
    barrio?: string | null
    localidad?: string | null
    cuota?: number | null
    cuotasadeudadas?: number | null
    montoadeudado?: number | null
    estadocaso?: boolean | null
    accion?: number | null
    edad?: number | null
    adherentes?: number | null
    alta?: Date | string | null
    vigencia?: Date | string | null
  }

  export type campanacasosUpdateManyMutationInput = {
    idcampana?: NullableIntFieldUpdateOperationsInput | number | null
    fechacampana?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    nro_calle?: NullableIntFieldUpdateOperationsInput | number | null
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasadeudadas?: NullableIntFieldUpdateOperationsInput | number | null
    montoadeudado?: NullableIntFieldUpdateOperationsInput | number | null
    estadocaso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accion?: NullableIntFieldUpdateOperationsInput | number | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    adherentes?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanacasosUncheckedUpdateManyInput = {
    idcaso?: IntFieldUpdateOperationsInput | number
    idcampana?: NullableIntFieldUpdateOperationsInput | number | null
    fechacampana?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    calle?: NullableStringFieldUpdateOperationsInput | string | null
    nro_calle?: NullableIntFieldUpdateOperationsInput | number | null
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    cuotasadeudadas?: NullableIntFieldUpdateOperationsInput | number | null
    montoadeudado?: NullableIntFieldUpdateOperationsInput | number | null
    estadocaso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accion?: NullableIntFieldUpdateOperationsInput | number | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    adherentes?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type campanasCreateInput = {
    descripcion?: string | null
    operador?: string | null
    fecha?: Date | string | null
    empresa?: string | null
    sucursal?: string | null
  }

  export type campanasUncheckedCreateInput = {
    idcampana?: number
    descripcion?: string | null
    operador?: string | null
    fecha?: Date | string | null
    empresa?: string | null
    sucursal?: string | null
  }

  export type campanasUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanasUncheckedUpdateInput = {
    idcampana?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanasCreateManyInput = {
    idcampana?: number
    descripcion?: string | null
    operador?: string | null
    fecha?: Date | string | null
    empresa?: string | null
    sucursal?: string | null
  }

  export type campanasUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanasUncheckedUpdateManyInput = {
    idcampana?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanatemporalCreateInput = {
    SUCURSAL?: string | null
    CONTRATO: number
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    ALTA?: Date | string | null
    VIGENCIA?: Date | string | null
    CALLE?: string | null
    NRO_CALLE?: number | null
    BARRIO?: string | null
    LOCALIDAD?: string | null
    GRUPO?: number | null
    ZONA?: number | null
    TELEFONO?: string | null
    MOVIL?: string | null
    EDAD?: number | null
    MES?: number | null
    ANO?: number | null
    IMPORTE?: number | null
    operador?: string | null
    estado?: boolean | null
    observacion?: string | null
    fecha?: string | null
    fecha_observacion?: string | null
    accion?: string | null
  }

  export type campanatemporalUncheckedCreateInput = {
    SUCURSAL?: string | null
    CONTRATO: number
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    ALTA?: Date | string | null
    VIGENCIA?: Date | string | null
    CALLE?: string | null
    NRO_CALLE?: number | null
    BARRIO?: string | null
    LOCALIDAD?: string | null
    GRUPO?: number | null
    ZONA?: number | null
    TELEFONO?: string | null
    MOVIL?: string | null
    EDAD?: number | null
    MES?: number | null
    ANO?: number | null
    IMPORTE?: number | null
    operador?: string | null
    estado?: boolean | null
    idcaso?: number
    observacion?: string | null
    fecha?: string | null
    fecha_observacion?: string | null
    accion?: string | null
  }

  export type campanatemporalUpdateInput = {
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: IntFieldUpdateOperationsInput | number
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    ALTA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VIGENCIA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CALLE?: NullableStringFieldUpdateOperationsInput | string | null
    NRO_CALLE?: NullableIntFieldUpdateOperationsInput | number | null
    BARRIO?: NullableStringFieldUpdateOperationsInput | string | null
    LOCALIDAD?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableIntFieldUpdateOperationsInput | number | null
    ZONA?: NullableIntFieldUpdateOperationsInput | number | null
    TELEFONO?: NullableStringFieldUpdateOperationsInput | string | null
    MOVIL?: NullableStringFieldUpdateOperationsInput | string | null
    EDAD?: NullableIntFieldUpdateOperationsInput | number | null
    MES?: NullableIntFieldUpdateOperationsInput | number | null
    ANO?: NullableIntFieldUpdateOperationsInput | number | null
    IMPORTE?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_observacion?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanatemporalUncheckedUpdateInput = {
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: IntFieldUpdateOperationsInput | number
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    ALTA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VIGENCIA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CALLE?: NullableStringFieldUpdateOperationsInput | string | null
    NRO_CALLE?: NullableIntFieldUpdateOperationsInput | number | null
    BARRIO?: NullableStringFieldUpdateOperationsInput | string | null
    LOCALIDAD?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableIntFieldUpdateOperationsInput | number | null
    ZONA?: NullableIntFieldUpdateOperationsInput | number | null
    TELEFONO?: NullableStringFieldUpdateOperationsInput | string | null
    MOVIL?: NullableStringFieldUpdateOperationsInput | string | null
    EDAD?: NullableIntFieldUpdateOperationsInput | number | null
    MES?: NullableIntFieldUpdateOperationsInput | number | null
    ANO?: NullableIntFieldUpdateOperationsInput | number | null
    IMPORTE?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idcaso?: IntFieldUpdateOperationsInput | number
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_observacion?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanatemporalCreateManyInput = {
    SUCURSAL?: string | null
    CONTRATO: number
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    ALTA?: Date | string | null
    VIGENCIA?: Date | string | null
    CALLE?: string | null
    NRO_CALLE?: number | null
    BARRIO?: string | null
    LOCALIDAD?: string | null
    GRUPO?: number | null
    ZONA?: number | null
    TELEFONO?: string | null
    MOVIL?: string | null
    EDAD?: number | null
    MES?: number | null
    ANO?: number | null
    IMPORTE?: number | null
    operador?: string | null
    estado?: boolean | null
    idcaso?: number
    observacion?: string | null
    fecha?: string | null
    fecha_observacion?: string | null
    accion?: string | null
  }

  export type campanatemporalUpdateManyMutationInput = {
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: IntFieldUpdateOperationsInput | number
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    ALTA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VIGENCIA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CALLE?: NullableStringFieldUpdateOperationsInput | string | null
    NRO_CALLE?: NullableIntFieldUpdateOperationsInput | number | null
    BARRIO?: NullableStringFieldUpdateOperationsInput | string | null
    LOCALIDAD?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableIntFieldUpdateOperationsInput | number | null
    ZONA?: NullableIntFieldUpdateOperationsInput | number | null
    TELEFONO?: NullableStringFieldUpdateOperationsInput | string | null
    MOVIL?: NullableStringFieldUpdateOperationsInput | string | null
    EDAD?: NullableIntFieldUpdateOperationsInput | number | null
    MES?: NullableIntFieldUpdateOperationsInput | number | null
    ANO?: NullableIntFieldUpdateOperationsInput | number | null
    IMPORTE?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_observacion?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campanatemporalUncheckedUpdateManyInput = {
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: IntFieldUpdateOperationsInput | number
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    ALTA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VIGENCIA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CALLE?: NullableStringFieldUpdateOperationsInput | string | null
    NRO_CALLE?: NullableIntFieldUpdateOperationsInput | number | null
    BARRIO?: NullableStringFieldUpdateOperationsInput | string | null
    LOCALIDAD?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableIntFieldUpdateOperationsInput | number | null
    ZONA?: NullableIntFieldUpdateOperationsInput | number | null
    TELEFONO?: NullableStringFieldUpdateOperationsInput | string | null
    MOVIL?: NullableStringFieldUpdateOperationsInput | string | null
    EDAD?: NullableIntFieldUpdateOperationsInput | number | null
    MES?: NullableIntFieldUpdateOperationsInput | number | null
    ANO?: NullableIntFieldUpdateOperationsInput | number | null
    IMPORTE?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idcaso?: IntFieldUpdateOperationsInput | number
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_observacion?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type capital_prestamoCreateInput = {
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamoUncheckedCreateInput = {
    idcapital?: number
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamoUpdateInput = {
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamoUncheckedUpdateInput = {
    idcapital?: IntFieldUpdateOperationsInput | number
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamoCreateManyInput = {
    idcapital?: number
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamoUpdateManyMutationInput = {
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamoUncheckedUpdateManyInput = {
    idcapital?: IntFieldUpdateOperationsInput | number
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamo_empleadosCreateInput = {
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamo_empleadosUncheckedCreateInput = {
    idcapital?: number
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamo_empleadosUpdateInput = {
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamo_empleadosUncheckedUpdateInput = {
    idcapital?: IntFieldUpdateOperationsInput | number
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamo_empleadosCreateManyInput = {
    idcapital?: number
    capital?: number | null
    fecha?: Date | string | null
    estado?: boolean | null
    autorizacion?: boolean | null
  }

  export type capital_prestamo_empleadosUpdateManyMutationInput = {
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type capital_prestamo_empleadosUncheckedUpdateManyInput = {
    idcapital?: IntFieldUpdateOperationsInput | number
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autorizacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type categoria_obsequioCreateInput = {
    categoria?: string | null
    observacion?: string | null
  }

  export type categoria_obsequioUncheckedCreateInput = {
    idcategoria?: number
    categoria?: string | null
    observacion?: string | null
  }

  export type categoria_obsequioUpdateInput = {
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoria_obsequioUncheckedUpdateInput = {
    idcategoria?: IntFieldUpdateOperationsInput | number
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoria_obsequioCreateManyInput = {
    idcategoria?: number
    categoria?: string | null
    observacion?: string | null
  }

  export type categoria_obsequioUpdateManyMutationInput = {
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoria_obsequioUncheckedUpdateManyInput = {
    idcategoria?: IntFieldUpdateOperationsInput | number
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratosCreateInput = {
    locatario1?: string | null
    dni1?: number | null
    domicilio1?: string | null
    locatario2?: string | null
    dni2?: number | null
    domicilio2?: string | null
    monto?: number | null
    fecha_inicio?: Date | string | null
    duracion?: number | null
    locador?: number | null
    operador?: string | null
    local?: string | null
    uf?: string | null
  }

  export type contratosUncheckedCreateInput = {
    idcontrato?: number
    locatario1?: string | null
    dni1?: number | null
    domicilio1?: string | null
    locatario2?: string | null
    dni2?: number | null
    domicilio2?: string | null
    monto?: number | null
    fecha_inicio?: Date | string | null
    duracion?: number | null
    locador?: number | null
    operador?: string | null
    local?: string | null
    uf?: string | null
  }

  export type contratosUpdateInput = {
    locatario1?: NullableStringFieldUpdateOperationsInput | string | null
    dni1?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio1?: NullableStringFieldUpdateOperationsInput | string | null
    locatario2?: NullableStringFieldUpdateOperationsInput | string | null
    dni2?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio2?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    locador?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratosUncheckedUpdateInput = {
    idcontrato?: IntFieldUpdateOperationsInput | number
    locatario1?: NullableStringFieldUpdateOperationsInput | string | null
    dni1?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio1?: NullableStringFieldUpdateOperationsInput | string | null
    locatario2?: NullableStringFieldUpdateOperationsInput | string | null
    dni2?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio2?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    locador?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratosCreateManyInput = {
    idcontrato?: number
    locatario1?: string | null
    dni1?: number | null
    domicilio1?: string | null
    locatario2?: string | null
    dni2?: number | null
    domicilio2?: string | null
    monto?: number | null
    fecha_inicio?: Date | string | null
    duracion?: number | null
    locador?: number | null
    operador?: string | null
    local?: string | null
    uf?: string | null
  }

  export type contratosUpdateManyMutationInput = {
    locatario1?: NullableStringFieldUpdateOperationsInput | string | null
    dni1?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio1?: NullableStringFieldUpdateOperationsInput | string | null
    locatario2?: NullableStringFieldUpdateOperationsInput | string | null
    dni2?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio2?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    locador?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contratosUncheckedUpdateManyInput = {
    idcontrato?: IntFieldUpdateOperationsInput | number
    locatario1?: NullableStringFieldUpdateOperationsInput | string | null
    dni1?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio1?: NullableStringFieldUpdateOperationsInput | string | null
    locatario2?: NullableStringFieldUpdateOperationsInput | string | null
    dni2?: NullableIntFieldUpdateOperationsInput | number | null
    domicilio2?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    locador?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    local?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type convenio_deudaCreateInput = {
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
    vencimiento1?: Date | string | null
    importe1?: number | null
    vencimiento2?: Date | string | null
    importe2?: number | null
    deuda?: number | null
    bonificacion?: number | null
    saldo?: number | null
  }

  export type convenio_deudaUncheckedCreateInput = {
    idconvdeuda?: number
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
    vencimiento1?: Date | string | null
    importe1?: number | null
    vencimiento2?: Date | string | null
    importe2?: number | null
    deuda?: number | null
    bonificacion?: number | null
    saldo?: number | null
  }

  export type convenio_deudaUpdateInput = {
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe1?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento2?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe2?: NullableIntFieldUpdateOperationsInput | number | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    bonificacion?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type convenio_deudaUncheckedUpdateInput = {
    idconvdeuda?: IntFieldUpdateOperationsInput | number
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe1?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento2?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe2?: NullableIntFieldUpdateOperationsInput | number | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    bonificacion?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type convenio_deudaCreateManyInput = {
    idconvdeuda?: number
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
    vencimiento1?: Date | string | null
    importe1?: number | null
    vencimiento2?: Date | string | null
    importe2?: number | null
    deuda?: number | null
    bonificacion?: number | null
    saldo?: number | null
  }

  export type convenio_deudaUpdateManyMutationInput = {
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe1?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento2?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe2?: NullableIntFieldUpdateOperationsInput | number | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    bonificacion?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type convenio_deudaUncheckedUpdateManyInput = {
    idconvdeuda?: IntFieldUpdateOperationsInput | number
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento1?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe1?: NullableIntFieldUpdateOperationsInput | number | null
    vencimiento2?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe2?: NullableIntFieldUpdateOperationsInput | number | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    bonificacion?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type datosCreateInput = {
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    telefono?: bigint | number | null
    celular?: number | null
    cobertura?: string | null
    grupo_familiar?: string | null
    observacion?: string | null
    operador?: string | null
    domicilio?: string | null
    fecha?: Date | string | null
  }

  export type datosUncheckedCreateInput = {
    iddato?: number
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    telefono?: bigint | number | null
    celular?: number | null
    cobertura?: string | null
    grupo_familiar?: string | null
    observacion?: string | null
    operador?: string | null
    domicilio?: string | null
    fecha?: Date | string | null
  }

  export type datosUpdateInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    celular?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    grupo_familiar?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datosUncheckedUpdateInput = {
    iddato?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    celular?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    grupo_familiar?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datosCreateManyInput = {
    iddato?: number
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    telefono?: bigint | number | null
    celular?: number | null
    cobertura?: string | null
    grupo_familiar?: string | null
    observacion?: string | null
    operador?: string | null
    domicilio?: string | null
    fecha?: Date | string | null
  }

  export type datosUpdateManyMutationInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    celular?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    grupo_familiar?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datosUncheckedUpdateManyInput = {
    iddato?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    celular?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    grupo_familiar?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datos_atencionCreateInput = {
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    motivo?: string | null
    operador?: string | null
    operadoratencion?: string | null
    fecha?: Date | string | null
  }

  export type datos_atencionUncheckedCreateInput = {
    iddatos?: number
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    motivo?: string | null
    operador?: string | null
    operadoratencion?: string | null
    fecha?: Date | string | null
  }

  export type datos_atencionUpdateInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    operadoratencion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datos_atencionUncheckedUpdateInput = {
    iddatos?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    operadoratencion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datos_atencionCreateManyInput = {
    iddatos?: number
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    motivo?: string | null
    operador?: string | null
    operadoratencion?: string | null
    fecha?: Date | string | null
  }

  export type datos_atencionUpdateManyMutationInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    operadoratencion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type datos_atencionUncheckedUpdateManyInput = {
    iddatos?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    operadoratencion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_orden_pagoCreateInput = {
    norden?: string | null
    nconsulta?: string | null
    sucursal?: string | null
    prestador?: string | null
    importe?: string | null
    operador_carga?: string | null
    fecha?: Date | string | null
  }

  export type detalle_orden_pagoUncheckedCreateInput = {
    iddetallepago?: number
    norden?: string | null
    nconsulta?: string | null
    sucursal?: string | null
    prestador?: string | null
    importe?: string | null
    operador_carga?: string | null
    fecha?: Date | string | null
  }

  export type detalle_orden_pagoUpdateInput = {
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    nconsulta?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestador?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableStringFieldUpdateOperationsInput | string | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_orden_pagoUncheckedUpdateInput = {
    iddetallepago?: IntFieldUpdateOperationsInput | number
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    nconsulta?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestador?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableStringFieldUpdateOperationsInput | string | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_orden_pagoCreateManyInput = {
    iddetallepago?: number
    norden?: string | null
    nconsulta?: string | null
    sucursal?: string | null
    prestador?: string | null
    importe?: string | null
    operador_carga?: string | null
    fecha?: Date | string | null
  }

  export type detalle_orden_pagoUpdateManyMutationInput = {
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    nconsulta?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestador?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableStringFieldUpdateOperationsInput | string | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_orden_pagoUncheckedUpdateManyInput = {
    iddetallepago?: IntFieldUpdateOperationsInput | number
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    nconsulta?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestador?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableStringFieldUpdateOperationsInput | string | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type empresasCreateInput = {
    empresa?: string | null
    cuit?: string | null
  }

  export type empresasUncheckedCreateInput = {
    idempresa?: number
    empresa?: string | null
    cuit?: string | null
  }

  export type empresasUpdateInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresasUncheckedUpdateInput = {
    idempresa?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresasCreateManyInput = {
    idempresa?: number
    empresa?: string | null
    cuit?: string | null
  }

  export type empresasUpdateManyMutationInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type empresasUncheckedUpdateManyInput = {
    idempresa?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventosCreateInput = {
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
  }

  export type eventosUncheckedCreateInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
  }

  export type eventosUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventosUncheckedUpdateInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventosCreateManyInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
  }

  export type eventosUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventosUncheckedUpdateManyInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fabricante_ataudCreateInput = {
    fabricante?: string | null
  }

  export type fabricante_ataudUncheckedCreateInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateManyInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateManyMutationInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateManyInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gestioncasoCreateInput = {
    idcaso?: number | null
    contrato?: number | null
    operador?: string | null
    accion?: string | null
    observacion?: string | null
    fechaaccion?: string | null
    nuevaaccion?: string | null
    fechanuevaaccion?: string | null
    realizado?: boolean | null
    observacion_nuevaaccion?: string | null
  }

  export type gestioncasoUncheckedCreateInput = {
    idgestion?: number
    idcaso?: number | null
    contrato?: number | null
    operador?: string | null
    accion?: string | null
    observacion?: string | null
    fechaaccion?: string | null
    nuevaaccion?: string | null
    fechanuevaaccion?: string | null
    realizado?: boolean | null
    observacion_nuevaaccion?: string | null
  }

  export type gestioncasoUpdateInput = {
    idcaso?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechanuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    realizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion_nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gestioncasoUncheckedUpdateInput = {
    idgestion?: IntFieldUpdateOperationsInput | number
    idcaso?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechanuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    realizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion_nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gestioncasoCreateManyInput = {
    idgestion?: number
    idcaso?: number | null
    contrato?: number | null
    operador?: string | null
    accion?: string | null
    observacion?: string | null
    fechaaccion?: string | null
    nuevaaccion?: string | null
    fechanuevaaccion?: string | null
    realizado?: boolean | null
    observacion_nuevaaccion?: string | null
  }

  export type gestioncasoUpdateManyMutationInput = {
    idcaso?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechanuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    realizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion_nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gestioncasoUncheckedUpdateManyInput = {
    idgestion?: IntFieldUpdateOperationsInput | number
    idcaso?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechanuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
    realizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    observacion_nuevaaccion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_accionesCreateInput = {
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_accionesUncheckedCreateInput = {
    idhistorial?: number
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_accionesUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_accionesUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_accionesCreateManyInput = {
    idhistorial?: number
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_accionesUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_accionesUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_aprobacion_prestamosCreateInput = {
    operador?: string | null
    idprestamo?: number | null
    fecha?: Date | string | null
    contrato?: number | null
    afiliado?: string | null
    productor?: number | null
  }

  export type historial_aprobacion_prestamosUncheckedCreateInput = {
    idaprobacion?: number
    operador?: string | null
    idprestamo?: number | null
    fecha?: Date | string | null
    contrato?: number | null
    afiliado?: string | null
    productor?: number | null
  }

  export type historial_aprobacion_prestamosUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    afiliado?: NullableStringFieldUpdateOperationsInput | string | null
    productor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_aprobacion_prestamosUncheckedUpdateInput = {
    idaprobacion?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    afiliado?: NullableStringFieldUpdateOperationsInput | string | null
    productor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_aprobacion_prestamosCreateManyInput = {
    idaprobacion?: number
    operador?: string | null
    idprestamo?: number | null
    fecha?: Date | string | null
    contrato?: number | null
    afiliado?: string | null
    productor?: number | null
  }

  export type historial_aprobacion_prestamosUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    afiliado?: NullableStringFieldUpdateOperationsInput | string | null
    productor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_aprobacion_prestamosUncheckedUpdateManyInput = {
    idaprobacion?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    afiliado?: NullableStringFieldUpdateOperationsInput | string | null
    productor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_liquidacionesCreateInput = {
    operador?: string | null
    fecha?: string | null
    mes?: number | null
    ano?: number | null
    cobranza?: number | null
    total?: number | null
    comision?: number | null
    entidad?: string | null
  }

  export type historial_liquidacionesUncheckedCreateInput = {
    idliquidacion?: number
    operador?: string | null
    fecha?: string | null
    mes?: number | null
    ano?: number | null
    cobranza?: number | null
    total?: number | null
    comision?: number | null
    entidad?: string | null
  }

  export type historial_liquidacionesUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    cobranza?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_liquidacionesUncheckedUpdateInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    cobranza?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_liquidacionesCreateManyInput = {
    idliquidacion?: number
    operador?: string | null
    fecha?: string | null
    mes?: number | null
    ano?: number | null
    cobranza?: number | null
    total?: number | null
    comision?: number | null
    entidad?: string | null
  }

  export type historial_liquidacionesUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    cobranza?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_liquidacionesUncheckedUpdateManyInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    cobranza?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    entidad?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type intereses_tarjetasCreateInput = {
    plan_cuota?: number | null
    interes?: number | null
    tarjeta?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type intereses_tarjetasUncheckedCreateInput = {
    idplan?: number
    plan_cuota?: number | null
    interes?: number | null
    tarjeta?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type intereses_tarjetasUpdateInput = {
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    interes?: NullableFloatFieldUpdateOperationsInput | number | null
    tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type intereses_tarjetasUncheckedUpdateInput = {
    idplan?: IntFieldUpdateOperationsInput | number
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    interes?: NullableFloatFieldUpdateOperationsInput | number | null
    tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type intereses_tarjetasCreateManyInput = {
    idplan?: number
    plan_cuota?: number | null
    interes?: number | null
    tarjeta?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type intereses_tarjetasUpdateManyMutationInput = {
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    interes?: NullableFloatFieldUpdateOperationsInput | number | null
    tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type intereses_tarjetasUncheckedUpdateManyInput = {
    idplan?: IntFieldUpdateOperationsInput | number
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    interes?: NullableFloatFieldUpdateOperationsInput | number | null
    tarjeta?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type legajo_virtualCreateInput = {
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    tipoarchivo?: string | null
  }

  export type legajo_virtualUncheckedCreateInput = {
    idlegajo?: number
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    tipoarchivo?: string | null
  }

  export type legajo_virtualUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipoarchivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtualUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipoarchivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtualCreateManyInput = {
    idlegajo?: number
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    tipoarchivo?: string | null
  }

  export type legajo_virtualUpdateManyMutationInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipoarchivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtualUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipoarchivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_cajasCreateInput = {
    idcaja?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_cajasUncheckedCreateInput = {
    idlegajo?: number
    idcaja?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_cajasUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_cajasUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_cajasCreateManyInput = {
    idlegajo?: number
    idcaja?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_cajasUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_cajasUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_ordenesCreateInput = {
    idorden?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_ordenesUncheckedCreateInput = {
    idlegajo?: number
    idorden?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_ordenesUpdateInput = {
    idorden?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_ordenesUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idorden?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_ordenesCreateManyInput = {
    idlegajo?: number
    idorden?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_ordenesUpdateManyMutationInput = {
    idorden?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_ordenesUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idorden?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_personalCreateInput = {
    idpersonal?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_personalUncheckedCreateInput = {
    idlegajo?: number
    idpersonal?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_personalUpdateInput = {
    idpersonal?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_personalUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idpersonal?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_personalCreateManyInput = {
    idlegajo?: number
    idpersonal?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_personalUpdateManyMutationInput = {
    idpersonal?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_personalUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    idpersonal?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_prestamosCreateInput = {
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    cod_ptm_leg?: string | null
  }

  export type legajo_virtual_prestamosUncheckedCreateInput = {
    idlegajo?: number
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    cod_ptm_leg?: string | null
  }

  export type legajo_virtual_prestamosUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cod_ptm_leg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_prestamosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cod_ptm_leg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_prestamosCreateManyInput = {
    idlegajo?: number
    contrato?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
    cod_ptm_leg?: string | null
  }

  export type legajo_virtual_prestamosUpdateManyMutationInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cod_ptm_leg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_prestamosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    cod_ptm_leg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locadorCreateInput = {
    dni: number
    apellido: string
    nombre: string
    domicilio: string
    barrio?: string | null
    localidad: string
    provincia: string
  }

  export type locadorUncheckedCreateInput = {
    dni: number
    apellido: string
    nombre: string
    domicilio: string
    barrio?: string | null
    localidad: string
    provincia: string
  }

  export type locadorUpdateInput = {
    dni?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type locadorUncheckedUpdateInput = {
    dni?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type locadorCreateManyInput = {
    dni: number
    apellido: string
    nombre: string
    domicilio: string
    barrio?: string | null
    localidad: string
    provincia: string
  }

  export type locadorUpdateManyMutationInput = {
    dni?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type locadorUncheckedUpdateManyInput = {
    dni?: IntFieldUpdateOperationsInput | number
    apellido?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    domicilio?: StringFieldUpdateOperationsInput | string
    barrio?: NullableStringFieldUpdateOperationsInput | string | null
    localidad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type mailsCreateInput = {
    fecha?: Date | string | null
    envia?: string | null
    recibe?: string | null
    descrip?: string | null
    codmail?: string | null
    asunto?: string | null
    leido?: boolean | null
    fecha_leido?: Date | string | null
    url_caja?: string | null
  }

  export type mailsUncheckedCreateInput = {
    idmail?: number
    fecha?: Date | string | null
    envia?: string | null
    recibe?: string | null
    descrip?: string | null
    codmail?: string | null
    asunto?: string | null
    leido?: boolean | null
    fecha_leido?: Date | string | null
    url_caja?: string | null
  }

  export type mailsUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envia?: NullableStringFieldUpdateOperationsInput | string | null
    recibe?: NullableStringFieldUpdateOperationsInput | string | null
    descrip?: NullableStringFieldUpdateOperationsInput | string | null
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_leido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url_caja?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mailsUncheckedUpdateInput = {
    idmail?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envia?: NullableStringFieldUpdateOperationsInput | string | null
    recibe?: NullableStringFieldUpdateOperationsInput | string | null
    descrip?: NullableStringFieldUpdateOperationsInput | string | null
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_leido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url_caja?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mailsCreateManyInput = {
    idmail?: number
    fecha?: Date | string | null
    envia?: string | null
    recibe?: string | null
    descrip?: string | null
    codmail?: string | null
    asunto?: string | null
    leido?: boolean | null
    fecha_leido?: Date | string | null
    url_caja?: string | null
  }

  export type mailsUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envia?: NullableStringFieldUpdateOperationsInput | string | null
    recibe?: NullableStringFieldUpdateOperationsInput | string | null
    descrip?: NullableStringFieldUpdateOperationsInput | string | null
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_leido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url_caja?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mailsUncheckedUpdateManyInput = {
    idmail?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envia?: NullableStringFieldUpdateOperationsInput | string | null
    recibe?: NullableStringFieldUpdateOperationsInput | string | null
    descrip?: NullableStringFieldUpdateOperationsInput | string | null
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_leido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url_caja?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mails_adjuntosCreateInput = {
    codmail?: string | null
    adjunto?: string | null
    tipo?: string | null
  }

  export type mails_adjuntosUncheckedCreateInput = {
    idadjunto?: number
    codmail?: string | null
    adjunto?: string | null
    tipo?: string | null
  }

  export type mails_adjuntosUpdateInput = {
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    adjunto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mails_adjuntosUncheckedUpdateInput = {
    idadjunto?: IntFieldUpdateOperationsInput | number
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    adjunto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mails_adjuntosCreateManyInput = {
    idadjunto?: number
    codmail?: string | null
    adjunto?: string | null
    tipo?: string | null
  }

  export type mails_adjuntosUpdateManyMutationInput = {
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    adjunto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mails_adjuntosUncheckedUpdateManyInput = {
    idadjunto?: IntFieldUpdateOperationsInput | number
    codmail?: NullableStringFieldUpdateOperationsInput | string | null
    adjunto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mbanconvCreateInput = {
    tipo?: string | null
    mora?: number | null
    fichas?: number | null
    morarec?: number | null
    fichasrec?: number | null
    mes?: number | null
    ano?: number | null
  }

  export type mbanconvUncheckedCreateInput = {
    id_mora?: number
    tipo?: string | null
    mora?: number | null
    fichas?: number | null
    morarec?: number | null
    fichasrec?: number | null
    mes?: number | null
    ano?: number | null
  }

  export type mbanconvUpdateInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    mora?: NullableIntFieldUpdateOperationsInput | number | null
    fichas?: NullableIntFieldUpdateOperationsInput | number | null
    morarec?: NullableIntFieldUpdateOperationsInput | number | null
    fichasrec?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mbanconvUncheckedUpdateInput = {
    id_mora?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    mora?: NullableIntFieldUpdateOperationsInput | number | null
    fichas?: NullableIntFieldUpdateOperationsInput | number | null
    morarec?: NullableIntFieldUpdateOperationsInput | number | null
    fichasrec?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mbanconvCreateManyInput = {
    id_mora?: number
    tipo?: string | null
    mora?: number | null
    fichas?: number | null
    morarec?: number | null
    fichasrec?: number | null
    mes?: number | null
    ano?: number | null
  }

  export type mbanconvUpdateManyMutationInput = {
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    mora?: NullableIntFieldUpdateOperationsInput | number | null
    fichas?: NullableIntFieldUpdateOperationsInput | number | null
    morarec?: NullableIntFieldUpdateOperationsInput | number | null
    fichasrec?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mbanconvUncheckedUpdateManyInput = {
    id_mora?: IntFieldUpdateOperationsInput | number
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    mora?: NullableIntFieldUpdateOperationsInput | number | null
    fichas?: NullableIntFieldUpdateOperationsInput | number | null
    morarec?: NullableIntFieldUpdateOperationsInput | number | null
    fichasrec?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movimiento_caja_sucursalesCreateInput = {
    fecha_carga?: Date | string | null
    fecha_movimiento?: Date | string | null
    sucursal?: string | null
    concepto?: string | null
    movimiento?: string | null
    importe?: number | null
    operador_carga?: string | null
    idcaja?: number | null
    empresa?: string | null
  }

  export type movimiento_caja_sucursalesUncheckedCreateInput = {
    idmovimiento?: number
    fecha_carga?: Date | string | null
    fecha_movimiento?: Date | string | null
    sucursal?: string | null
    concepto?: string | null
    movimiento?: string | null
    importe?: number | null
    operador_carga?: string | null
    idcaja?: number | null
    empresa?: string | null
  }

  export type movimiento_caja_sucursalesUpdateInput = {
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type movimiento_caja_sucursalesUncheckedUpdateInput = {
    idmovimiento?: IntFieldUpdateOperationsInput | number
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type movimiento_caja_sucursalesCreateManyInput = {
    idmovimiento?: number
    fecha_carga?: Date | string | null
    fecha_movimiento?: Date | string | null
    sucursal?: string | null
    concepto?: string | null
    movimiento?: string | null
    importe?: number | null
    operador_carga?: string | null
    idcaja?: number | null
    empresa?: string | null
  }

  export type movimiento_caja_sucursalesUpdateManyMutationInput = {
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type movimiento_caja_sucursalesUncheckedUpdateManyInput = {
    idmovimiento?: IntFieldUpdateOperationsInput | number
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_movimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type noticiaCreateInput = {
    fecha?: Date | string | null
    noticia?: string | null
    operador?: string | null
    perfil?: number | null
  }

  export type noticiaUncheckedCreateInput = {
    idnoticia?: number
    fecha?: Date | string | null
    noticia?: string | null
    operador?: string | null
    perfil?: number | null
  }

  export type noticiaUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticia?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noticiaUncheckedUpdateInput = {
    idnoticia?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticia?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noticiaCreateManyInput = {
    idnoticia?: number
    fecha?: Date | string | null
    noticia?: string | null
    operador?: string | null
    perfil?: number | null
  }

  export type noticiaUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticia?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type noticiaUncheckedUpdateManyInput = {
    idnoticia?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticia?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type novedadesCreateInput = {
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type novedadesUncheckedCreateInput = {
    idnovedades?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type novedadesUpdateInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type novedadesUncheckedUpdateInput = {
    idnovedades?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type novedadesCreateManyInput = {
    idnovedades?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type novedadesUpdateManyMutationInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type novedadesUncheckedUpdateManyInput = {
    idnovedades?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type obsequiosCreateInput = {
    producto?: string | null
    marca?: string | null
    categoria?: string | null
    precio?: number | null
    stock?: number | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
    fecha_reposicion?: string | null
    operador_rep?: string | null
  }

  export type obsequiosUncheckedCreateInput = {
    idobsequio?: number
    producto?: string | null
    marca?: string | null
    categoria?: string | null
    precio?: number | null
    stock?: number | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
    fecha_reposicion?: string | null
    operador_rep?: string | null
  }

  export type obsequiosUpdateInput = {
    producto?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_reposicion?: NullableStringFieldUpdateOperationsInput | string | null
    operador_rep?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type obsequiosUncheckedUpdateInput = {
    idobsequio?: IntFieldUpdateOperationsInput | number
    producto?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_reposicion?: NullableStringFieldUpdateOperationsInput | string | null
    operador_rep?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type obsequiosCreateManyInput = {
    idobsequio?: number
    producto?: string | null
    marca?: string | null
    categoria?: string | null
    precio?: number | null
    stock?: number | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
    fecha_reposicion?: string | null
    operador_rep?: string | null
  }

  export type obsequiosUpdateManyMutationInput = {
    producto?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_reposicion?: NullableStringFieldUpdateOperationsInput | string | null
    operador_rep?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type obsequiosUncheckedUpdateManyInput = {
    idobsequio?: IntFieldUpdateOperationsInput | number
    producto?: NullableStringFieldUpdateOperationsInput | string | null
    marca?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_reposicion?: NullableStringFieldUpdateOperationsInput | string | null
    operador_rep?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type openia_keysCreateInput = {
    key?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type openia_keysUncheckedCreateInput = {
    idkey?: number
    key?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type openia_keysUpdateInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type openia_keysUncheckedUpdateInput = {
    idkey?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type openia_keysCreateManyInput = {
    idkey?: number
    key?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type openia_keysUpdateManyMutationInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type openia_keysUncheckedUpdateManyInput = {
    idkey?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type operadorCreateInput = {
    nombre: string
    apellido: string
    usuario: string
    contrasena: string
    createdAt: Date | string
    updatedAt: Date | string
    puestom?: number | null
    perfil?: number | null
    estado?: boolean | null
    puestow?: number | null
    codigo?: number | null
    medicos?: boolean | null
    sucursal?: string | null
    prestamos?: boolean | null
    ordenpago?: boolean | null
    clubwerchow?: boolean | null
    ventas?: boolean | null
    administracion?: boolean | null
    campanas?: boolean | null
    socios?: boolean | null
    sepelio?: boolean | null
  }

  export type operadorUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    usuario: string
    contrasena: string
    createdAt: Date | string
    updatedAt: Date | string
    puestom?: number | null
    perfil?: number | null
    estado?: boolean | null
    puestow?: number | null
    codigo?: number | null
    medicos?: boolean | null
    sucursal?: string | null
    prestamos?: boolean | null
    ordenpago?: boolean | null
    clubwerchow?: boolean | null
    ventas?: boolean | null
    administracion?: boolean | null
    campanas?: boolean | null
    socios?: boolean | null
    sepelio?: boolean | null
  }

  export type operadorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    puestom?: NullableIntFieldUpdateOperationsInput | number | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    puestow?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    medicos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestamos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordenpago?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clubwerchow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ventas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    administracion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campanas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socios?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sepelio?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type operadorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    puestom?: NullableIntFieldUpdateOperationsInput | number | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    puestow?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    medicos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestamos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordenpago?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clubwerchow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ventas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    administracion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campanas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socios?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sepelio?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type operadorCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    usuario: string
    contrasena: string
    createdAt: Date | string
    updatedAt: Date | string
    puestom?: number | null
    perfil?: number | null
    estado?: boolean | null
    puestow?: number | null
    codigo?: number | null
    medicos?: boolean | null
    sucursal?: string | null
    prestamos?: boolean | null
    ordenpago?: boolean | null
    clubwerchow?: boolean | null
    ventas?: boolean | null
    administracion?: boolean | null
    campanas?: boolean | null
    socios?: boolean | null
    sepelio?: boolean | null
  }

  export type operadorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    puestom?: NullableIntFieldUpdateOperationsInput | number | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    puestow?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    medicos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestamos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordenpago?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clubwerchow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ventas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    administracion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campanas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socios?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sepelio?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type operadorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    puestom?: NullableIntFieldUpdateOperationsInput | number | null
    perfil?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    puestow?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    medicos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    prestamos?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ordenpago?: NullableBoolFieldUpdateOperationsInput | boolean | null
    clubwerchow?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ventas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    administracion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campanas?: NullableBoolFieldUpdateOperationsInput | boolean | null
    socios?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sepelio?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordenes_pagoCreateInput = {
    fecha?: Date | string | null
    proveedor?: string | null
    cuit_cuil?: string | null
    total?: number | null
    operador_carga?: string | null
    autorizado?: boolean | null
    operador_autorizacion?: string | null
    fecha_autorizacion?: Date | string | null
    norden?: string | null
    observacion?: string | null
    nombre?: string | null
    tipo_orden?: string | null
    nfactura?: string | null
    tipo_factura?: string | null
    fecha_pago?: Date | string | null
    pagado?: boolean | null
    estado?: boolean | null
  }

  export type ordenes_pagoUncheckedCreateInput = {
    idorden?: number
    fecha?: Date | string | null
    proveedor?: string | null
    cuit_cuil?: string | null
    total?: number | null
    operador_carga?: string | null
    autorizado?: boolean | null
    operador_autorizacion?: string | null
    fecha_autorizacion?: Date | string | null
    norden?: string | null
    observacion?: string | null
    nombre?: string | null
    tipo_orden?: string | null
    nfactura?: string | null
    tipo_factura?: string | null
    fecha_pago?: Date | string | null
    pagado?: boolean | null
    estado?: boolean | null
  }

  export type ordenes_pagoUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    cuit_cuil?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    autorizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador_autorizacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_autorizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_orden?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordenes_pagoUncheckedUpdateInput = {
    idorden?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    cuit_cuil?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    autorizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador_autorizacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_autorizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_orden?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordenes_pagoCreateManyInput = {
    idorden?: number
    fecha?: Date | string | null
    proveedor?: string | null
    cuit_cuil?: string | null
    total?: number | null
    operador_carga?: string | null
    autorizado?: boolean | null
    operador_autorizacion?: string | null
    fecha_autorizacion?: Date | string | null
    norden?: string | null
    observacion?: string | null
    nombre?: string | null
    tipo_orden?: string | null
    nfactura?: string | null
    tipo_factura?: string | null
    fecha_pago?: Date | string | null
    pagado?: boolean | null
    estado?: boolean | null
  }

  export type ordenes_pagoUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    cuit_cuil?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    autorizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador_autorizacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_autorizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_orden?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ordenes_pagoUncheckedUpdateManyInput = {
    idorden?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    cuit_cuil?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    operador_carga?: NullableStringFieldUpdateOperationsInput | string | null
    autorizado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador_autorizacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_autorizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    norden?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_orden?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pagado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type personalCreateInput = {
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    alta?: Date | string | null
    rol?: string | null
    legajo?: string | null
    baja?: Date | string | null
  }

  export type personalUncheckedCreateInput = {
    idpersonal?: number
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    alta?: Date | string | null
    rol?: string | null
    legajo?: string | null
    baja?: Date | string | null
  }

  export type personalUpdateInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    legajo?: NullableStringFieldUpdateOperationsInput | string | null
    baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personalUncheckedUpdateInput = {
    idpersonal?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    legajo?: NullableStringFieldUpdateOperationsInput | string | null
    baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personalCreateManyInput = {
    idpersonal?: number
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    alta?: Date | string | null
    rol?: string | null
    legajo?: string | null
    baja?: Date | string | null
  }

  export type personalUpdateManyMutationInput = {
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    legajo?: NullableStringFieldUpdateOperationsInput | string | null
    baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personalUncheckedUpdateManyInput = {
    idpersonal?: IntFieldUpdateOperationsInput | number
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rol?: NullableStringFieldUpdateOperationsInput | string | null
    legajo?: NullableStringFieldUpdateOperationsInput | string | null
    baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plan_cuentasCreateInput = {
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentasUncheckedCreateInput = {
    idcuenta?: number
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentasUpdateInput = {
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentasUncheckedUpdateInput = {
    idcuenta?: IntFieldUpdateOperationsInput | number
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentasCreateManyInput = {
    idcuenta?: number
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentasUpdateManyMutationInput = {
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentasUncheckedUpdateManyInput = {
    idcuenta?: IntFieldUpdateOperationsInput | number
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentas_xCreateInput = {
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentas_xUncheckedCreateInput = {
    idcuenta?: number
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentas_xUpdateInput = {
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentas_xUncheckedUpdateInput = {
    idcuenta?: IntFieldUpdateOperationsInput | number
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentas_xCreateManyInput = {
    idcuenta?: number
    idempresa?: number | null
    codigo?: number | null
    descripcion?: string | null
    asiento?: number | null
    tipo?: string | null
  }

  export type plan_cuentas_xUpdateManyMutationInput = {
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_cuentas_xUncheckedUpdateManyInput = {
    idcuenta?: IntFieldUpdateOperationsInput | number
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asiento?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_detalleCreateInput = {
    detalle?: string | null
    cuota?: number | null
    sub_ext?: boolean | null
    vigencia?: string | null
    id_plan?: number | null
  }

  export type plan_detalleUncheckedCreateInput = {
    id_plandetalle?: number
    detalle?: string | null
    cuota?: number | null
    sub_ext?: boolean | null
    vigencia?: string | null
    id_plan?: number | null
  }

  export type plan_detalleUpdateInput = {
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    sub_ext?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vigencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type plan_detalleUncheckedUpdateInput = {
    id_plandetalle?: IntFieldUpdateOperationsInput | number
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    sub_ext?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vigencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type plan_detalleCreateManyInput = {
    id_plandetalle?: number
    detalle?: string | null
    cuota?: number | null
    sub_ext?: boolean | null
    vigencia?: string | null
    id_plan?: number | null
  }

  export type plan_detalleUpdateManyMutationInput = {
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    sub_ext?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vigencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type plan_detalleUncheckedUpdateManyInput = {
    id_plandetalle?: IntFieldUpdateOperationsInput | number
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    sub_ext?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vigencia?: NullableStringFieldUpdateOperationsInput | string | null
    id_plan?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type plan_precioCreateInput = {
    plan?: string | null
    tipo_plan?: string | null
    codigo?: string | null
  }

  export type plan_precioUncheckedCreateInput = {
    id_plan?: number
    plan?: string | null
    tipo_plan?: string | null
    codigo?: string | null
  }

  export type plan_precioUpdateInput = {
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plan?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_precioUncheckedUpdateInput = {
    id_plan?: IntFieldUpdateOperationsInput | number
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plan?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_precioCreateManyInput = {
    id_plan?: number
    plan?: string | null
    tipo_plan?: string | null
    codigo?: string | null
  }

  export type plan_precioUpdateManyMutationInput = {
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plan?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plan_precioUncheckedUpdateManyInput = {
    id_plan?: IntFieldUpdateOperationsInput | number
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_plan?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type porcentaje_liqCreateInput = {
    porcliq_nombre?: string | null
    porcliq_descrip?: string | null
    porcliq_cuotas?: number | null
    porcliq_porcentaje?: number | null
  }

  export type porcentaje_liqUncheckedCreateInput = {
    porcliq_id?: number
    porcliq_nombre?: string | null
    porcliq_descrip?: string | null
    porcliq_cuotas?: number | null
    porcliq_porcentaje?: number | null
  }

  export type porcentaje_liqUpdateInput = {
    porcliq_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_descrip?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    porcliq_porcentaje?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type porcentaje_liqUncheckedUpdateInput = {
    porcliq_id?: IntFieldUpdateOperationsInput | number
    porcliq_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_descrip?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    porcliq_porcentaje?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type porcentaje_liqCreateManyInput = {
    porcliq_id?: number
    porcliq_nombre?: string | null
    porcliq_descrip?: string | null
    porcliq_cuotas?: number | null
    porcliq_porcentaje?: number | null
  }

  export type porcentaje_liqUpdateManyMutationInput = {
    porcliq_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_descrip?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    porcliq_porcentaje?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type porcentaje_liqUncheckedUpdateManyInput = {
    porcliq_id?: IntFieldUpdateOperationsInput | number
    porcliq_nombre?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_descrip?: NullableStringFieldUpdateOperationsInput | string | null
    porcliq_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    porcliq_porcentaje?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prestamos_empleadosCreateInput = {
    empleado?: string | null
    fecha_solicitud?: Date | string | null
    capital?: number | null
    plan_cuotas?: number | null
    cuota_mensual?: number | null
    capital_dev?: number | null
    inicia?: string | null
    termina?: string | null
    estado?: string | null
    capinoaut?: boolean | null
  }

  export type prestamos_empleadosUncheckedCreateInput = {
    idprestamo?: number
    empleado?: string | null
    fecha_solicitud?: Date | string | null
    capital?: number | null
    plan_cuotas?: number | null
    cuota_mensual?: number | null
    capital_dev?: number | null
    inicia?: string | null
    termina?: string | null
    estado?: string | null
    capinoaut?: boolean | null
  }

  export type prestamos_empleadosUpdateInput = {
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_solicitud?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    cuota_mensual?: NullableFloatFieldUpdateOperationsInput | number | null
    capital_dev?: NullableFloatFieldUpdateOperationsInput | number | null
    inicia?: NullableStringFieldUpdateOperationsInput | string | null
    termina?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    capinoaut?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_empleadosUncheckedUpdateInput = {
    idprestamo?: IntFieldUpdateOperationsInput | number
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_solicitud?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    cuota_mensual?: NullableFloatFieldUpdateOperationsInput | number | null
    capital_dev?: NullableFloatFieldUpdateOperationsInput | number | null
    inicia?: NullableStringFieldUpdateOperationsInput | string | null
    termina?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    capinoaut?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_empleadosCreateManyInput = {
    idprestamo?: number
    empleado?: string | null
    fecha_solicitud?: Date | string | null
    capital?: number | null
    plan_cuotas?: number | null
    cuota_mensual?: number | null
    capital_dev?: number | null
    inicia?: string | null
    termina?: string | null
    estado?: string | null
    capinoaut?: boolean | null
  }

  export type prestamos_empleadosUpdateManyMutationInput = {
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_solicitud?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    cuota_mensual?: NullableFloatFieldUpdateOperationsInput | number | null
    capital_dev?: NullableFloatFieldUpdateOperationsInput | number | null
    inicia?: NullableStringFieldUpdateOperationsInput | string | null
    termina?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    capinoaut?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_empleadosUncheckedUpdateManyInput = {
    idprestamo?: IntFieldUpdateOperationsInput | number
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_solicitud?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capital?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    cuota_mensual?: NullableFloatFieldUpdateOperationsInput | number | null
    capital_dev?: NullableFloatFieldUpdateOperationsInput | number | null
    inicia?: NullableStringFieldUpdateOperationsInput | string | null
    termina?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    capinoaut?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_empleados_cobroCreateInput = {
    idprestamo?: number | null
    cuota?: number | null
    importe?: number | null
    fecha_cobro?: Date | string | null
    estado?: boolean | null
    fecha_pago?: Date | string | null
    operador?: string | null
  }

  export type prestamos_empleados_cobroUncheckedCreateInput = {
    idpago?: number
    idprestamo?: number | null
    cuota?: number | null
    importe?: number | null
    fecha_cobro?: Date | string | null
    estado?: boolean | null
    fecha_pago?: Date | string | null
    operador?: string | null
  }

  export type prestamos_empleados_cobroUpdateInput = {
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_cobro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prestamos_empleados_cobroUncheckedUpdateInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_cobro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prestamos_empleados_cobroCreateManyInput = {
    idpago?: number
    idprestamo?: number | null
    cuota?: number | null
    importe?: number | null
    fecha_cobro?: Date | string | null
    estado?: boolean | null
    fecha_pago?: Date | string | null
    operador?: string | null
  }

  export type prestamos_empleados_cobroUpdateManyMutationInput = {
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_cobro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prestamos_empleados_cobroUncheckedUpdateManyInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    idprestamo?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_cobro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type produccionCreateInput = {
    prod_fechacarga?: Date | string | null
    prod_fechaafi?: Date | string | null
    prod_asesor?: number | null
    prod_empre?: string | null
    prod_mes?: string | null
    prod_anio?: number | null
    prod_apeafi?: string | null
    prod_nomafi?: string | null
    prod_dniafi?: number | null
    prod_local?: number | null
    prod_recibo?: number | null
    prod_monto?: number | null
    prod_plan?: string | null
    prod_pago?: string | null
    prod_cta_tar?: bigint | number | null
    prod_obs?: string | null
    prod_semana?: number | null
    prod_estado?: string | null
    prod_cierre?: number | null
    prod_afiliado?: number | null
    prod_rendido?: string | null
    prod_recibosis?: number | null
    prod_fechren?: Date | string | null
    prod_tel?: string | null
  }

  export type produccionUncheckedCreateInput = {
    prod_ide?: number
    prod_fechacarga?: Date | string | null
    prod_fechaafi?: Date | string | null
    prod_asesor?: number | null
    prod_empre?: string | null
    prod_mes?: string | null
    prod_anio?: number | null
    prod_apeafi?: string | null
    prod_nomafi?: string | null
    prod_dniafi?: number | null
    prod_local?: number | null
    prod_recibo?: number | null
    prod_monto?: number | null
    prod_plan?: string | null
    prod_pago?: string | null
    prod_cta_tar?: bigint | number | null
    prod_obs?: string | null
    prod_semana?: number | null
    prod_estado?: string | null
    prod_cierre?: number | null
    prod_afiliado?: number | null
    prod_rendido?: string | null
    prod_recibosis?: number | null
    prod_fechren?: Date | string | null
    prod_tel?: string | null
  }

  export type produccionUpdateInput = {
    prod_fechacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_fechaafi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_asesor?: NullableIntFieldUpdateOperationsInput | number | null
    prod_empre?: NullableStringFieldUpdateOperationsInput | string | null
    prod_mes?: NullableStringFieldUpdateOperationsInput | string | null
    prod_anio?: NullableIntFieldUpdateOperationsInput | number | null
    prod_apeafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_nomafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_dniafi?: NullableIntFieldUpdateOperationsInput | number | null
    prod_local?: NullableIntFieldUpdateOperationsInput | number | null
    prod_recibo?: NullableIntFieldUpdateOperationsInput | number | null
    prod_monto?: NullableFloatFieldUpdateOperationsInput | number | null
    prod_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prod_pago?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cta_tar?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    prod_obs?: NullableStringFieldUpdateOperationsInput | string | null
    prod_semana?: NullableIntFieldUpdateOperationsInput | number | null
    prod_estado?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cierre?: NullableIntFieldUpdateOperationsInput | number | null
    prod_afiliado?: NullableIntFieldUpdateOperationsInput | number | null
    prod_rendido?: NullableStringFieldUpdateOperationsInput | string | null
    prod_recibosis?: NullableIntFieldUpdateOperationsInput | number | null
    prod_fechren?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_tel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type produccionUncheckedUpdateInput = {
    prod_ide?: IntFieldUpdateOperationsInput | number
    prod_fechacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_fechaafi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_asesor?: NullableIntFieldUpdateOperationsInput | number | null
    prod_empre?: NullableStringFieldUpdateOperationsInput | string | null
    prod_mes?: NullableStringFieldUpdateOperationsInput | string | null
    prod_anio?: NullableIntFieldUpdateOperationsInput | number | null
    prod_apeafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_nomafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_dniafi?: NullableIntFieldUpdateOperationsInput | number | null
    prod_local?: NullableIntFieldUpdateOperationsInput | number | null
    prod_recibo?: NullableIntFieldUpdateOperationsInput | number | null
    prod_monto?: NullableFloatFieldUpdateOperationsInput | number | null
    prod_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prod_pago?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cta_tar?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    prod_obs?: NullableStringFieldUpdateOperationsInput | string | null
    prod_semana?: NullableIntFieldUpdateOperationsInput | number | null
    prod_estado?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cierre?: NullableIntFieldUpdateOperationsInput | number | null
    prod_afiliado?: NullableIntFieldUpdateOperationsInput | number | null
    prod_rendido?: NullableStringFieldUpdateOperationsInput | string | null
    prod_recibosis?: NullableIntFieldUpdateOperationsInput | number | null
    prod_fechren?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_tel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type produccionCreateManyInput = {
    prod_ide?: number
    prod_fechacarga?: Date | string | null
    prod_fechaafi?: Date | string | null
    prod_asesor?: number | null
    prod_empre?: string | null
    prod_mes?: string | null
    prod_anio?: number | null
    prod_apeafi?: string | null
    prod_nomafi?: string | null
    prod_dniafi?: number | null
    prod_local?: number | null
    prod_recibo?: number | null
    prod_monto?: number | null
    prod_plan?: string | null
    prod_pago?: string | null
    prod_cta_tar?: bigint | number | null
    prod_obs?: string | null
    prod_semana?: number | null
    prod_estado?: string | null
    prod_cierre?: number | null
    prod_afiliado?: number | null
    prod_rendido?: string | null
    prod_recibosis?: number | null
    prod_fechren?: Date | string | null
    prod_tel?: string | null
  }

  export type produccionUpdateManyMutationInput = {
    prod_fechacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_fechaafi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_asesor?: NullableIntFieldUpdateOperationsInput | number | null
    prod_empre?: NullableStringFieldUpdateOperationsInput | string | null
    prod_mes?: NullableStringFieldUpdateOperationsInput | string | null
    prod_anio?: NullableIntFieldUpdateOperationsInput | number | null
    prod_apeafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_nomafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_dniafi?: NullableIntFieldUpdateOperationsInput | number | null
    prod_local?: NullableIntFieldUpdateOperationsInput | number | null
    prod_recibo?: NullableIntFieldUpdateOperationsInput | number | null
    prod_monto?: NullableFloatFieldUpdateOperationsInput | number | null
    prod_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prod_pago?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cta_tar?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    prod_obs?: NullableStringFieldUpdateOperationsInput | string | null
    prod_semana?: NullableIntFieldUpdateOperationsInput | number | null
    prod_estado?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cierre?: NullableIntFieldUpdateOperationsInput | number | null
    prod_afiliado?: NullableIntFieldUpdateOperationsInput | number | null
    prod_rendido?: NullableStringFieldUpdateOperationsInput | string | null
    prod_recibosis?: NullableIntFieldUpdateOperationsInput | number | null
    prod_fechren?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_tel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type produccionUncheckedUpdateManyInput = {
    prod_ide?: IntFieldUpdateOperationsInput | number
    prod_fechacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_fechaafi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_asesor?: NullableIntFieldUpdateOperationsInput | number | null
    prod_empre?: NullableStringFieldUpdateOperationsInput | string | null
    prod_mes?: NullableStringFieldUpdateOperationsInput | string | null
    prod_anio?: NullableIntFieldUpdateOperationsInput | number | null
    prod_apeafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_nomafi?: NullableStringFieldUpdateOperationsInput | string | null
    prod_dniafi?: NullableIntFieldUpdateOperationsInput | number | null
    prod_local?: NullableIntFieldUpdateOperationsInput | number | null
    prod_recibo?: NullableIntFieldUpdateOperationsInput | number | null
    prod_monto?: NullableFloatFieldUpdateOperationsInput | number | null
    prod_plan?: NullableStringFieldUpdateOperationsInput | string | null
    prod_pago?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cta_tar?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    prod_obs?: NullableStringFieldUpdateOperationsInput | string | null
    prod_semana?: NullableIntFieldUpdateOperationsInput | number | null
    prod_estado?: NullableStringFieldUpdateOperationsInput | string | null
    prod_cierre?: NullableIntFieldUpdateOperationsInput | number | null
    prod_afiliado?: NullableIntFieldUpdateOperationsInput | number | null
    prod_rendido?: NullableStringFieldUpdateOperationsInput | string | null
    prod_recibosis?: NullableIntFieldUpdateOperationsInput | number | null
    prod_fechren?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prod_tel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type registro_constancia_afiliacionCreateInput = {
    apellido_extinto?: string | null
    nombre_extinto?: string | null
    dni_extinto?: number | null
    apellido_soli?: string | null
    nombre_soli?: string | null
    dni_soli?: string | null
    lugar_presentacion?: string | null
    fecha?: Date | string | null
    operador?: string | null
    idservicio?: number | null
  }

  export type registro_constancia_afiliacionUncheckedCreateInput = {
    idconstancia?: number
    apellido_extinto?: string | null
    nombre_extinto?: string | null
    dni_extinto?: number | null
    apellido_soli?: string | null
    nombre_soli?: string | null
    dni_soli?: string | null
    lugar_presentacion?: string | null
    fecha?: Date | string | null
    operador?: string | null
    idservicio?: number | null
  }

  export type registro_constancia_afiliacionUpdateInput = {
    apellido_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_soli?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_soli?: NullableStringFieldUpdateOperationsInput | string | null
    dni_soli?: NullableStringFieldUpdateOperationsInput | string | null
    lugar_presentacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type registro_constancia_afiliacionUncheckedUpdateInput = {
    idconstancia?: IntFieldUpdateOperationsInput | number
    apellido_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_soli?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_soli?: NullableStringFieldUpdateOperationsInput | string | null
    dni_soli?: NullableStringFieldUpdateOperationsInput | string | null
    lugar_presentacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type registro_constancia_afiliacionCreateManyInput = {
    idconstancia?: number
    apellido_extinto?: string | null
    nombre_extinto?: string | null
    dni_extinto?: number | null
    apellido_soli?: string | null
    nombre_soli?: string | null
    dni_soli?: string | null
    lugar_presentacion?: string | null
    fecha?: Date | string | null
    operador?: string | null
    idservicio?: number | null
  }

  export type registro_constancia_afiliacionUpdateManyMutationInput = {
    apellido_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_soli?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_soli?: NullableStringFieldUpdateOperationsInput | string | null
    dni_soli?: NullableStringFieldUpdateOperationsInput | string | null
    lugar_presentacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type registro_constancia_afiliacionUncheckedUpdateManyInput = {
    idconstancia?: IntFieldUpdateOperationsInput | number
    apellido_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_extinto?: NullableStringFieldUpdateOperationsInput | string | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_soli?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_soli?: NullableStringFieldUpdateOperationsInput | string | null
    dni_soli?: NullableStringFieldUpdateOperationsInput | string | null
    lugar_presentacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rehabilitacionesCreateInput = {
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
  }

  export type rehabilitacionesUncheckedCreateInput = {
    idrehab?: number
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
  }

  export type rehabilitacionesUpdateInput = {
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rehabilitacionesUncheckedUpdateInput = {
    idrehab?: IntFieldUpdateOperationsInput | number
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rehabilitacionesCreateManyInput = {
    idrehab?: number
    contrato?: string | null
    apellido?: string | null
    nombre?: string | null
    operador?: string | null
    vigencia?: Date | string | null
    fecha?: Date | string | null
    cuotas?: number | null
    dni?: number | null
    empresa?: string | null
    idoperador?: number | null
  }

  export type rehabilitacionesUpdateManyMutationInput = {
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rehabilitacionesUncheckedUpdateManyInput = {
    idrehab?: IntFieldUpdateOperationsInput | number
    contrato?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    idoperador?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rol_personalCreateInput = {
    rol?: string | null
  }

  export type rol_personalUncheckedCreateInput = {
    idrol?: number
    rol?: string | null
  }

  export type rol_personalUpdateInput = {
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rol_personalUncheckedUpdateInput = {
    idrol?: IntFieldUpdateOperationsInput | number
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rol_personalCreateManyInput = {
    idrol?: number
    rol?: string | null
  }

  export type rol_personalUpdateManyMutationInput = {
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rol_personalUncheckedUpdateManyInput = {
    idrol?: IntFieldUpdateOperationsInput | number
    rol?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sucursalCreateInput = {
    sucursal?: string | null
    codigo?: string | null
  }

  export type sucursalUncheckedCreateInput = {
    idsucursal?: number
    sucursal?: string | null
    codigo?: string | null
  }

  export type sucursalUpdateInput = {
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sucursalUncheckedUpdateInput = {
    idsucursal?: IntFieldUpdateOperationsInput | number
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sucursalCreateManyInput = {
    idsucursal?: number
    sucursal?: string | null
    codigo?: string | null
  }

  export type sucursalUpdateManyMutationInput = {
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sucursalUncheckedUpdateManyInput = {
    idsucursal?: IntFieldUpdateOperationsInput | number
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sueldosCreateInput = {
    sld_perfil?: string | null
    sld_basico?: number | null
    sld_basicoant?: number | null
  }

  export type sueldosUncheckedCreateInput = {
    sld_id?: number
    sld_perfil?: string | null
    sld_basico?: number | null
    sld_basicoant?: number | null
  }

  export type sueldosUpdateInput = {
    sld_perfil?: NullableStringFieldUpdateOperationsInput | string | null
    sld_basico?: NullableFloatFieldUpdateOperationsInput | number | null
    sld_basicoant?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sueldosUncheckedUpdateInput = {
    sld_id?: IntFieldUpdateOperationsInput | number
    sld_perfil?: NullableStringFieldUpdateOperationsInput | string | null
    sld_basico?: NullableFloatFieldUpdateOperationsInput | number | null
    sld_basicoant?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sueldosCreateManyInput = {
    sld_id?: number
    sld_perfil?: string | null
    sld_basico?: number | null
    sld_basicoant?: number | null
  }

  export type sueldosUpdateManyMutationInput = {
    sld_perfil?: NullableStringFieldUpdateOperationsInput | string | null
    sld_basico?: NullableFloatFieldUpdateOperationsInput | number | null
    sld_basicoant?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type sueldosUncheckedUpdateManyInput = {
    sld_id?: IntFieldUpdateOperationsInput | number
    sld_perfil?: NullableStringFieldUpdateOperationsInput | string | null
    sld_basico?: NullableFloatFieldUpdateOperationsInput | number | null
    sld_basicoant?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type tab_efCreateInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    holiday?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type tab_efUncheckedCreateInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    holiday?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type tab_efUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    holiday?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tab_efUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    holiday?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tab_efCreateManyInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    holiday?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type tab_efUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    holiday?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tab_efUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    holiday?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tablero_efectividadCreateInput = {
    ano?: number | null
    mes?: number | null
    dia?: number | null
    efectividad?: number | null
    aumento?: boolean | null
    por_aumento?: number | null
    feriado?: boolean | null
  }

  export type tablero_efectividadUncheckedCreateInput = {
    idregistro?: number
    ano?: number | null
    mes?: number | null
    dia?: number | null
    efectividad?: number | null
    aumento?: boolean | null
    por_aumento?: number | null
    feriado?: boolean | null
  }

  export type tablero_efectividadUpdateInput = {
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableIntFieldUpdateOperationsInput | number | null
    efectividad?: NullableFloatFieldUpdateOperationsInput | number | null
    aumento?: NullableBoolFieldUpdateOperationsInput | boolean | null
    por_aumento?: NullableFloatFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tablero_efectividadUncheckedUpdateInput = {
    idregistro?: IntFieldUpdateOperationsInput | number
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableIntFieldUpdateOperationsInput | number | null
    efectividad?: NullableFloatFieldUpdateOperationsInput | number | null
    aumento?: NullableBoolFieldUpdateOperationsInput | boolean | null
    por_aumento?: NullableFloatFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tablero_efectividadCreateManyInput = {
    idregistro?: number
    ano?: number | null
    mes?: number | null
    dia?: number | null
    efectividad?: number | null
    aumento?: boolean | null
    por_aumento?: number | null
    feriado?: boolean | null
  }

  export type tablero_efectividadUpdateManyMutationInput = {
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableIntFieldUpdateOperationsInput | number | null
    efectividad?: NullableFloatFieldUpdateOperationsInput | number | null
    aumento?: NullableBoolFieldUpdateOperationsInput | boolean | null
    por_aumento?: NullableFloatFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tablero_efectividadUncheckedUpdateManyInput = {
    idregistro?: IntFieldUpdateOperationsInput | number
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    dia?: NullableIntFieldUpdateOperationsInput | number | null
    efectividad?: NullableFloatFieldUpdateOperationsInput | number | null
    aumento?: NullableBoolFieldUpdateOperationsInput | boolean | null
    por_aumento?: NullableFloatFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareas_sucursalesCreateInput = {
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
    priority?: number | null
    sucursal?: string | null
    operador?: string | null
    leido?: boolean | null
  }

  export type tareas_sucursalesUncheckedCreateInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
    priority?: number | null
    sucursal?: string | null
    operador?: string | null
    leido?: boolean | null
  }

  export type tareas_sucursalesUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareas_sucursalesUncheckedUpdateInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareas_sucursalesCreateManyInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: Date | string | null
    end?: Date | string | null
    priority?: number | null
    sucursal?: string | null
    operador?: string | null
    leido?: boolean | null
  }

  export type tareas_sucursalesUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareas_sucursalesUncheckedUpdateManyInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    leido?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tipo_contratosCreateInput = {
    tipo_contrato?: string | null
    url?: string | null
  }

  export type tipo_contratosUncheckedCreateInput = {
    idtipocontrato?: number
    tipo_contrato?: string | null
    url?: string | null
  }

  export type tipo_contratosUpdateInput = {
    tipo_contrato?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_contratosUncheckedUpdateInput = {
    idtipocontrato?: IntFieldUpdateOperationsInput | number
    tipo_contrato?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_contratosCreateManyInput = {
    idtipocontrato?: number
    tipo_contrato?: string | null
    url?: string | null
  }

  export type tipo_contratosUpdateManyMutationInput = {
    tipo_contrato?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_contratosUncheckedUpdateManyInput = {
    idtipocontrato?: IntFieldUpdateOperationsInput | number
    tipo_contrato?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_facturasCreateInput = {
    tipo_factura?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type tipo_facturasUncheckedCreateInput = {
    idfactura?: number
    tipo_factura?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type tipo_facturasUpdateInput = {
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tipo_facturasUncheckedUpdateInput = {
    idfactura?: IntFieldUpdateOperationsInput | number
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tipo_facturasCreateManyInput = {
    idfactura?: number
    tipo_factura?: string | null
    fecha?: Date | string | null
    estado?: boolean | null
  }

  export type tipo_facturasUpdateManyMutationInput = {
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tipo_facturasUncheckedUpdateManyInput = {
    idfactura?: IntFieldUpdateOperationsInput | number
    tipo_factura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type turno_bajasCreateInput = {
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    fecha_pedido?: Date | string | null
    fecha_turno?: Date | string | null
    motivo?: string | null
    operador?: string | null
    telefono?: string | null
    movil?: string | null
    fecha_atencion?: Date | string | null
    estado?: number | null
    empresa?: string | null
    respuesta?: string | null
    operador_atencion?: string | null
    detalle?: string | null
  }

  export type turno_bajasUncheckedCreateInput = {
    idturno?: number
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    fecha_pedido?: Date | string | null
    fecha_turno?: Date | string | null
    motivo?: string | null
    operador?: string | null
    telefono?: string | null
    movil?: string | null
    fecha_atencion?: Date | string | null
    estado?: number | null
    empresa?: string | null
    respuesta?: string | null
    operador_atencion?: string | null
    detalle?: string | null
  }

  export type turno_bajasUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_turno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_atencion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_atencion?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type turno_bajasUncheckedUpdateInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_turno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_atencion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_atencion?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type turno_bajasCreateManyInput = {
    idturno?: number
    contrato?: number | null
    apellido?: string | null
    nombre?: string | null
    dni?: number | null
    fecha_pedido?: Date | string | null
    fecha_turno?: Date | string | null
    motivo?: string | null
    operador?: string | null
    telefono?: string | null
    movil?: string | null
    fecha_atencion?: Date | string | null
    estado?: number | null
    empresa?: string | null
    respuesta?: string | null
    operador_atencion?: string | null
    detalle?: string | null
  }

  export type turno_bajasUpdateManyMutationInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_turno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_atencion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_atencion?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type turno_bajasUncheckedUpdateManyInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_pedido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_turno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_atencion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    respuesta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_atencion?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vacacionesCreateInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    priority?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type vacacionesUncheckedCreateInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    priority?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type vacacionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vacacionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vacacionesCreateManyInput = {
    id: string
    start?: Date | string | null
    end?: Date | string | null
    allDay?: number | null
    priority?: number | null
    title?: string | null
    user?: string | null
    detail?: string | null
  }

  export type vacacionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vacacionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type motivos_atencionCreateInput = {
    motivo?: string | null
    estado?: boolean | null
  }

  export type motivos_atencionUncheckedCreateInput = {
    idmotivo?: number
    motivo?: string | null
    estado?: boolean | null
  }

  export type motivos_atencionUpdateInput = {
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type motivos_atencionUncheckedUpdateInput = {
    idmotivo?: IntFieldUpdateOperationsInput | number
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type motivos_atencionCreateManyInput = {
    idmotivo?: number
    motivo?: string | null
    estado?: boolean | null
  }

  export type motivos_atencionUpdateManyMutationInput = {
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type motivos_atencionUncheckedUpdateManyInput = {
    idmotivo?: IntFieldUpdateOperationsInput | number
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_plan_cuotasCreateInput = {
    plan_cuotas?: number | null
    detalle?: string | null
    estado?: boolean | null
  }

  export type prestamos_plan_cuotasUncheckedCreateInput = {
    idplan?: number
    plan_cuotas?: number | null
    detalle?: string | null
    estado?: boolean | null
  }

  export type prestamos_plan_cuotasUpdateInput = {
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_plan_cuotasUncheckedUpdateInput = {
    idplan?: IntFieldUpdateOperationsInput | number
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_plan_cuotasCreateManyInput = {
    idplan?: number
    plan_cuotas?: number | null
    detalle?: string | null
    estado?: boolean | null
  }

  export type prestamos_plan_cuotasUpdateManyMutationInput = {
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_plan_cuotasUncheckedUpdateManyInput = {
    idplan?: IntFieldUpdateOperationsInput | number
    plan_cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_tasasCreateInput = {
    tasa?: number | null
    plan?: string | null
    tipo?: string | null
    estado?: boolean | null
  }

  export type prestamos_tasasUncheckedCreateInput = {
    idtasa?: number
    tasa?: number | null
    plan?: string | null
    tipo?: string | null
    estado?: boolean | null
  }

  export type prestamos_tasasUpdateInput = {
    tasa?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_tasasUncheckedUpdateInput = {
    idtasa?: IntFieldUpdateOperationsInput | number
    tasa?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_tasasCreateManyInput = {
    idtasa?: number
    tasa?: number | null
    plan?: string | null
    tipo?: string | null
    estado?: boolean | null
  }

  export type prestamos_tasasUpdateManyMutationInput = {
    tasa?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type prestamos_tasasUncheckedUpdateManyInput = {
    idtasa?: IntFieldUpdateOperationsInput | number
    tasa?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type certificado_estudiantesCreateInput = {
    contrato?: number | null
    socio?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ncert?: string | null
  }

  export type certificado_estudiantesUncheckedCreateInput = {
    idcertificado?: number
    contrato?: number | null
    socio?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ncert?: string | null
  }

  export type certificado_estudiantesUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ncert?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificado_estudiantesUncheckedUpdateInput = {
    idcertificado?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ncert?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificado_estudiantesCreateManyInput = {
    idcertificado?: number
    contrato?: number | null
    socio?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ncert?: string | null
  }

  export type certificado_estudiantesUpdateManyMutationInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ncert?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificado_estudiantesUncheckedUpdateManyInput = {
    idcertificado?: IntFieldUpdateOperationsInput | number
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ncert?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type carteraCreateInput = {
    contrato?: number | null
    socio?: string | null
    alta?: Date | string | null
    grupo?: number | null
    adhs?: number | null
    plan?: string | null
    sub_plan?: string | null
    zona?: number | null
    cuota?: number | null
    empresa?: string | null
    sucursal?: string | null
    deuda?: number | null
    mes?: number | null
    ano?: number | null
  }

  export type carteraUncheckedCreateInput = {
    contrato?: number | null
    socio?: string | null
    alta?: Date | string | null
    grupo?: number | null
    adhs?: number | null
    plan?: string | null
    sub_plan?: string | null
    zona?: number | null
    cuota?: number | null
    empresa?: string | null
    sucursal?: string | null
    deuda?: number | null
    mes?: number | null
    ano?: number | null
    idcartera?: number
  }

  export type carteraUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo?: NullableIntFieldUpdateOperationsInput | number | null
    adhs?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    sub_plan?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carteraUncheckedUpdateInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo?: NullableIntFieldUpdateOperationsInput | number | null
    adhs?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    sub_plan?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    idcartera?: IntFieldUpdateOperationsInput | number
  }

  export type carteraCreateManyInput = {
    contrato?: number | null
    socio?: string | null
    alta?: Date | string | null
    grupo?: number | null
    adhs?: number | null
    plan?: string | null
    sub_plan?: string | null
    zona?: number | null
    cuota?: number | null
    empresa?: string | null
    sucursal?: string | null
    deuda?: number | null
    mes?: number | null
    ano?: number | null
    idcartera?: number
  }

  export type carteraUpdateManyMutationInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo?: NullableIntFieldUpdateOperationsInput | number | null
    adhs?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    sub_plan?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carteraUncheckedUpdateManyInput = {
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    socio?: NullableStringFieldUpdateOperationsInput | string | null
    alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grupo?: NullableIntFieldUpdateOperationsInput | number | null
    adhs?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    sub_plan?: NullableStringFieldUpdateOperationsInput | string | null
    zona?: NullableIntFieldUpdateOperationsInput | number | null
    cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    deuda?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    idcartera?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type alta_novellCountOrderByAggregateInput = {
    idnovell?: SortOrder
    fecha_recepcion?: SortOrder
    servicio?: SortOrder
    monto?: SortOrder
    monto_letra?: SortOrder
    anticipo?: SortOrder
    gastos_adm?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    estcivil_sol?: SortOrder
    fecha_nac_sol?: SortOrder
    dom_sol?: SortOrder
    domnum_sol?: SortOrder
    piso_sol?: SortOrder
    barrio_sol?: SortOrder
    localidad_sol?: SortOrder
    codpostal_sol?: SortOrder
    telefono_sol?: SortOrder
    movil_sol?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    dni_ben?: SortOrder
    estcivil_ben?: SortOrder
    fecha_nac_ben?: SortOrder
    dom_ben?: SortOrder
    domnum_ben?: SortOrder
    piso_ben?: SortOrder
    barrio_ben?: SortOrder
    localidad_ben?: SortOrder
    codpostal_ben?: SortOrder
    telefono_ben?: SortOrder
    movil_ben?: SortOrder
    operador?: SortOrder
    cuotas?: SortOrder
    nacionalidad_sol?: SortOrder
    nacionalidad_ben?: SortOrder
    anticipo_letra?: SortOrder
    cuotasaldo?: SortOrder
    cuotasaldo_letra?: SortOrder
    cuota_mantenimiento?: SortOrder
  }

  export type alta_novellAvgOrderByAggregateInput = {
    idnovell?: SortOrder
    monto?: SortOrder
    anticipo?: SortOrder
    gastos_adm?: SortOrder
    dni_sol?: SortOrder
    domnum_sol?: SortOrder
    codpostal_sol?: SortOrder
    dni_ben?: SortOrder
    domnum_ben?: SortOrder
    codpostal_ben?: SortOrder
    cuotas?: SortOrder
    cuotasaldo?: SortOrder
    cuota_mantenimiento?: SortOrder
  }

  export type alta_novellMaxOrderByAggregateInput = {
    idnovell?: SortOrder
    fecha_recepcion?: SortOrder
    servicio?: SortOrder
    monto?: SortOrder
    monto_letra?: SortOrder
    anticipo?: SortOrder
    gastos_adm?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    estcivil_sol?: SortOrder
    fecha_nac_sol?: SortOrder
    dom_sol?: SortOrder
    domnum_sol?: SortOrder
    piso_sol?: SortOrder
    barrio_sol?: SortOrder
    localidad_sol?: SortOrder
    codpostal_sol?: SortOrder
    telefono_sol?: SortOrder
    movil_sol?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    dni_ben?: SortOrder
    estcivil_ben?: SortOrder
    fecha_nac_ben?: SortOrder
    dom_ben?: SortOrder
    domnum_ben?: SortOrder
    piso_ben?: SortOrder
    barrio_ben?: SortOrder
    localidad_ben?: SortOrder
    codpostal_ben?: SortOrder
    telefono_ben?: SortOrder
    movil_ben?: SortOrder
    operador?: SortOrder
    cuotas?: SortOrder
    nacionalidad_sol?: SortOrder
    nacionalidad_ben?: SortOrder
    anticipo_letra?: SortOrder
    cuotasaldo?: SortOrder
    cuotasaldo_letra?: SortOrder
    cuota_mantenimiento?: SortOrder
  }

  export type alta_novellMinOrderByAggregateInput = {
    idnovell?: SortOrder
    fecha_recepcion?: SortOrder
    servicio?: SortOrder
    monto?: SortOrder
    monto_letra?: SortOrder
    anticipo?: SortOrder
    gastos_adm?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    estcivil_sol?: SortOrder
    fecha_nac_sol?: SortOrder
    dom_sol?: SortOrder
    domnum_sol?: SortOrder
    piso_sol?: SortOrder
    barrio_sol?: SortOrder
    localidad_sol?: SortOrder
    codpostal_sol?: SortOrder
    telefono_sol?: SortOrder
    movil_sol?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    dni_ben?: SortOrder
    estcivil_ben?: SortOrder
    fecha_nac_ben?: SortOrder
    dom_ben?: SortOrder
    domnum_ben?: SortOrder
    piso_ben?: SortOrder
    barrio_ben?: SortOrder
    localidad_ben?: SortOrder
    codpostal_ben?: SortOrder
    telefono_ben?: SortOrder
    movil_ben?: SortOrder
    operador?: SortOrder
    cuotas?: SortOrder
    nacionalidad_sol?: SortOrder
    nacionalidad_ben?: SortOrder
    anticipo_letra?: SortOrder
    cuotasaldo?: SortOrder
    cuotasaldo_letra?: SortOrder
    cuota_mantenimiento?: SortOrder
  }

  export type alta_novellSumOrderByAggregateInput = {
    idnovell?: SortOrder
    monto?: SortOrder
    anticipo?: SortOrder
    gastos_adm?: SortOrder
    dni_sol?: SortOrder
    domnum_sol?: SortOrder
    codpostal_sol?: SortOrder
    dni_ben?: SortOrder
    domnum_ben?: SortOrder
    codpostal_ben?: SortOrder
    cuotas?: SortOrder
    cuotasaldo?: SortOrder
    cuota_mantenimiento?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type caja_sucursalesCountOrderByAggregateInput = {
    idcaja?: SortOrder
    fecha_carga?: SortOrder
    sucursal?: SortOrder
    ingresos?: SortOrder
    egresos?: SortOrder
    saldo?: SortOrder
    operador_carga?: SortOrder
    empresa?: SortOrder
  }

  export type caja_sucursalesAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    ingresos?: SortOrder
    egresos?: SortOrder
    saldo?: SortOrder
  }

  export type caja_sucursalesMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    fecha_carga?: SortOrder
    sucursal?: SortOrder
    ingresos?: SortOrder
    egresos?: SortOrder
    saldo?: SortOrder
    operador_carga?: SortOrder
    empresa?: SortOrder
  }

  export type caja_sucursalesMinOrderByAggregateInput = {
    idcaja?: SortOrder
    fecha_carga?: SortOrder
    sucursal?: SortOrder
    ingresos?: SortOrder
    egresos?: SortOrder
    saldo?: SortOrder
    operador_carga?: SortOrder
    empresa?: SortOrder
  }

  export type caja_sucursalesSumOrderByAggregateInput = {
    idcaja?: SortOrder
    ingresos?: SortOrder
    egresos?: SortOrder
    saldo?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type campanacasosCountOrderByAggregateInput = {
    idcaso?: SortOrder
    idcampana?: SortOrder
    fechacampana?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    sucursal?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    calle?: SortOrder
    nro_calle?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    cuota?: SortOrder
    cuotasadeudadas?: SortOrder
    montoadeudado?: SortOrder
    estadocaso?: SortOrder
    accion?: SortOrder
    edad?: SortOrder
    adherentes?: SortOrder
    alta?: SortOrder
    vigencia?: SortOrder
  }

  export type campanacasosAvgOrderByAggregateInput = {
    idcaso?: SortOrder
    idcampana?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    nro_calle?: SortOrder
    cuota?: SortOrder
    cuotasadeudadas?: SortOrder
    montoadeudado?: SortOrder
    accion?: SortOrder
    edad?: SortOrder
    adherentes?: SortOrder
  }

  export type campanacasosMaxOrderByAggregateInput = {
    idcaso?: SortOrder
    idcampana?: SortOrder
    fechacampana?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    sucursal?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    calle?: SortOrder
    nro_calle?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    cuota?: SortOrder
    cuotasadeudadas?: SortOrder
    montoadeudado?: SortOrder
    estadocaso?: SortOrder
    accion?: SortOrder
    edad?: SortOrder
    adherentes?: SortOrder
    alta?: SortOrder
    vigencia?: SortOrder
  }

  export type campanacasosMinOrderByAggregateInput = {
    idcaso?: SortOrder
    idcampana?: SortOrder
    fechacampana?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    sucursal?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    calle?: SortOrder
    nro_calle?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    cuota?: SortOrder
    cuotasadeudadas?: SortOrder
    montoadeudado?: SortOrder
    estadocaso?: SortOrder
    accion?: SortOrder
    edad?: SortOrder
    adherentes?: SortOrder
    alta?: SortOrder
    vigencia?: SortOrder
  }

  export type campanacasosSumOrderByAggregateInput = {
    idcaso?: SortOrder
    idcampana?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    nro_calle?: SortOrder
    cuota?: SortOrder
    cuotasadeudadas?: SortOrder
    montoadeudado?: SortOrder
    accion?: SortOrder
    edad?: SortOrder
    adherentes?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type campanasCountOrderByAggregateInput = {
    idcampana?: SortOrder
    descripcion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
  }

  export type campanasAvgOrderByAggregateInput = {
    idcampana?: SortOrder
  }

  export type campanasMaxOrderByAggregateInput = {
    idcampana?: SortOrder
    descripcion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
  }

  export type campanasMinOrderByAggregateInput = {
    idcampana?: SortOrder
    descripcion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
  }

  export type campanasSumOrderByAggregateInput = {
    idcampana?: SortOrder
  }

  export type campanatemporalCountOrderByAggregateInput = {
    SUCURSAL?: SortOrder
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    ALTA?: SortOrder
    VIGENCIA?: SortOrder
    CALLE?: SortOrder
    NRO_CALLE?: SortOrder
    BARRIO?: SortOrder
    LOCALIDAD?: SortOrder
    GRUPO?: SortOrder
    ZONA?: SortOrder
    TELEFONO?: SortOrder
    MOVIL?: SortOrder
    EDAD?: SortOrder
    MES?: SortOrder
    ANO?: SortOrder
    IMPORTE?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
    idcaso?: SortOrder
    observacion?: SortOrder
    fecha?: SortOrder
    fecha_observacion?: SortOrder
    accion?: SortOrder
  }

  export type campanatemporalAvgOrderByAggregateInput = {
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrder
    NRO_CALLE?: SortOrder
    GRUPO?: SortOrder
    ZONA?: SortOrder
    EDAD?: SortOrder
    MES?: SortOrder
    ANO?: SortOrder
    IMPORTE?: SortOrder
    idcaso?: SortOrder
  }

  export type campanatemporalMaxOrderByAggregateInput = {
    SUCURSAL?: SortOrder
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    ALTA?: SortOrder
    VIGENCIA?: SortOrder
    CALLE?: SortOrder
    NRO_CALLE?: SortOrder
    BARRIO?: SortOrder
    LOCALIDAD?: SortOrder
    GRUPO?: SortOrder
    ZONA?: SortOrder
    TELEFONO?: SortOrder
    MOVIL?: SortOrder
    EDAD?: SortOrder
    MES?: SortOrder
    ANO?: SortOrder
    IMPORTE?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
    idcaso?: SortOrder
    observacion?: SortOrder
    fecha?: SortOrder
    fecha_observacion?: SortOrder
    accion?: SortOrder
  }

  export type campanatemporalMinOrderByAggregateInput = {
    SUCURSAL?: SortOrder
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    ALTA?: SortOrder
    VIGENCIA?: SortOrder
    CALLE?: SortOrder
    NRO_CALLE?: SortOrder
    BARRIO?: SortOrder
    LOCALIDAD?: SortOrder
    GRUPO?: SortOrder
    ZONA?: SortOrder
    TELEFONO?: SortOrder
    MOVIL?: SortOrder
    EDAD?: SortOrder
    MES?: SortOrder
    ANO?: SortOrder
    IMPORTE?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
    idcaso?: SortOrder
    observacion?: SortOrder
    fecha?: SortOrder
    fecha_observacion?: SortOrder
    accion?: SortOrder
  }

  export type campanatemporalSumOrderByAggregateInput = {
    CONTRATO?: SortOrder
    NRO_DOC?: SortOrder
    NRO_CALLE?: SortOrder
    GRUPO?: SortOrder
    ZONA?: SortOrder
    EDAD?: SortOrder
    MES?: SortOrder
    ANO?: SortOrder
    IMPORTE?: SortOrder
    idcaso?: SortOrder
  }

  export type capital_prestamoCountOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamoAvgOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
  }

  export type capital_prestamoMaxOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamoMinOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamoSumOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
  }

  export type capital_prestamo_empleadosCountOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamo_empleadosAvgOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
  }

  export type capital_prestamo_empleadosMaxOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamo_empleadosMinOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    autorizacion?: SortOrder
  }

  export type capital_prestamo_empleadosSumOrderByAggregateInput = {
    idcapital?: SortOrder
    capital?: SortOrder
  }

  export type categoria_obsequioCountOrderByAggregateInput = {
    idcategoria?: SortOrder
    categoria?: SortOrder
    observacion?: SortOrder
  }

  export type categoria_obsequioAvgOrderByAggregateInput = {
    idcategoria?: SortOrder
  }

  export type categoria_obsequioMaxOrderByAggregateInput = {
    idcategoria?: SortOrder
    categoria?: SortOrder
    observacion?: SortOrder
  }

  export type categoria_obsequioMinOrderByAggregateInput = {
    idcategoria?: SortOrder
    categoria?: SortOrder
    observacion?: SortOrder
  }

  export type categoria_obsequioSumOrderByAggregateInput = {
    idcategoria?: SortOrder
  }

  export type contratosCountOrderByAggregateInput = {
    idcontrato?: SortOrder
    locatario1?: SortOrder
    dni1?: SortOrder
    domicilio1?: SortOrder
    locatario2?: SortOrder
    dni2?: SortOrder
    domicilio2?: SortOrder
    monto?: SortOrder
    fecha_inicio?: SortOrder
    duracion?: SortOrder
    locador?: SortOrder
    operador?: SortOrder
    local?: SortOrder
    uf?: SortOrder
  }

  export type contratosAvgOrderByAggregateInput = {
    idcontrato?: SortOrder
    dni1?: SortOrder
    dni2?: SortOrder
    monto?: SortOrder
    duracion?: SortOrder
    locador?: SortOrder
  }

  export type contratosMaxOrderByAggregateInput = {
    idcontrato?: SortOrder
    locatario1?: SortOrder
    dni1?: SortOrder
    domicilio1?: SortOrder
    locatario2?: SortOrder
    dni2?: SortOrder
    domicilio2?: SortOrder
    monto?: SortOrder
    fecha_inicio?: SortOrder
    duracion?: SortOrder
    locador?: SortOrder
    operador?: SortOrder
    local?: SortOrder
    uf?: SortOrder
  }

  export type contratosMinOrderByAggregateInput = {
    idcontrato?: SortOrder
    locatario1?: SortOrder
    dni1?: SortOrder
    domicilio1?: SortOrder
    locatario2?: SortOrder
    dni2?: SortOrder
    domicilio2?: SortOrder
    monto?: SortOrder
    fecha_inicio?: SortOrder
    duracion?: SortOrder
    locador?: SortOrder
    operador?: SortOrder
    local?: SortOrder
    uf?: SortOrder
  }

  export type contratosSumOrderByAggregateInput = {
    idcontrato?: SortOrder
    dni1?: SortOrder
    dni2?: SortOrder
    monto?: SortOrder
    duracion?: SortOrder
    locador?: SortOrder
  }

  export type convenio_deudaCountOrderByAggregateInput = {
    idconvdeuda?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
    vencimiento1?: SortOrder
    importe1?: SortOrder
    vencimiento2?: SortOrder
    importe2?: SortOrder
    deuda?: SortOrder
    bonificacion?: SortOrder
    saldo?: SortOrder
  }

  export type convenio_deudaAvgOrderByAggregateInput = {
    idconvdeuda?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    idoperador?: SortOrder
    importe1?: SortOrder
    importe2?: SortOrder
    deuda?: SortOrder
    bonificacion?: SortOrder
    saldo?: SortOrder
  }

  export type convenio_deudaMaxOrderByAggregateInput = {
    idconvdeuda?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
    vencimiento1?: SortOrder
    importe1?: SortOrder
    vencimiento2?: SortOrder
    importe2?: SortOrder
    deuda?: SortOrder
    bonificacion?: SortOrder
    saldo?: SortOrder
  }

  export type convenio_deudaMinOrderByAggregateInput = {
    idconvdeuda?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
    vencimiento1?: SortOrder
    importe1?: SortOrder
    vencimiento2?: SortOrder
    importe2?: SortOrder
    deuda?: SortOrder
    bonificacion?: SortOrder
    saldo?: SortOrder
  }

  export type convenio_deudaSumOrderByAggregateInput = {
    idconvdeuda?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    idoperador?: SortOrder
    importe1?: SortOrder
    importe2?: SortOrder
    deuda?: SortOrder
    bonificacion?: SortOrder
    saldo?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type datosCountOrderByAggregateInput = {
    iddato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    cobertura?: SortOrder
    grupo_familiar?: SortOrder
    observacion?: SortOrder
    operador?: SortOrder
    domicilio?: SortOrder
    fecha?: SortOrder
  }

  export type datosAvgOrderByAggregateInput = {
    iddato?: SortOrder
    edad?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
  }

  export type datosMaxOrderByAggregateInput = {
    iddato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    cobertura?: SortOrder
    grupo_familiar?: SortOrder
    observacion?: SortOrder
    operador?: SortOrder
    domicilio?: SortOrder
    fecha?: SortOrder
  }

  export type datosMinOrderByAggregateInput = {
    iddato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    cobertura?: SortOrder
    grupo_familiar?: SortOrder
    observacion?: SortOrder
    operador?: SortOrder
    domicilio?: SortOrder
    fecha?: SortOrder
  }

  export type datosSumOrderByAggregateInput = {
    iddato?: SortOrder
    edad?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type datos_atencionCountOrderByAggregateInput = {
    iddatos?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    operadoratencion?: SortOrder
    fecha?: SortOrder
  }

  export type datos_atencionAvgOrderByAggregateInput = {
    iddatos?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type datos_atencionMaxOrderByAggregateInput = {
    iddatos?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    operadoratencion?: SortOrder
    fecha?: SortOrder
  }

  export type datos_atencionMinOrderByAggregateInput = {
    iddatos?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    operadoratencion?: SortOrder
    fecha?: SortOrder
  }

  export type datos_atencionSumOrderByAggregateInput = {
    iddatos?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type detalle_orden_pagoCountOrderByAggregateInput = {
    iddetallepago?: SortOrder
    norden?: SortOrder
    nconsulta?: SortOrder
    sucursal?: SortOrder
    prestador?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    fecha?: SortOrder
  }

  export type detalle_orden_pagoAvgOrderByAggregateInput = {
    iddetallepago?: SortOrder
  }

  export type detalle_orden_pagoMaxOrderByAggregateInput = {
    iddetallepago?: SortOrder
    norden?: SortOrder
    nconsulta?: SortOrder
    sucursal?: SortOrder
    prestador?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    fecha?: SortOrder
  }

  export type detalle_orden_pagoMinOrderByAggregateInput = {
    iddetallepago?: SortOrder
    norden?: SortOrder
    nconsulta?: SortOrder
    sucursal?: SortOrder
    prestador?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    fecha?: SortOrder
  }

  export type detalle_orden_pagoSumOrderByAggregateInput = {
    iddetallepago?: SortOrder
  }

  export type empresasCountOrderByAggregateInput = {
    idempresa?: SortOrder
    empresa?: SortOrder
    cuit?: SortOrder
  }

  export type empresasAvgOrderByAggregateInput = {
    idempresa?: SortOrder
  }

  export type empresasMaxOrderByAggregateInput = {
    idempresa?: SortOrder
    empresa?: SortOrder
    cuit?: SortOrder
  }

  export type empresasMinOrderByAggregateInput = {
    idempresa?: SortOrder
    empresa?: SortOrder
    cuit?: SortOrder
  }

  export type empresasSumOrderByAggregateInput = {
    idempresa?: SortOrder
  }

  export type eventosCountOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventosAvgOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
  }

  export type eventosMaxOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventosMinOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventosSumOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
  }

  export type fabricante_ataudCountOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudAvgOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type fabricante_ataudMaxOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudMinOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudSumOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type gestioncasoCountOrderByAggregateInput = {
    idgestion?: SortOrder
    idcaso?: SortOrder
    contrato?: SortOrder
    operador?: SortOrder
    accion?: SortOrder
    observacion?: SortOrder
    fechaaccion?: SortOrder
    nuevaaccion?: SortOrder
    fechanuevaaccion?: SortOrder
    realizado?: SortOrder
    observacion_nuevaaccion?: SortOrder
  }

  export type gestioncasoAvgOrderByAggregateInput = {
    idgestion?: SortOrder
    idcaso?: SortOrder
    contrato?: SortOrder
  }

  export type gestioncasoMaxOrderByAggregateInput = {
    idgestion?: SortOrder
    idcaso?: SortOrder
    contrato?: SortOrder
    operador?: SortOrder
    accion?: SortOrder
    observacion?: SortOrder
    fechaaccion?: SortOrder
    nuevaaccion?: SortOrder
    fechanuevaaccion?: SortOrder
    realizado?: SortOrder
    observacion_nuevaaccion?: SortOrder
  }

  export type gestioncasoMinOrderByAggregateInput = {
    idgestion?: SortOrder
    idcaso?: SortOrder
    contrato?: SortOrder
    operador?: SortOrder
    accion?: SortOrder
    observacion?: SortOrder
    fechaaccion?: SortOrder
    nuevaaccion?: SortOrder
    fechanuevaaccion?: SortOrder
    realizado?: SortOrder
    observacion_nuevaaccion?: SortOrder
  }

  export type gestioncasoSumOrderByAggregateInput = {
    idgestion?: SortOrder
    idcaso?: SortOrder
    contrato?: SortOrder
  }

  export type historial_accionesCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_accionesAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
  }

  export type historial_accionesMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_accionesMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_accionesSumOrderByAggregateInput = {
    idhistorial?: SortOrder
  }

  export type historial_aprobacion_prestamosCountOrderByAggregateInput = {
    idaprobacion?: SortOrder
    operador?: SortOrder
    idprestamo?: SortOrder
    fecha?: SortOrder
    contrato?: SortOrder
    afiliado?: SortOrder
    productor?: SortOrder
  }

  export type historial_aprobacion_prestamosAvgOrderByAggregateInput = {
    idaprobacion?: SortOrder
    idprestamo?: SortOrder
    contrato?: SortOrder
    productor?: SortOrder
  }

  export type historial_aprobacion_prestamosMaxOrderByAggregateInput = {
    idaprobacion?: SortOrder
    operador?: SortOrder
    idprestamo?: SortOrder
    fecha?: SortOrder
    contrato?: SortOrder
    afiliado?: SortOrder
    productor?: SortOrder
  }

  export type historial_aprobacion_prestamosMinOrderByAggregateInput = {
    idaprobacion?: SortOrder
    operador?: SortOrder
    idprestamo?: SortOrder
    fecha?: SortOrder
    contrato?: SortOrder
    afiliado?: SortOrder
    productor?: SortOrder
  }

  export type historial_aprobacion_prestamosSumOrderByAggregateInput = {
    idaprobacion?: SortOrder
    idprestamo?: SortOrder
    contrato?: SortOrder
    productor?: SortOrder
  }

  export type historial_liquidacionesCountOrderByAggregateInput = {
    idliquidacion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    cobranza?: SortOrder
    total?: SortOrder
    comision?: SortOrder
    entidad?: SortOrder
  }

  export type historial_liquidacionesAvgOrderByAggregateInput = {
    idliquidacion?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    cobranza?: SortOrder
    total?: SortOrder
    comision?: SortOrder
  }

  export type historial_liquidacionesMaxOrderByAggregateInput = {
    idliquidacion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    cobranza?: SortOrder
    total?: SortOrder
    comision?: SortOrder
    entidad?: SortOrder
  }

  export type historial_liquidacionesMinOrderByAggregateInput = {
    idliquidacion?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    cobranza?: SortOrder
    total?: SortOrder
    comision?: SortOrder
    entidad?: SortOrder
  }

  export type historial_liquidacionesSumOrderByAggregateInput = {
    idliquidacion?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    cobranza?: SortOrder
    total?: SortOrder
    comision?: SortOrder
  }

  export type intereses_tarjetasCountOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrder
    interes?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type intereses_tarjetasAvgOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrder
    interes?: SortOrder
  }

  export type intereses_tarjetasMaxOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrder
    interes?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type intereses_tarjetasMinOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrder
    interes?: SortOrder
    tarjeta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type intereses_tarjetasSumOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuota?: SortOrder
    interes?: SortOrder
  }

  export type legajo_virtualCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    tipoarchivo?: SortOrder
  }

  export type legajo_virtualAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
  }

  export type legajo_virtualMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    tipoarchivo?: SortOrder
  }

  export type legajo_virtualMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    tipoarchivo?: SortOrder
  }

  export type legajo_virtualSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
  }

  export type legajo_virtual_cajasCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_cajasAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrder
  }

  export type legajo_virtual_cajasMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_cajasMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_cajasSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    idcaja?: SortOrder
  }

  export type legajo_virtual_ordenesCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    idorden?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_ordenesAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    idorden?: SortOrder
  }

  export type legajo_virtual_ordenesMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    idorden?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_ordenesMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    idorden?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_ordenesSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    idorden?: SortOrder
  }

  export type legajo_virtual_personalCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_personalAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrder
  }

  export type legajo_virtual_personalMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_personalMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_personalSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    idpersonal?: SortOrder
  }

  export type legajo_virtual_prestamosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    cod_ptm_leg?: SortOrder
  }

  export type legajo_virtual_prestamosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
  }

  export type legajo_virtual_prestamosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    cod_ptm_leg?: SortOrder
  }

  export type legajo_virtual_prestamosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    cod_ptm_leg?: SortOrder
  }

  export type legajo_virtual_prestamosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    contrato?: SortOrder
  }

  export type StringFilter = {
    equals?: string
    in?: string[]
    notIn?: string[]
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type locadorCountOrderByAggregateInput = {
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    provincia?: SortOrder
  }

  export type locadorAvgOrderByAggregateInput = {
    dni?: SortOrder
  }

  export type locadorMaxOrderByAggregateInput = {
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    provincia?: SortOrder
  }

  export type locadorMinOrderByAggregateInput = {
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    domicilio?: SortOrder
    barrio?: SortOrder
    localidad?: SortOrder
    provincia?: SortOrder
  }

  export type locadorSumOrderByAggregateInput = {
    dni?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: string[]
    notIn?: string[]
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type mailsCountOrderByAggregateInput = {
    idmail?: SortOrder
    fecha?: SortOrder
    envia?: SortOrder
    recibe?: SortOrder
    descrip?: SortOrder
    codmail?: SortOrder
    asunto?: SortOrder
    leido?: SortOrder
    fecha_leido?: SortOrder
    url_caja?: SortOrder
  }

  export type mailsAvgOrderByAggregateInput = {
    idmail?: SortOrder
  }

  export type mailsMaxOrderByAggregateInput = {
    idmail?: SortOrder
    fecha?: SortOrder
    envia?: SortOrder
    recibe?: SortOrder
    descrip?: SortOrder
    codmail?: SortOrder
    asunto?: SortOrder
    leido?: SortOrder
    fecha_leido?: SortOrder
    url_caja?: SortOrder
  }

  export type mailsMinOrderByAggregateInput = {
    idmail?: SortOrder
    fecha?: SortOrder
    envia?: SortOrder
    recibe?: SortOrder
    descrip?: SortOrder
    codmail?: SortOrder
    asunto?: SortOrder
    leido?: SortOrder
    fecha_leido?: SortOrder
    url_caja?: SortOrder
  }

  export type mailsSumOrderByAggregateInput = {
    idmail?: SortOrder
  }

  export type mails_adjuntosCountOrderByAggregateInput = {
    idadjunto?: SortOrder
    codmail?: SortOrder
    adjunto?: SortOrder
    tipo?: SortOrder
  }

  export type mails_adjuntosAvgOrderByAggregateInput = {
    idadjunto?: SortOrder
  }

  export type mails_adjuntosMaxOrderByAggregateInput = {
    idadjunto?: SortOrder
    codmail?: SortOrder
    adjunto?: SortOrder
    tipo?: SortOrder
  }

  export type mails_adjuntosMinOrderByAggregateInput = {
    idadjunto?: SortOrder
    codmail?: SortOrder
    adjunto?: SortOrder
    tipo?: SortOrder
  }

  export type mails_adjuntosSumOrderByAggregateInput = {
    idadjunto?: SortOrder
  }

  export type mbanconvCountOrderByAggregateInput = {
    id_mora?: SortOrder
    tipo?: SortOrder
    mora?: SortOrder
    fichas?: SortOrder
    morarec?: SortOrder
    fichasrec?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
  }

  export type mbanconvAvgOrderByAggregateInput = {
    id_mora?: SortOrder
    mora?: SortOrder
    fichas?: SortOrder
    morarec?: SortOrder
    fichasrec?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
  }

  export type mbanconvMaxOrderByAggregateInput = {
    id_mora?: SortOrder
    tipo?: SortOrder
    mora?: SortOrder
    fichas?: SortOrder
    morarec?: SortOrder
    fichasrec?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
  }

  export type mbanconvMinOrderByAggregateInput = {
    id_mora?: SortOrder
    tipo?: SortOrder
    mora?: SortOrder
    fichas?: SortOrder
    morarec?: SortOrder
    fichasrec?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
  }

  export type mbanconvSumOrderByAggregateInput = {
    id_mora?: SortOrder
    mora?: SortOrder
    fichas?: SortOrder
    morarec?: SortOrder
    fichasrec?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
  }

  export type movimiento_caja_sucursalesCountOrderByAggregateInput = {
    idmovimiento?: SortOrder
    fecha_carga?: SortOrder
    fecha_movimiento?: SortOrder
    sucursal?: SortOrder
    concepto?: SortOrder
    movimiento?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    idcaja?: SortOrder
    empresa?: SortOrder
  }

  export type movimiento_caja_sucursalesAvgOrderByAggregateInput = {
    idmovimiento?: SortOrder
    importe?: SortOrder
    idcaja?: SortOrder
  }

  export type movimiento_caja_sucursalesMaxOrderByAggregateInput = {
    idmovimiento?: SortOrder
    fecha_carga?: SortOrder
    fecha_movimiento?: SortOrder
    sucursal?: SortOrder
    concepto?: SortOrder
    movimiento?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    idcaja?: SortOrder
    empresa?: SortOrder
  }

  export type movimiento_caja_sucursalesMinOrderByAggregateInput = {
    idmovimiento?: SortOrder
    fecha_carga?: SortOrder
    fecha_movimiento?: SortOrder
    sucursal?: SortOrder
    concepto?: SortOrder
    movimiento?: SortOrder
    importe?: SortOrder
    operador_carga?: SortOrder
    idcaja?: SortOrder
    empresa?: SortOrder
  }

  export type movimiento_caja_sucursalesSumOrderByAggregateInput = {
    idmovimiento?: SortOrder
    importe?: SortOrder
    idcaja?: SortOrder
  }

  export type noticiaCountOrderByAggregateInput = {
    idnoticia?: SortOrder
    fecha?: SortOrder
    noticia?: SortOrder
    operador?: SortOrder
    perfil?: SortOrder
  }

  export type noticiaAvgOrderByAggregateInput = {
    idnoticia?: SortOrder
    perfil?: SortOrder
  }

  export type noticiaMaxOrderByAggregateInput = {
    idnoticia?: SortOrder
    fecha?: SortOrder
    noticia?: SortOrder
    operador?: SortOrder
    perfil?: SortOrder
  }

  export type noticiaMinOrderByAggregateInput = {
    idnoticia?: SortOrder
    fecha?: SortOrder
    noticia?: SortOrder
    operador?: SortOrder
    perfil?: SortOrder
  }

  export type noticiaSumOrderByAggregateInput = {
    idnoticia?: SortOrder
    perfil?: SortOrder
  }

  export type novedadesCountOrderByAggregateInput = {
    idnovedades?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type novedadesAvgOrderByAggregateInput = {
    idnovedades?: SortOrder
  }

  export type novedadesMaxOrderByAggregateInput = {
    idnovedades?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type novedadesMinOrderByAggregateInput = {
    idnovedades?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type novedadesSumOrderByAggregateInput = {
    idnovedades?: SortOrder
  }

  export type obsequiosCountOrderByAggregateInput = {
    idobsequio?: SortOrder
    producto?: SortOrder
    marca?: SortOrder
    categoria?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
    fecha_reposicion?: SortOrder
    operador_rep?: SortOrder
  }

  export type obsequiosAvgOrderByAggregateInput = {
    idobsequio?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
  }

  export type obsequiosMaxOrderByAggregateInput = {
    idobsequio?: SortOrder
    producto?: SortOrder
    marca?: SortOrder
    categoria?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
    fecha_reposicion?: SortOrder
    operador_rep?: SortOrder
  }

  export type obsequiosMinOrderByAggregateInput = {
    idobsequio?: SortOrder
    producto?: SortOrder
    marca?: SortOrder
    categoria?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
    fecha_reposicion?: SortOrder
    operador_rep?: SortOrder
  }

  export type obsequiosSumOrderByAggregateInput = {
    idobsequio?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
  }

  export type openia_keysCountOrderByAggregateInput = {
    idkey?: SortOrder
    key?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type openia_keysAvgOrderByAggregateInput = {
    idkey?: SortOrder
  }

  export type openia_keysMaxOrderByAggregateInput = {
    idkey?: SortOrder
    key?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type openia_keysMinOrderByAggregateInput = {
    idkey?: SortOrder
    key?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type openia_keysSumOrderByAggregateInput = {
    idkey?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type operadorCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    puestom?: SortOrder
    perfil?: SortOrder
    estado?: SortOrder
    puestow?: SortOrder
    codigo?: SortOrder
    medicos?: SortOrder
    sucursal?: SortOrder
    prestamos?: SortOrder
    ordenpago?: SortOrder
    clubwerchow?: SortOrder
    ventas?: SortOrder
    administracion?: SortOrder
    campanas?: SortOrder
    socios?: SortOrder
    sepelio?: SortOrder
  }

  export type operadorAvgOrderByAggregateInput = {
    id?: SortOrder
    puestom?: SortOrder
    perfil?: SortOrder
    puestow?: SortOrder
    codigo?: SortOrder
  }

  export type operadorMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    puestom?: SortOrder
    perfil?: SortOrder
    estado?: SortOrder
    puestow?: SortOrder
    codigo?: SortOrder
    medicos?: SortOrder
    sucursal?: SortOrder
    prestamos?: SortOrder
    ordenpago?: SortOrder
    clubwerchow?: SortOrder
    ventas?: SortOrder
    administracion?: SortOrder
    campanas?: SortOrder
    socios?: SortOrder
    sepelio?: SortOrder
  }

  export type operadorMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    puestom?: SortOrder
    perfil?: SortOrder
    estado?: SortOrder
    puestow?: SortOrder
    codigo?: SortOrder
    medicos?: SortOrder
    sucursal?: SortOrder
    prestamos?: SortOrder
    ordenpago?: SortOrder
    clubwerchow?: SortOrder
    ventas?: SortOrder
    administracion?: SortOrder
    campanas?: SortOrder
    socios?: SortOrder
    sepelio?: SortOrder
  }

  export type operadorSumOrderByAggregateInput = {
    id?: SortOrder
    puestom?: SortOrder
    perfil?: SortOrder
    puestow?: SortOrder
    codigo?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type ordenes_pagoCountOrderByAggregateInput = {
    idorden?: SortOrder
    fecha?: SortOrder
    proveedor?: SortOrder
    cuit_cuil?: SortOrder
    total?: SortOrder
    operador_carga?: SortOrder
    autorizado?: SortOrder
    operador_autorizacion?: SortOrder
    fecha_autorizacion?: SortOrder
    norden?: SortOrder
    observacion?: SortOrder
    nombre?: SortOrder
    tipo_orden?: SortOrder
    nfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha_pago?: SortOrder
    pagado?: SortOrder
    estado?: SortOrder
  }

  export type ordenes_pagoAvgOrderByAggregateInput = {
    idorden?: SortOrder
    total?: SortOrder
  }

  export type ordenes_pagoMaxOrderByAggregateInput = {
    idorden?: SortOrder
    fecha?: SortOrder
    proveedor?: SortOrder
    cuit_cuil?: SortOrder
    total?: SortOrder
    operador_carga?: SortOrder
    autorizado?: SortOrder
    operador_autorizacion?: SortOrder
    fecha_autorizacion?: SortOrder
    norden?: SortOrder
    observacion?: SortOrder
    nombre?: SortOrder
    tipo_orden?: SortOrder
    nfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha_pago?: SortOrder
    pagado?: SortOrder
    estado?: SortOrder
  }

  export type ordenes_pagoMinOrderByAggregateInput = {
    idorden?: SortOrder
    fecha?: SortOrder
    proveedor?: SortOrder
    cuit_cuil?: SortOrder
    total?: SortOrder
    operador_carga?: SortOrder
    autorizado?: SortOrder
    operador_autorizacion?: SortOrder
    fecha_autorizacion?: SortOrder
    norden?: SortOrder
    observacion?: SortOrder
    nombre?: SortOrder
    tipo_orden?: SortOrder
    nfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha_pago?: SortOrder
    pagado?: SortOrder
    estado?: SortOrder
  }

  export type ordenes_pagoSumOrderByAggregateInput = {
    idorden?: SortOrder
    total?: SortOrder
  }

  export type personalCountOrderByAggregateInput = {
    idpersonal?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    alta?: SortOrder
    rol?: SortOrder
    legajo?: SortOrder
    baja?: SortOrder
  }

  export type personalAvgOrderByAggregateInput = {
    idpersonal?: SortOrder
    dni?: SortOrder
  }

  export type personalMaxOrderByAggregateInput = {
    idpersonal?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    alta?: SortOrder
    rol?: SortOrder
    legajo?: SortOrder
    baja?: SortOrder
  }

  export type personalMinOrderByAggregateInput = {
    idpersonal?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    alta?: SortOrder
    rol?: SortOrder
    legajo?: SortOrder
    baja?: SortOrder
  }

  export type personalSumOrderByAggregateInput = {
    idpersonal?: SortOrder
    dni?: SortOrder
  }

  export type plan_cuentasCountOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentasAvgOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    asiento?: SortOrder
  }

  export type plan_cuentasMaxOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentasMinOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentasSumOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    asiento?: SortOrder
  }

  export type plan_cuentas_xCountOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentas_xAvgOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    asiento?: SortOrder
  }

  export type plan_cuentas_xMaxOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentas_xMinOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    descripcion?: SortOrder
    asiento?: SortOrder
    tipo?: SortOrder
  }

  export type plan_cuentas_xSumOrderByAggregateInput = {
    idcuenta?: SortOrder
    idempresa?: SortOrder
    codigo?: SortOrder
    asiento?: SortOrder
  }

  export type plan_detalleCountOrderByAggregateInput = {
    id_plandetalle?: SortOrder
    detalle?: SortOrder
    cuota?: SortOrder
    sub_ext?: SortOrder
    vigencia?: SortOrder
    id_plan?: SortOrder
  }

  export type plan_detalleAvgOrderByAggregateInput = {
    id_plandetalle?: SortOrder
    cuota?: SortOrder
    id_plan?: SortOrder
  }

  export type plan_detalleMaxOrderByAggregateInput = {
    id_plandetalle?: SortOrder
    detalle?: SortOrder
    cuota?: SortOrder
    sub_ext?: SortOrder
    vigencia?: SortOrder
    id_plan?: SortOrder
  }

  export type plan_detalleMinOrderByAggregateInput = {
    id_plandetalle?: SortOrder
    detalle?: SortOrder
    cuota?: SortOrder
    sub_ext?: SortOrder
    vigencia?: SortOrder
    id_plan?: SortOrder
  }

  export type plan_detalleSumOrderByAggregateInput = {
    id_plandetalle?: SortOrder
    cuota?: SortOrder
    id_plan?: SortOrder
  }

  export type plan_precioCountOrderByAggregateInput = {
    id_plan?: SortOrder
    plan?: SortOrder
    tipo_plan?: SortOrder
    codigo?: SortOrder
  }

  export type plan_precioAvgOrderByAggregateInput = {
    id_plan?: SortOrder
  }

  export type plan_precioMaxOrderByAggregateInput = {
    id_plan?: SortOrder
    plan?: SortOrder
    tipo_plan?: SortOrder
    codigo?: SortOrder
  }

  export type plan_precioMinOrderByAggregateInput = {
    id_plan?: SortOrder
    plan?: SortOrder
    tipo_plan?: SortOrder
    codigo?: SortOrder
  }

  export type plan_precioSumOrderByAggregateInput = {
    id_plan?: SortOrder
  }

  export type porcentaje_liqCountOrderByAggregateInput = {
    porcliq_id?: SortOrder
    porcliq_nombre?: SortOrder
    porcliq_descrip?: SortOrder
    porcliq_cuotas?: SortOrder
    porcliq_porcentaje?: SortOrder
  }

  export type porcentaje_liqAvgOrderByAggregateInput = {
    porcliq_id?: SortOrder
    porcliq_cuotas?: SortOrder
    porcliq_porcentaje?: SortOrder
  }

  export type porcentaje_liqMaxOrderByAggregateInput = {
    porcliq_id?: SortOrder
    porcliq_nombre?: SortOrder
    porcliq_descrip?: SortOrder
    porcliq_cuotas?: SortOrder
    porcliq_porcentaje?: SortOrder
  }

  export type porcentaje_liqMinOrderByAggregateInput = {
    porcliq_id?: SortOrder
    porcliq_nombre?: SortOrder
    porcliq_descrip?: SortOrder
    porcliq_cuotas?: SortOrder
    porcliq_porcentaje?: SortOrder
  }

  export type porcentaje_liqSumOrderByAggregateInput = {
    porcliq_id?: SortOrder
    porcliq_cuotas?: SortOrder
    porcliq_porcentaje?: SortOrder
  }

  export type prestamos_empleadosCountOrderByAggregateInput = {
    idprestamo?: SortOrder
    empleado?: SortOrder
    fecha_solicitud?: SortOrder
    capital?: SortOrder
    plan_cuotas?: SortOrder
    cuota_mensual?: SortOrder
    capital_dev?: SortOrder
    inicia?: SortOrder
    termina?: SortOrder
    estado?: SortOrder
    capinoaut?: SortOrder
  }

  export type prestamos_empleadosAvgOrderByAggregateInput = {
    idprestamo?: SortOrder
    capital?: SortOrder
    plan_cuotas?: SortOrder
    cuota_mensual?: SortOrder
    capital_dev?: SortOrder
  }

  export type prestamos_empleadosMaxOrderByAggregateInput = {
    idprestamo?: SortOrder
    empleado?: SortOrder
    fecha_solicitud?: SortOrder
    capital?: SortOrder
    plan_cuotas?: SortOrder
    cuota_mensual?: SortOrder
    capital_dev?: SortOrder
    inicia?: SortOrder
    termina?: SortOrder
    estado?: SortOrder
    capinoaut?: SortOrder
  }

  export type prestamos_empleadosMinOrderByAggregateInput = {
    idprestamo?: SortOrder
    empleado?: SortOrder
    fecha_solicitud?: SortOrder
    capital?: SortOrder
    plan_cuotas?: SortOrder
    cuota_mensual?: SortOrder
    capital_dev?: SortOrder
    inicia?: SortOrder
    termina?: SortOrder
    estado?: SortOrder
    capinoaut?: SortOrder
  }

  export type prestamos_empleadosSumOrderByAggregateInput = {
    idprestamo?: SortOrder
    capital?: SortOrder
    plan_cuotas?: SortOrder
    cuota_mensual?: SortOrder
    capital_dev?: SortOrder
  }

  export type prestamos_empleados_cobroCountOrderByAggregateInput = {
    idpago?: SortOrder
    idprestamo?: SortOrder
    cuota?: SortOrder
    importe?: SortOrder
    fecha_cobro?: SortOrder
    estado?: SortOrder
    fecha_pago?: SortOrder
    operador?: SortOrder
  }

  export type prestamos_empleados_cobroAvgOrderByAggregateInput = {
    idpago?: SortOrder
    idprestamo?: SortOrder
    cuota?: SortOrder
    importe?: SortOrder
  }

  export type prestamos_empleados_cobroMaxOrderByAggregateInput = {
    idpago?: SortOrder
    idprestamo?: SortOrder
    cuota?: SortOrder
    importe?: SortOrder
    fecha_cobro?: SortOrder
    estado?: SortOrder
    fecha_pago?: SortOrder
    operador?: SortOrder
  }

  export type prestamos_empleados_cobroMinOrderByAggregateInput = {
    idpago?: SortOrder
    idprestamo?: SortOrder
    cuota?: SortOrder
    importe?: SortOrder
    fecha_cobro?: SortOrder
    estado?: SortOrder
    fecha_pago?: SortOrder
    operador?: SortOrder
  }

  export type prestamos_empleados_cobroSumOrderByAggregateInput = {
    idpago?: SortOrder
    idprestamo?: SortOrder
    cuota?: SortOrder
    importe?: SortOrder
  }

  export type produccionCountOrderByAggregateInput = {
    prod_ide?: SortOrder
    prod_fechacarga?: SortOrder
    prod_fechaafi?: SortOrder
    prod_asesor?: SortOrder
    prod_empre?: SortOrder
    prod_mes?: SortOrder
    prod_anio?: SortOrder
    prod_apeafi?: SortOrder
    prod_nomafi?: SortOrder
    prod_dniafi?: SortOrder
    prod_local?: SortOrder
    prod_recibo?: SortOrder
    prod_monto?: SortOrder
    prod_plan?: SortOrder
    prod_pago?: SortOrder
    prod_cta_tar?: SortOrder
    prod_obs?: SortOrder
    prod_semana?: SortOrder
    prod_estado?: SortOrder
    prod_cierre?: SortOrder
    prod_afiliado?: SortOrder
    prod_rendido?: SortOrder
    prod_recibosis?: SortOrder
    prod_fechren?: SortOrder
    prod_tel?: SortOrder
  }

  export type produccionAvgOrderByAggregateInput = {
    prod_ide?: SortOrder
    prod_asesor?: SortOrder
    prod_anio?: SortOrder
    prod_dniafi?: SortOrder
    prod_local?: SortOrder
    prod_recibo?: SortOrder
    prod_monto?: SortOrder
    prod_cta_tar?: SortOrder
    prod_semana?: SortOrder
    prod_cierre?: SortOrder
    prod_afiliado?: SortOrder
    prod_recibosis?: SortOrder
  }

  export type produccionMaxOrderByAggregateInput = {
    prod_ide?: SortOrder
    prod_fechacarga?: SortOrder
    prod_fechaafi?: SortOrder
    prod_asesor?: SortOrder
    prod_empre?: SortOrder
    prod_mes?: SortOrder
    prod_anio?: SortOrder
    prod_apeafi?: SortOrder
    prod_nomafi?: SortOrder
    prod_dniafi?: SortOrder
    prod_local?: SortOrder
    prod_recibo?: SortOrder
    prod_monto?: SortOrder
    prod_plan?: SortOrder
    prod_pago?: SortOrder
    prod_cta_tar?: SortOrder
    prod_obs?: SortOrder
    prod_semana?: SortOrder
    prod_estado?: SortOrder
    prod_cierre?: SortOrder
    prod_afiliado?: SortOrder
    prod_rendido?: SortOrder
    prod_recibosis?: SortOrder
    prod_fechren?: SortOrder
    prod_tel?: SortOrder
  }

  export type produccionMinOrderByAggregateInput = {
    prod_ide?: SortOrder
    prod_fechacarga?: SortOrder
    prod_fechaafi?: SortOrder
    prod_asesor?: SortOrder
    prod_empre?: SortOrder
    prod_mes?: SortOrder
    prod_anio?: SortOrder
    prod_apeafi?: SortOrder
    prod_nomafi?: SortOrder
    prod_dniafi?: SortOrder
    prod_local?: SortOrder
    prod_recibo?: SortOrder
    prod_monto?: SortOrder
    prod_plan?: SortOrder
    prod_pago?: SortOrder
    prod_cta_tar?: SortOrder
    prod_obs?: SortOrder
    prod_semana?: SortOrder
    prod_estado?: SortOrder
    prod_cierre?: SortOrder
    prod_afiliado?: SortOrder
    prod_rendido?: SortOrder
    prod_recibosis?: SortOrder
    prod_fechren?: SortOrder
    prod_tel?: SortOrder
  }

  export type produccionSumOrderByAggregateInput = {
    prod_ide?: SortOrder
    prod_asesor?: SortOrder
    prod_anio?: SortOrder
    prod_dniafi?: SortOrder
    prod_local?: SortOrder
    prod_recibo?: SortOrder
    prod_monto?: SortOrder
    prod_cta_tar?: SortOrder
    prod_semana?: SortOrder
    prod_cierre?: SortOrder
    prod_afiliado?: SortOrder
    prod_recibosis?: SortOrder
  }

  export type registro_constancia_afiliacionCountOrderByAggregateInput = {
    idconstancia?: SortOrder
    apellido_extinto?: SortOrder
    nombre_extinto?: SortOrder
    dni_extinto?: SortOrder
    apellido_soli?: SortOrder
    nombre_soli?: SortOrder
    dni_soli?: SortOrder
    lugar_presentacion?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    idservicio?: SortOrder
  }

  export type registro_constancia_afiliacionAvgOrderByAggregateInput = {
    idconstancia?: SortOrder
    dni_extinto?: SortOrder
    idservicio?: SortOrder
  }

  export type registro_constancia_afiliacionMaxOrderByAggregateInput = {
    idconstancia?: SortOrder
    apellido_extinto?: SortOrder
    nombre_extinto?: SortOrder
    dni_extinto?: SortOrder
    apellido_soli?: SortOrder
    nombre_soli?: SortOrder
    dni_soli?: SortOrder
    lugar_presentacion?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    idservicio?: SortOrder
  }

  export type registro_constancia_afiliacionMinOrderByAggregateInput = {
    idconstancia?: SortOrder
    apellido_extinto?: SortOrder
    nombre_extinto?: SortOrder
    dni_extinto?: SortOrder
    apellido_soli?: SortOrder
    nombre_soli?: SortOrder
    dni_soli?: SortOrder
    lugar_presentacion?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    idservicio?: SortOrder
  }

  export type registro_constancia_afiliacionSumOrderByAggregateInput = {
    idconstancia?: SortOrder
    dni_extinto?: SortOrder
    idservicio?: SortOrder
  }

  export type rehabilitacionesCountOrderByAggregateInput = {
    idrehab?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
  }

  export type rehabilitacionesAvgOrderByAggregateInput = {
    idrehab?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    idoperador?: SortOrder
  }

  export type rehabilitacionesMaxOrderByAggregateInput = {
    idrehab?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
  }

  export type rehabilitacionesMinOrderByAggregateInput = {
    idrehab?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    operador?: SortOrder
    vigencia?: SortOrder
    fecha?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    empresa?: SortOrder
    idoperador?: SortOrder
  }

  export type rehabilitacionesSumOrderByAggregateInput = {
    idrehab?: SortOrder
    cuotas?: SortOrder
    dni?: SortOrder
    idoperador?: SortOrder
  }

  export type rol_personalCountOrderByAggregateInput = {
    idrol?: SortOrder
    rol?: SortOrder
  }

  export type rol_personalAvgOrderByAggregateInput = {
    idrol?: SortOrder
  }

  export type rol_personalMaxOrderByAggregateInput = {
    idrol?: SortOrder
    rol?: SortOrder
  }

  export type rol_personalMinOrderByAggregateInput = {
    idrol?: SortOrder
    rol?: SortOrder
  }

  export type rol_personalSumOrderByAggregateInput = {
    idrol?: SortOrder
  }

  export type sucursalCountOrderByAggregateInput = {
    idsucursal?: SortOrder
    sucursal?: SortOrder
    codigo?: SortOrder
  }

  export type sucursalAvgOrderByAggregateInput = {
    idsucursal?: SortOrder
  }

  export type sucursalMaxOrderByAggregateInput = {
    idsucursal?: SortOrder
    sucursal?: SortOrder
    codigo?: SortOrder
  }

  export type sucursalMinOrderByAggregateInput = {
    idsucursal?: SortOrder
    sucursal?: SortOrder
    codigo?: SortOrder
  }

  export type sucursalSumOrderByAggregateInput = {
    idsucursal?: SortOrder
  }

  export type sueldosCountOrderByAggregateInput = {
    sld_id?: SortOrder
    sld_perfil?: SortOrder
    sld_basico?: SortOrder
    sld_basicoant?: SortOrder
  }

  export type sueldosAvgOrderByAggregateInput = {
    sld_id?: SortOrder
    sld_basico?: SortOrder
    sld_basicoant?: SortOrder
  }

  export type sueldosMaxOrderByAggregateInput = {
    sld_id?: SortOrder
    sld_perfil?: SortOrder
    sld_basico?: SortOrder
    sld_basicoant?: SortOrder
  }

  export type sueldosMinOrderByAggregateInput = {
    sld_id?: SortOrder
    sld_perfil?: SortOrder
    sld_basico?: SortOrder
    sld_basicoant?: SortOrder
  }

  export type sueldosSumOrderByAggregateInput = {
    sld_id?: SortOrder
    sld_basico?: SortOrder
    sld_basicoant?: SortOrder
  }

  export type tab_efCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    holiday?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type tab_efAvgOrderByAggregateInput = {
    allDay?: SortOrder
    holiday?: SortOrder
  }

  export type tab_efMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    holiday?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type tab_efMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    holiday?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type tab_efSumOrderByAggregateInput = {
    allDay?: SortOrder
    holiday?: SortOrder
  }

  export type tablero_efectividadCountOrderByAggregateInput = {
    idregistro?: SortOrder
    ano?: SortOrder
    mes?: SortOrder
    dia?: SortOrder
    efectividad?: SortOrder
    aumento?: SortOrder
    por_aumento?: SortOrder
    feriado?: SortOrder
  }

  export type tablero_efectividadAvgOrderByAggregateInput = {
    idregistro?: SortOrder
    ano?: SortOrder
    mes?: SortOrder
    dia?: SortOrder
    efectividad?: SortOrder
    por_aumento?: SortOrder
  }

  export type tablero_efectividadMaxOrderByAggregateInput = {
    idregistro?: SortOrder
    ano?: SortOrder
    mes?: SortOrder
    dia?: SortOrder
    efectividad?: SortOrder
    aumento?: SortOrder
    por_aumento?: SortOrder
    feriado?: SortOrder
  }

  export type tablero_efectividadMinOrderByAggregateInput = {
    idregistro?: SortOrder
    ano?: SortOrder
    mes?: SortOrder
    dia?: SortOrder
    efectividad?: SortOrder
    aumento?: SortOrder
    por_aumento?: SortOrder
    feriado?: SortOrder
  }

  export type tablero_efectividadSumOrderByAggregateInput = {
    idregistro?: SortOrder
    ano?: SortOrder
    mes?: SortOrder
    dia?: SortOrder
    efectividad?: SortOrder
    por_aumento?: SortOrder
  }

  export type tareas_sucursalesCountOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
    sucursal?: SortOrder
    operador?: SortOrder
    leido?: SortOrder
  }

  export type tareas_sucursalesAvgOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type tareas_sucursalesMaxOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
    sucursal?: SortOrder
    operador?: SortOrder
    leido?: SortOrder
  }

  export type tareas_sucursalesMinOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
    sucursal?: SortOrder
    operador?: SortOrder
    leido?: SortOrder
  }

  export type tareas_sucursalesSumOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type tipo_contratosCountOrderByAggregateInput = {
    idtipocontrato?: SortOrder
    tipo_contrato?: SortOrder
    url?: SortOrder
  }

  export type tipo_contratosAvgOrderByAggregateInput = {
    idtipocontrato?: SortOrder
  }

  export type tipo_contratosMaxOrderByAggregateInput = {
    idtipocontrato?: SortOrder
    tipo_contrato?: SortOrder
    url?: SortOrder
  }

  export type tipo_contratosMinOrderByAggregateInput = {
    idtipocontrato?: SortOrder
    tipo_contrato?: SortOrder
    url?: SortOrder
  }

  export type tipo_contratosSumOrderByAggregateInput = {
    idtipocontrato?: SortOrder
  }

  export type tipo_facturasCountOrderByAggregateInput = {
    idfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type tipo_facturasAvgOrderByAggregateInput = {
    idfactura?: SortOrder
  }

  export type tipo_facturasMaxOrderByAggregateInput = {
    idfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type tipo_facturasMinOrderByAggregateInput = {
    idfactura?: SortOrder
    tipo_factura?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type tipo_facturasSumOrderByAggregateInput = {
    idfactura?: SortOrder
  }

  export type turno_bajasCountOrderByAggregateInput = {
    idturno?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    fecha_pedido?: SortOrder
    fecha_turno?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    fecha_atencion?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    respuesta?: SortOrder
    operador_atencion?: SortOrder
    detalle?: SortOrder
  }

  export type turno_bajasAvgOrderByAggregateInput = {
    idturno?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    estado?: SortOrder
  }

  export type turno_bajasMaxOrderByAggregateInput = {
    idturno?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    fecha_pedido?: SortOrder
    fecha_turno?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    fecha_atencion?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    respuesta?: SortOrder
    operador_atencion?: SortOrder
    detalle?: SortOrder
  }

  export type turno_bajasMinOrderByAggregateInput = {
    idturno?: SortOrder
    contrato?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    fecha_pedido?: SortOrder
    fecha_turno?: SortOrder
    motivo?: SortOrder
    operador?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    fecha_atencion?: SortOrder
    estado?: SortOrder
    empresa?: SortOrder
    respuesta?: SortOrder
    operador_atencion?: SortOrder
    detalle?: SortOrder
  }

  export type turno_bajasSumOrderByAggregateInput = {
    idturno?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    estado?: SortOrder
  }

  export type vacacionesCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type vacacionesAvgOrderByAggregateInput = {
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type vacacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type vacacionesMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    user?: SortOrder
    detail?: SortOrder
  }

  export type vacacionesSumOrderByAggregateInput = {
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type motivos_atencionCountOrderByAggregateInput = {
    idmotivo?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
  }

  export type motivos_atencionAvgOrderByAggregateInput = {
    idmotivo?: SortOrder
  }

  export type motivos_atencionMaxOrderByAggregateInput = {
    idmotivo?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
  }

  export type motivos_atencionMinOrderByAggregateInput = {
    idmotivo?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
  }

  export type motivos_atencionSumOrderByAggregateInput = {
    idmotivo?: SortOrder
  }

  export type prestamos_plan_cuotasCountOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrder
    detalle?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_plan_cuotasAvgOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrder
  }

  export type prestamos_plan_cuotasMaxOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrder
    detalle?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_plan_cuotasMinOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrder
    detalle?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_plan_cuotasSumOrderByAggregateInput = {
    idplan?: SortOrder
    plan_cuotas?: SortOrder
  }

  export type prestamos_tasasCountOrderByAggregateInput = {
    idtasa?: SortOrder
    tasa?: SortOrder
    plan?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_tasasAvgOrderByAggregateInput = {
    idtasa?: SortOrder
    tasa?: SortOrder
  }

  export type prestamos_tasasMaxOrderByAggregateInput = {
    idtasa?: SortOrder
    tasa?: SortOrder
    plan?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_tasasMinOrderByAggregateInput = {
    idtasa?: SortOrder
    tasa?: SortOrder
    plan?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
  }

  export type prestamos_tasasSumOrderByAggregateInput = {
    idtasa?: SortOrder
    tasa?: SortOrder
  }

  export type certificado_estudiantesCountOrderByAggregateInput = {
    idcertificado?: SortOrder
    contrato?: SortOrder
    socio?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ncert?: SortOrder
  }

  export type certificado_estudiantesAvgOrderByAggregateInput = {
    idcertificado?: SortOrder
    contrato?: SortOrder
  }

  export type certificado_estudiantesMaxOrderByAggregateInput = {
    idcertificado?: SortOrder
    contrato?: SortOrder
    socio?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ncert?: SortOrder
  }

  export type certificado_estudiantesMinOrderByAggregateInput = {
    idcertificado?: SortOrder
    contrato?: SortOrder
    socio?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ncert?: SortOrder
  }

  export type certificado_estudiantesSumOrderByAggregateInput = {
    idcertificado?: SortOrder
    contrato?: SortOrder
  }

  export type carteraCountOrderByAggregateInput = {
    contrato?: SortOrder
    socio?: SortOrder
    alta?: SortOrder
    grupo?: SortOrder
    adhs?: SortOrder
    plan?: SortOrder
    sub_plan?: SortOrder
    zona?: SortOrder
    cuota?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
    deuda?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    idcartera?: SortOrder
  }

  export type carteraAvgOrderByAggregateInput = {
    contrato?: SortOrder
    grupo?: SortOrder
    adhs?: SortOrder
    zona?: SortOrder
    cuota?: SortOrder
    deuda?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    idcartera?: SortOrder
  }

  export type carteraMaxOrderByAggregateInput = {
    contrato?: SortOrder
    socio?: SortOrder
    alta?: SortOrder
    grupo?: SortOrder
    adhs?: SortOrder
    plan?: SortOrder
    sub_plan?: SortOrder
    zona?: SortOrder
    cuota?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
    deuda?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    idcartera?: SortOrder
  }

  export type carteraMinOrderByAggregateInput = {
    contrato?: SortOrder
    socio?: SortOrder
    alta?: SortOrder
    grupo?: SortOrder
    adhs?: SortOrder
    plan?: SortOrder
    sub_plan?: SortOrder
    zona?: SortOrder
    cuota?: SortOrder
    empresa?: SortOrder
    sucursal?: SortOrder
    deuda?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    idcartera?: SortOrder
  }

  export type carteraSumOrderByAggregateInput = {
    contrato?: SortOrder
    grupo?: SortOrder
    adhs?: SortOrder
    zona?: SortOrder
    cuota?: SortOrder
    deuda?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    idcartera?: SortOrder
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedStringFilter = {
    equals?: string
    in?: string[]
    notIn?: string[]
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: string[]
    notIn?: string[]
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}