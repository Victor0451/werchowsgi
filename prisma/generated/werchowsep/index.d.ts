
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type ataud_precioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idprecio: number
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }, ExtArgs["result"]["ataud_precio"]>
  composites: {}
}

/**
 * Model ataud_precio
 * 
 */
export type ataud_precio = runtime.Types.DefaultSelection<ataud_precioPayload>
export type ataud_ventaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idataudventa: number
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }, ExtArgs["result"]["ataud_venta"]>
  composites: {}
}

/**
 * Model ataud_venta
 * 
 */
export type ataud_venta = runtime.Types.DefaultSelection<ataud_ventaPayload>
export type ataudesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idataud: number
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }, ExtArgs["result"]["ataudes"]>
  composites: {}
}

/**
 * Model ataudes
 * 
 */
export type ataudes = runtime.Types.DefaultSelection<ataudesPayload>
export type auto_usosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    FECHA: Date | null
    PATENTE: string | null
    DESCRIP: string | null
    NOMB_OPE: string | null
    CHOFER: string | null
    HORA1: string | null
    HORA2: string | null
    TAREA: string | null
    OBSERVA_1: string | null
    OBSERVA_2: string | null
    OPE_LLEGA: string | null
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number
  }, ExtArgs["result"]["auto_usos"]>
  composites: {}
}

/**
 * Model auto_usos
 * 
 */
export type auto_usos = runtime.Types.DefaultSelection<auto_usosPayload>
export type autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number
    estado: boolean | null
    operador: string | null
  }, ExtArgs["result"]["autos"]>
  composites: {}
}

/**
 * Model autos
 * 
 */
export type autos = runtime.Types.DefaultSelection<autosPayload>
export type autos_hoja_rutaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhojaruta: number
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }, ExtArgs["result"]["autos_hoja_ruta"]>
  composites: {}
}

/**
 * Model autos_hoja_ruta
 * 
 */
export type autos_hoja_ruta = runtime.Types.DefaultSelection<autos_hoja_rutaPayload>
export type autos_novedadesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovedad: number
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }, ExtArgs["result"]["autos_novedades"]>
  composites: {}
}

/**
 * Model autos_novedades
 * 
 */
export type autos_novedades = runtime.Types.DefaultSelection<autos_novedadesPayload>
export type autos_pago_patentePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idpago: number
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }, ExtArgs["result"]["autos_pago_patente"]>
  composites: {}
}

/**
 * Model autos_pago_patente
 * 
 */
export type autos_pago_patente = runtime.Types.DefaultSelection<autos_pago_patentePayload>
export type caja_saPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }, ExtArgs["result"]["caja_sa"]>
  composites: {}
}

/**
 * Model caja_sa
 * 
 */
export type caja_sa = runtime.Types.DefaultSelection<caja_saPayload>
export type caja_sepelioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }, ExtArgs["result"]["caja_sepelio"]>
  composites: {}
}

/**
 * Model caja_sepelio
 * 
 */
export type caja_sepelio = runtime.Types.DefaultSelection<caja_sepelioPayload>
export type caja_srlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }, ExtArgs["result"]["caja_srl"]>
  composites: {}
}

/**
 * Model caja_srl
 * 
 */
export type caja_srl = runtime.Types.DefaultSelection<caja_srlPayload>
export type conceptosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idconcepto: number
    concepto: string | null
    tipo: string | null
  }, ExtArgs["result"]["conceptos"]>
  composites: {}
}

/**
 * Model conceptos
 * 
 */
export type conceptos = runtime.Types.DefaultSelection<conceptosPayload>
export type conceptos_sepelio_cuentasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idconcepto: number | null
    idempresa: number | null
    sc_descripcion: string | null
    sc_cuenta: number | null
    id: number
  }, ExtArgs["result"]["conceptos_sepelio_cuentas"]>
  composites: {}
}

/**
 * Model conceptos_sepelio_cuentas
 * 
 */
export type conceptos_sepelio_cuentas = runtime.Types.DefaultSelection<conceptos_sepelio_cuentasPayload>
export type fabricante_ataudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idfabricante: number
    fabricante: string | null
  }, ExtArgs["result"]["fabricante_ataud"]>
  composites: {}
}

/**
 * Model fabricante_ataud
 * 
 */
export type fabricante_ataud = runtime.Types.DefaultSelection<fabricante_ataudPayload>
export type gasto_lutoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastoluto: number
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }, ExtArgs["result"]["gasto_luto"]>
  composites: {}
}

/**
 * Model gasto_luto
 * 
 */
export type gasto_luto = runtime.Types.DefaultSelection<gasto_lutoPayload>
export type gastos_cajaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }, ExtArgs["result"]["gastos_caja"]>
  composites: {}
}

/**
 * Model gastos_caja
 * 
 */
export type gastos_caja = runtime.Types.DefaultSelection<gastos_cajaPayload>
export type generacion_cajasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgeneracion: number
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }, ExtArgs["result"]["generacion_cajas"]>
  composites: {}
}

/**
 * Model generacion_cajas
 * 
 */
export type generacion_cajas = runtime.Types.DefaultSelection<generacion_cajasPayload>
export type historial_autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhistorial: number
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }, ExtArgs["result"]["historial_autos"]>
  composites: {}
}

/**
 * Model historial_autos
 * 
 */
export type historial_autos = runtime.Types.DefaultSelection<historial_autosPayload>
export type historial_stock_ataudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhistorial: number
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }, ExtArgs["result"]["historial_stock_ataud"]>
  composites: {}
}

/**
 * Model historial_stock_ataud
 * 
 */
export type historial_stock_ataud = runtime.Types.DefaultSelection<historial_stock_ataudPayload>
export type honorariosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtrabajo: number
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }, ExtArgs["result"]["honorarios"]>
  composites: {}
}

/**
 * Model honorarios
 * 
 */
export type honorarios = runtime.Types.DefaultSelection<honorariosPayload>
export type informe_tareasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtareas: number
    idinforme: number | null
    idservicio: number | null
    operador: string | null
    tarea: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    monto: number | null
    liquidado: boolean | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
  }, ExtArgs["result"]["informe_tareas"]>
  composites: {}
}

/**
 * Model informe_tareas
 * 
 */
export type informe_tareas = runtime.Types.DefaultSelection<informe_tareasPayload>
export type ingreso_cajaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idingreso: number
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }, ExtArgs["result"]["ingreso_caja"]>
  composites: {}
}

/**
 * Model ingreso_caja
 * 
 */
export type ingreso_caja = runtime.Types.DefaultSelection<ingreso_cajaPayload>
export type legajo_virtual_autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }, ExtArgs["result"]["legajo_virtual_autos"]>
  composites: {}
}

/**
 * Model legajo_virtual_autos
 * 
 */
export type legajo_virtual_autos = runtime.Types.DefaultSelection<legajo_virtual_autosPayload>
export type legajo_virtual_serviciosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }, ExtArgs["result"]["legajo_virtual_servicios"]>
  composites: {}
}

/**
 * Model legajo_virtual_servicios
 * 
 */
export type legajo_virtual_servicios = runtime.Types.DefaultSelection<legajo_virtual_serviciosPayload>
export type lic_conducirPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    FEC_NAC: Date | null
    NRO_CARNET: string | null
    FEC_VENCI: Date | null
    CLASE: string | null
    GRUPO: string | null
    FACTOR_RH: string | null
    id: number
  }, ExtArgs["result"]["lic_conducir"]>
  composites: {}
}

/**
 * Model lic_conducir
 * 
 */
export type lic_conducir = runtime.Types.DefaultSelection<lic_conducirPayload>
export type novedadesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovedad: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }, ExtArgs["result"]["novedades"]>
  composites: {}
}

/**
 * Model novedades
 * 
 */
export type novedades = runtime.Types.DefaultSelection<novedadesPayload>
export type operadorsepPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idoperador: number
    operador: string | null
  }, ExtArgs["result"]["operadorsep"]>
  composites: {}
}

/**
 * Model operadorsep
 * 
 */
export type operadorsep = runtime.Types.DefaultSelection<operadorsepPayload>
export type parcelasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idparcela: number
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }, ExtArgs["result"]["parcelas"]>
  composites: {}
}

/**
 * Model parcelas
 * 
 */
export type parcelas = runtime.Types.DefaultSelection<parcelasPayload>
export type parcelas_lugaresPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlugar: number
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }, ExtArgs["result"]["parcelas_lugares"]>
  composites: {}
}

/**
 * Model parcelas_lugares
 * 
 */
export type parcelas_lugares = runtime.Types.DefaultSelection<parcelas_lugaresPayload>
export type precio_servicioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idprecio: number
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }, ExtArgs["result"]["precio_servicio"]>
  composites: {}
}

/**
 * Model precio_servicio
 * 
 */
export type precio_servicio = runtime.Types.DefaultSelection<precio_servicioPayload>
export type proveedoresPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idproveedor: number
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }, ExtArgs["result"]["proveedores"]>
  composites: {}
}

/**
 * Model proveedores
 * 
 */
export type proveedores = runtime.Types.DefaultSelection<proveedoresPayload>
export type rodadosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    patente: string | null
    descripcion: string | null
    km: string | null
    responsable: string | null
    n_poliza: string | null
    emp_poliza: string | null
    n_motor: string | null
    n_chasis: string | null
    ano_fabri: string | null
    desde: Date | null
    hasta: Date | null
    id: number
  }, ExtArgs["result"]["rodados"]>
  composites: {}
}

/**
 * Model rodados
 * 
 */
export type rodados = runtime.Types.DefaultSelection<rodadosPayload>
export type servicio_informesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idinforme: number
    idservicio: number | null
    fecha: Date | null
    aprobado: boolean | null
    fecha_aprobado: Date | null
    operador_aprobado: string | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operador_liquidado: string | null
  }, ExtArgs["result"]["servicio_informes"]>
  composites: {}
}

/**
 * Model servicio_informes
 * 
 */
export type servicio_informes = runtime.Types.DefaultSelection<servicio_informesPayload>
export type servicio_ventaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idventa: number
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }, ExtArgs["result"]["servicio_venta"]>
  composites: {}
}

/**
 * Model servicio_venta
 * 
 */
export type servicio_venta = runtime.Types.DefaultSelection<servicio_ventaPayload>
export type serviciosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idservicio: number
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    detalle_corona: string | null
    religion: string | null
    estado_civil: string | null
    importe_servicio: number | null
    telefono: string | null
    movil: string | null
    gasto_luto: string | null
    conyugue: string | null
  }, ExtArgs["result"]["servicios"]>
  composites: {}
}

/**
 * Model servicios
 * 
 */
export type servicios = runtime.Types.DefaultSelection<serviciosPayload>
export type servicios_historicoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    NRO_NOTACR: number | null
    FEC_CREDIT: Date | null
    EXINTO: string | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    FEC_FALLEC: Date | null
    LUGAR: string | null
    TIPO_SERV: string | null
    PLAN: string | null
    SUB_PLAN: string | null
    CONTRATO: number | null
    CASA_MORT: string | null
    FEC_INHU: Date | null
    HORA: string | null
    CEMENTERIO: string | null
    DONDE_ENTI: string | null
    ATAUD_TIPO: string | null
    COD_ATAUD: number | null
    DETALLE: string | null
    RETI_CUER: string | null
    TRASLADO_A: string | null
    DIFE_KM: number | null
    CAPI_DOMI: string | null
    GRAB_PLACA: string | null
    TRAMITES: string | null
    AVISO_TELR: string | null
    CARROZA: number | null
    PORTACORO: string | null
    AUTO_DUELO: number | null
    SALA_VELAT: string | null
    ADICIONAL: string | null
    ADICIO_PAG: number | null
    OBSERVA0: string | null
    PARCELA: string | null
    SEC: string | null
    PARC: string | null
    SECC: string | null
    GASTO_ASOC: number | null
    GASTO_PAMI: string | null
    OBSERVA1: string | null
    OPE_ANUL: number | null
    ANULAR: number | null
    FEC_ANULA: Date | null
    CREDITO: number | null
    TOTA_LETRA: string | null
    TOTA_NUM: number | null
    FORMA_PAGO: string | null
    DOCUMENTO: string | null
    SOLI_CRED: string | null
    GARANT_CRE: string | null
    DNI_SOLI: number | null
    TEL_SOLI: string | null
    DOMI_SOLI: string | null
    DNI_GARANT: number | null
    TEL_GARANT: string | null
    DOMI_GARAN: string | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    FECANU_CRE: Date | null
    INFO_CRE: number | null
    SUCURSAL: string | null
    OPERADOR: number | null
    TRASPASO: Date | null
    EMPRESA: string | null
    id: number
  }, ExtArgs["result"]["servicios_historico"]>
  composites: {}
}

/**
 * Model servicios_historico
 * 
 */
export type servicios_historico = runtime.Types.DefaultSelection<servicios_historicoPayload>
export type tareasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idevents: number
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }, ExtArgs["result"]["tareas"]>
  composites: {}
}

/**
 * Model tareas
 * 
 */
export type tareas = runtime.Types.DefaultSelection<tareasPayload>
export type visitantesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idvisitante: number
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }, ExtArgs["result"]["visitantes"]>
  composites: {}
}

/**
 * Model visitantes
 * 
 */
export type visitantes = runtime.Types.DefaultSelection<visitantesPayload>
export type informe_gastosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    idinforme: number | null
    idservicio: number | null
    gasto: string | null
    observacion: string | null
    importe: number | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operadorliq: string | null
  }, ExtArgs["result"]["informe_gastos"]>
  composites: {}
}

/**
 * Model informe_gastos
 * 
 */
export type informe_gastos = runtime.Types.DefaultSelection<informe_gastosPayload>
export type servicios_gastosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    gastos: string | null
    observacion: string | null
  }, ExtArgs["result"]["servicios_gastos"]>
  composites: {}
}

/**
 * Model servicios_gastos
 * 
 */
export type servicios_gastos = runtime.Types.DefaultSelection<servicios_gastosPayload>
export type liquidacion_guardiasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idturno: number
    lugar: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    operador: string | null
    mes: number | null
    ano: number | null
    feriado: boolean | null
    liquidado: number | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
    aprobado: number | null
    fecha_aprobacion: Date | null
    operadorap: string | null
    importe: number | null
  }, ExtArgs["result"]["liquidacion_guardias"]>
  composites: {}
}

/**
 * Model liquidacion_guardias
 * 
 */
export type liquidacion_guardias = runtime.Types.DefaultSelection<liquidacion_guardiasPayload>
export type liquidacion_registroPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idliquidacion: number
    fecha: Date | null
    empleado: string | null
    concepto: string | null
    fecha_concepto: Date | null
    importe: number | null
    operador: string | null
  }, ExtArgs["result"]["liquidacion_registro"]>
  composites: {}
}

/**
 * Model liquidacion_registro
 * 
 */
export type liquidacion_registro = runtime.Types.DefaultSelection<liquidacion_registroPayload>
export type gastos_caja_copyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }, ExtArgs["result"]["gastos_caja_copy"]>
  composites: {}
}

/**
 * Model gastos_caja_copy
 * 
 */
export type gastos_caja_copy = runtime.Types.DefaultSelection<gastos_caja_copyPayload>
export type servicio_presupuestoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idpresupuesto: number
    idservicio: number | null
    fecha: Date | null
    apoderado: string | null
    domicilio: string | null
    telefono: string | null
    detalle: string | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
    operador: string | null
  }, ExtArgs["result"]["servicio_presupuesto"]>
  composites: {}
}

/**
 * Model servicio_presupuesto
 * 
 */
export type servicio_presupuesto = runtime.Types.DefaultSelection<servicio_presupuestoPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ataud_precios
 * const ataud_precios = await prisma.ataud_precio.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ataud_precios
   * const ataud_precios = await prisma.ataud_precio.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ataud_precio`: Exposes CRUD operations for the **ataud_precio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_precios
    * const ataud_precios = await prisma.ataud_precio.findMany()
    * ```
    */
  get ataud_precio(): Prisma.ataud_precioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ataud_venta`: Exposes CRUD operations for the **ataud_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_ventas
    * const ataud_ventas = await prisma.ataud_venta.findMany()
    * ```
    */
  get ataud_venta(): Prisma.ataud_ventaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ataudes`: Exposes CRUD operations for the **ataudes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataudes
    * const ataudes = await prisma.ataudes.findMany()
    * ```
    */
  get ataudes(): Prisma.ataudesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.auto_usos`: Exposes CRUD operations for the **auto_usos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auto_usos
    * const auto_usos = await prisma.auto_usos.findMany()
    * ```
    */
  get auto_usos(): Prisma.auto_usosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos`: Exposes CRUD operations for the **autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos
    * const autos = await prisma.autos.findMany()
    * ```
    */
  get autos(): Prisma.autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_hoja_ruta`: Exposes CRUD operations for the **autos_hoja_ruta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_hoja_rutas
    * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
    * ```
    */
  get autos_hoja_ruta(): Prisma.autos_hoja_rutaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_novedades`: Exposes CRUD operations for the **autos_novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_novedades
    * const autos_novedades = await prisma.autos_novedades.findMany()
    * ```
    */
  get autos_novedades(): Prisma.autos_novedadesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_pago_patente`: Exposes CRUD operations for the **autos_pago_patente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_pago_patentes
    * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
    * ```
    */
  get autos_pago_patente(): Prisma.autos_pago_patenteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_sa`: Exposes CRUD operations for the **caja_sa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sas
    * const caja_sas = await prisma.caja_sa.findMany()
    * ```
    */
  get caja_sa(): Prisma.caja_saDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_sepelio`: Exposes CRUD operations for the **caja_sepelio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sepelios
    * const caja_sepelios = await prisma.caja_sepelio.findMany()
    * ```
    */
  get caja_sepelio(): Prisma.caja_sepelioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_srl`: Exposes CRUD operations for the **caja_srl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_srls
    * const caja_srls = await prisma.caja_srl.findMany()
    * ```
    */
  get caja_srl(): Prisma.caja_srlDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.conceptos`: Exposes CRUD operations for the **conceptos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conceptos
    * const conceptos = await prisma.conceptos.findMany()
    * ```
    */
  get conceptos(): Prisma.conceptosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.conceptos_sepelio_cuentas`: Exposes CRUD operations for the **conceptos_sepelio_cuentas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conceptos_sepelio_cuentas
    * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findMany()
    * ```
    */
  get conceptos_sepelio_cuentas(): Prisma.conceptos_sepelio_cuentasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fabricante_ataud`: Exposes CRUD operations for the **fabricante_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fabricante_atauds
    * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
    * ```
    */
  get fabricante_ataud(): Prisma.fabricante_ataudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gasto_luto`: Exposes CRUD operations for the **gasto_luto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gasto_lutos
    * const gasto_lutos = await prisma.gasto_luto.findMany()
    * ```
    */
  get gasto_luto(): Prisma.gasto_lutoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gastos_caja`: Exposes CRUD operations for the **gastos_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastos_cajas
    * const gastos_cajas = await prisma.gastos_caja.findMany()
    * ```
    */
  get gastos_caja(): Prisma.gastos_cajaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.generacion_cajas`: Exposes CRUD operations for the **generacion_cajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generacion_cajas
    * const generacion_cajas = await prisma.generacion_cajas.findMany()
    * ```
    */
  get generacion_cajas(): Prisma.generacion_cajasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_autos`: Exposes CRUD operations for the **historial_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_autos
    * const historial_autos = await prisma.historial_autos.findMany()
    * ```
    */
  get historial_autos(): Prisma.historial_autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_stock_ataud`: Exposes CRUD operations for the **historial_stock_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_stock_atauds
    * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
    * ```
    */
  get historial_stock_ataud(): Prisma.historial_stock_ataudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.honorarios`: Exposes CRUD operations for the **honorarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Honorarios
    * const honorarios = await prisma.honorarios.findMany()
    * ```
    */
  get honorarios(): Prisma.honorariosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.informe_tareas`: Exposes CRUD operations for the **informe_tareas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Informe_tareas
    * const informe_tareas = await prisma.informe_tareas.findMany()
    * ```
    */
  get informe_tareas(): Prisma.informe_tareasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ingreso_caja`: Exposes CRUD operations for the **ingreso_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingreso_cajas
    * const ingreso_cajas = await prisma.ingreso_caja.findMany()
    * ```
    */
  get ingreso_caja(): Prisma.ingreso_cajaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_autos`: Exposes CRUD operations for the **legajo_virtual_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_autos
    * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
    * ```
    */
  get legajo_virtual_autos(): Prisma.legajo_virtual_autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_servicios`: Exposes CRUD operations for the **legajo_virtual_servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_servicios
    * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
    * ```
    */
  get legajo_virtual_servicios(): Prisma.legajo_virtual_serviciosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.lic_conducir`: Exposes CRUD operations for the **lic_conducir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lic_conducirs
    * const lic_conducirs = await prisma.lic_conducir.findMany()
    * ```
    */
  get lic_conducir(): Prisma.lic_conducirDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.novedades`: Exposes CRUD operations for the **novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Novedades
    * const novedades = await prisma.novedades.findMany()
    * ```
    */
  get novedades(): Prisma.novedadesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.operadorsep`: Exposes CRUD operations for the **operadorsep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operadorseps
    * const operadorseps = await prisma.operadorsep.findMany()
    * ```
    */
  get operadorsep(): Prisma.operadorsepDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parcelas`: Exposes CRUD operations for the **parcelas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcelas
    * const parcelas = await prisma.parcelas.findMany()
    * ```
    */
  get parcelas(): Prisma.parcelasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parcelas_lugares`: Exposes CRUD operations for the **parcelas_lugares** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcelas_lugares
    * const parcelas_lugares = await prisma.parcelas_lugares.findMany()
    * ```
    */
  get parcelas_lugares(): Prisma.parcelas_lugaresDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.precio_servicio`: Exposes CRUD operations for the **precio_servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Precio_servicios
    * const precio_servicios = await prisma.precio_servicio.findMany()
    * ```
    */
  get precio_servicio(): Prisma.precio_servicioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.proveedoresDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rodados`: Exposes CRUD operations for the **rodados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rodados
    * const rodados = await prisma.rodados.findMany()
    * ```
    */
  get rodados(): Prisma.rodadosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_informes`: Exposes CRUD operations for the **servicio_informes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_informes
    * const servicio_informes = await prisma.servicio_informes.findMany()
    * ```
    */
  get servicio_informes(): Prisma.servicio_informesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_venta`: Exposes CRUD operations for the **servicio_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_ventas
    * const servicio_ventas = await prisma.servicio_venta.findMany()
    * ```
    */
  get servicio_venta(): Prisma.servicio_ventaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.serviciosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicios_historico`: Exposes CRUD operations for the **servicios_historico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios_historicos
    * const servicios_historicos = await prisma.servicios_historico.findMany()
    * ```
    */
  get servicios_historico(): Prisma.servicios_historicoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tareas`: Exposes CRUD operations for the **tareas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas
    * const tareas = await prisma.tareas.findMany()
    * ```
    */
  get tareas(): Prisma.tareasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.visitantes`: Exposes CRUD operations for the **visitantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitantes
    * const visitantes = await prisma.visitantes.findMany()
    * ```
    */
  get visitantes(): Prisma.visitantesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.informe_gastos`: Exposes CRUD operations for the **informe_gastos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Informe_gastos
    * const informe_gastos = await prisma.informe_gastos.findMany()
    * ```
    */
  get informe_gastos(): Prisma.informe_gastosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicios_gastos`: Exposes CRUD operations for the **servicios_gastos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios_gastos
    * const servicios_gastos = await prisma.servicios_gastos.findMany()
    * ```
    */
  get servicios_gastos(): Prisma.servicios_gastosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.liquidacion_guardias`: Exposes CRUD operations for the **liquidacion_guardias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liquidacion_guardias
    * const liquidacion_guardias = await prisma.liquidacion_guardias.findMany()
    * ```
    */
  get liquidacion_guardias(): Prisma.liquidacion_guardiasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.liquidacion_registro`: Exposes CRUD operations for the **liquidacion_registro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liquidacion_registros
    * const liquidacion_registros = await prisma.liquidacion_registro.findMany()
    * ```
    */
  get liquidacion_registro(): Prisma.liquidacion_registroDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gastos_caja_copy`: Exposes CRUD operations for the **gastos_caja_copy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastos_caja_copies
    * const gastos_caja_copies = await prisma.gastos_caja_copy.findMany()
    * ```
    */
  get gastos_caja_copy(): Prisma.gastos_caja_copyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_presupuesto`: Exposes CRUD operations for the **servicio_presupuesto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_presupuestos
    * const servicio_presupuestos = await prisma.servicio_presupuesto.findMany()
    * ```
    */
  get servicio_presupuesto(): Prisma.servicio_presupuestoDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.17.0-dev.38
   * Query Engine version: e6267db1c1bc827b8eb87f644288c3cb0800ec89
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ataud_precio: 'ataud_precio',
    ataud_venta: 'ataud_venta',
    ataudes: 'ataudes',
    auto_usos: 'auto_usos',
    autos: 'autos',
    autos_hoja_ruta: 'autos_hoja_ruta',
    autos_novedades: 'autos_novedades',
    autos_pago_patente: 'autos_pago_patente',
    caja_sa: 'caja_sa',
    caja_sepelio: 'caja_sepelio',
    caja_srl: 'caja_srl',
    conceptos: 'conceptos',
    conceptos_sepelio_cuentas: 'conceptos_sepelio_cuentas',
    fabricante_ataud: 'fabricante_ataud',
    gasto_luto: 'gasto_luto',
    gastos_caja: 'gastos_caja',
    generacion_cajas: 'generacion_cajas',
    historial_autos: 'historial_autos',
    historial_stock_ataud: 'historial_stock_ataud',
    honorarios: 'honorarios',
    informe_tareas: 'informe_tareas',
    ingreso_caja: 'ingreso_caja',
    legajo_virtual_autos: 'legajo_virtual_autos',
    legajo_virtual_servicios: 'legajo_virtual_servicios',
    lic_conducir: 'lic_conducir',
    novedades: 'novedades',
    operadorsep: 'operadorsep',
    parcelas: 'parcelas',
    parcelas_lugares: 'parcelas_lugares',
    precio_servicio: 'precio_servicio',
    proveedores: 'proveedores',
    rodados: 'rodados',
    servicio_informes: 'servicio_informes',
    servicio_venta: 'servicio_venta',
    servicios: 'servicios',
    servicios_historico: 'servicios_historico',
    tareas: 'tareas',
    visitantes: 'visitantes',
    informe_gastos: 'informe_gastos',
    servicios_gastos: 'servicios_gastos',
    liquidacion_guardias: 'liquidacion_guardias',
    liquidacion_registro: 'liquidacion_registro',
    gastos_caja_copy: 'gastos_caja_copy',
    servicio_presupuesto: 'servicio_presupuesto'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'ataud_precio' | 'ataud_venta' | 'ataudes' | 'auto_usos' | 'autos' | 'autos_hoja_ruta' | 'autos_novedades' | 'autos_pago_patente' | 'caja_sa' | 'caja_sepelio' | 'caja_srl' | 'conceptos' | 'conceptos_sepelio_cuentas' | 'fabricante_ataud' | 'gasto_luto' | 'gastos_caja' | 'generacion_cajas' | 'historial_autos' | 'historial_stock_ataud' | 'honorarios' | 'informe_tareas' | 'ingreso_caja' | 'legajo_virtual_autos' | 'legajo_virtual_servicios' | 'lic_conducir' | 'novedades' | 'operadorsep' | 'parcelas' | 'parcelas_lugares' | 'precio_servicio' | 'proveedores' | 'rodados' | 'servicio_informes' | 'servicio_venta' | 'servicios' | 'servicios_historico' | 'tareas' | 'visitantes' | 'informe_gastos' | 'servicios_gastos' | 'liquidacion_guardias' | 'liquidacion_registro' | 'gastos_caja_copy' | 'servicio_presupuesto'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      ataud_precio: {
        operations: {
          findUnique: {
            args: Prisma.ataud_precioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload> | null
            payload: ataud_precioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataud_precioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataud_precioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload> | null
            payload: ataud_precioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataud_precioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataud_precioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>[]
            payload: ataud_precioPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataud_precioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataud_precioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataud_precioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataud_precioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataud_precioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataud_precioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataud_precioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ataud_precioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaud_precio>
            payload: ataud_precioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataud_precioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_precioGroupByOutputType>[]
            payload: ataud_precioPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataud_precioCountArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_precioCountAggregateOutputType> | number
            payload: ataud_precioPayload<ExtArgs>
          }
        }
      }
      ataud_venta: {
        operations: {
          findUnique: {
            args: Prisma.ataud_ventaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload> | null
            payload: ataud_ventaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataud_ventaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataud_ventaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload> | null
            payload: ataud_ventaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataud_ventaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataud_ventaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>[]
            payload: ataud_ventaPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataud_ventaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataud_ventaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataud_ventaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataud_ventaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataud_ventaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataud_ventaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataud_ventaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ataud_ventaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaud_venta>
            payload: ataud_ventaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataud_ventaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_ventaGroupByOutputType>[]
            payload: ataud_ventaPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataud_ventaCountArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_ventaCountAggregateOutputType> | number
            payload: ataud_ventaPayload<ExtArgs>
          }
        }
      }
      ataudes: {
        operations: {
          findUnique: {
            args: Prisma.ataudesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload> | null
            payload: ataudesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataudesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataudesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload> | null
            payload: ataudesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataudesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataudesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>[]
            payload: ataudesPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataudesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataudesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataudesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataudesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataudesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataudesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataudesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AtaudesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaudes>
            payload: ataudesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataudesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AtaudesGroupByOutputType>[]
            payload: ataudesPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataudesCountArgs<ExtArgs>,
            result: $Utils.Optional<AtaudesCountAggregateOutputType> | number
            payload: ataudesPayload<ExtArgs>
          }
        }
      }
      auto_usos: {
        operations: {
          findUnique: {
            args: Prisma.auto_usosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload> | null
            payload: auto_usosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.auto_usosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.auto_usosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload> | null
            payload: auto_usosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.auto_usosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.auto_usosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>[]
            payload: auto_usosPayload<ExtArgs>
          }
          create: {
            args: Prisma.auto_usosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.auto_usosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: auto_usosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.auto_usosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          update: {
            args: Prisma.auto_usosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.auto_usosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: auto_usosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.auto_usosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: auto_usosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.auto_usosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<auto_usosPayload>
            payload: auto_usosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Auto_usosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuto_usos>
            payload: auto_usosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.auto_usosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Auto_usosGroupByOutputType>[]
            payload: auto_usosPayload<ExtArgs>
          }
          count: {
            args: Prisma.auto_usosCountArgs<ExtArgs>,
            result: $Utils.Optional<Auto_usosCountAggregateOutputType> | number
            payload: auto_usosPayload<ExtArgs>
          }
        }
      }
      autos: {
        operations: {
          findUnique: {
            args: Prisma.autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload> | null
            payload: autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload> | null
            payload: autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>[]
            payload: autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AutosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos>
            payload: autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AutosGroupByOutputType>[]
            payload: autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.autosCountArgs<ExtArgs>,
            result: $Utils.Optional<AutosCountAggregateOutputType> | number
            payload: autosPayload<ExtArgs>
          }
        }
      }
      autos_hoja_ruta: {
        operations: {
          findUnique: {
            args: Prisma.autos_hoja_rutaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload> | null
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_hoja_rutaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload> | null
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_hoja_rutaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>[]
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_hoja_rutaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_hoja_rutaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_hoja_rutaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_hoja_rutaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_hoja_rutaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_hoja_rutaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_hoja_rutaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_hoja_rutaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_hoja_ruta>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_hoja_rutaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_hoja_rutaGroupByOutputType>[]
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_hoja_rutaCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_hoja_rutaCountAggregateOutputType> | number
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
        }
      }
      autos_novedades: {
        operations: {
          findUnique: {
            args: Prisma.autos_novedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload> | null
            payload: autos_novedadesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_novedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_novedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload> | null
            payload: autos_novedadesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_novedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_novedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>[]
            payload: autos_novedadesPayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_novedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_novedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_novedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_novedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_novedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_novedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_novedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_novedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_novedades>
            payload: autos_novedadesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_novedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_novedadesGroupByOutputType>[]
            payload: autos_novedadesPayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_novedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_novedadesCountAggregateOutputType> | number
            payload: autos_novedadesPayload<ExtArgs>
          }
        }
      }
      autos_pago_patente: {
        operations: {
          findUnique: {
            args: Prisma.autos_pago_patenteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload> | null
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_pago_patenteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload> | null
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_pago_patenteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>[]
            payload: autos_pago_patentePayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_pago_patenteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_pago_patenteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_pago_patenteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_pago_patenteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_pago_patenteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_pago_patenteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_pago_patenteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_pago_patenteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_pago_patente>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_pago_patenteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_pago_patenteGroupByOutputType>[]
            payload: autos_pago_patentePayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_pago_patenteCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_pago_patenteCountAggregateOutputType> | number
            payload: autos_pago_patentePayload<ExtArgs>
          }
        }
      }
      caja_sa: {
        operations: {
          findUnique: {
            args: Prisma.caja_saFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload> | null
            payload: caja_saPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_saFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_saFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload> | null
            payload: caja_saPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_saFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_saFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>[]
            payload: caja_saPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_saCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_saCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_saDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_saUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_saDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_saUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_saUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_saAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_sa>
            payload: caja_saPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_saGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_saGroupByOutputType>[]
            payload: caja_saPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_saCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_saCountAggregateOutputType> | number
            payload: caja_saPayload<ExtArgs>
          }
        }
      }
      caja_sepelio: {
        operations: {
          findUnique: {
            args: Prisma.caja_sepelioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload> | null
            payload: caja_sepelioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_sepelioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_sepelioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload> | null
            payload: caja_sepelioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_sepelioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_sepelioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>[]
            payload: caja_sepelioPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_sepelioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_sepelioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_sepelioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_sepelioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_sepelioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_sepelioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_sepelioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_sepelioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_sepelio>
            payload: caja_sepelioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_sepelioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sepelioGroupByOutputType>[]
            payload: caja_sepelioPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_sepelioCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sepelioCountAggregateOutputType> | number
            payload: caja_sepelioPayload<ExtArgs>
          }
        }
      }
      caja_srl: {
        operations: {
          findUnique: {
            args: Prisma.caja_srlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload> | null
            payload: caja_srlPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_srlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_srlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload> | null
            payload: caja_srlPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_srlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_srlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>[]
            payload: caja_srlPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_srlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_srlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_srlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_srlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_srlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_srlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_srlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_srlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_srl>
            payload: caja_srlPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_srlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_srlGroupByOutputType>[]
            payload: caja_srlPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_srlCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_srlCountAggregateOutputType> | number
            payload: caja_srlPayload<ExtArgs>
          }
        }
      }
      conceptos: {
        operations: {
          findUnique: {
            args: Prisma.conceptosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload> | null
            payload: conceptosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.conceptosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.conceptosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload> | null
            payload: conceptosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.conceptosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.conceptosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>[]
            payload: conceptosPayload<ExtArgs>
          }
          create: {
            args: Prisma.conceptosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.conceptosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.conceptosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          update: {
            args: Prisma.conceptosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.conceptosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.conceptosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.conceptosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ConceptosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptos>
            payload: conceptosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.conceptosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptosGroupByOutputType>[]
            payload: conceptosPayload<ExtArgs>
          }
          count: {
            args: Prisma.conceptosCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptosCountAggregateOutputType> | number
            payload: conceptosPayload<ExtArgs>
          }
        }
      }
      conceptos_sepelio_cuentas: {
        operations: {
          findUnique: {
            args: Prisma.conceptos_sepelio_cuentasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload> | null
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.conceptos_sepelio_cuentasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.conceptos_sepelio_cuentasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload> | null
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.conceptos_sepelio_cuentasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.conceptos_sepelio_cuentasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>[]
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          create: {
            args: Prisma.conceptos_sepelio_cuentasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.conceptos_sepelio_cuentasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.conceptos_sepelio_cuentasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          update: {
            args: Prisma.conceptos_sepelio_cuentasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.conceptos_sepelio_cuentasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.conceptos_sepelio_cuentasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.conceptos_sepelio_cuentasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptos_sepelio_cuentasPayload>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Conceptos_sepelio_cuentasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptos_sepelio_cuentas>
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.conceptos_sepelio_cuentasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Conceptos_sepelio_cuentasGroupByOutputType>[]
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
          count: {
            args: Prisma.conceptos_sepelio_cuentasCountArgs<ExtArgs>,
            result: $Utils.Optional<Conceptos_sepelio_cuentasCountAggregateOutputType> | number
            payload: conceptos_sepelio_cuentasPayload<ExtArgs>
          }
        }
      }
      fabricante_ataud: {
        operations: {
          findUnique: {
            args: Prisma.fabricante_ataudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.fabricante_ataudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.fabricante_ataudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.fabricante_ataudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          create: {
            args: Prisma.fabricante_ataudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.fabricante_ataudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          delete: {
            args: Prisma.fabricante_ataudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          update: {
            args: Prisma.fabricante_ataudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.fabricante_ataudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.fabricante_ataudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.fabricante_ataudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Fabricante_ataudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFabricante_ataud>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.fabricante_ataudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudGroupByOutputType>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          count: {
            args: Prisma.fabricante_ataudCountArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudCountAggregateOutputType> | number
            payload: fabricante_ataudPayload<ExtArgs>
          }
        }
      }
      gasto_luto: {
        operations: {
          findUnique: {
            args: Prisma.gasto_lutoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload> | null
            payload: gasto_lutoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gasto_lutoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gasto_lutoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload> | null
            payload: gasto_lutoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gasto_lutoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gasto_lutoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>[]
            payload: gasto_lutoPayload<ExtArgs>
          }
          create: {
            args: Prisma.gasto_lutoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gasto_lutoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gasto_lutoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          update: {
            args: Prisma.gasto_lutoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gasto_lutoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gasto_lutoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gasto_lutoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Gasto_lutoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGasto_luto>
            payload: gasto_lutoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gasto_lutoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gasto_lutoGroupByOutputType>[]
            payload: gasto_lutoPayload<ExtArgs>
          }
          count: {
            args: Prisma.gasto_lutoCountArgs<ExtArgs>,
            result: $Utils.Optional<Gasto_lutoCountAggregateOutputType> | number
            payload: gasto_lutoPayload<ExtArgs>
          }
        }
      }
      gastos_caja: {
        operations: {
          findUnique: {
            args: Prisma.gastos_cajaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload> | null
            payload: gastos_cajaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gastos_cajaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gastos_cajaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload> | null
            payload: gastos_cajaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gastos_cajaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gastos_cajaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>[]
            payload: gastos_cajaPayload<ExtArgs>
          }
          create: {
            args: Prisma.gastos_cajaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gastos_cajaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gastos_cajaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          update: {
            args: Prisma.gastos_cajaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gastos_cajaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gastos_cajaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gastos_cajaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Gastos_cajaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGastos_caja>
            payload: gastos_cajaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gastos_cajaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_cajaGroupByOutputType>[]
            payload: gastos_cajaPayload<ExtArgs>
          }
          count: {
            args: Prisma.gastos_cajaCountArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_cajaCountAggregateOutputType> | number
            payload: gastos_cajaPayload<ExtArgs>
          }
        }
      }
      generacion_cajas: {
        operations: {
          findUnique: {
            args: Prisma.generacion_cajasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload> | null
            payload: generacion_cajasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.generacion_cajasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.generacion_cajasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload> | null
            payload: generacion_cajasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.generacion_cajasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.generacion_cajasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>[]
            payload: generacion_cajasPayload<ExtArgs>
          }
          create: {
            args: Prisma.generacion_cajasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.generacion_cajasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.generacion_cajasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          update: {
            args: Prisma.generacion_cajasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.generacion_cajasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.generacion_cajasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.generacion_cajasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Generacion_cajasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGeneracion_cajas>
            payload: generacion_cajasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.generacion_cajasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Generacion_cajasGroupByOutputType>[]
            payload: generacion_cajasPayload<ExtArgs>
          }
          count: {
            args: Prisma.generacion_cajasCountArgs<ExtArgs>,
            result: $Utils.Optional<Generacion_cajasCountAggregateOutputType> | number
            payload: generacion_cajasPayload<ExtArgs>
          }
        }
      }
      historial_autos: {
        operations: {
          findUnique: {
            args: Prisma.historial_autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload> | null
            payload: historial_autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload> | null
            payload: historial_autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>[]
            payload: historial_autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_autosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_autos>
            payload: historial_autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_autosGroupByOutputType>[]
            payload: historial_autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_autosCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_autosCountAggregateOutputType> | number
            payload: historial_autosPayload<ExtArgs>
          }
        }
      }
      historial_stock_ataud: {
        operations: {
          findUnique: {
            args: Prisma.historial_stock_ataudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload> | null
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_stock_ataudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload> | null
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_stock_ataudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>[]
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_stock_ataudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_stock_ataudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_stock_ataudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_stock_ataudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_stock_ataudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_stock_ataudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_stock_ataudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_stock_ataudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_stock_ataud>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_stock_ataudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_stock_ataudGroupByOutputType>[]
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_stock_ataudCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_stock_ataudCountAggregateOutputType> | number
            payload: historial_stock_ataudPayload<ExtArgs>
          }
        }
      }
      honorarios: {
        operations: {
          findUnique: {
            args: Prisma.honorariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload> | null
            payload: honorariosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.honorariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.honorariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload> | null
            payload: honorariosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.honorariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.honorariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>[]
            payload: honorariosPayload<ExtArgs>
          }
          create: {
            args: Prisma.honorariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.honorariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.honorariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          update: {
            args: Prisma.honorariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.honorariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.honorariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.honorariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.HonorariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHonorarios>
            payload: honorariosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.honorariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HonorariosGroupByOutputType>[]
            payload: honorariosPayload<ExtArgs>
          }
          count: {
            args: Prisma.honorariosCountArgs<ExtArgs>,
            result: $Utils.Optional<HonorariosCountAggregateOutputType> | number
            payload: honorariosPayload<ExtArgs>
          }
        }
      }
      informe_tareas: {
        operations: {
          findUnique: {
            args: Prisma.informe_tareasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload> | null
            payload: informe_tareasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.informe_tareasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.informe_tareasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload> | null
            payload: informe_tareasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.informe_tareasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.informe_tareasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>[]
            payload: informe_tareasPayload<ExtArgs>
          }
          create: {
            args: Prisma.informe_tareasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.informe_tareasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_tareasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.informe_tareasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          update: {
            args: Prisma.informe_tareasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.informe_tareasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_tareasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.informe_tareasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_tareasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.informe_tareasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_tareasPayload>
            payload: informe_tareasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Informe_tareasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInforme_tareas>
            payload: informe_tareasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.informe_tareasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Informe_tareasGroupByOutputType>[]
            payload: informe_tareasPayload<ExtArgs>
          }
          count: {
            args: Prisma.informe_tareasCountArgs<ExtArgs>,
            result: $Utils.Optional<Informe_tareasCountAggregateOutputType> | number
            payload: informe_tareasPayload<ExtArgs>
          }
        }
      }
      ingreso_caja: {
        operations: {
          findUnique: {
            args: Prisma.ingreso_cajaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload> | null
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ingreso_cajaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload> | null
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ingreso_cajaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ingreso_cajaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>[]
            payload: ingreso_cajaPayload<ExtArgs>
          }
          create: {
            args: Prisma.ingreso_cajaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ingreso_cajaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ingreso_cajaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          update: {
            args: Prisma.ingreso_cajaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ingreso_cajaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ingreso_cajaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ingreso_cajaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ingreso_cajaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngreso_caja>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ingreso_cajaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ingreso_cajaGroupByOutputType>[]
            payload: ingreso_cajaPayload<ExtArgs>
          }
          count: {
            args: Prisma.ingreso_cajaCountArgs<ExtArgs>,
            result: $Utils.Optional<Ingreso_cajaCountAggregateOutputType> | number
            payload: ingreso_cajaPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_autos: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload> | null
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload> | null
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>[]
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_autosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_autos>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_autosGroupByOutputType>[]
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_autosCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_autosCountAggregateOutputType> | number
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_servicios: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_serviciosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload> | null
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_serviciosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload> | null
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_serviciosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>[]
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_serviciosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_serviciosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_serviciosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_serviciosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_serviciosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_serviciosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_serviciosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_serviciosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_servicios>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_serviciosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_serviciosGroupByOutputType>[]
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_serviciosCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_serviciosCountAggregateOutputType> | number
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
        }
      }
      lic_conducir: {
        operations: {
          findUnique: {
            args: Prisma.lic_conducirFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload> | null
            payload: lic_conducirPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.lic_conducirFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.lic_conducirFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload> | null
            payload: lic_conducirPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.lic_conducirFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.lic_conducirFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>[]
            payload: lic_conducirPayload<ExtArgs>
          }
          create: {
            args: Prisma.lic_conducirCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.lic_conducirCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lic_conducirPayload<ExtArgs>
          }
          delete: {
            args: Prisma.lic_conducirDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          update: {
            args: Prisma.lic_conducirUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.lic_conducirDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lic_conducirPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.lic_conducirUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lic_conducirPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.lic_conducirUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lic_conducirPayload>
            payload: lic_conducirPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Lic_conducirAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLic_conducir>
            payload: lic_conducirPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.lic_conducirGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lic_conducirGroupByOutputType>[]
            payload: lic_conducirPayload<ExtArgs>
          }
          count: {
            args: Prisma.lic_conducirCountArgs<ExtArgs>,
            result: $Utils.Optional<Lic_conducirCountAggregateOutputType> | number
            payload: lic_conducirPayload<ExtArgs>
          }
        }
      }
      novedades: {
        operations: {
          findUnique: {
            args: Prisma.novedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.novedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.novedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.novedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.novedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>[]
            payload: novedadesPayload<ExtArgs>
          }
          create: {
            args: Prisma.novedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.novedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.novedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          update: {
            args: Prisma.novedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.novedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.novedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.novedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NovedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNovedades>
            payload: novedadesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.novedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesGroupByOutputType>[]
            payload: novedadesPayload<ExtArgs>
          }
          count: {
            args: Prisma.novedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesCountAggregateOutputType> | number
            payload: novedadesPayload<ExtArgs>
          }
        }
      }
      operadorsep: {
        operations: {
          findUnique: {
            args: Prisma.operadorsepFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload> | null
            payload: operadorsepPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.operadorsepFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.operadorsepFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload> | null
            payload: operadorsepPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.operadorsepFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.operadorsepFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>[]
            payload: operadorsepPayload<ExtArgs>
          }
          create: {
            args: Prisma.operadorsepCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.operadorsepCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          delete: {
            args: Prisma.operadorsepDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          update: {
            args: Prisma.operadorsepUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.operadorsepDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.operadorsepUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.operadorsepUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.OperadorsepAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperadorsep>
            payload: operadorsepPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.operadorsepGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperadorsepGroupByOutputType>[]
            payload: operadorsepPayload<ExtArgs>
          }
          count: {
            args: Prisma.operadorsepCountArgs<ExtArgs>,
            result: $Utils.Optional<OperadorsepCountAggregateOutputType> | number
            payload: operadorsepPayload<ExtArgs>
          }
        }
      }
      parcelas: {
        operations: {
          findUnique: {
            args: Prisma.parcelasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload> | null
            payload: parcelasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.parcelasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.parcelasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload> | null
            payload: parcelasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.parcelasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.parcelasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>[]
            payload: parcelasPayload<ExtArgs>
          }
          create: {
            args: Prisma.parcelasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.parcelasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.parcelasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          update: {
            args: Prisma.parcelasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.parcelasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.parcelasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.parcelasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ParcelasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParcelas>
            payload: parcelasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.parcelasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParcelasGroupByOutputType>[]
            payload: parcelasPayload<ExtArgs>
          }
          count: {
            args: Prisma.parcelasCountArgs<ExtArgs>,
            result: $Utils.Optional<ParcelasCountAggregateOutputType> | number
            payload: parcelasPayload<ExtArgs>
          }
        }
      }
      parcelas_lugares: {
        operations: {
          findUnique: {
            args: Prisma.parcelas_lugaresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload> | null
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.parcelas_lugaresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload> | null
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.parcelas_lugaresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>[]
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          create: {
            args: Prisma.parcelas_lugaresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.parcelas_lugaresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          delete: {
            args: Prisma.parcelas_lugaresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          update: {
            args: Prisma.parcelas_lugaresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.parcelas_lugaresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.parcelas_lugaresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.parcelas_lugaresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Parcelas_lugaresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParcelas_lugares>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.parcelas_lugaresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Parcelas_lugaresGroupByOutputType>[]
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          count: {
            args: Prisma.parcelas_lugaresCountArgs<ExtArgs>,
            result: $Utils.Optional<Parcelas_lugaresCountAggregateOutputType> | number
            payload: parcelas_lugaresPayload<ExtArgs>
          }
        }
      }
      precio_servicio: {
        operations: {
          findUnique: {
            args: Prisma.precio_servicioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload> | null
            payload: precio_servicioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.precio_servicioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.precio_servicioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload> | null
            payload: precio_servicioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.precio_servicioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.precio_servicioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>[]
            payload: precio_servicioPayload<ExtArgs>
          }
          create: {
            args: Prisma.precio_servicioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.precio_servicioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.precio_servicioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          update: {
            args: Prisma.precio_servicioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.precio_servicioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.precio_servicioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.precio_servicioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Precio_servicioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrecio_servicio>
            payload: precio_servicioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.precio_servicioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Precio_servicioGroupByOutputType>[]
            payload: precio_servicioPayload<ExtArgs>
          }
          count: {
            args: Prisma.precio_servicioCountArgs<ExtArgs>,
            result: $Utils.Optional<Precio_servicioCountAggregateOutputType> | number
            payload: precio_servicioPayload<ExtArgs>
          }
        }
      }
      proveedores: {
        operations: {
          findUnique: {
            args: Prisma.proveedoresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload> | null
            payload: proveedoresPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.proveedoresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.proveedoresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload> | null
            payload: proveedoresPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.proveedoresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.proveedoresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>[]
            payload: proveedoresPayload<ExtArgs>
          }
          create: {
            args: Prisma.proveedoresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.proveedoresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          delete: {
            args: Prisma.proveedoresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          update: {
            args: Prisma.proveedoresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.proveedoresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.proveedoresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.proveedoresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ProveedoresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProveedores>
            payload: proveedoresPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.proveedoresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProveedoresGroupByOutputType>[]
            payload: proveedoresPayload<ExtArgs>
          }
          count: {
            args: Prisma.proveedoresCountArgs<ExtArgs>,
            result: $Utils.Optional<ProveedoresCountAggregateOutputType> | number
            payload: proveedoresPayload<ExtArgs>
          }
        }
      }
      rodados: {
        operations: {
          findUnique: {
            args: Prisma.rodadosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload> | null
            payload: rodadosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.rodadosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.rodadosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload> | null
            payload: rodadosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.rodadosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.rodadosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>[]
            payload: rodadosPayload<ExtArgs>
          }
          create: {
            args: Prisma.rodadosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.rodadosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rodadosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.rodadosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          update: {
            args: Prisma.rodadosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.rodadosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rodadosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.rodadosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: rodadosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.rodadosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<rodadosPayload>
            payload: rodadosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.RodadosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRodados>
            payload: rodadosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.rodadosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RodadosGroupByOutputType>[]
            payload: rodadosPayload<ExtArgs>
          }
          count: {
            args: Prisma.rodadosCountArgs<ExtArgs>,
            result: $Utils.Optional<RodadosCountAggregateOutputType> | number
            payload: rodadosPayload<ExtArgs>
          }
        }
      }
      servicio_informes: {
        operations: {
          findUnique: {
            args: Prisma.servicio_informesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload> | null
            payload: servicio_informesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_informesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_informesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload> | null
            payload: servicio_informesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_informesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_informesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>[]
            payload: servicio_informesPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_informesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_informesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_informesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_informesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_informesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_informesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_informesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_informesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_informesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_informesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_informesPayload>
            payload: servicio_informesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_informesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_informes>
            payload: servicio_informesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_informesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_informesGroupByOutputType>[]
            payload: servicio_informesPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_informesCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_informesCountAggregateOutputType> | number
            payload: servicio_informesPayload<ExtArgs>
          }
        }
      }
      servicio_venta: {
        operations: {
          findUnique: {
            args: Prisma.servicio_ventaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload> | null
            payload: servicio_ventaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_ventaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_ventaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload> | null
            payload: servicio_ventaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_ventaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_ventaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>[]
            payload: servicio_ventaPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_ventaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_ventaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_ventaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_ventaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_ventaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_ventaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_ventaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_ventaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_venta>
            payload: servicio_ventaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_ventaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_ventaGroupByOutputType>[]
            payload: servicio_ventaPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_ventaCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_ventaCountAggregateOutputType> | number
            payload: servicio_ventaPayload<ExtArgs>
          }
        }
      }
      servicios: {
        operations: {
          findUnique: {
            args: Prisma.serviciosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload> | null
            payload: serviciosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.serviciosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.serviciosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload> | null
            payload: serviciosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.serviciosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.serviciosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>[]
            payload: serviciosPayload<ExtArgs>
          }
          create: {
            args: Prisma.serviciosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.serviciosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.serviciosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          update: {
            args: Prisma.serviciosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.serviciosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.serviciosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.serviciosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ServiciosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios>
            payload: serviciosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.serviciosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosGroupByOutputType>[]
            payload: serviciosPayload<ExtArgs>
          }
          count: {
            args: Prisma.serviciosCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosCountAggregateOutputType> | number
            payload: serviciosPayload<ExtArgs>
          }
        }
      }
      servicios_historico: {
        operations: {
          findUnique: {
            args: Prisma.servicios_historicoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload> | null
            payload: servicios_historicoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicios_historicoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicios_historicoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload> | null
            payload: servicios_historicoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicios_historicoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicios_historicoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>[]
            payload: servicios_historicoPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicios_historicoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicios_historicoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_historicoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicios_historicoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicios_historicoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicios_historicoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_historicoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicios_historicoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_historicoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicios_historicoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_historicoPayload>
            payload: servicios_historicoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicios_historicoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios_historico>
            payload: servicios_historicoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicios_historicoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_historicoGroupByOutputType>[]
            payload: servicios_historicoPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicios_historicoCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_historicoCountAggregateOutputType> | number
            payload: servicios_historicoPayload<ExtArgs>
          }
        }
      }
      tareas: {
        operations: {
          findUnique: {
            args: Prisma.tareasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload> | null
            payload: tareasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tareasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tareasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload> | null
            payload: tareasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tareasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tareasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>[]
            payload: tareasPayload<ExtArgs>
          }
          create: {
            args: Prisma.tareasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tareasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tareasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          update: {
            args: Prisma.tareasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tareasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tareasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tareasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.TareasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTareas>
            payload: tareasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tareasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TareasGroupByOutputType>[]
            payload: tareasPayload<ExtArgs>
          }
          count: {
            args: Prisma.tareasCountArgs<ExtArgs>,
            result: $Utils.Optional<TareasCountAggregateOutputType> | number
            payload: tareasPayload<ExtArgs>
          }
        }
      }
      visitantes: {
        operations: {
          findUnique: {
            args: Prisma.visitantesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload> | null
            payload: visitantesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.visitantesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.visitantesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload> | null
            payload: visitantesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.visitantesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.visitantesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>[]
            payload: visitantesPayload<ExtArgs>
          }
          create: {
            args: Prisma.visitantesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.visitantesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.visitantesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          update: {
            args: Prisma.visitantesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.visitantesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.visitantesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.visitantesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.VisitantesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVisitantes>
            payload: visitantesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.visitantesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VisitantesGroupByOutputType>[]
            payload: visitantesPayload<ExtArgs>
          }
          count: {
            args: Prisma.visitantesCountArgs<ExtArgs>,
            result: $Utils.Optional<VisitantesCountAggregateOutputType> | number
            payload: visitantesPayload<ExtArgs>
          }
        }
      }
      informe_gastos: {
        operations: {
          findUnique: {
            args: Prisma.informe_gastosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload> | null
            payload: informe_gastosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.informe_gastosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.informe_gastosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload> | null
            payload: informe_gastosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.informe_gastosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.informe_gastosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>[]
            payload: informe_gastosPayload<ExtArgs>
          }
          create: {
            args: Prisma.informe_gastosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.informe_gastosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_gastosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.informe_gastosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          update: {
            args: Prisma.informe_gastosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.informe_gastosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_gastosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.informe_gastosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: informe_gastosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.informe_gastosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<informe_gastosPayload>
            payload: informe_gastosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Informe_gastosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInforme_gastos>
            payload: informe_gastosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.informe_gastosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Informe_gastosGroupByOutputType>[]
            payload: informe_gastosPayload<ExtArgs>
          }
          count: {
            args: Prisma.informe_gastosCountArgs<ExtArgs>,
            result: $Utils.Optional<Informe_gastosCountAggregateOutputType> | number
            payload: informe_gastosPayload<ExtArgs>
          }
        }
      }
      servicios_gastos: {
        operations: {
          findUnique: {
            args: Prisma.servicios_gastosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload> | null
            payload: servicios_gastosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicios_gastosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicios_gastosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload> | null
            payload: servicios_gastosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicios_gastosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicios_gastosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>[]
            payload: servicios_gastosPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicios_gastosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicios_gastosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_gastosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicios_gastosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicios_gastosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicios_gastosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_gastosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicios_gastosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_gastosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicios_gastosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_gastosPayload>
            payload: servicios_gastosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicios_gastosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios_gastos>
            payload: servicios_gastosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicios_gastosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_gastosGroupByOutputType>[]
            payload: servicios_gastosPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicios_gastosCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_gastosCountAggregateOutputType> | number
            payload: servicios_gastosPayload<ExtArgs>
          }
        }
      }
      liquidacion_guardias: {
        operations: {
          findUnique: {
            args: Prisma.liquidacion_guardiasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload> | null
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.liquidacion_guardiasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.liquidacion_guardiasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload> | null
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.liquidacion_guardiasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.liquidacion_guardiasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>[]
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          create: {
            args: Prisma.liquidacion_guardiasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.liquidacion_guardiasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.liquidacion_guardiasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          update: {
            args: Prisma.liquidacion_guardiasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.liquidacion_guardiasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.liquidacion_guardiasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.liquidacion_guardiasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_guardiasPayload>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Liquidacion_guardiasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLiquidacion_guardias>
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.liquidacion_guardiasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Liquidacion_guardiasGroupByOutputType>[]
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
          count: {
            args: Prisma.liquidacion_guardiasCountArgs<ExtArgs>,
            result: $Utils.Optional<Liquidacion_guardiasCountAggregateOutputType> | number
            payload: liquidacion_guardiasPayload<ExtArgs>
          }
        }
      }
      liquidacion_registro: {
        operations: {
          findUnique: {
            args: Prisma.liquidacion_registroFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload> | null
            payload: liquidacion_registroPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.liquidacion_registroFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.liquidacion_registroFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload> | null
            payload: liquidacion_registroPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.liquidacion_registroFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.liquidacion_registroFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>[]
            payload: liquidacion_registroPayload<ExtArgs>
          }
          create: {
            args: Prisma.liquidacion_registroCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.liquidacion_registroCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_registroPayload<ExtArgs>
          }
          delete: {
            args: Prisma.liquidacion_registroDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          update: {
            args: Prisma.liquidacion_registroUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.liquidacion_registroDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_registroPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.liquidacion_registroUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: liquidacion_registroPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.liquidacion_registroUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<liquidacion_registroPayload>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Liquidacion_registroAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLiquidacion_registro>
            payload: liquidacion_registroPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.liquidacion_registroGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Liquidacion_registroGroupByOutputType>[]
            payload: liquidacion_registroPayload<ExtArgs>
          }
          count: {
            args: Prisma.liquidacion_registroCountArgs<ExtArgs>,
            result: $Utils.Optional<Liquidacion_registroCountAggregateOutputType> | number
            payload: liquidacion_registroPayload<ExtArgs>
          }
        }
      }
      gastos_caja_copy: {
        operations: {
          findUnique: {
            args: Prisma.gastos_caja_copyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload> | null
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gastos_caja_copyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gastos_caja_copyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload> | null
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gastos_caja_copyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gastos_caja_copyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>[]
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          create: {
            args: Prisma.gastos_caja_copyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gastos_caja_copyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gastos_caja_copyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          update: {
            args: Prisma.gastos_caja_copyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gastos_caja_copyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gastos_caja_copyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gastos_caja_copyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_caja_copyPayload>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Gastos_caja_copyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGastos_caja_copy>
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gastos_caja_copyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_caja_copyGroupByOutputType>[]
            payload: gastos_caja_copyPayload<ExtArgs>
          }
          count: {
            args: Prisma.gastos_caja_copyCountArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_caja_copyCountAggregateOutputType> | number
            payload: gastos_caja_copyPayload<ExtArgs>
          }
        }
      }
      servicio_presupuesto: {
        operations: {
          findUnique: {
            args: Prisma.servicio_presupuestoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload> | null
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_presupuestoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_presupuestoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload> | null
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_presupuestoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_presupuestoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>[]
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_presupuestoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_presupuestoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_presupuestoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_presupuestoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_presupuestoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_presupuestoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_presupuestoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_presupuestoPayload>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_presupuestoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_presupuesto>
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_presupuestoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_presupuestoGroupByOutputType>[]
            payload: servicio_presupuestoPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_presupuestoCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_presupuestoCountAggregateOutputType> | number
            payload: servicio_presupuestoPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model ataud_precio
   */


  export type AggregateAtaud_precio = {
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  export type Ataud_precioAvgAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioSumAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioMinAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioMaxAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioCountAggregateOutputType = {
    idprecio: number
    idataud: number
    codigo: number
    ataud: number
    precio: number
    pri_desc: number
    sec_desc: number
    fecha: number
    operador: number
    estado: number
    _all: number
  }


  export type Ataud_precioAvgAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioSumAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioMinAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioMaxAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioCountAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
    _all?: true
  }

  export type Ataud_precioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_precio to aggregate.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_precios
    **/
    _count?: true | Ataud_precioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_precioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_precioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_precioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_precioMaxAggregateInputType
  }

  export type GetAtaud_precioAggregateType<T extends Ataud_precioAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_precio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_precio[P]>
      : GetScalarType<T[P], AggregateAtaud_precio[P]>
  }




  export type ataud_precioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataud_precioWhereInput
    orderBy?: ataud_precioOrderByWithAggregationInput | ataud_precioOrderByWithAggregationInput[]
    by: Ataud_precioScalarFieldEnum[] | Ataud_precioScalarFieldEnum
    having?: ataud_precioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_precioCountAggregateInputType | true
    _avg?: Ataud_precioAvgAggregateInputType
    _sum?: Ataud_precioSumAggregateInputType
    _min?: Ataud_precioMinAggregateInputType
    _max?: Ataud_precioMaxAggregateInputType
  }


  export type Ataud_precioGroupByOutputType = {
    idprecio: number
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  type GetAtaud_precioGroupByPayload<T extends ataud_precioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ataud_precioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_precioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
        }
      >
    >


  export type ataud_precioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprecio?: boolean
    idataud?: boolean
    codigo?: boolean
    ataud?: boolean
    precio?: boolean
    pri_desc?: boolean
    sec_desc?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }, ExtArgs["result"]["ataud_precio"]>

  export type ataud_precioSelectScalar = {
    idprecio?: boolean
    idataud?: boolean
    codigo?: boolean
    ataud?: boolean
    precio?: boolean
    pri_desc?: boolean
    sec_desc?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }


  type ataud_precioGetPayload<S extends boolean | null | undefined | ataud_precioArgs> = $Types.GetResult<ataud_precioPayload, S>

  type ataud_precioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataud_precioFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_precioCountAggregateInputType | true
    }

  export interface ataud_precioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataud_precio'], meta: { name: 'ataud_precio' } }
    /**
     * Find zero or one Ataud_precio that matches the filter.
     * @param {ataud_precioFindUniqueArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_precioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_precioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataud_precio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_precioFindUniqueOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_precioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataud_precio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_precioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_precioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataud_precio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_precioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataud_precios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany()
     * 
     * // Get first 10 Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const ataud_precioWithIdprecioOnly = await prisma.ataud_precio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends ataud_precioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataud_precio.
     * @param {ataud_precioCreateArgs} args - Arguments to create a Ataud_precio.
     * @example
     * // Create one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.create({
     *   data: {
     *     // ... data to create a Ataud_precio
     *   }
     * })
     * 
    **/
    create<T extends ataud_precioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioCreateArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataud_precios.
     *     @param {ataud_precioCreateManyArgs} args - Arguments to create many Ataud_precios.
     *     @example
     *     // Create many Ataud_precios
     *     const ataud_precio = await prisma.ataud_precio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_precioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_precio.
     * @param {ataud_precioDeleteArgs} args - Arguments to delete one Ataud_precio.
     * @example
     * // Delete one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.delete({
     *   where: {
     *     // ... filter to delete one Ataud_precio
     *   }
     * })
     * 
    **/
    delete<T extends ataud_precioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioDeleteArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataud_precio.
     * @param {ataud_precioUpdateArgs} args - Arguments to update one Ataud_precio.
     * @example
     * // Update one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_precioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpdateArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataud_precios.
     * @param {ataud_precioDeleteManyArgs} args - Arguments to filter Ataud_precios to delete.
     * @example
     * // Delete a few Ataud_precios
     * const { count } = await prisma.ataud_precio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_precioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_precios
     * const ataud_precio = await prisma.ataud_precio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_precioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_precio.
     * @param {ataud_precioUpsertArgs} args - Arguments to update or create a Ataud_precio.
     * @example
     * // Update or create a Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.upsert({
     *   create: {
     *     // ... data to create a Ataud_precio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_precio we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_precioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpsertArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioCountArgs} args - Arguments to filter Ataud_precios to count.
     * @example
     * // Count the number of Ataud_precios
     * const count = await prisma.ataud_precio.count({
     *   where: {
     *     // ... the filter for the Ataud_precios we want to count
     *   }
     * })
    **/
    count<T extends ataud_precioCountArgs>(
      args?: Subset<T, ataud_precioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_precioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_precioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_precioAggregateArgs>(args: Subset<T, Ataud_precioAggregateArgs>): Prisma.PrismaPromise<GetAtaud_precioAggregateType<T>>

    /**
     * Group by Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataud_precioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataud_precioGroupByArgs['orderBy'] }
        : { orderBy?: ataud_precioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataud_precioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_precioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_precio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_precioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_precio base type for findUnique actions
   */
  export type ataud_precioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }

  /**
   * ataud_precio findUnique
   */
  export interface ataud_precioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_precioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findUniqueOrThrow
   */
  export type ataud_precioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio base type for findFirst actions
   */
  export type ataud_precioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }

  /**
   * ataud_precio findFirst
   */
  export interface ataud_precioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_precioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findFirstOrThrow
   */
  export type ataud_precioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }


  /**
   * ataud_precio findMany
   */
  export type ataud_precioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precios to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }


  /**
   * ataud_precio create
   */
  export type ataud_precioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The data needed to create a ataud_precio.
     */
    data?: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
  }


  /**
   * ataud_precio createMany
   */
  export type ataud_precioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataud_precios.
     */
    data: ataud_precioCreateManyInput | ataud_precioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataud_precio update
   */
  export type ataud_precioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The data needed to update a ataud_precio.
     */
    data: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
    /**
     * Choose, which ataud_precio to update.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio updateMany
   */
  export type ataud_precioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataud_precios.
     */
    data: XOR<ataud_precioUpdateManyMutationInput, ataud_precioUncheckedUpdateManyInput>
    /**
     * Filter which ataud_precios to update
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio upsert
   */
  export type ataud_precioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The filter to search for the ataud_precio to update in case it exists.
     */
    where: ataud_precioWhereUniqueInput
    /**
     * In case the ataud_precio found by the `where` argument doesn't exist, create a new ataud_precio with this data.
     */
    create: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
    /**
     * In case the ataud_precio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
  }


  /**
   * ataud_precio delete
   */
  export type ataud_precioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter which ataud_precio to delete.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio deleteMany
   */
  export type ataud_precioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_precios to delete
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio without action
   */
  export type ataud_precioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
  }



  /**
   * Model ataud_venta
   */


  export type AggregateAtaud_venta = {
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  export type Ataud_ventaAvgAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaSumAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaMinAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaMaxAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaCountAggregateOutputType = {
    idataudventa: number
    idataud: number
    contrato: number
    apellido_fall: number
    nombre_fall: number
    dni_fall: number
    dom_fall: number
    ndom_fall: number
    barrio_fall: number
    telefono_fall: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    telefono_sol: number
    fecha: number
    operador: number
    ataud: number
    _all: number
  }


  export type Ataud_ventaAvgAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaSumAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaMinAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaMaxAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaCountAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
    _all?: true
  }

  export type Ataud_ventaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_venta to aggregate.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_ventas
    **/
    _count?: true | Ataud_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_ventaMaxAggregateInputType
  }

  export type GetAtaud_ventaAggregateType<T extends Ataud_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_venta[P]>
      : GetScalarType<T[P], AggregateAtaud_venta[P]>
  }




  export type ataud_ventaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataud_ventaWhereInput
    orderBy?: ataud_ventaOrderByWithAggregationInput | ataud_ventaOrderByWithAggregationInput[]
    by: Ataud_ventaScalarFieldEnum[] | Ataud_ventaScalarFieldEnum
    having?: ataud_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_ventaCountAggregateInputType | true
    _avg?: Ataud_ventaAvgAggregateInputType
    _sum?: Ataud_ventaSumAggregateInputType
    _min?: Ataud_ventaMinAggregateInputType
    _max?: Ataud_ventaMaxAggregateInputType
  }


  export type Ataud_ventaGroupByOutputType = {
    idataudventa: number
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  type GetAtaud_ventaGroupByPayload<T extends ataud_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ataud_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
        }
      >
    >


  export type ataud_ventaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idataudventa?: boolean
    idataud?: boolean
    contrato?: boolean
    apellido_fall?: boolean
    nombre_fall?: boolean
    dni_fall?: boolean
    dom_fall?: boolean
    ndom_fall?: boolean
    barrio_fall?: boolean
    telefono_fall?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    telefono_sol?: boolean
    fecha?: boolean
    operador?: boolean
    ataud?: boolean
  }, ExtArgs["result"]["ataud_venta"]>

  export type ataud_ventaSelectScalar = {
    idataudventa?: boolean
    idataud?: boolean
    contrato?: boolean
    apellido_fall?: boolean
    nombre_fall?: boolean
    dni_fall?: boolean
    dom_fall?: boolean
    ndom_fall?: boolean
    barrio_fall?: boolean
    telefono_fall?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    telefono_sol?: boolean
    fecha?: boolean
    operador?: boolean
    ataud?: boolean
  }


  type ataud_ventaGetPayload<S extends boolean | null | undefined | ataud_ventaArgs> = $Types.GetResult<ataud_ventaPayload, S>

  type ataud_ventaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataud_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_ventaCountAggregateInputType | true
    }

  export interface ataud_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataud_venta'], meta: { name: 'ataud_venta' } }
    /**
     * Find zero or one Ataud_venta that matches the filter.
     * @param {ataud_ventaFindUniqueArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_ventaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_ventaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataud_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_ventaFindUniqueOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_ventaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataud_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_ventaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_ventaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataud_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_ventaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataud_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany()
     * 
     * // Get first 10 Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany({ take: 10 })
     * 
     * // Only select the `idataudventa`
     * const ataud_ventaWithIdataudventaOnly = await prisma.ataud_venta.findMany({ select: { idataudventa: true } })
     * 
    **/
    findMany<T extends ataud_ventaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataud_venta.
     * @param {ataud_ventaCreateArgs} args - Arguments to create a Ataud_venta.
     * @example
     * // Create one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.create({
     *   data: {
     *     // ... data to create a Ataud_venta
     *   }
     * })
     * 
    **/
    create<T extends ataud_ventaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaCreateArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataud_ventas.
     *     @param {ataud_ventaCreateManyArgs} args - Arguments to create many Ataud_ventas.
     *     @example
     *     // Create many Ataud_ventas
     *     const ataud_venta = await prisma.ataud_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_ventaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_venta.
     * @param {ataud_ventaDeleteArgs} args - Arguments to delete one Ataud_venta.
     * @example
     * // Delete one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.delete({
     *   where: {
     *     // ... filter to delete one Ataud_venta
     *   }
     * })
     * 
    **/
    delete<T extends ataud_ventaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaDeleteArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataud_venta.
     * @param {ataud_ventaUpdateArgs} args - Arguments to update one Ataud_venta.
     * @example
     * // Update one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_ventaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpdateArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataud_ventas.
     * @param {ataud_ventaDeleteManyArgs} args - Arguments to filter Ataud_ventas to delete.
     * @example
     * // Delete a few Ataud_ventas
     * const { count } = await prisma.ataud_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_ventaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_ventas
     * const ataud_venta = await prisma.ataud_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_ventaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_venta.
     * @param {ataud_ventaUpsertArgs} args - Arguments to update or create a Ataud_venta.
     * @example
     * // Update or create a Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.upsert({
     *   create: {
     *     // ... data to create a Ataud_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_venta we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_ventaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpsertArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaCountArgs} args - Arguments to filter Ataud_ventas to count.
     * @example
     * // Count the number of Ataud_ventas
     * const count = await prisma.ataud_venta.count({
     *   where: {
     *     // ... the filter for the Ataud_ventas we want to count
     *   }
     * })
    **/
    count<T extends ataud_ventaCountArgs>(
      args?: Subset<T, ataud_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_ventaAggregateArgs>(args: Subset<T, Ataud_ventaAggregateArgs>): Prisma.PrismaPromise<GetAtaud_ventaAggregateType<T>>

    /**
     * Group by Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataud_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataud_ventaGroupByArgs['orderBy'] }
        : { orderBy?: ataud_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataud_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_ventaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_venta base type for findUnique actions
   */
  export type ataud_ventaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }

  /**
   * ataud_venta findUnique
   */
  export interface ataud_ventaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_ventaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findUniqueOrThrow
   */
  export type ataud_ventaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta base type for findFirst actions
   */
  export type ataud_ventaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }

  /**
   * ataud_venta findFirst
   */
  export interface ataud_ventaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_ventaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findFirstOrThrow
   */
  export type ataud_ventaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }


  /**
   * ataud_venta findMany
   */
  export type ataud_ventaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_ventas to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }


  /**
   * ataud_venta create
   */
  export type ataud_ventaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The data needed to create a ataud_venta.
     */
    data?: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
  }


  /**
   * ataud_venta createMany
   */
  export type ataud_ventaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataud_ventas.
     */
    data: ataud_ventaCreateManyInput | ataud_ventaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataud_venta update
   */
  export type ataud_ventaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The data needed to update a ataud_venta.
     */
    data: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
    /**
     * Choose, which ataud_venta to update.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta updateMany
   */
  export type ataud_ventaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataud_ventas.
     */
    data: XOR<ataud_ventaUpdateManyMutationInput, ataud_ventaUncheckedUpdateManyInput>
    /**
     * Filter which ataud_ventas to update
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta upsert
   */
  export type ataud_ventaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The filter to search for the ataud_venta to update in case it exists.
     */
    where: ataud_ventaWhereUniqueInput
    /**
     * In case the ataud_venta found by the `where` argument doesn't exist, create a new ataud_venta with this data.
     */
    create: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
    /**
     * In case the ataud_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
  }


  /**
   * ataud_venta delete
   */
  export type ataud_ventaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter which ataud_venta to delete.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta deleteMany
   */
  export type ataud_ventaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_ventas to delete
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta without action
   */
  export type ataud_ventaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
  }



  /**
   * Model ataudes
   */


  export type AggregateAtaudes = {
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  export type AtaudesAvgAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesSumAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesMinAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesMaxAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesCountAggregateOutputType = {
    idataud: number
    nombre: number
    tipo: number
    medidas: number
    uso: number
    fabricante: number
    codigo: number
    fecha_alta: number
    stock: number
    fecha_reposicion: number
    fecha_baja: number
    observaciones: number
    estado: number
    operador: number
    _all: number
  }


  export type AtaudesAvgAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesSumAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesMinAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesMaxAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesCountAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AtaudesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataudes to aggregate.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataudes
    **/
    _count?: true | AtaudesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtaudesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtaudesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtaudesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtaudesMaxAggregateInputType
  }

  export type GetAtaudesAggregateType<T extends AtaudesAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaudes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaudes[P]>
      : GetScalarType<T[P], AggregateAtaudes[P]>
  }




  export type ataudesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataudesWhereInput
    orderBy?: ataudesOrderByWithAggregationInput | ataudesOrderByWithAggregationInput[]
    by: AtaudesScalarFieldEnum[] | AtaudesScalarFieldEnum
    having?: ataudesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtaudesCountAggregateInputType | true
    _avg?: AtaudesAvgAggregateInputType
    _sum?: AtaudesSumAggregateInputType
    _min?: AtaudesMinAggregateInputType
    _max?: AtaudesMaxAggregateInputType
  }


  export type AtaudesGroupByOutputType = {
    idataud: number
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  type GetAtaudesGroupByPayload<T extends ataudesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtaudesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtaudesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
            : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
        }
      >
    >


  export type ataudesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idataud?: boolean
    nombre?: boolean
    tipo?: boolean
    medidas?: boolean
    uso?: boolean
    fabricante?: boolean
    codigo?: boolean
    fecha_alta?: boolean
    stock?: boolean
    fecha_reposicion?: boolean
    fecha_baja?: boolean
    observaciones?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["ataudes"]>

  export type ataudesSelectScalar = {
    idataud?: boolean
    nombre?: boolean
    tipo?: boolean
    medidas?: boolean
    uso?: boolean
    fabricante?: boolean
    codigo?: boolean
    fecha_alta?: boolean
    stock?: boolean
    fecha_reposicion?: boolean
    fecha_baja?: boolean
    observaciones?: boolean
    estado?: boolean
    operador?: boolean
  }


  type ataudesGetPayload<S extends boolean | null | undefined | ataudesArgs> = $Types.GetResult<ataudesPayload, S>

  type ataudesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataudesFindManyArgs, 'select' | 'include'> & {
      select?: AtaudesCountAggregateInputType | true
    }

  export interface ataudesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataudes'], meta: { name: 'ataudes' } }
    /**
     * Find zero or one Ataudes that matches the filter.
     * @param {ataudesFindUniqueArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataudesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataudesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataudes'> extends True ? Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataudes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataudesFindUniqueOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataudesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataudesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataudesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataudes'> extends True ? Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataudes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataudesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataudes
     * const ataudes = await prisma.ataudes.findMany()
     * 
     * // Get first 10 Ataudes
     * const ataudes = await prisma.ataudes.findMany({ take: 10 })
     * 
     * // Only select the `idataud`
     * const ataudesWithIdataudOnly = await prisma.ataudes.findMany({ select: { idataud: true } })
     * 
    **/
    findMany<T extends ataudesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataudes.
     * @param {ataudesCreateArgs} args - Arguments to create a Ataudes.
     * @example
     * // Create one Ataudes
     * const Ataudes = await prisma.ataudes.create({
     *   data: {
     *     // ... data to create a Ataudes
     *   }
     * })
     * 
    **/
    create<T extends ataudesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesCreateArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataudes.
     *     @param {ataudesCreateManyArgs} args - Arguments to create many Ataudes.
     *     @example
     *     // Create many Ataudes
     *     const ataudes = await prisma.ataudes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataudesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataudes.
     * @param {ataudesDeleteArgs} args - Arguments to delete one Ataudes.
     * @example
     * // Delete one Ataudes
     * const Ataudes = await prisma.ataudes.delete({
     *   where: {
     *     // ... filter to delete one Ataudes
     *   }
     * })
     * 
    **/
    delete<T extends ataudesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesDeleteArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataudes.
     * @param {ataudesUpdateArgs} args - Arguments to update one Ataudes.
     * @example
     * // Update one Ataudes
     * const ataudes = await prisma.ataudes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataudesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpdateArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataudes.
     * @param {ataudesDeleteManyArgs} args - Arguments to filter Ataudes to delete.
     * @example
     * // Delete a few Ataudes
     * const { count } = await prisma.ataudes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataudesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataudes
     * const ataudes = await prisma.ataudes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataudesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataudes.
     * @param {ataudesUpsertArgs} args - Arguments to update or create a Ataudes.
     * @example
     * // Update or create a Ataudes
     * const ataudes = await prisma.ataudes.upsert({
     *   create: {
     *     // ... data to create a Ataudes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataudes we want to update
     *   }
     * })
    **/
    upsert<T extends ataudesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpsertArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesCountArgs} args - Arguments to filter Ataudes to count.
     * @example
     * // Count the number of Ataudes
     * const count = await prisma.ataudes.count({
     *   where: {
     *     // ... the filter for the Ataudes we want to count
     *   }
     * })
    **/
    count<T extends ataudesCountArgs>(
      args?: Subset<T, ataudesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtaudesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtaudesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtaudesAggregateArgs>(args: Subset<T, AtaudesAggregateArgs>): Prisma.PrismaPromise<GetAtaudesAggregateType<T>>

    /**
     * Group by Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataudesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataudesGroupByArgs['orderBy'] }
        : { orderBy?: ataudesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataudesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaudesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataudes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataudesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataudes base type for findUnique actions
   */
  export type ataudesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }

  /**
   * ataudes findUnique
   */
  export interface ataudesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataudesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findUniqueOrThrow
   */
  export type ataudesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes base type for findFirst actions
   */
  export type ataudesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }

  /**
   * ataudes findFirst
   */
  export interface ataudesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataudesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findFirstOrThrow
   */
  export type ataudesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }


  /**
   * ataudes findMany
   */
  export type ataudesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }


  /**
   * ataudes create
   */
  export type ataudesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The data needed to create a ataudes.
     */
    data?: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
  }


  /**
   * ataudes createMany
   */
  export type ataudesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataudes.
     */
    data: ataudesCreateManyInput | ataudesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataudes update
   */
  export type ataudesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The data needed to update a ataudes.
     */
    data: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
    /**
     * Choose, which ataudes to update.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes updateMany
   */
  export type ataudesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataudes.
     */
    data: XOR<ataudesUpdateManyMutationInput, ataudesUncheckedUpdateManyInput>
    /**
     * Filter which ataudes to update
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes upsert
   */
  export type ataudesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The filter to search for the ataudes to update in case it exists.
     */
    where: ataudesWhereUniqueInput
    /**
     * In case the ataudes found by the `where` argument doesn't exist, create a new ataudes with this data.
     */
    create: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
    /**
     * In case the ataudes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
  }


  /**
   * ataudes delete
   */
  export type ataudesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter which ataudes to delete.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes deleteMany
   */
  export type ataudesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataudes to delete
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes without action
   */
  export type ataudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
  }



  /**
   * Model auto_usos
   */


  export type AggregateAuto_usos = {
    _count: Auto_usosCountAggregateOutputType | null
    _avg: Auto_usosAvgAggregateOutputType | null
    _sum: Auto_usosSumAggregateOutputType | null
    _min: Auto_usosMinAggregateOutputType | null
    _max: Auto_usosMaxAggregateOutputType | null
  }

  export type Auto_usosAvgAggregateOutputType = {
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number | null
  }

  export type Auto_usosSumAggregateOutputType = {
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number | null
  }

  export type Auto_usosMinAggregateOutputType = {
    FECHA: Date | null
    PATENTE: string | null
    DESCRIP: string | null
    NOMB_OPE: string | null
    CHOFER: string | null
    HORA1: string | null
    HORA2: string | null
    TAREA: string | null
    OBSERVA_1: string | null
    OBSERVA_2: string | null
    OPE_LLEGA: string | null
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number | null
  }

  export type Auto_usosMaxAggregateOutputType = {
    FECHA: Date | null
    PATENTE: string | null
    DESCRIP: string | null
    NOMB_OPE: string | null
    CHOFER: string | null
    HORA1: string | null
    HORA2: string | null
    TAREA: string | null
    OBSERVA_1: string | null
    OBSERVA_2: string | null
    OPE_LLEGA: string | null
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number | null
  }

  export type Auto_usosCountAggregateOutputType = {
    FECHA: number
    PATENTE: number
    DESCRIP: number
    NOMB_OPE: number
    CHOFER: number
    HORA1: number
    HORA2: number
    TAREA: number
    OBSERVA_1: number
    OBSERVA_2: number
    OPE_LLEGA: number
    KILO_SAL: number
    KILO_LLE: number
    idusos: number
    _all: number
  }


  export type Auto_usosAvgAggregateInputType = {
    KILO_SAL?: true
    KILO_LLE?: true
    idusos?: true
  }

  export type Auto_usosSumAggregateInputType = {
    KILO_SAL?: true
    KILO_LLE?: true
    idusos?: true
  }

  export type Auto_usosMinAggregateInputType = {
    FECHA?: true
    PATENTE?: true
    DESCRIP?: true
    NOMB_OPE?: true
    CHOFER?: true
    HORA1?: true
    HORA2?: true
    TAREA?: true
    OBSERVA_1?: true
    OBSERVA_2?: true
    OPE_LLEGA?: true
    KILO_SAL?: true
    KILO_LLE?: true
    idusos?: true
  }

  export type Auto_usosMaxAggregateInputType = {
    FECHA?: true
    PATENTE?: true
    DESCRIP?: true
    NOMB_OPE?: true
    CHOFER?: true
    HORA1?: true
    HORA2?: true
    TAREA?: true
    OBSERVA_1?: true
    OBSERVA_2?: true
    OPE_LLEGA?: true
    KILO_SAL?: true
    KILO_LLE?: true
    idusos?: true
  }

  export type Auto_usosCountAggregateInputType = {
    FECHA?: true
    PATENTE?: true
    DESCRIP?: true
    NOMB_OPE?: true
    CHOFER?: true
    HORA1?: true
    HORA2?: true
    TAREA?: true
    OBSERVA_1?: true
    OBSERVA_2?: true
    OPE_LLEGA?: true
    KILO_SAL?: true
    KILO_LLE?: true
    idusos?: true
    _all?: true
  }

  export type Auto_usosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which auto_usos to aggregate.
     */
    where?: auto_usosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auto_usos to fetch.
     */
    orderBy?: auto_usosOrderByWithRelationInput | auto_usosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auto_usosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auto_usos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auto_usos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auto_usos
    **/
    _count?: true | Auto_usosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auto_usosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auto_usosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auto_usosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auto_usosMaxAggregateInputType
  }

  export type GetAuto_usosAggregateType<T extends Auto_usosAggregateArgs> = {
        [P in keyof T & keyof AggregateAuto_usos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuto_usos[P]>
      : GetScalarType<T[P], AggregateAuto_usos[P]>
  }




  export type auto_usosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: auto_usosWhereInput
    orderBy?: auto_usosOrderByWithAggregationInput | auto_usosOrderByWithAggregationInput[]
    by: Auto_usosScalarFieldEnum[] | Auto_usosScalarFieldEnum
    having?: auto_usosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auto_usosCountAggregateInputType | true
    _avg?: Auto_usosAvgAggregateInputType
    _sum?: Auto_usosSumAggregateInputType
    _min?: Auto_usosMinAggregateInputType
    _max?: Auto_usosMaxAggregateInputType
  }


  export type Auto_usosGroupByOutputType = {
    FECHA: Date | null
    PATENTE: string | null
    DESCRIP: string | null
    NOMB_OPE: string | null
    CHOFER: string | null
    HORA1: string | null
    HORA2: string | null
    TAREA: string | null
    OBSERVA_1: string | null
    OBSERVA_2: string | null
    OPE_LLEGA: string | null
    KILO_SAL: number | null
    KILO_LLE: number | null
    idusos: number
    _count: Auto_usosCountAggregateOutputType | null
    _avg: Auto_usosAvgAggregateOutputType | null
    _sum: Auto_usosSumAggregateOutputType | null
    _min: Auto_usosMinAggregateOutputType | null
    _max: Auto_usosMaxAggregateOutputType | null
  }

  type GetAuto_usosGroupByPayload<T extends auto_usosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auto_usosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auto_usosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auto_usosGroupByOutputType[P]>
            : GetScalarType<T[P], Auto_usosGroupByOutputType[P]>
        }
      >
    >


  export type auto_usosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FECHA?: boolean
    PATENTE?: boolean
    DESCRIP?: boolean
    NOMB_OPE?: boolean
    CHOFER?: boolean
    HORA1?: boolean
    HORA2?: boolean
    TAREA?: boolean
    OBSERVA_1?: boolean
    OBSERVA_2?: boolean
    OPE_LLEGA?: boolean
    KILO_SAL?: boolean
    KILO_LLE?: boolean
    idusos?: boolean
  }, ExtArgs["result"]["auto_usos"]>

  export type auto_usosSelectScalar = {
    FECHA?: boolean
    PATENTE?: boolean
    DESCRIP?: boolean
    NOMB_OPE?: boolean
    CHOFER?: boolean
    HORA1?: boolean
    HORA2?: boolean
    TAREA?: boolean
    OBSERVA_1?: boolean
    OBSERVA_2?: boolean
    OPE_LLEGA?: boolean
    KILO_SAL?: boolean
    KILO_LLE?: boolean
    idusos?: boolean
  }


  type auto_usosGetPayload<S extends boolean | null | undefined | auto_usosArgs> = $Types.GetResult<auto_usosPayload, S>

  type auto_usosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<auto_usosFindManyArgs, 'select' | 'include'> & {
      select?: Auto_usosCountAggregateInputType | true
    }

  export interface auto_usosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auto_usos'], meta: { name: 'auto_usos' } }
    /**
     * Find zero or one Auto_usos that matches the filter.
     * @param {auto_usosFindUniqueArgs} args - Arguments to find a Auto_usos
     * @example
     * // Get one Auto_usos
     * const auto_usos = await prisma.auto_usos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auto_usosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auto_usosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auto_usos'> extends True ? Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Auto_usos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auto_usosFindUniqueOrThrowArgs} args - Arguments to find a Auto_usos
     * @example
     * // Get one Auto_usos
     * const auto_usos = await prisma.auto_usos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auto_usosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auto_usosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Auto_usos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosFindFirstArgs} args - Arguments to find a Auto_usos
     * @example
     * // Get one Auto_usos
     * const auto_usos = await prisma.auto_usos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auto_usosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auto_usosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auto_usos'> extends True ? Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Auto_usos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosFindFirstOrThrowArgs} args - Arguments to find a Auto_usos
     * @example
     * // Get one Auto_usos
     * const auto_usos = await prisma.auto_usos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auto_usosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, auto_usosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Auto_usos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auto_usos
     * const auto_usos = await prisma.auto_usos.findMany()
     * 
     * // Get first 10 Auto_usos
     * const auto_usos = await prisma.auto_usos.findMany({ take: 10 })
     * 
     * // Only select the `FECHA`
     * const auto_usosWithFECHAOnly = await prisma.auto_usos.findMany({ select: { FECHA: true } })
     * 
    **/
    findMany<T extends auto_usosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auto_usosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Auto_usos.
     * @param {auto_usosCreateArgs} args - Arguments to create a Auto_usos.
     * @example
     * // Create one Auto_usos
     * const Auto_usos = await prisma.auto_usos.create({
     *   data: {
     *     // ... data to create a Auto_usos
     *   }
     * })
     * 
    **/
    create<T extends auto_usosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, auto_usosCreateArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Auto_usos.
     *     @param {auto_usosCreateManyArgs} args - Arguments to create many Auto_usos.
     *     @example
     *     // Create many Auto_usos
     *     const auto_usos = await prisma.auto_usos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auto_usosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auto_usosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auto_usos.
     * @param {auto_usosDeleteArgs} args - Arguments to delete one Auto_usos.
     * @example
     * // Delete one Auto_usos
     * const Auto_usos = await prisma.auto_usos.delete({
     *   where: {
     *     // ... filter to delete one Auto_usos
     *   }
     * })
     * 
    **/
    delete<T extends auto_usosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, auto_usosDeleteArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Auto_usos.
     * @param {auto_usosUpdateArgs} args - Arguments to update one Auto_usos.
     * @example
     * // Update one Auto_usos
     * const auto_usos = await prisma.auto_usos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auto_usosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, auto_usosUpdateArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Auto_usos.
     * @param {auto_usosDeleteManyArgs} args - Arguments to filter Auto_usos to delete.
     * @example
     * // Delete a few Auto_usos
     * const { count } = await prisma.auto_usos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auto_usosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, auto_usosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auto_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auto_usos
     * const auto_usos = await prisma.auto_usos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auto_usosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, auto_usosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auto_usos.
     * @param {auto_usosUpsertArgs} args - Arguments to update or create a Auto_usos.
     * @example
     * // Update or create a Auto_usos
     * const auto_usos = await prisma.auto_usos.upsert({
     *   create: {
     *     // ... data to create a Auto_usos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auto_usos we want to update
     *   }
     * })
    **/
    upsert<T extends auto_usosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, auto_usosUpsertArgs<ExtArgs>>
    ): Prisma__auto_usosClient<$Types.GetResult<auto_usosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Auto_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosCountArgs} args - Arguments to filter Auto_usos to count.
     * @example
     * // Count the number of Auto_usos
     * const count = await prisma.auto_usos.count({
     *   where: {
     *     // ... the filter for the Auto_usos we want to count
     *   }
     * })
    **/
    count<T extends auto_usosCountArgs>(
      args?: Subset<T, auto_usosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auto_usosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auto_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auto_usosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auto_usosAggregateArgs>(args: Subset<T, Auto_usosAggregateArgs>): Prisma.PrismaPromise<GetAuto_usosAggregateType<T>>

    /**
     * Group by Auto_usos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auto_usosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auto_usosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auto_usosGroupByArgs['orderBy'] }
        : { orderBy?: auto_usosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auto_usosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuto_usosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auto_usos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auto_usosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auto_usos base type for findUnique actions
   */
  export type auto_usosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter, which auto_usos to fetch.
     */
    where: auto_usosWhereUniqueInput
  }

  /**
   * auto_usos findUnique
   */
  export interface auto_usosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends auto_usosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auto_usos findUniqueOrThrow
   */
  export type auto_usosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter, which auto_usos to fetch.
     */
    where: auto_usosWhereUniqueInput
  }


  /**
   * auto_usos base type for findFirst actions
   */
  export type auto_usosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter, which auto_usos to fetch.
     */
    where?: auto_usosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auto_usos to fetch.
     */
    orderBy?: auto_usosOrderByWithRelationInput | auto_usosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auto_usos.
     */
    cursor?: auto_usosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auto_usos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auto_usos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auto_usos.
     */
    distinct?: Auto_usosScalarFieldEnum | Auto_usosScalarFieldEnum[]
  }

  /**
   * auto_usos findFirst
   */
  export interface auto_usosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends auto_usosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auto_usos findFirstOrThrow
   */
  export type auto_usosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter, which auto_usos to fetch.
     */
    where?: auto_usosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auto_usos to fetch.
     */
    orderBy?: auto_usosOrderByWithRelationInput | auto_usosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auto_usos.
     */
    cursor?: auto_usosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auto_usos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auto_usos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auto_usos.
     */
    distinct?: Auto_usosScalarFieldEnum | Auto_usosScalarFieldEnum[]
  }


  /**
   * auto_usos findMany
   */
  export type auto_usosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter, which auto_usos to fetch.
     */
    where?: auto_usosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auto_usos to fetch.
     */
    orderBy?: auto_usosOrderByWithRelationInput | auto_usosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auto_usos.
     */
    cursor?: auto_usosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auto_usos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auto_usos.
     */
    skip?: number
    distinct?: Auto_usosScalarFieldEnum | Auto_usosScalarFieldEnum[]
  }


  /**
   * auto_usos create
   */
  export type auto_usosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * The data needed to create a auto_usos.
     */
    data?: XOR<auto_usosCreateInput, auto_usosUncheckedCreateInput>
  }


  /**
   * auto_usos createMany
   */
  export type auto_usosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auto_usos.
     */
    data: auto_usosCreateManyInput | auto_usosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * auto_usos update
   */
  export type auto_usosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * The data needed to update a auto_usos.
     */
    data: XOR<auto_usosUpdateInput, auto_usosUncheckedUpdateInput>
    /**
     * Choose, which auto_usos to update.
     */
    where: auto_usosWhereUniqueInput
  }


  /**
   * auto_usos updateMany
   */
  export type auto_usosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auto_usos.
     */
    data: XOR<auto_usosUpdateManyMutationInput, auto_usosUncheckedUpdateManyInput>
    /**
     * Filter which auto_usos to update
     */
    where?: auto_usosWhereInput
  }


  /**
   * auto_usos upsert
   */
  export type auto_usosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * The filter to search for the auto_usos to update in case it exists.
     */
    where: auto_usosWhereUniqueInput
    /**
     * In case the auto_usos found by the `where` argument doesn't exist, create a new auto_usos with this data.
     */
    create: XOR<auto_usosCreateInput, auto_usosUncheckedCreateInput>
    /**
     * In case the auto_usos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auto_usosUpdateInput, auto_usosUncheckedUpdateInput>
  }


  /**
   * auto_usos delete
   */
  export type auto_usosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
    /**
     * Filter which auto_usos to delete.
     */
    where: auto_usosWhereUniqueInput
  }


  /**
   * auto_usos deleteMany
   */
  export type auto_usosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which auto_usos to delete
     */
    where?: auto_usosWhereInput
  }


  /**
   * auto_usos without action
   */
  export type auto_usosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auto_usos
     */
    select?: auto_usosSelect<ExtArgs> | null
  }



  /**
   * Model autos
   */


  export type AggregateAutos = {
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  export type AutosAvgAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosSumAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosMinAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosMaxAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosCountAggregateOutputType = {
    patente: number
    auto: number
    kilometros: number
    responsable: number
    nro_poliza: number
    empresa: number
    vencimiento: number
    motor: number
    chasis: number
    modelo: number
    cobertura: number
    idauto: number
    estado: number
    operador: number
    _all: number
  }


  export type AutosAvgAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosSumAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosMinAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosMaxAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosCountAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AutosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos to aggregate.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos
    **/
    _count?: true | AutosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutosMaxAggregateInputType
  }

  export type GetAutosAggregateType<T extends AutosAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos[P]>
      : GetScalarType<T[P], AggregateAutos[P]>
  }




  export type autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autosWhereInput
    orderBy?: autosOrderByWithAggregationInput | autosOrderByWithAggregationInput[]
    by: AutosScalarFieldEnum[] | AutosScalarFieldEnum
    having?: autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutosCountAggregateInputType | true
    _avg?: AutosAvgAggregateInputType
    _sum?: AutosSumAggregateInputType
    _min?: AutosMinAggregateInputType
    _max?: AutosMaxAggregateInputType
  }


  export type AutosGroupByOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number
    estado: boolean | null
    operador: string | null
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  type GetAutosGroupByPayload<T extends autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutosGroupByOutputType[P]>
            : GetScalarType<T[P], AutosGroupByOutputType[P]>
        }
      >
    >


  export type autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patente?: boolean
    auto?: boolean
    kilometros?: boolean
    responsable?: boolean
    nro_poliza?: boolean
    empresa?: boolean
    vencimiento?: boolean
    motor?: boolean
    chasis?: boolean
    modelo?: boolean
    cobertura?: boolean
    idauto?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos"]>

  export type autosSelectScalar = {
    patente?: boolean
    auto?: boolean
    kilometros?: boolean
    responsable?: boolean
    nro_poliza?: boolean
    empresa?: boolean
    vencimiento?: boolean
    motor?: boolean
    chasis?: boolean
    modelo?: boolean
    cobertura?: boolean
    idauto?: boolean
    estado?: boolean
    operador?: boolean
  }


  type autosGetPayload<S extends boolean | null | undefined | autosArgs> = $Types.GetResult<autosPayload, S>

  type autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autosFindManyArgs, 'select' | 'include'> & {
      select?: AutosCountAggregateInputType | true
    }

  export interface autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos'], meta: { name: 'autos' } }
    /**
     * Find zero or one Autos that matches the filter.
     * @param {autosFindUniqueArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos'> extends True ? Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autosFindUniqueOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos'> extends True ? Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos
     * const autos = await prisma.autos.findMany()
     * 
     * // Get first 10 Autos
     * const autos = await prisma.autos.findMany({ take: 10 })
     * 
     * // Only select the `patente`
     * const autosWithPatenteOnly = await prisma.autos.findMany({ select: { patente: true } })
     * 
    **/
    findMany<T extends autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos.
     * @param {autosCreateArgs} args - Arguments to create a Autos.
     * @example
     * // Create one Autos
     * const Autos = await prisma.autos.create({
     *   data: {
     *     // ... data to create a Autos
     *   }
     * })
     * 
    **/
    create<T extends autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autosCreateArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos.
     *     @param {autosCreateManyArgs} args - Arguments to create many Autos.
     *     @example
     *     // Create many Autos
     *     const autos = await prisma.autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos.
     * @param {autosDeleteArgs} args - Arguments to delete one Autos.
     * @example
     * // Delete one Autos
     * const Autos = await prisma.autos.delete({
     *   where: {
     *     // ... filter to delete one Autos
     *   }
     * })
     * 
    **/
    delete<T extends autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autosDeleteArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos.
     * @param {autosUpdateArgs} args - Arguments to update one Autos.
     * @example
     * // Update one Autos
     * const autos = await prisma.autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpdateArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos.
     * @param {autosDeleteManyArgs} args - Arguments to filter Autos to delete.
     * @example
     * // Delete a few Autos
     * const { count } = await prisma.autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos
     * const autos = await prisma.autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos.
     * @param {autosUpsertArgs} args - Arguments to update or create a Autos.
     * @example
     * // Update or create a Autos
     * const autos = await prisma.autos.upsert({
     *   create: {
     *     // ... data to create a Autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos we want to update
     *   }
     * })
    **/
    upsert<T extends autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpsertArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosCountArgs} args - Arguments to filter Autos to count.
     * @example
     * // Count the number of Autos
     * const count = await prisma.autos.count({
     *   where: {
     *     // ... the filter for the Autos we want to count
     *   }
     * })
    **/
    count<T extends autosCountArgs>(
      args?: Subset<T, autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutosAggregateArgs>(args: Subset<T, AutosAggregateArgs>): Prisma.PrismaPromise<GetAutosAggregateType<T>>

    /**
     * Group by Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autosGroupByArgs['orderBy'] }
        : { orderBy?: autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos base type for findUnique actions
   */
  export type autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }

  /**
   * autos findUnique
   */
  export interface autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findUniqueOrThrow
   */
  export type autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos base type for findFirst actions
   */
  export type autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }

  /**
   * autos findFirst
   */
  export interface autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findFirstOrThrow
   */
  export type autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }


  /**
   * autos findMany
   */
  export type autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }


  /**
   * autos create
   */
  export type autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The data needed to create a autos.
     */
    data?: XOR<autosCreateInput, autosUncheckedCreateInput>
  }


  /**
   * autos createMany
   */
  export type autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos.
     */
    data: autosCreateManyInput | autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos update
   */
  export type autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The data needed to update a autos.
     */
    data: XOR<autosUpdateInput, autosUncheckedUpdateInput>
    /**
     * Choose, which autos to update.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos updateMany
   */
  export type autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos.
     */
    data: XOR<autosUpdateManyMutationInput, autosUncheckedUpdateManyInput>
    /**
     * Filter which autos to update
     */
    where?: autosWhereInput
  }


  /**
   * autos upsert
   */
  export type autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The filter to search for the autos to update in case it exists.
     */
    where: autosWhereUniqueInput
    /**
     * In case the autos found by the `where` argument doesn't exist, create a new autos with this data.
     */
    create: XOR<autosCreateInput, autosUncheckedCreateInput>
    /**
     * In case the autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autosUpdateInput, autosUncheckedUpdateInput>
  }


  /**
   * autos delete
   */
  export type autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter which autos to delete.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos deleteMany
   */
  export type autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos to delete
     */
    where?: autosWhereInput
  }


  /**
   * autos without action
   */
  export type autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
  }



  /**
   * Model autos_hoja_ruta
   */


  export type AggregateAutos_hoja_ruta = {
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  export type Autos_hoja_rutaAvgAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaSumAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaMinAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaMaxAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaCountAggregateOutputType = {
    idhojaruta: number
    patente: number
    auto: number
    conductor: number
    idservicio: number
    fecha_salida: number
    km_salida: number
    fecha_llegada: number
    km_llegada: number
    fecha_registro: number
    operador: number
    _all: number
  }


  export type Autos_hoja_rutaAvgAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaSumAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaMinAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaMaxAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaCountAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
    _all?: true
  }

  export type Autos_hoja_rutaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_hoja_ruta to aggregate.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_hoja_rutas
    **/
    _count?: true | Autos_hoja_rutaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_hoja_rutaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_hoja_rutaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }

  export type GetAutos_hoja_rutaAggregateType<T extends Autos_hoja_rutaAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_hoja_ruta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
      : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
  }




  export type autos_hoja_rutaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_hoja_rutaWhereInput
    orderBy?: autos_hoja_rutaOrderByWithAggregationInput | autos_hoja_rutaOrderByWithAggregationInput[]
    by: Autos_hoja_rutaScalarFieldEnum[] | Autos_hoja_rutaScalarFieldEnum
    having?: autos_hoja_rutaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_hoja_rutaCountAggregateInputType | true
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    _sum?: Autos_hoja_rutaSumAggregateInputType
    _min?: Autos_hoja_rutaMinAggregateInputType
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }


  export type Autos_hoja_rutaGroupByOutputType = {
    idhojaruta: number
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  type GetAutos_hoja_rutaGroupByPayload<T extends autos_hoja_rutaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_hoja_rutaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_hoja_rutaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
        }
      >
    >


  export type autos_hoja_rutaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhojaruta?: boolean
    patente?: boolean
    auto?: boolean
    conductor?: boolean
    idservicio?: boolean
    fecha_salida?: boolean
    km_salida?: boolean
    fecha_llegada?: boolean
    km_llegada?: boolean
    fecha_registro?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos_hoja_ruta"]>

  export type autos_hoja_rutaSelectScalar = {
    idhojaruta?: boolean
    patente?: boolean
    auto?: boolean
    conductor?: boolean
    idservicio?: boolean
    fecha_salida?: boolean
    km_salida?: boolean
    fecha_llegada?: boolean
    km_llegada?: boolean
    fecha_registro?: boolean
    operador?: boolean
  }


  type autos_hoja_rutaGetPayload<S extends boolean | null | undefined | autos_hoja_rutaArgs> = $Types.GetResult<autos_hoja_rutaPayload, S>

  type autos_hoja_rutaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_hoja_rutaFindManyArgs, 'select' | 'include'> & {
      select?: Autos_hoja_rutaCountAggregateInputType | true
    }

  export interface autos_hoja_rutaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_hoja_ruta'], meta: { name: 'autos_hoja_ruta' } }
    /**
     * Find zero or one Autos_hoja_ruta that matches the filter.
     * @param {autos_hoja_rutaFindUniqueArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_hoja_rutaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_hoja_rutaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_hoja_ruta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_hoja_rutaFindUniqueOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_hoja_ruta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_hoja_rutaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_hoja_ruta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_hoja_rutas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
     * 
     * // Get first 10 Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany({ take: 10 })
     * 
     * // Only select the `idhojaruta`
     * const autos_hoja_rutaWithIdhojarutaOnly = await prisma.autos_hoja_ruta.findMany({ select: { idhojaruta: true } })
     * 
    **/
    findMany<T extends autos_hoja_rutaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_hoja_ruta.
     * @param {autos_hoja_rutaCreateArgs} args - Arguments to create a Autos_hoja_ruta.
     * @example
     * // Create one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.create({
     *   data: {
     *     // ... data to create a Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    create<T extends autos_hoja_rutaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaCreateArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_hoja_rutas.
     *     @param {autos_hoja_rutaCreateManyArgs} args - Arguments to create many Autos_hoja_rutas.
     *     @example
     *     // Create many Autos_hoja_rutas
     *     const autos_hoja_ruta = await prisma.autos_hoja_ruta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_hoja_rutaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_hoja_ruta.
     * @param {autos_hoja_rutaDeleteArgs} args - Arguments to delete one Autos_hoja_ruta.
     * @example
     * // Delete one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.delete({
     *   where: {
     *     // ... filter to delete one Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    delete<T extends autos_hoja_rutaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaDeleteArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpdateArgs} args - Arguments to update one Autos_hoja_ruta.
     * @example
     * // Update one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_hoja_rutaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpdateArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_hoja_rutas.
     * @param {autos_hoja_rutaDeleteManyArgs} args - Arguments to filter Autos_hoja_rutas to delete.
     * @example
     * // Delete a few Autos_hoja_rutas
     * const { count } = await prisma.autos_hoja_ruta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_hoja_rutaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_hoja_rutas
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_hoja_rutaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpsertArgs} args - Arguments to update or create a Autos_hoja_ruta.
     * @example
     * // Update or create a Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.upsert({
     *   create: {
     *     // ... data to create a Autos_hoja_ruta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_hoja_ruta we want to update
     *   }
     * })
    **/
    upsert<T extends autos_hoja_rutaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpsertArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaCountArgs} args - Arguments to filter Autos_hoja_rutas to count.
     * @example
     * // Count the number of Autos_hoja_rutas
     * const count = await prisma.autos_hoja_ruta.count({
     *   where: {
     *     // ... the filter for the Autos_hoja_rutas we want to count
     *   }
     * })
    **/
    count<T extends autos_hoja_rutaCountArgs>(
      args?: Subset<T, autos_hoja_rutaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_hoja_rutaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_hoja_rutaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_hoja_rutaAggregateArgs>(args: Subset<T, Autos_hoja_rutaAggregateArgs>): Prisma.PrismaPromise<GetAutos_hoja_rutaAggregateType<T>>

    /**
     * Group by Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_hoja_rutaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_hoja_rutaGroupByArgs['orderBy'] }
        : { orderBy?: autos_hoja_rutaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_hoja_rutaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_hoja_rutaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_hoja_ruta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_hoja_rutaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_hoja_ruta base type for findUnique actions
   */
  export type autos_hoja_rutaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }

  /**
   * autos_hoja_ruta findUnique
   */
  export interface autos_hoja_rutaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_hoja_rutaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findUniqueOrThrow
   */
  export type autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta base type for findFirst actions
   */
  export type autos_hoja_rutaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }

  /**
   * autos_hoja_ruta findFirst
   */
  export interface autos_hoja_rutaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_hoja_rutaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findFirstOrThrow
   */
  export type autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }


  /**
   * autos_hoja_ruta findMany
   */
  export type autos_hoja_rutaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_rutas to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }


  /**
   * autos_hoja_ruta create
   */
  export type autos_hoja_rutaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_hoja_ruta.
     */
    data?: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
  }


  /**
   * autos_hoja_ruta createMany
   */
  export type autos_hoja_rutaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_hoja_rutas.
     */
    data: autos_hoja_rutaCreateManyInput | autos_hoja_rutaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_hoja_ruta update
   */
  export type autos_hoja_rutaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_hoja_ruta.
     */
    data: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
    /**
     * Choose, which autos_hoja_ruta to update.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta updateMany
   */
  export type autos_hoja_rutaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_hoja_rutas.
     */
    data: XOR<autos_hoja_rutaUpdateManyMutationInput, autos_hoja_rutaUncheckedUpdateManyInput>
    /**
     * Filter which autos_hoja_rutas to update
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta upsert
   */
  export type autos_hoja_rutaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_hoja_ruta to update in case it exists.
     */
    where: autos_hoja_rutaWhereUniqueInput
    /**
     * In case the autos_hoja_ruta found by the `where` argument doesn't exist, create a new autos_hoja_ruta with this data.
     */
    create: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
    /**
     * In case the autos_hoja_ruta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
  }


  /**
   * autos_hoja_ruta delete
   */
  export type autos_hoja_rutaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter which autos_hoja_ruta to delete.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta deleteMany
   */
  export type autos_hoja_rutaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_hoja_rutas to delete
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta without action
   */
  export type autos_hoja_rutaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
  }



  /**
   * Model autos_novedades
   */


  export type AggregateAutos_novedades = {
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  export type Autos_novedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesMinAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesMaxAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesCountAggregateOutputType = {
    idnovedad: number
    patente: number
    fecha: number
    novedad: number
    operador: number
    auto: number
    _all: number
  }


  export type Autos_novedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesMinAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesMaxAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesCountAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
    _all?: true
  }

  export type Autos_novedadesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_novedades to aggregate.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_novedades
    **/
    _count?: true | Autos_novedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_novedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_novedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_novedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_novedadesMaxAggregateInputType
  }

  export type GetAutos_novedadesAggregateType<T extends Autos_novedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_novedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_novedades[P]>
      : GetScalarType<T[P], AggregateAutos_novedades[P]>
  }




  export type autos_novedadesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_novedadesWhereInput
    orderBy?: autos_novedadesOrderByWithAggregationInput | autos_novedadesOrderByWithAggregationInput[]
    by: Autos_novedadesScalarFieldEnum[] | Autos_novedadesScalarFieldEnum
    having?: autos_novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_novedadesCountAggregateInputType | true
    _avg?: Autos_novedadesAvgAggregateInputType
    _sum?: Autos_novedadesSumAggregateInputType
    _min?: Autos_novedadesMinAggregateInputType
    _max?: Autos_novedadesMaxAggregateInputType
  }


  export type Autos_novedadesGroupByOutputType = {
    idnovedad: number
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  type GetAutos_novedadesGroupByPayload<T extends autos_novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_novedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_novedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
        }
      >
    >


  export type autos_novedadesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovedad?: boolean
    patente?: boolean
    fecha?: boolean
    novedad?: boolean
    operador?: boolean
    auto?: boolean
  }, ExtArgs["result"]["autos_novedades"]>

  export type autos_novedadesSelectScalar = {
    idnovedad?: boolean
    patente?: boolean
    fecha?: boolean
    novedad?: boolean
    operador?: boolean
    auto?: boolean
  }


  type autos_novedadesGetPayload<S extends boolean | null | undefined | autos_novedadesArgs> = $Types.GetResult<autos_novedadesPayload, S>

  type autos_novedadesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_novedadesFindManyArgs, 'select' | 'include'> & {
      select?: Autos_novedadesCountAggregateInputType | true
    }

  export interface autos_novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_novedades'], meta: { name: 'autos_novedades' } }
    /**
     * Find zero or one Autos_novedades that matches the filter.
     * @param {autos_novedadesFindUniqueArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_novedadesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_novedadesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_novedadesFindUniqueOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_novedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_novedadesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_novedadesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_novedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany()
     * 
     * // Get first 10 Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const autos_novedadesWithIdnovedadOnly = await prisma.autos_novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends autos_novedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_novedades.
     * @param {autos_novedadesCreateArgs} args - Arguments to create a Autos_novedades.
     * @example
     * // Create one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.create({
     *   data: {
     *     // ... data to create a Autos_novedades
     *   }
     * })
     * 
    **/
    create<T extends autos_novedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesCreateArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_novedades.
     *     @param {autos_novedadesCreateManyArgs} args - Arguments to create many Autos_novedades.
     *     @example
     *     // Create many Autos_novedades
     *     const autos_novedades = await prisma.autos_novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_novedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_novedades.
     * @param {autos_novedadesDeleteArgs} args - Arguments to delete one Autos_novedades.
     * @example
     * // Delete one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.delete({
     *   where: {
     *     // ... filter to delete one Autos_novedades
     *   }
     * })
     * 
    **/
    delete<T extends autos_novedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesDeleteArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_novedades.
     * @param {autos_novedadesUpdateArgs} args - Arguments to update one Autos_novedades.
     * @example
     * // Update one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_novedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpdateArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_novedades.
     * @param {autos_novedadesDeleteManyArgs} args - Arguments to filter Autos_novedades to delete.
     * @example
     * // Delete a few Autos_novedades
     * const { count } = await prisma.autos_novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_novedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_novedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_novedades.
     * @param {autos_novedadesUpsertArgs} args - Arguments to update or create a Autos_novedades.
     * @example
     * // Update or create a Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.upsert({
     *   create: {
     *     // ... data to create a Autos_novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_novedades we want to update
     *   }
     * })
    **/
    upsert<T extends autos_novedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpsertArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesCountArgs} args - Arguments to filter Autos_novedades to count.
     * @example
     * // Count the number of Autos_novedades
     * const count = await prisma.autos_novedades.count({
     *   where: {
     *     // ... the filter for the Autos_novedades we want to count
     *   }
     * })
    **/
    count<T extends autos_novedadesCountArgs>(
      args?: Subset<T, autos_novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_novedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_novedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_novedadesAggregateArgs>(args: Subset<T, Autos_novedadesAggregateArgs>): Prisma.PrismaPromise<GetAutos_novedadesAggregateType<T>>

    /**
     * Group by Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_novedadesGroupByArgs['orderBy'] }
        : { orderBy?: autos_novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_novedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_novedadesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_novedades base type for findUnique actions
   */
  export type autos_novedadesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }

  /**
   * autos_novedades findUnique
   */
  export interface autos_novedadesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_novedadesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findUniqueOrThrow
   */
  export type autos_novedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades base type for findFirst actions
   */
  export type autos_novedadesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }

  /**
   * autos_novedades findFirst
   */
  export interface autos_novedadesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_novedadesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findFirstOrThrow
   */
  export type autos_novedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }


  /**
   * autos_novedades findMany
   */
  export type autos_novedadesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }


  /**
   * autos_novedades create
   */
  export type autos_novedadesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_novedades.
     */
    data?: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
  }


  /**
   * autos_novedades createMany
   */
  export type autos_novedadesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_novedades.
     */
    data: autos_novedadesCreateManyInput | autos_novedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_novedades update
   */
  export type autos_novedadesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_novedades.
     */
    data: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
    /**
     * Choose, which autos_novedades to update.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades updateMany
   */
  export type autos_novedadesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_novedades.
     */
    data: XOR<autos_novedadesUpdateManyMutationInput, autos_novedadesUncheckedUpdateManyInput>
    /**
     * Filter which autos_novedades to update
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades upsert
   */
  export type autos_novedadesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_novedades to update in case it exists.
     */
    where: autos_novedadesWhereUniqueInput
    /**
     * In case the autos_novedades found by the `where` argument doesn't exist, create a new autos_novedades with this data.
     */
    create: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
    /**
     * In case the autos_novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
  }


  /**
   * autos_novedades delete
   */
  export type autos_novedadesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter which autos_novedades to delete.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades deleteMany
   */
  export type autos_novedadesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_novedades to delete
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades without action
   */
  export type autos_novedadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
  }



  /**
   * Model autos_pago_patente
   */


  export type AggregateAutos_pago_patente = {
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  export type Autos_pago_patenteAvgAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteSumAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteMinAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteMaxAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteCountAggregateOutputType = {
    idpago: number
    patente: number
    mes: number
    ano: number
    importe: number
    cod_pago: number
    idauto: number
    operador: number
    _all: number
  }


  export type Autos_pago_patenteAvgAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteSumAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteMinAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteMaxAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteCountAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
    _all?: true
  }

  export type Autos_pago_patenteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_pago_patente to aggregate.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_pago_patentes
    **/
    _count?: true | Autos_pago_patenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_pago_patenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_pago_patenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_pago_patenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_pago_patenteMaxAggregateInputType
  }

  export type GetAutos_pago_patenteAggregateType<T extends Autos_pago_patenteAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_pago_patente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
      : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
  }




  export type autos_pago_patenteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_pago_patenteWhereInput
    orderBy?: autos_pago_patenteOrderByWithAggregationInput | autos_pago_patenteOrderByWithAggregationInput[]
    by: Autos_pago_patenteScalarFieldEnum[] | Autos_pago_patenteScalarFieldEnum
    having?: autos_pago_patenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_pago_patenteCountAggregateInputType | true
    _avg?: Autos_pago_patenteAvgAggregateInputType
    _sum?: Autos_pago_patenteSumAggregateInputType
    _min?: Autos_pago_patenteMinAggregateInputType
    _max?: Autos_pago_patenteMaxAggregateInputType
  }


  export type Autos_pago_patenteGroupByOutputType = {
    idpago: number
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  type GetAutos_pago_patenteGroupByPayload<T extends autos_pago_patenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_pago_patenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_pago_patenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
        }
      >
    >


  export type autos_pago_patenteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpago?: boolean
    patente?: boolean
    mes?: boolean
    ano?: boolean
    importe?: boolean
    cod_pago?: boolean
    idauto?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos_pago_patente"]>

  export type autos_pago_patenteSelectScalar = {
    idpago?: boolean
    patente?: boolean
    mes?: boolean
    ano?: boolean
    importe?: boolean
    cod_pago?: boolean
    idauto?: boolean
    operador?: boolean
  }


  type autos_pago_patenteGetPayload<S extends boolean | null | undefined | autos_pago_patenteArgs> = $Types.GetResult<autos_pago_patentePayload, S>

  type autos_pago_patenteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_pago_patenteFindManyArgs, 'select' | 'include'> & {
      select?: Autos_pago_patenteCountAggregateInputType | true
    }

  export interface autos_pago_patenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_pago_patente'], meta: { name: 'autos_pago_patente' } }
    /**
     * Find zero or one Autos_pago_patente that matches the filter.
     * @param {autos_pago_patenteFindUniqueArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_pago_patenteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_pago_patenteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_pago_patente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_pago_patenteFindUniqueOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_pago_patente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_pago_patenteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_pago_patente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_pago_patentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
     * 
     * // Get first 10 Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany({ take: 10 })
     * 
     * // Only select the `idpago`
     * const autos_pago_patenteWithIdpagoOnly = await prisma.autos_pago_patente.findMany({ select: { idpago: true } })
     * 
    **/
    findMany<T extends autos_pago_patenteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_pago_patente.
     * @param {autos_pago_patenteCreateArgs} args - Arguments to create a Autos_pago_patente.
     * @example
     * // Create one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.create({
     *   data: {
     *     // ... data to create a Autos_pago_patente
     *   }
     * })
     * 
    **/
    create<T extends autos_pago_patenteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteCreateArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_pago_patentes.
     *     @param {autos_pago_patenteCreateManyArgs} args - Arguments to create many Autos_pago_patentes.
     *     @example
     *     // Create many Autos_pago_patentes
     *     const autos_pago_patente = await prisma.autos_pago_patente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_pago_patenteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_pago_patente.
     * @param {autos_pago_patenteDeleteArgs} args - Arguments to delete one Autos_pago_patente.
     * @example
     * // Delete one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.delete({
     *   where: {
     *     // ... filter to delete one Autos_pago_patente
     *   }
     * })
     * 
    **/
    delete<T extends autos_pago_patenteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteDeleteArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_pago_patente.
     * @param {autos_pago_patenteUpdateArgs} args - Arguments to update one Autos_pago_patente.
     * @example
     * // Update one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_pago_patenteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpdateArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_pago_patentes.
     * @param {autos_pago_patenteDeleteManyArgs} args - Arguments to filter Autos_pago_patentes to delete.
     * @example
     * // Delete a few Autos_pago_patentes
     * const { count } = await prisma.autos_pago_patente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_pago_patenteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_pago_patentes
     * const autos_pago_patente = await prisma.autos_pago_patente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_pago_patenteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_pago_patente.
     * @param {autos_pago_patenteUpsertArgs} args - Arguments to update or create a Autos_pago_patente.
     * @example
     * // Update or create a Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.upsert({
     *   create: {
     *     // ... data to create a Autos_pago_patente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_pago_patente we want to update
     *   }
     * })
    **/
    upsert<T extends autos_pago_patenteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpsertArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteCountArgs} args - Arguments to filter Autos_pago_patentes to count.
     * @example
     * // Count the number of Autos_pago_patentes
     * const count = await prisma.autos_pago_patente.count({
     *   where: {
     *     // ... the filter for the Autos_pago_patentes we want to count
     *   }
     * })
    **/
    count<T extends autos_pago_patenteCountArgs>(
      args?: Subset<T, autos_pago_patenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_pago_patenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_pago_patenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_pago_patenteAggregateArgs>(args: Subset<T, Autos_pago_patenteAggregateArgs>): Prisma.PrismaPromise<GetAutos_pago_patenteAggregateType<T>>

    /**
     * Group by Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_pago_patenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_pago_patenteGroupByArgs['orderBy'] }
        : { orderBy?: autos_pago_patenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_pago_patenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_pago_patenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_pago_patente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_pago_patenteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_pago_patente base type for findUnique actions
   */
  export type autos_pago_patenteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }

  /**
   * autos_pago_patente findUnique
   */
  export interface autos_pago_patenteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_pago_patenteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findUniqueOrThrow
   */
  export type autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente base type for findFirst actions
   */
  export type autos_pago_patenteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }

  /**
   * autos_pago_patente findFirst
   */
  export interface autos_pago_patenteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_pago_patenteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findFirstOrThrow
   */
  export type autos_pago_patenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }


  /**
   * autos_pago_patente findMany
   */
  export type autos_pago_patenteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patentes to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }


  /**
   * autos_pago_patente create
   */
  export type autos_pago_patenteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_pago_patente.
     */
    data?: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
  }


  /**
   * autos_pago_patente createMany
   */
  export type autos_pago_patenteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_pago_patentes.
     */
    data: autos_pago_patenteCreateManyInput | autos_pago_patenteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_pago_patente update
   */
  export type autos_pago_patenteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_pago_patente.
     */
    data: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
    /**
     * Choose, which autos_pago_patente to update.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente updateMany
   */
  export type autos_pago_patenteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_pago_patentes.
     */
    data: XOR<autos_pago_patenteUpdateManyMutationInput, autos_pago_patenteUncheckedUpdateManyInput>
    /**
     * Filter which autos_pago_patentes to update
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente upsert
   */
  export type autos_pago_patenteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_pago_patente to update in case it exists.
     */
    where: autos_pago_patenteWhereUniqueInput
    /**
     * In case the autos_pago_patente found by the `where` argument doesn't exist, create a new autos_pago_patente with this data.
     */
    create: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
    /**
     * In case the autos_pago_patente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
  }


  /**
   * autos_pago_patente delete
   */
  export type autos_pago_patenteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter which autos_pago_patente to delete.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente deleteMany
   */
  export type autos_pago_patenteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_pago_patentes to delete
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente without action
   */
  export type autos_pago_patenteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
  }



  /**
   * Model caja_sa
   */


  export type AggregateCaja_sa = {
    _count: Caja_saCountAggregateOutputType | null
    _avg: Caja_saAvgAggregateOutputType | null
    _sum: Caja_saSumAggregateOutputType | null
    _min: Caja_saMinAggregateOutputType | null
    _max: Caja_saMaxAggregateOutputType | null
  }

  export type Caja_saAvgAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_saSumAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_saMinAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_saMaxAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_saCountAggregateOutputType = {
    idcaja: number
    codigo: number
    cuenta: number
    tipo: number
    serie: number
    factura: number
    importe: number
    comentarios: number
    nro_caja: number
    movim: number
    fecha: number
    puesto: number
    operador: number
    cuit: number
    proveedor: number
    sucursal: number
    _all: number
  }


  export type Caja_saAvgAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_saSumAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_saMinAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_saMaxAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_saCountAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
    _all?: true
  }

  export type Caja_saAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sa to aggregate.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sas
    **/
    _count?: true | Caja_saCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_saAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_saSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_saMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_saMaxAggregateInputType
  }

  export type GetCaja_saAggregateType<T extends Caja_saAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sa[P]>
      : GetScalarType<T[P], AggregateCaja_sa[P]>
  }




  export type caja_saGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_saWhereInput
    orderBy?: caja_saOrderByWithAggregationInput | caja_saOrderByWithAggregationInput[]
    by: Caja_saScalarFieldEnum[] | Caja_saScalarFieldEnum
    having?: caja_saScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_saCountAggregateInputType | true
    _avg?: Caja_saAvgAggregateInputType
    _sum?: Caja_saSumAggregateInputType
    _min?: Caja_saMinAggregateInputType
    _max?: Caja_saMaxAggregateInputType
  }


  export type Caja_saGroupByOutputType = {
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
    _count: Caja_saCountAggregateOutputType | null
    _avg: Caja_saAvgAggregateOutputType | null
    _sum: Caja_saSumAggregateOutputType | null
    _min: Caja_saMinAggregateOutputType | null
    _max: Caja_saMaxAggregateOutputType | null
  }

  type GetCaja_saGroupByPayload<T extends caja_saGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_saGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_saGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_saGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_saGroupByOutputType[P]>
        }
      >
    >


  export type caja_saSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["caja_sa"]>

  export type caja_saSelectScalar = {
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }


  type caja_saGetPayload<S extends boolean | null | undefined | caja_saArgs> = $Types.GetResult<caja_saPayload, S>

  type caja_saCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_saFindManyArgs, 'select' | 'include'> & {
      select?: Caja_saCountAggregateInputType | true
    }

  export interface caja_saDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_sa'], meta: { name: 'caja_sa' } }
    /**
     * Find zero or one Caja_sa that matches the filter.
     * @param {caja_saFindUniqueArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_saFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_saFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sa'> extends True ? Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_sa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_saFindUniqueOrThrowArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_saFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_sa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindFirstArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_saFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_saFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sa'> extends True ? Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_sa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindFirstOrThrowArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_saFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_sas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sas
     * const caja_sas = await prisma.caja_sa.findMany()
     * 
     * // Get first 10 Caja_sas
     * const caja_sas = await prisma.caja_sa.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_saWithIdcajaOnly = await prisma.caja_sa.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_saFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_sa.
     * @param {caja_saCreateArgs} args - Arguments to create a Caja_sa.
     * @example
     * // Create one Caja_sa
     * const Caja_sa = await prisma.caja_sa.create({
     *   data: {
     *     // ... data to create a Caja_sa
     *   }
     * })
     * 
    **/
    create<T extends caja_saCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saCreateArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_sas.
     *     @param {caja_saCreateManyArgs} args - Arguments to create many Caja_sas.
     *     @example
     *     // Create many Caja_sas
     *     const caja_sa = await prisma.caja_sa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_saCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sa.
     * @param {caja_saDeleteArgs} args - Arguments to delete one Caja_sa.
     * @example
     * // Delete one Caja_sa
     * const Caja_sa = await prisma.caja_sa.delete({
     *   where: {
     *     // ... filter to delete one Caja_sa
     *   }
     * })
     * 
    **/
    delete<T extends caja_saDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saDeleteArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_sa.
     * @param {caja_saUpdateArgs} args - Arguments to update one Caja_sa.
     * @example
     * // Update one Caja_sa
     * const caja_sa = await prisma.caja_sa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_saUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpdateArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_sas.
     * @param {caja_saDeleteManyArgs} args - Arguments to filter Caja_sas to delete.
     * @example
     * // Delete a few Caja_sas
     * const { count } = await prisma.caja_sa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_saDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sas
     * const caja_sa = await prisma.caja_sa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_saUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sa.
     * @param {caja_saUpsertArgs} args - Arguments to update or create a Caja_sa.
     * @example
     * // Update or create a Caja_sa
     * const caja_sa = await prisma.caja_sa.upsert({
     *   create: {
     *     // ... data to create a Caja_sa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sa we want to update
     *   }
     * })
    **/
    upsert<T extends caja_saUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpsertArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_sas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saCountArgs} args - Arguments to filter Caja_sas to count.
     * @example
     * // Count the number of Caja_sas
     * const count = await prisma.caja_sa.count({
     *   where: {
     *     // ... the filter for the Caja_sas we want to count
     *   }
     * })
    **/
    count<T extends caja_saCountArgs>(
      args?: Subset<T, caja_saCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_saCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_saAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_saAggregateArgs>(args: Subset<T, Caja_saAggregateArgs>): Prisma.PrismaPromise<GetCaja_saAggregateType<T>>

    /**
     * Group by Caja_sa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_saGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_saGroupByArgs['orderBy'] }
        : { orderBy?: caja_saGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_saGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_saGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_saClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sa base type for findUnique actions
   */
  export type caja_saFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where: caja_saWhereUniqueInput
  }

  /**
   * caja_sa findUnique
   */
  export interface caja_saFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_saFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sa findUniqueOrThrow
   */
  export type caja_saFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa base type for findFirst actions
   */
  export type caja_saFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sas.
     */
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }

  /**
   * caja_sa findFirst
   */
  export interface caja_saFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_saFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sa findFirstOrThrow
   */
  export type caja_saFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sas.
     */
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }


  /**
   * caja_sa findMany
   */
  export type caja_saFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sas to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }


  /**
   * caja_sa create
   */
  export type caja_saCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_sa.
     */
    data?: XOR<caja_saCreateInput, caja_saUncheckedCreateInput>
  }


  /**
   * caja_sa createMany
   */
  export type caja_saCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_sas.
     */
    data: caja_saCreateManyInput | caja_saCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_sa update
   */
  export type caja_saUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_sa.
     */
    data: XOR<caja_saUpdateInput, caja_saUncheckedUpdateInput>
    /**
     * Choose, which caja_sa to update.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa updateMany
   */
  export type caja_saUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_sas.
     */
    data: XOR<caja_saUpdateManyMutationInput, caja_saUncheckedUpdateManyInput>
    /**
     * Filter which caja_sas to update
     */
    where?: caja_saWhereInput
  }


  /**
   * caja_sa upsert
   */
  export type caja_saUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_sa to update in case it exists.
     */
    where: caja_saWhereUniqueInput
    /**
     * In case the caja_sa found by the `where` argument doesn't exist, create a new caja_sa with this data.
     */
    create: XOR<caja_saCreateInput, caja_saUncheckedCreateInput>
    /**
     * In case the caja_sa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_saUpdateInput, caja_saUncheckedUpdateInput>
  }


  /**
   * caja_sa delete
   */
  export type caja_saDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter which caja_sa to delete.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa deleteMany
   */
  export type caja_saDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sas to delete
     */
    where?: caja_saWhereInput
  }


  /**
   * caja_sa without action
   */
  export type caja_saArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
  }



  /**
   * Model caja_sepelio
   */


  export type AggregateCaja_sepelio = {
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  export type Caja_sepelioAvgAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioSumAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioMinAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioMaxAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioCountAggregateOutputType = {
    idcaja: number
    operador: number
    detalle: number
    monto: number
    estado: number
    fecha: number
    gastos: number
    totalcaja: number
    empresa: number
    tipofactura: number
    nfactura: number
    ptoventa: number
    concepto: number
    cierre: number
    ultimacarga: number
    _all: number
  }


  export type Caja_sepelioAvgAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioSumAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioMinAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioMaxAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioCountAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
    _all?: true
  }

  export type Caja_sepelioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sepelio to aggregate.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sepelios
    **/
    _count?: true | Caja_sepelioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_sepelioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_sepelioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_sepelioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_sepelioMaxAggregateInputType
  }

  export type GetCaja_sepelioAggregateType<T extends Caja_sepelioAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sepelio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sepelio[P]>
      : GetScalarType<T[P], AggregateCaja_sepelio[P]>
  }




  export type caja_sepelioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_sepelioWhereInput
    orderBy?: caja_sepelioOrderByWithAggregationInput | caja_sepelioOrderByWithAggregationInput[]
    by: Caja_sepelioScalarFieldEnum[] | Caja_sepelioScalarFieldEnum
    having?: caja_sepelioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_sepelioCountAggregateInputType | true
    _avg?: Caja_sepelioAvgAggregateInputType
    _sum?: Caja_sepelioSumAggregateInputType
    _min?: Caja_sepelioMinAggregateInputType
    _max?: Caja_sepelioMaxAggregateInputType
  }


  export type Caja_sepelioGroupByOutputType = {
    idcaja: number
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  type GetCaja_sepelioGroupByPayload<T extends caja_sepelioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_sepelioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_sepelioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
        }
      >
    >


  export type caja_sepelioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    operador?: boolean
    detalle?: boolean
    monto?: boolean
    estado?: boolean
    fecha?: boolean
    gastos?: boolean
    totalcaja?: boolean
    empresa?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    ptoventa?: boolean
    concepto?: boolean
    cierre?: boolean
    ultimacarga?: boolean
  }, ExtArgs["result"]["caja_sepelio"]>

  export type caja_sepelioSelectScalar = {
    idcaja?: boolean
    operador?: boolean
    detalle?: boolean
    monto?: boolean
    estado?: boolean
    fecha?: boolean
    gastos?: boolean
    totalcaja?: boolean
    empresa?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    ptoventa?: boolean
    concepto?: boolean
    cierre?: boolean
    ultimacarga?: boolean
  }


  type caja_sepelioGetPayload<S extends boolean | null | undefined | caja_sepelioArgs> = $Types.GetResult<caja_sepelioPayload, S>

  type caja_sepelioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_sepelioFindManyArgs, 'select' | 'include'> & {
      select?: Caja_sepelioCountAggregateInputType | true
    }

  export interface caja_sepelioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_sepelio'], meta: { name: 'caja_sepelio' } }
    /**
     * Find zero or one Caja_sepelio that matches the filter.
     * @param {caja_sepelioFindUniqueArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_sepelioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_sepelioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_sepelio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_sepelioFindUniqueOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_sepelioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_sepelio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_sepelioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_sepelioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_sepelio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_sepelioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_sepelios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany()
     * 
     * // Get first 10 Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_sepelioWithIdcajaOnly = await prisma.caja_sepelio.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_sepelioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_sepelio.
     * @param {caja_sepelioCreateArgs} args - Arguments to create a Caja_sepelio.
     * @example
     * // Create one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.create({
     *   data: {
     *     // ... data to create a Caja_sepelio
     *   }
     * })
     * 
    **/
    create<T extends caja_sepelioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioCreateArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_sepelios.
     *     @param {caja_sepelioCreateManyArgs} args - Arguments to create many Caja_sepelios.
     *     @example
     *     // Create many Caja_sepelios
     *     const caja_sepelio = await prisma.caja_sepelio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_sepelioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sepelio.
     * @param {caja_sepelioDeleteArgs} args - Arguments to delete one Caja_sepelio.
     * @example
     * // Delete one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.delete({
     *   where: {
     *     // ... filter to delete one Caja_sepelio
     *   }
     * })
     * 
    **/
    delete<T extends caja_sepelioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioDeleteArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_sepelio.
     * @param {caja_sepelioUpdateArgs} args - Arguments to update one Caja_sepelio.
     * @example
     * // Update one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_sepelioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpdateArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_sepelios.
     * @param {caja_sepelioDeleteManyArgs} args - Arguments to filter Caja_sepelios to delete.
     * @example
     * // Delete a few Caja_sepelios
     * const { count } = await prisma.caja_sepelio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_sepelioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sepelios
     * const caja_sepelio = await prisma.caja_sepelio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_sepelioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sepelio.
     * @param {caja_sepelioUpsertArgs} args - Arguments to update or create a Caja_sepelio.
     * @example
     * // Update or create a Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.upsert({
     *   create: {
     *     // ... data to create a Caja_sepelio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sepelio we want to update
     *   }
     * })
    **/
    upsert<T extends caja_sepelioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpsertArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioCountArgs} args - Arguments to filter Caja_sepelios to count.
     * @example
     * // Count the number of Caja_sepelios
     * const count = await prisma.caja_sepelio.count({
     *   where: {
     *     // ... the filter for the Caja_sepelios we want to count
     *   }
     * })
    **/
    count<T extends caja_sepelioCountArgs>(
      args?: Subset<T, caja_sepelioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_sepelioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_sepelioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_sepelioAggregateArgs>(args: Subset<T, Caja_sepelioAggregateArgs>): Prisma.PrismaPromise<GetCaja_sepelioAggregateType<T>>

    /**
     * Group by Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_sepelioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_sepelioGroupByArgs['orderBy'] }
        : { orderBy?: caja_sepelioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_sepelioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_sepelioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sepelio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_sepelioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sepelio base type for findUnique actions
   */
  export type caja_sepelioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }

  /**
   * caja_sepelio findUnique
   */
  export interface caja_sepelioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sepelioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findUniqueOrThrow
   */
  export type caja_sepelioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio base type for findFirst actions
   */
  export type caja_sepelioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }

  /**
   * caja_sepelio findFirst
   */
  export interface caja_sepelioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sepelioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findFirstOrThrow
   */
  export type caja_sepelioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }


  /**
   * caja_sepelio findMany
   */
  export type caja_sepelioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelios to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }


  /**
   * caja_sepelio create
   */
  export type caja_sepelioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_sepelio.
     */
    data?: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
  }


  /**
   * caja_sepelio createMany
   */
  export type caja_sepelioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_sepelios.
     */
    data: caja_sepelioCreateManyInput | caja_sepelioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_sepelio update
   */
  export type caja_sepelioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_sepelio.
     */
    data: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
    /**
     * Choose, which caja_sepelio to update.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio updateMany
   */
  export type caja_sepelioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_sepelios.
     */
    data: XOR<caja_sepelioUpdateManyMutationInput, caja_sepelioUncheckedUpdateManyInput>
    /**
     * Filter which caja_sepelios to update
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio upsert
   */
  export type caja_sepelioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_sepelio to update in case it exists.
     */
    where: caja_sepelioWhereUniqueInput
    /**
     * In case the caja_sepelio found by the `where` argument doesn't exist, create a new caja_sepelio with this data.
     */
    create: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
    /**
     * In case the caja_sepelio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
  }


  /**
   * caja_sepelio delete
   */
  export type caja_sepelioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter which caja_sepelio to delete.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio deleteMany
   */
  export type caja_sepelioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sepelios to delete
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio without action
   */
  export type caja_sepelioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
  }



  /**
   * Model caja_srl
   */


  export type AggregateCaja_srl = {
    _count: Caja_srlCountAggregateOutputType | null
    _avg: Caja_srlAvgAggregateOutputType | null
    _sum: Caja_srlSumAggregateOutputType | null
    _min: Caja_srlMinAggregateOutputType | null
    _max: Caja_srlMaxAggregateOutputType | null
  }

  export type Caja_srlAvgAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_srlSumAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_srlMinAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_srlMaxAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_srlCountAggregateOutputType = {
    idcaja: number
    codigo: number
    cuenta: number
    tipo: number
    serie: number
    factura: number
    importe: number
    comentarios: number
    nro_caja: number
    movim: number
    fecha: number
    puesto: number
    operador: number
    cuit: number
    proveedor: number
    sucursal: number
    _all: number
  }


  export type Caja_srlAvgAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_srlSumAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_srlMinAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_srlMaxAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_srlCountAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
    _all?: true
  }

  export type Caja_srlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_srl to aggregate.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_srls
    **/
    _count?: true | Caja_srlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_srlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_srlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_srlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_srlMaxAggregateInputType
  }

  export type GetCaja_srlAggregateType<T extends Caja_srlAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_srl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_srl[P]>
      : GetScalarType<T[P], AggregateCaja_srl[P]>
  }




  export type caja_srlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_srlWhereInput
    orderBy?: caja_srlOrderByWithAggregationInput | caja_srlOrderByWithAggregationInput[]
    by: Caja_srlScalarFieldEnum[] | Caja_srlScalarFieldEnum
    having?: caja_srlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_srlCountAggregateInputType | true
    _avg?: Caja_srlAvgAggregateInputType
    _sum?: Caja_srlSumAggregateInputType
    _min?: Caja_srlMinAggregateInputType
    _max?: Caja_srlMaxAggregateInputType
  }


  export type Caja_srlGroupByOutputType = {
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
    _count: Caja_srlCountAggregateOutputType | null
    _avg: Caja_srlAvgAggregateOutputType | null
    _sum: Caja_srlSumAggregateOutputType | null
    _min: Caja_srlMinAggregateOutputType | null
    _max: Caja_srlMaxAggregateOutputType | null
  }

  type GetCaja_srlGroupByPayload<T extends caja_srlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_srlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_srlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_srlGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_srlGroupByOutputType[P]>
        }
      >
    >


  export type caja_srlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["caja_srl"]>

  export type caja_srlSelectScalar = {
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }


  type caja_srlGetPayload<S extends boolean | null | undefined | caja_srlArgs> = $Types.GetResult<caja_srlPayload, S>

  type caja_srlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_srlFindManyArgs, 'select' | 'include'> & {
      select?: Caja_srlCountAggregateInputType | true
    }

  export interface caja_srlDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_srl'], meta: { name: 'caja_srl' } }
    /**
     * Find zero or one Caja_srl that matches the filter.
     * @param {caja_srlFindUniqueArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_srlFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_srlFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_srl'> extends True ? Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_srl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_srlFindUniqueOrThrowArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_srlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_srl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindFirstArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_srlFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_srlFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_srl'> extends True ? Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_srl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindFirstOrThrowArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_srlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_srls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_srls
     * const caja_srls = await prisma.caja_srl.findMany()
     * 
     * // Get first 10 Caja_srls
     * const caja_srls = await prisma.caja_srl.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_srlWithIdcajaOnly = await prisma.caja_srl.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_srlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_srl.
     * @param {caja_srlCreateArgs} args - Arguments to create a Caja_srl.
     * @example
     * // Create one Caja_srl
     * const Caja_srl = await prisma.caja_srl.create({
     *   data: {
     *     // ... data to create a Caja_srl
     *   }
     * })
     * 
    **/
    create<T extends caja_srlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlCreateArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_srls.
     *     @param {caja_srlCreateManyArgs} args - Arguments to create many Caja_srls.
     *     @example
     *     // Create many Caja_srls
     *     const caja_srl = await prisma.caja_srl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_srlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_srl.
     * @param {caja_srlDeleteArgs} args - Arguments to delete one Caja_srl.
     * @example
     * // Delete one Caja_srl
     * const Caja_srl = await prisma.caja_srl.delete({
     *   where: {
     *     // ... filter to delete one Caja_srl
     *   }
     * })
     * 
    **/
    delete<T extends caja_srlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlDeleteArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_srl.
     * @param {caja_srlUpdateArgs} args - Arguments to update one Caja_srl.
     * @example
     * // Update one Caja_srl
     * const caja_srl = await prisma.caja_srl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_srlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpdateArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_srls.
     * @param {caja_srlDeleteManyArgs} args - Arguments to filter Caja_srls to delete.
     * @example
     * // Delete a few Caja_srls
     * const { count } = await prisma.caja_srl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_srlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_srls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_srls
     * const caja_srl = await prisma.caja_srl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_srlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_srl.
     * @param {caja_srlUpsertArgs} args - Arguments to update or create a Caja_srl.
     * @example
     * // Update or create a Caja_srl
     * const caja_srl = await prisma.caja_srl.upsert({
     *   create: {
     *     // ... data to create a Caja_srl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_srl we want to update
     *   }
     * })
    **/
    upsert<T extends caja_srlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpsertArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_srls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlCountArgs} args - Arguments to filter Caja_srls to count.
     * @example
     * // Count the number of Caja_srls
     * const count = await prisma.caja_srl.count({
     *   where: {
     *     // ... the filter for the Caja_srls we want to count
     *   }
     * })
    **/
    count<T extends caja_srlCountArgs>(
      args?: Subset<T, caja_srlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_srlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_srl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_srlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_srlAggregateArgs>(args: Subset<T, Caja_srlAggregateArgs>): Prisma.PrismaPromise<GetCaja_srlAggregateType<T>>

    /**
     * Group by Caja_srl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_srlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_srlGroupByArgs['orderBy'] }
        : { orderBy?: caja_srlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_srlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_srlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_srl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_srlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_srl base type for findUnique actions
   */
  export type caja_srlFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where: caja_srlWhereUniqueInput
  }

  /**
   * caja_srl findUnique
   */
  export interface caja_srlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_srlFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_srl findUniqueOrThrow
   */
  export type caja_srlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl base type for findFirst actions
   */
  export type caja_srlFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_srls.
     */
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }

  /**
   * caja_srl findFirst
   */
  export interface caja_srlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_srlFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_srl findFirstOrThrow
   */
  export type caja_srlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_srls.
     */
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }


  /**
   * caja_srl findMany
   */
  export type caja_srlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srls to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }


  /**
   * caja_srl create
   */
  export type caja_srlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_srl.
     */
    data?: XOR<caja_srlCreateInput, caja_srlUncheckedCreateInput>
  }


  /**
   * caja_srl createMany
   */
  export type caja_srlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_srls.
     */
    data: caja_srlCreateManyInput | caja_srlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_srl update
   */
  export type caja_srlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_srl.
     */
    data: XOR<caja_srlUpdateInput, caja_srlUncheckedUpdateInput>
    /**
     * Choose, which caja_srl to update.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl updateMany
   */
  export type caja_srlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_srls.
     */
    data: XOR<caja_srlUpdateManyMutationInput, caja_srlUncheckedUpdateManyInput>
    /**
     * Filter which caja_srls to update
     */
    where?: caja_srlWhereInput
  }


  /**
   * caja_srl upsert
   */
  export type caja_srlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_srl to update in case it exists.
     */
    where: caja_srlWhereUniqueInput
    /**
     * In case the caja_srl found by the `where` argument doesn't exist, create a new caja_srl with this data.
     */
    create: XOR<caja_srlCreateInput, caja_srlUncheckedCreateInput>
    /**
     * In case the caja_srl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_srlUpdateInput, caja_srlUncheckedUpdateInput>
  }


  /**
   * caja_srl delete
   */
  export type caja_srlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter which caja_srl to delete.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl deleteMany
   */
  export type caja_srlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_srls to delete
     */
    where?: caja_srlWhereInput
  }


  /**
   * caja_srl without action
   */
  export type caja_srlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
  }



  /**
   * Model conceptos
   */


  export type AggregateConceptos = {
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  export type ConceptosAvgAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosSumAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosMinAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosMaxAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosCountAggregateOutputType = {
    idconcepto: number
    concepto: number
    tipo: number
    _all: number
  }


  export type ConceptosAvgAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosSumAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosMinAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosMaxAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosCountAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
    _all?: true
  }

  export type ConceptosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos to aggregate.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conceptos
    **/
    _count?: true | ConceptosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptosMaxAggregateInputType
  }

  export type GetConceptosAggregateType<T extends ConceptosAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptos[P]>
      : GetScalarType<T[P], AggregateConceptos[P]>
  }




  export type conceptosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: conceptosWhereInput
    orderBy?: conceptosOrderByWithAggregationInput | conceptosOrderByWithAggregationInput[]
    by: ConceptosScalarFieldEnum[] | ConceptosScalarFieldEnum
    having?: conceptosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptosCountAggregateInputType | true
    _avg?: ConceptosAvgAggregateInputType
    _sum?: ConceptosSumAggregateInputType
    _min?: ConceptosMinAggregateInputType
    _max?: ConceptosMaxAggregateInputType
  }


  export type ConceptosGroupByOutputType = {
    idconcepto: number
    concepto: string | null
    tipo: string | null
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  type GetConceptosGroupByPayload<T extends conceptosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
        }
      >
    >


  export type conceptosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconcepto?: boolean
    concepto?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["conceptos"]>

  export type conceptosSelectScalar = {
    idconcepto?: boolean
    concepto?: boolean
    tipo?: boolean
  }


  type conceptosGetPayload<S extends boolean | null | undefined | conceptosArgs> = $Types.GetResult<conceptosPayload, S>

  type conceptosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<conceptosFindManyArgs, 'select' | 'include'> & {
      select?: ConceptosCountAggregateInputType | true
    }

  export interface conceptosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conceptos'], meta: { name: 'conceptos' } }
    /**
     * Find zero or one Conceptos that matches the filter.
     * @param {conceptosFindUniqueArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conceptosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, conceptosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'conceptos'> extends True ? Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Conceptos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conceptosFindUniqueOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conceptosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conceptosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, conceptosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'conceptos'> extends True ? Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Conceptos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conceptosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conceptos
     * const conceptos = await prisma.conceptos.findMany()
     * 
     * // Get first 10 Conceptos
     * const conceptos = await prisma.conceptos.findMany({ take: 10 })
     * 
     * // Only select the `idconcepto`
     * const conceptosWithIdconceptoOnly = await prisma.conceptos.findMany({ select: { idconcepto: true } })
     * 
    **/
    findMany<T extends conceptosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Conceptos.
     * @param {conceptosCreateArgs} args - Arguments to create a Conceptos.
     * @example
     * // Create one Conceptos
     * const Conceptos = await prisma.conceptos.create({
     *   data: {
     *     // ... data to create a Conceptos
     *   }
     * })
     * 
    **/
    create<T extends conceptosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosCreateArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Conceptos.
     *     @param {conceptosCreateManyArgs} args - Arguments to create many Conceptos.
     *     @example
     *     // Create many Conceptos
     *     const conceptos = await prisma.conceptos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conceptosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conceptos.
     * @param {conceptosDeleteArgs} args - Arguments to delete one Conceptos.
     * @example
     * // Delete one Conceptos
     * const Conceptos = await prisma.conceptos.delete({
     *   where: {
     *     // ... filter to delete one Conceptos
     *   }
     * })
     * 
    **/
    delete<T extends conceptosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosDeleteArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Conceptos.
     * @param {conceptosUpdateArgs} args - Arguments to update one Conceptos.
     * @example
     * // Update one Conceptos
     * const conceptos = await prisma.conceptos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conceptosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpdateArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Conceptos.
     * @param {conceptosDeleteManyArgs} args - Arguments to filter Conceptos to delete.
     * @example
     * // Delete a few Conceptos
     * const { count } = await prisma.conceptos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conceptosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conceptos
     * const conceptos = await prisma.conceptos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conceptosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conceptos.
     * @param {conceptosUpsertArgs} args - Arguments to update or create a Conceptos.
     * @example
     * // Update or create a Conceptos
     * const conceptos = await prisma.conceptos.upsert({
     *   create: {
     *     // ... data to create a Conceptos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conceptos we want to update
     *   }
     * })
    **/
    upsert<T extends conceptosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpsertArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosCountArgs} args - Arguments to filter Conceptos to count.
     * @example
     * // Count the number of Conceptos
     * const count = await prisma.conceptos.count({
     *   where: {
     *     // ... the filter for the Conceptos we want to count
     *   }
     * })
    **/
    count<T extends conceptosCountArgs>(
      args?: Subset<T, conceptosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptosAggregateArgs>(args: Subset<T, ConceptosAggregateArgs>): Prisma.PrismaPromise<GetConceptosAggregateType<T>>

    /**
     * Group by Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conceptosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conceptosGroupByArgs['orderBy'] }
        : { orderBy?: conceptosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conceptosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for conceptos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__conceptosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * conceptos base type for findUnique actions
   */
  export type conceptosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }

  /**
   * conceptos findUnique
   */
  export interface conceptosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findUniqueOrThrow
   */
  export type conceptosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos base type for findFirst actions
   */
  export type conceptosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }

  /**
   * conceptos findFirst
   */
  export interface conceptosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findFirstOrThrow
   */
  export type conceptosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }


  /**
   * conceptos findMany
   */
  export type conceptosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }


  /**
   * conceptos create
   */
  export type conceptosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The data needed to create a conceptos.
     */
    data?: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
  }


  /**
   * conceptos createMany
   */
  export type conceptosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conceptos.
     */
    data: conceptosCreateManyInput | conceptosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conceptos update
   */
  export type conceptosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The data needed to update a conceptos.
     */
    data: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
    /**
     * Choose, which conceptos to update.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos updateMany
   */
  export type conceptosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conceptos.
     */
    data: XOR<conceptosUpdateManyMutationInput, conceptosUncheckedUpdateManyInput>
    /**
     * Filter which conceptos to update
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos upsert
   */
  export type conceptosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The filter to search for the conceptos to update in case it exists.
     */
    where: conceptosWhereUniqueInput
    /**
     * In case the conceptos found by the `where` argument doesn't exist, create a new conceptos with this data.
     */
    create: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
    /**
     * In case the conceptos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
  }


  /**
   * conceptos delete
   */
  export type conceptosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter which conceptos to delete.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos deleteMany
   */
  export type conceptosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos to delete
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos without action
   */
  export type conceptosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
  }



  /**
   * Model conceptos_sepelio_cuentas
   */


  export type AggregateConceptos_sepelio_cuentas = {
    _count: Conceptos_sepelio_cuentasCountAggregateOutputType | null
    _avg: Conceptos_sepelio_cuentasAvgAggregateOutputType | null
    _sum: Conceptos_sepelio_cuentasSumAggregateOutputType | null
    _min: Conceptos_sepelio_cuentasMinAggregateOutputType | null
    _max: Conceptos_sepelio_cuentasMaxAggregateOutputType | null
  }

  export type Conceptos_sepelio_cuentasAvgAggregateOutputType = {
    idconcepto: number | null
    idempresa: number | null
    sc_cuenta: number | null
    id: number | null
  }

  export type Conceptos_sepelio_cuentasSumAggregateOutputType = {
    idconcepto: number | null
    idempresa: number | null
    sc_cuenta: number | null
    id: number | null
  }

  export type Conceptos_sepelio_cuentasMinAggregateOutputType = {
    idconcepto: number | null
    idempresa: number | null
    sc_descripcion: string | null
    sc_cuenta: number | null
    id: number | null
  }

  export type Conceptos_sepelio_cuentasMaxAggregateOutputType = {
    idconcepto: number | null
    idempresa: number | null
    sc_descripcion: string | null
    sc_cuenta: number | null
    id: number | null
  }

  export type Conceptos_sepelio_cuentasCountAggregateOutputType = {
    idconcepto: number
    idempresa: number
    sc_descripcion: number
    sc_cuenta: number
    id: number
    _all: number
  }


  export type Conceptos_sepelio_cuentasAvgAggregateInputType = {
    idconcepto?: true
    idempresa?: true
    sc_cuenta?: true
    id?: true
  }

  export type Conceptos_sepelio_cuentasSumAggregateInputType = {
    idconcepto?: true
    idempresa?: true
    sc_cuenta?: true
    id?: true
  }

  export type Conceptos_sepelio_cuentasMinAggregateInputType = {
    idconcepto?: true
    idempresa?: true
    sc_descripcion?: true
    sc_cuenta?: true
    id?: true
  }

  export type Conceptos_sepelio_cuentasMaxAggregateInputType = {
    idconcepto?: true
    idempresa?: true
    sc_descripcion?: true
    sc_cuenta?: true
    id?: true
  }

  export type Conceptos_sepelio_cuentasCountAggregateInputType = {
    idconcepto?: true
    idempresa?: true
    sc_descripcion?: true
    sc_cuenta?: true
    id?: true
    _all?: true
  }

  export type Conceptos_sepelio_cuentasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos_sepelio_cuentas to aggregate.
     */
    where?: conceptos_sepelio_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos_sepelio_cuentas to fetch.
     */
    orderBy?: conceptos_sepelio_cuentasOrderByWithRelationInput | conceptos_sepelio_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conceptos_sepelio_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos_sepelio_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos_sepelio_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conceptos_sepelio_cuentas
    **/
    _count?: true | Conceptos_sepelio_cuentasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Conceptos_sepelio_cuentasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Conceptos_sepelio_cuentasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conceptos_sepelio_cuentasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conceptos_sepelio_cuentasMaxAggregateInputType
  }

  export type GetConceptos_sepelio_cuentasAggregateType<T extends Conceptos_sepelio_cuentasAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptos_sepelio_cuentas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptos_sepelio_cuentas[P]>
      : GetScalarType<T[P], AggregateConceptos_sepelio_cuentas[P]>
  }




  export type conceptos_sepelio_cuentasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: conceptos_sepelio_cuentasWhereInput
    orderBy?: conceptos_sepelio_cuentasOrderByWithAggregationInput | conceptos_sepelio_cuentasOrderByWithAggregationInput[]
    by: Conceptos_sepelio_cuentasScalarFieldEnum[] | Conceptos_sepelio_cuentasScalarFieldEnum
    having?: conceptos_sepelio_cuentasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conceptos_sepelio_cuentasCountAggregateInputType | true
    _avg?: Conceptos_sepelio_cuentasAvgAggregateInputType
    _sum?: Conceptos_sepelio_cuentasSumAggregateInputType
    _min?: Conceptos_sepelio_cuentasMinAggregateInputType
    _max?: Conceptos_sepelio_cuentasMaxAggregateInputType
  }


  export type Conceptos_sepelio_cuentasGroupByOutputType = {
    idconcepto: number | null
    idempresa: number | null
    sc_descripcion: string | null
    sc_cuenta: number | null
    id: number
    _count: Conceptos_sepelio_cuentasCountAggregateOutputType | null
    _avg: Conceptos_sepelio_cuentasAvgAggregateOutputType | null
    _sum: Conceptos_sepelio_cuentasSumAggregateOutputType | null
    _min: Conceptos_sepelio_cuentasMinAggregateOutputType | null
    _max: Conceptos_sepelio_cuentasMaxAggregateOutputType | null
  }

  type GetConceptos_sepelio_cuentasGroupByPayload<T extends conceptos_sepelio_cuentasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conceptos_sepelio_cuentasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conceptos_sepelio_cuentasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conceptos_sepelio_cuentasGroupByOutputType[P]>
            : GetScalarType<T[P], Conceptos_sepelio_cuentasGroupByOutputType[P]>
        }
      >
    >


  export type conceptos_sepelio_cuentasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconcepto?: boolean
    idempresa?: boolean
    sc_descripcion?: boolean
    sc_cuenta?: boolean
    id?: boolean
  }, ExtArgs["result"]["conceptos_sepelio_cuentas"]>

  export type conceptos_sepelio_cuentasSelectScalar = {
    idconcepto?: boolean
    idempresa?: boolean
    sc_descripcion?: boolean
    sc_cuenta?: boolean
    id?: boolean
  }


  type conceptos_sepelio_cuentasGetPayload<S extends boolean | null | undefined | conceptos_sepelio_cuentasArgs> = $Types.GetResult<conceptos_sepelio_cuentasPayload, S>

  type conceptos_sepelio_cuentasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<conceptos_sepelio_cuentasFindManyArgs, 'select' | 'include'> & {
      select?: Conceptos_sepelio_cuentasCountAggregateInputType | true
    }

  export interface conceptos_sepelio_cuentasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conceptos_sepelio_cuentas'], meta: { name: 'conceptos_sepelio_cuentas' } }
    /**
     * Find zero or one Conceptos_sepelio_cuentas that matches the filter.
     * @param {conceptos_sepelio_cuentasFindUniqueArgs} args - Arguments to find a Conceptos_sepelio_cuentas
     * @example
     * // Get one Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conceptos_sepelio_cuentasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, conceptos_sepelio_cuentasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'conceptos_sepelio_cuentas'> extends True ? Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Conceptos_sepelio_cuentas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conceptos_sepelio_cuentasFindUniqueOrThrowArgs} args - Arguments to find a Conceptos_sepelio_cuentas
     * @example
     * // Get one Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conceptos_sepelio_cuentasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Conceptos_sepelio_cuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasFindFirstArgs} args - Arguments to find a Conceptos_sepelio_cuentas
     * @example
     * // Get one Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conceptos_sepelio_cuentasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'conceptos_sepelio_cuentas'> extends True ? Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Conceptos_sepelio_cuentas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasFindFirstOrThrowArgs} args - Arguments to find a Conceptos_sepelio_cuentas
     * @example
     * // Get one Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conceptos_sepelio_cuentasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Conceptos_sepelio_cuentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findMany()
     * 
     * // Get first 10 Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.findMany({ take: 10 })
     * 
     * // Only select the `idconcepto`
     * const conceptos_sepelio_cuentasWithIdconceptoOnly = await prisma.conceptos_sepelio_cuentas.findMany({ select: { idconcepto: true } })
     * 
    **/
    findMany<T extends conceptos_sepelio_cuentasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Conceptos_sepelio_cuentas.
     * @param {conceptos_sepelio_cuentasCreateArgs} args - Arguments to create a Conceptos_sepelio_cuentas.
     * @example
     * // Create one Conceptos_sepelio_cuentas
     * const Conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.create({
     *   data: {
     *     // ... data to create a Conceptos_sepelio_cuentas
     *   }
     * })
     * 
    **/
    create<T extends conceptos_sepelio_cuentasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptos_sepelio_cuentasCreateArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Conceptos_sepelio_cuentas.
     *     @param {conceptos_sepelio_cuentasCreateManyArgs} args - Arguments to create many Conceptos_sepelio_cuentas.
     *     @example
     *     // Create many Conceptos_sepelio_cuentas
     *     const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conceptos_sepelio_cuentasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conceptos_sepelio_cuentas.
     * @param {conceptos_sepelio_cuentasDeleteArgs} args - Arguments to delete one Conceptos_sepelio_cuentas.
     * @example
     * // Delete one Conceptos_sepelio_cuentas
     * const Conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.delete({
     *   where: {
     *     // ... filter to delete one Conceptos_sepelio_cuentas
     *   }
     * })
     * 
    **/
    delete<T extends conceptos_sepelio_cuentasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conceptos_sepelio_cuentasDeleteArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Conceptos_sepelio_cuentas.
     * @param {conceptos_sepelio_cuentasUpdateArgs} args - Arguments to update one Conceptos_sepelio_cuentas.
     * @example
     * // Update one Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conceptos_sepelio_cuentasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptos_sepelio_cuentasUpdateArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Conceptos_sepelio_cuentas.
     * @param {conceptos_sepelio_cuentasDeleteManyArgs} args - Arguments to filter Conceptos_sepelio_cuentas to delete.
     * @example
     * // Delete a few Conceptos_sepelio_cuentas
     * const { count } = await prisma.conceptos_sepelio_cuentas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conceptos_sepelio_cuentasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptos_sepelio_cuentasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos_sepelio_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conceptos_sepelio_cuentasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conceptos_sepelio_cuentasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conceptos_sepelio_cuentas.
     * @param {conceptos_sepelio_cuentasUpsertArgs} args - Arguments to update or create a Conceptos_sepelio_cuentas.
     * @example
     * // Update or create a Conceptos_sepelio_cuentas
     * const conceptos_sepelio_cuentas = await prisma.conceptos_sepelio_cuentas.upsert({
     *   create: {
     *     // ... data to create a Conceptos_sepelio_cuentas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conceptos_sepelio_cuentas we want to update
     *   }
     * })
    **/
    upsert<T extends conceptos_sepelio_cuentasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conceptos_sepelio_cuentasUpsertArgs<ExtArgs>>
    ): Prisma__conceptos_sepelio_cuentasClient<$Types.GetResult<conceptos_sepelio_cuentasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Conceptos_sepelio_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasCountArgs} args - Arguments to filter Conceptos_sepelio_cuentas to count.
     * @example
     * // Count the number of Conceptos_sepelio_cuentas
     * const count = await prisma.conceptos_sepelio_cuentas.count({
     *   where: {
     *     // ... the filter for the Conceptos_sepelio_cuentas we want to count
     *   }
     * })
    **/
    count<T extends conceptos_sepelio_cuentasCountArgs>(
      args?: Subset<T, conceptos_sepelio_cuentasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conceptos_sepelio_cuentasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conceptos_sepelio_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conceptos_sepelio_cuentasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conceptos_sepelio_cuentasAggregateArgs>(args: Subset<T, Conceptos_sepelio_cuentasAggregateArgs>): Prisma.PrismaPromise<GetConceptos_sepelio_cuentasAggregateType<T>>

    /**
     * Group by Conceptos_sepelio_cuentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptos_sepelio_cuentasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conceptos_sepelio_cuentasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conceptos_sepelio_cuentasGroupByArgs['orderBy'] }
        : { orderBy?: conceptos_sepelio_cuentasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conceptos_sepelio_cuentasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptos_sepelio_cuentasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for conceptos_sepelio_cuentas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__conceptos_sepelio_cuentasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * conceptos_sepelio_cuentas base type for findUnique actions
   */
  export type conceptos_sepelio_cuentasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which conceptos_sepelio_cuentas to fetch.
     */
    where: conceptos_sepelio_cuentasWhereUniqueInput
  }

  /**
   * conceptos_sepelio_cuentas findUnique
   */
  export interface conceptos_sepelio_cuentasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptos_sepelio_cuentasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos_sepelio_cuentas findUniqueOrThrow
   */
  export type conceptos_sepelio_cuentasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which conceptos_sepelio_cuentas to fetch.
     */
    where: conceptos_sepelio_cuentasWhereUniqueInput
  }


  /**
   * conceptos_sepelio_cuentas base type for findFirst actions
   */
  export type conceptos_sepelio_cuentasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which conceptos_sepelio_cuentas to fetch.
     */
    where?: conceptos_sepelio_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos_sepelio_cuentas to fetch.
     */
    orderBy?: conceptos_sepelio_cuentasOrderByWithRelationInput | conceptos_sepelio_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos_sepelio_cuentas.
     */
    cursor?: conceptos_sepelio_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos_sepelio_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos_sepelio_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos_sepelio_cuentas.
     */
    distinct?: Conceptos_sepelio_cuentasScalarFieldEnum | Conceptos_sepelio_cuentasScalarFieldEnum[]
  }

  /**
   * conceptos_sepelio_cuentas findFirst
   */
  export interface conceptos_sepelio_cuentasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptos_sepelio_cuentasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos_sepelio_cuentas findFirstOrThrow
   */
  export type conceptos_sepelio_cuentasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which conceptos_sepelio_cuentas to fetch.
     */
    where?: conceptos_sepelio_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos_sepelio_cuentas to fetch.
     */
    orderBy?: conceptos_sepelio_cuentasOrderByWithRelationInput | conceptos_sepelio_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos_sepelio_cuentas.
     */
    cursor?: conceptos_sepelio_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos_sepelio_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos_sepelio_cuentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos_sepelio_cuentas.
     */
    distinct?: Conceptos_sepelio_cuentasScalarFieldEnum | Conceptos_sepelio_cuentasScalarFieldEnum[]
  }


  /**
   * conceptos_sepelio_cuentas findMany
   */
  export type conceptos_sepelio_cuentasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter, which conceptos_sepelio_cuentas to fetch.
     */
    where?: conceptos_sepelio_cuentasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos_sepelio_cuentas to fetch.
     */
    orderBy?: conceptos_sepelio_cuentasOrderByWithRelationInput | conceptos_sepelio_cuentasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conceptos_sepelio_cuentas.
     */
    cursor?: conceptos_sepelio_cuentasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos_sepelio_cuentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos_sepelio_cuentas.
     */
    skip?: number
    distinct?: Conceptos_sepelio_cuentasScalarFieldEnum | Conceptos_sepelio_cuentasScalarFieldEnum[]
  }


  /**
   * conceptos_sepelio_cuentas create
   */
  export type conceptos_sepelio_cuentasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * The data needed to create a conceptos_sepelio_cuentas.
     */
    data?: XOR<conceptos_sepelio_cuentasCreateInput, conceptos_sepelio_cuentasUncheckedCreateInput>
  }


  /**
   * conceptos_sepelio_cuentas createMany
   */
  export type conceptos_sepelio_cuentasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conceptos_sepelio_cuentas.
     */
    data: conceptos_sepelio_cuentasCreateManyInput | conceptos_sepelio_cuentasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conceptos_sepelio_cuentas update
   */
  export type conceptos_sepelio_cuentasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * The data needed to update a conceptos_sepelio_cuentas.
     */
    data: XOR<conceptos_sepelio_cuentasUpdateInput, conceptos_sepelio_cuentasUncheckedUpdateInput>
    /**
     * Choose, which conceptos_sepelio_cuentas to update.
     */
    where: conceptos_sepelio_cuentasWhereUniqueInput
  }


  /**
   * conceptos_sepelio_cuentas updateMany
   */
  export type conceptos_sepelio_cuentasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conceptos_sepelio_cuentas.
     */
    data: XOR<conceptos_sepelio_cuentasUpdateManyMutationInput, conceptos_sepelio_cuentasUncheckedUpdateManyInput>
    /**
     * Filter which conceptos_sepelio_cuentas to update
     */
    where?: conceptos_sepelio_cuentasWhereInput
  }


  /**
   * conceptos_sepelio_cuentas upsert
   */
  export type conceptos_sepelio_cuentasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * The filter to search for the conceptos_sepelio_cuentas to update in case it exists.
     */
    where: conceptos_sepelio_cuentasWhereUniqueInput
    /**
     * In case the conceptos_sepelio_cuentas found by the `where` argument doesn't exist, create a new conceptos_sepelio_cuentas with this data.
     */
    create: XOR<conceptos_sepelio_cuentasCreateInput, conceptos_sepelio_cuentasUncheckedCreateInput>
    /**
     * In case the conceptos_sepelio_cuentas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conceptos_sepelio_cuentasUpdateInput, conceptos_sepelio_cuentasUncheckedUpdateInput>
  }


  /**
   * conceptos_sepelio_cuentas delete
   */
  export type conceptos_sepelio_cuentasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
    /**
     * Filter which conceptos_sepelio_cuentas to delete.
     */
    where: conceptos_sepelio_cuentasWhereUniqueInput
  }


  /**
   * conceptos_sepelio_cuentas deleteMany
   */
  export type conceptos_sepelio_cuentasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos_sepelio_cuentas to delete
     */
    where?: conceptos_sepelio_cuentasWhereInput
  }


  /**
   * conceptos_sepelio_cuentas without action
   */
  export type conceptos_sepelio_cuentasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos_sepelio_cuentas
     */
    select?: conceptos_sepelio_cuentasSelect<ExtArgs> | null
  }



  /**
   * Model fabricante_ataud
   */


  export type AggregateFabricante_ataud = {
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  export type Fabricante_ataudAvgAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudSumAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudMinAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudMaxAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudCountAggregateOutputType = {
    idfabricante: number
    fabricante: number
    _all: number
  }


  export type Fabricante_ataudAvgAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudSumAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudMinAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudMaxAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudCountAggregateInputType = {
    idfabricante?: true
    fabricante?: true
    _all?: true
  }

  export type Fabricante_ataudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_ataud to aggregate.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fabricante_atauds
    **/
    _count?: true | Fabricante_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fabricante_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fabricante_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fabricante_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fabricante_ataudMaxAggregateInputType
  }

  export type GetFabricante_ataudAggregateType<T extends Fabricante_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateFabricante_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabricante_ataud[P]>
      : GetScalarType<T[P], AggregateFabricante_ataud[P]>
  }




  export type fabricante_ataudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fabricante_ataudWhereInput
    orderBy?: fabricante_ataudOrderByWithAggregationInput | fabricante_ataudOrderByWithAggregationInput[]
    by: Fabricante_ataudScalarFieldEnum[] | Fabricante_ataudScalarFieldEnum
    having?: fabricante_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fabricante_ataudCountAggregateInputType | true
    _avg?: Fabricante_ataudAvgAggregateInputType
    _sum?: Fabricante_ataudSumAggregateInputType
    _min?: Fabricante_ataudMinAggregateInputType
    _max?: Fabricante_ataudMaxAggregateInputType
  }


  export type Fabricante_ataudGroupByOutputType = {
    idfabricante: number
    fabricante: string | null
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  type GetFabricante_ataudGroupByPayload<T extends fabricante_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fabricante_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fabricante_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
        }
      >
    >


  export type fabricante_ataudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idfabricante?: boolean
    fabricante?: boolean
  }, ExtArgs["result"]["fabricante_ataud"]>

  export type fabricante_ataudSelectScalar = {
    idfabricante?: boolean
    fabricante?: boolean
  }


  type fabricante_ataudGetPayload<S extends boolean | null | undefined | fabricante_ataudArgs> = $Types.GetResult<fabricante_ataudPayload, S>

  type fabricante_ataudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fabricante_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Fabricante_ataudCountAggregateInputType | true
    }

  export interface fabricante_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fabricante_ataud'], meta: { name: 'fabricante_ataud' } }
    /**
     * Find zero or one Fabricante_ataud that matches the filter.
     * @param {fabricante_ataudFindUniqueArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fabricante_ataudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fabricante_ataudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fabricante_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fabricante_ataudFindUniqueOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fabricante_ataudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fabricante_ataudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fabricante_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
     * 
     * // Get first 10 Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idfabricante`
     * const fabricante_ataudWithIdfabricanteOnly = await prisma.fabricante_ataud.findMany({ select: { idfabricante: true } })
     * 
    **/
    findMany<T extends fabricante_ataudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fabricante_ataud.
     * @param {fabricante_ataudCreateArgs} args - Arguments to create a Fabricante_ataud.
     * @example
     * // Create one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.create({
     *   data: {
     *     // ... data to create a Fabricante_ataud
     *   }
     * })
     * 
    **/
    create<T extends fabricante_ataudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudCreateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fabricante_atauds.
     *     @param {fabricante_ataudCreateManyArgs} args - Arguments to create many Fabricante_atauds.
     *     @example
     *     // Create many Fabricante_atauds
     *     const fabricante_ataud = await prisma.fabricante_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fabricante_ataudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fabricante_ataud.
     * @param {fabricante_ataudDeleteArgs} args - Arguments to delete one Fabricante_ataud.
     * @example
     * // Delete one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.delete({
     *   where: {
     *     // ... filter to delete one Fabricante_ataud
     *   }
     * })
     * 
    **/
    delete<T extends fabricante_ataudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudDeleteArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fabricante_ataud.
     * @param {fabricante_ataudUpdateArgs} args - Arguments to update one Fabricante_ataud.
     * @example
     * // Update one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fabricante_ataudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fabricante_atauds.
     * @param {fabricante_ataudDeleteManyArgs} args - Arguments to filter Fabricante_atauds to delete.
     * @example
     * // Delete a few Fabricante_atauds
     * const { count } = await prisma.fabricante_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fabricante_ataudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fabricante_atauds
     * const fabricante_ataud = await prisma.fabricante_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fabricante_ataudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fabricante_ataud.
     * @param {fabricante_ataudUpsertArgs} args - Arguments to update or create a Fabricante_ataud.
     * @example
     * // Update or create a Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.upsert({
     *   create: {
     *     // ... data to create a Fabricante_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fabricante_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends fabricante_ataudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpsertArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudCountArgs} args - Arguments to filter Fabricante_atauds to count.
     * @example
     * // Count the number of Fabricante_atauds
     * const count = await prisma.fabricante_ataud.count({
     *   where: {
     *     // ... the filter for the Fabricante_atauds we want to count
     *   }
     * })
    **/
    count<T extends fabricante_ataudCountArgs>(
      args?: Subset<T, fabricante_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fabricante_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fabricante_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fabricante_ataudAggregateArgs>(args: Subset<T, Fabricante_ataudAggregateArgs>): Prisma.PrismaPromise<GetFabricante_ataudAggregateType<T>>

    /**
     * Group by Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fabricante_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fabricante_ataudGroupByArgs['orderBy'] }
        : { orderBy?: fabricante_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fabricante_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricante_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fabricante_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fabricante_ataudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fabricante_ataud base type for findUnique actions
   */
  export type fabricante_ataudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }

  /**
   * fabricante_ataud findUnique
   */
  export interface fabricante_ataudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findUniqueOrThrow
   */
  export type fabricante_ataudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud base type for findFirst actions
   */
  export type fabricante_ataudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }

  /**
   * fabricante_ataud findFirst
   */
  export interface fabricante_ataudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findFirstOrThrow
   */
  export type fabricante_ataudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud findMany
   */
  export type fabricante_ataudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_atauds to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud create
   */
  export type fabricante_ataudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to create a fabricante_ataud.
     */
    data?: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
  }


  /**
   * fabricante_ataud createMany
   */
  export type fabricante_ataudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fabricante_atauds.
     */
    data: fabricante_ataudCreateManyInput | fabricante_ataudCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fabricante_ataud update
   */
  export type fabricante_ataudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to update a fabricante_ataud.
     */
    data: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
    /**
     * Choose, which fabricante_ataud to update.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud updateMany
   */
  export type fabricante_ataudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fabricante_atauds.
     */
    data: XOR<fabricante_ataudUpdateManyMutationInput, fabricante_ataudUncheckedUpdateManyInput>
    /**
     * Filter which fabricante_atauds to update
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud upsert
   */
  export type fabricante_ataudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The filter to search for the fabricante_ataud to update in case it exists.
     */
    where: fabricante_ataudWhereUniqueInput
    /**
     * In case the fabricante_ataud found by the `where` argument doesn't exist, create a new fabricante_ataud with this data.
     */
    create: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
    /**
     * In case the fabricante_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
  }


  /**
   * fabricante_ataud delete
   */
  export type fabricante_ataudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter which fabricante_ataud to delete.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud deleteMany
   */
  export type fabricante_ataudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_atauds to delete
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud without action
   */
  export type fabricante_ataudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
  }



  /**
   * Model gasto_luto
   */


  export type AggregateGasto_luto = {
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  export type Gasto_lutoAvgAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoSumAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoMinAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoMaxAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoCountAggregateOutputType = {
    idgastoluto: number
    idservicio: number
    contrato: number
    dni_extinto: number
    extinto: number
    gasto_luto: number
    idataud: number
    apellido_ben: number
    nombre_ben: number
    telefono_ben: number
    fecha: number
    operador: number
    parentezco: number
    _all: number
  }


  export type Gasto_lutoAvgAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoSumAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoMinAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoMaxAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoCountAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
    _all?: true
  }

  export type Gasto_lutoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gasto_luto to aggregate.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gasto_lutos
    **/
    _count?: true | Gasto_lutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gasto_lutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gasto_lutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gasto_lutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gasto_lutoMaxAggregateInputType
  }

  export type GetGasto_lutoAggregateType<T extends Gasto_lutoAggregateArgs> = {
        [P in keyof T & keyof AggregateGasto_luto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGasto_luto[P]>
      : GetScalarType<T[P], AggregateGasto_luto[P]>
  }




  export type gasto_lutoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gasto_lutoWhereInput
    orderBy?: gasto_lutoOrderByWithAggregationInput | gasto_lutoOrderByWithAggregationInput[]
    by: Gasto_lutoScalarFieldEnum[] | Gasto_lutoScalarFieldEnum
    having?: gasto_lutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gasto_lutoCountAggregateInputType | true
    _avg?: Gasto_lutoAvgAggregateInputType
    _sum?: Gasto_lutoSumAggregateInputType
    _min?: Gasto_lutoMinAggregateInputType
    _max?: Gasto_lutoMaxAggregateInputType
  }


  export type Gasto_lutoGroupByOutputType = {
    idgastoluto: number
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  type GetGasto_lutoGroupByPayload<T extends gasto_lutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gasto_lutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gasto_lutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
            : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
        }
      >
    >


  export type gasto_lutoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastoluto?: boolean
    idservicio?: boolean
    contrato?: boolean
    dni_extinto?: boolean
    extinto?: boolean
    gasto_luto?: boolean
    idataud?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    telefono_ben?: boolean
    fecha?: boolean
    operador?: boolean
    parentezco?: boolean
  }, ExtArgs["result"]["gasto_luto"]>

  export type gasto_lutoSelectScalar = {
    idgastoluto?: boolean
    idservicio?: boolean
    contrato?: boolean
    dni_extinto?: boolean
    extinto?: boolean
    gasto_luto?: boolean
    idataud?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    telefono_ben?: boolean
    fecha?: boolean
    operador?: boolean
    parentezco?: boolean
  }


  type gasto_lutoGetPayload<S extends boolean | null | undefined | gasto_lutoArgs> = $Types.GetResult<gasto_lutoPayload, S>

  type gasto_lutoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gasto_lutoFindManyArgs, 'select' | 'include'> & {
      select?: Gasto_lutoCountAggregateInputType | true
    }

  export interface gasto_lutoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gasto_luto'], meta: { name: 'gasto_luto' } }
    /**
     * Find zero or one Gasto_luto that matches the filter.
     * @param {gasto_lutoFindUniqueArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gasto_lutoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gasto_lutoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gasto_luto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gasto_lutoFindUniqueOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gasto_lutoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gasto_luto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gasto_lutoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gasto_lutoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gasto_luto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gasto_lutoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gasto_lutos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany()
     * 
     * // Get first 10 Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany({ take: 10 })
     * 
     * // Only select the `idgastoluto`
     * const gasto_lutoWithIdgastolutoOnly = await prisma.gasto_luto.findMany({ select: { idgastoluto: true } })
     * 
    **/
    findMany<T extends gasto_lutoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gasto_luto.
     * @param {gasto_lutoCreateArgs} args - Arguments to create a Gasto_luto.
     * @example
     * // Create one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.create({
     *   data: {
     *     // ... data to create a Gasto_luto
     *   }
     * })
     * 
    **/
    create<T extends gasto_lutoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoCreateArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gasto_lutos.
     *     @param {gasto_lutoCreateManyArgs} args - Arguments to create many Gasto_lutos.
     *     @example
     *     // Create many Gasto_lutos
     *     const gasto_luto = await prisma.gasto_luto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gasto_lutoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gasto_luto.
     * @param {gasto_lutoDeleteArgs} args - Arguments to delete one Gasto_luto.
     * @example
     * // Delete one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.delete({
     *   where: {
     *     // ... filter to delete one Gasto_luto
     *   }
     * })
     * 
    **/
    delete<T extends gasto_lutoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoDeleteArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gasto_luto.
     * @param {gasto_lutoUpdateArgs} args - Arguments to update one Gasto_luto.
     * @example
     * // Update one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gasto_lutoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpdateArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gasto_lutos.
     * @param {gasto_lutoDeleteManyArgs} args - Arguments to filter Gasto_lutos to delete.
     * @example
     * // Delete a few Gasto_lutos
     * const { count } = await prisma.gasto_luto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gasto_lutoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gasto_lutos
     * const gasto_luto = await prisma.gasto_luto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gasto_lutoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gasto_luto.
     * @param {gasto_lutoUpsertArgs} args - Arguments to update or create a Gasto_luto.
     * @example
     * // Update or create a Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.upsert({
     *   create: {
     *     // ... data to create a Gasto_luto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gasto_luto we want to update
     *   }
     * })
    **/
    upsert<T extends gasto_lutoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpsertArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoCountArgs} args - Arguments to filter Gasto_lutos to count.
     * @example
     * // Count the number of Gasto_lutos
     * const count = await prisma.gasto_luto.count({
     *   where: {
     *     // ... the filter for the Gasto_lutos we want to count
     *   }
     * })
    **/
    count<T extends gasto_lutoCountArgs>(
      args?: Subset<T, gasto_lutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gasto_lutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gasto_lutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gasto_lutoAggregateArgs>(args: Subset<T, Gasto_lutoAggregateArgs>): Prisma.PrismaPromise<GetGasto_lutoAggregateType<T>>

    /**
     * Group by Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gasto_lutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gasto_lutoGroupByArgs['orderBy'] }
        : { orderBy?: gasto_lutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gasto_lutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGasto_lutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gasto_luto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gasto_lutoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gasto_luto base type for findUnique actions
   */
  export type gasto_lutoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }

  /**
   * gasto_luto findUnique
   */
  export interface gasto_lutoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gasto_lutoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findUniqueOrThrow
   */
  export type gasto_lutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto base type for findFirst actions
   */
  export type gasto_lutoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }

  /**
   * gasto_luto findFirst
   */
  export interface gasto_lutoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gasto_lutoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findFirstOrThrow
   */
  export type gasto_lutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }


  /**
   * gasto_luto findMany
   */
  export type gasto_lutoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_lutos to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }


  /**
   * gasto_luto create
   */
  export type gasto_lutoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The data needed to create a gasto_luto.
     */
    data?: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
  }


  /**
   * gasto_luto createMany
   */
  export type gasto_lutoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gasto_lutos.
     */
    data: gasto_lutoCreateManyInput | gasto_lutoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gasto_luto update
   */
  export type gasto_lutoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The data needed to update a gasto_luto.
     */
    data: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
    /**
     * Choose, which gasto_luto to update.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto updateMany
   */
  export type gasto_lutoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gasto_lutos.
     */
    data: XOR<gasto_lutoUpdateManyMutationInput, gasto_lutoUncheckedUpdateManyInput>
    /**
     * Filter which gasto_lutos to update
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto upsert
   */
  export type gasto_lutoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The filter to search for the gasto_luto to update in case it exists.
     */
    where: gasto_lutoWhereUniqueInput
    /**
     * In case the gasto_luto found by the `where` argument doesn't exist, create a new gasto_luto with this data.
     */
    create: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
    /**
     * In case the gasto_luto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
  }


  /**
   * gasto_luto delete
   */
  export type gasto_lutoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter which gasto_luto to delete.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto deleteMany
   */
  export type gasto_lutoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gasto_lutos to delete
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto without action
   */
  export type gasto_lutoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
  }



  /**
   * Model gastos_caja
   */


  export type AggregateGastos_caja = {
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  export type Gastos_cajaAvgAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaSumAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMinAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMaxAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaCountAggregateOutputType = {
    idgastos: number
    idcaja: number
    concepto: number
    tipofactura: number
    nfactura: number
    fecha: number
    operadorgestion: number
    operadortramite: number
    ptoventa: number
    porciva: number
    montoiva: number
    retiibb: number
    retggcias: number
    perciva: number
    detalle: number
    mediopago: number
    proveedor: number
    empresa: number
    total: number
    idservicio: number
    _all: number
  }


  export type Gastos_cajaAvgAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaSumAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMinAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMaxAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaCountAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
    _all?: true
  }

  export type Gastos_cajaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_caja to aggregate.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastos_cajas
    **/
    _count?: true | Gastos_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gastos_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gastos_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gastos_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gastos_cajaMaxAggregateInputType
  }

  export type GetGastos_cajaAggregateType<T extends Gastos_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateGastos_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastos_caja[P]>
      : GetScalarType<T[P], AggregateGastos_caja[P]>
  }




  export type gastos_cajaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gastos_cajaWhereInput
    orderBy?: gastos_cajaOrderByWithAggregationInput | gastos_cajaOrderByWithAggregationInput[]
    by: Gastos_cajaScalarFieldEnum[] | Gastos_cajaScalarFieldEnum
    having?: gastos_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gastos_cajaCountAggregateInputType | true
    _avg?: Gastos_cajaAvgAggregateInputType
    _sum?: Gastos_cajaSumAggregateInputType
    _min?: Gastos_cajaMinAggregateInputType
    _max?: Gastos_cajaMaxAggregateInputType
  }


  export type Gastos_cajaGroupByOutputType = {
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  type GetGastos_cajaGroupByPayload<T extends gastos_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gastos_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gastos_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
        }
      >
    >


  export type gastos_cajaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }, ExtArgs["result"]["gastos_caja"]>

  export type gastos_cajaSelectScalar = {
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }


  type gastos_cajaGetPayload<S extends boolean | null | undefined | gastos_cajaArgs> = $Types.GetResult<gastos_cajaPayload, S>

  type gastos_cajaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gastos_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Gastos_cajaCountAggregateInputType | true
    }

  export interface gastos_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gastos_caja'], meta: { name: 'gastos_caja' } }
    /**
     * Find zero or one Gastos_caja that matches the filter.
     * @param {gastos_cajaFindUniqueArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastos_cajaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastos_cajaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gastos_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gastos_cajaFindUniqueOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gastos_cajaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gastos_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastos_cajaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastos_cajaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gastos_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gastos_cajaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gastos_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany()
     * 
     * // Get first 10 Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const gastos_cajaWithIdgastosOnly = await prisma.gastos_caja.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends gastos_cajaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gastos_caja.
     * @param {gastos_cajaCreateArgs} args - Arguments to create a Gastos_caja.
     * @example
     * // Create one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.create({
     *   data: {
     *     // ... data to create a Gastos_caja
     *   }
     * })
     * 
    **/
    create<T extends gastos_cajaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaCreateArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gastos_cajas.
     *     @param {gastos_cajaCreateManyArgs} args - Arguments to create many Gastos_cajas.
     *     @example
     *     // Create many Gastos_cajas
     *     const gastos_caja = await prisma.gastos_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastos_cajaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gastos_caja.
     * @param {gastos_cajaDeleteArgs} args - Arguments to delete one Gastos_caja.
     * @example
     * // Delete one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.delete({
     *   where: {
     *     // ... filter to delete one Gastos_caja
     *   }
     * })
     * 
    **/
    delete<T extends gastos_cajaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaDeleteArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gastos_caja.
     * @param {gastos_cajaUpdateArgs} args - Arguments to update one Gastos_caja.
     * @example
     * // Update one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastos_cajaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpdateArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gastos_cajas.
     * @param {gastos_cajaDeleteManyArgs} args - Arguments to filter Gastos_cajas to delete.
     * @example
     * // Delete a few Gastos_cajas
     * const { count } = await prisma.gastos_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastos_cajaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastos_cajas
     * const gastos_caja = await prisma.gastos_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastos_cajaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastos_caja.
     * @param {gastos_cajaUpsertArgs} args - Arguments to update or create a Gastos_caja.
     * @example
     * // Update or create a Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.upsert({
     *   create: {
     *     // ... data to create a Gastos_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastos_caja we want to update
     *   }
     * })
    **/
    upsert<T extends gastos_cajaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpsertArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaCountArgs} args - Arguments to filter Gastos_cajas to count.
     * @example
     * // Count the number of Gastos_cajas
     * const count = await prisma.gastos_caja.count({
     *   where: {
     *     // ... the filter for the Gastos_cajas we want to count
     *   }
     * })
    **/
    count<T extends gastos_cajaCountArgs>(
      args?: Subset<T, gastos_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gastos_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gastos_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gastos_cajaAggregateArgs>(args: Subset<T, Gastos_cajaAggregateArgs>): Prisma.PrismaPromise<GetGastos_cajaAggregateType<T>>

    /**
     * Group by Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gastos_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gastos_cajaGroupByArgs['orderBy'] }
        : { orderBy?: gastos_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gastos_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastos_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gastos_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastos_cajaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gastos_caja base type for findUnique actions
   */
  export type gastos_cajaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }

  /**
   * gastos_caja findUnique
   */
  export interface gastos_cajaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_cajaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findUniqueOrThrow
   */
  export type gastos_cajaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja base type for findFirst actions
   */
  export type gastos_cajaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }

  /**
   * gastos_caja findFirst
   */
  export interface gastos_cajaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_cajaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findFirstOrThrow
   */
  export type gastos_cajaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }


  /**
   * gastos_caja findMany
   */
  export type gastos_cajaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_cajas to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }


  /**
   * gastos_caja create
   */
  export type gastos_cajaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The data needed to create a gastos_caja.
     */
    data?: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
  }


  /**
   * gastos_caja createMany
   */
  export type gastos_cajaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gastos_cajas.
     */
    data: gastos_cajaCreateManyInput | gastos_cajaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gastos_caja update
   */
  export type gastos_cajaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The data needed to update a gastos_caja.
     */
    data: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
    /**
     * Choose, which gastos_caja to update.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja updateMany
   */
  export type gastos_cajaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gastos_cajas.
     */
    data: XOR<gastos_cajaUpdateManyMutationInput, gastos_cajaUncheckedUpdateManyInput>
    /**
     * Filter which gastos_cajas to update
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja upsert
   */
  export type gastos_cajaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The filter to search for the gastos_caja to update in case it exists.
     */
    where: gastos_cajaWhereUniqueInput
    /**
     * In case the gastos_caja found by the `where` argument doesn't exist, create a new gastos_caja with this data.
     */
    create: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
    /**
     * In case the gastos_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
  }


  /**
   * gastos_caja delete
   */
  export type gastos_cajaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter which gastos_caja to delete.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja deleteMany
   */
  export type gastos_cajaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_cajas to delete
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja without action
   */
  export type gastos_cajaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
  }



  /**
   * Model generacion_cajas
   */


  export type AggregateGeneracion_cajas = {
    _count: Generacion_cajasCountAggregateOutputType | null
    _avg: Generacion_cajasAvgAggregateOutputType | null
    _sum: Generacion_cajasSumAggregateOutputType | null
    _min: Generacion_cajasMinAggregateOutputType | null
    _max: Generacion_cajasMaxAggregateOutputType | null
  }

  export type Generacion_cajasAvgAggregateOutputType = {
    idgeneracion: number | null
  }

  export type Generacion_cajasSumAggregateOutputType = {
    idgeneracion: number | null
  }

  export type Generacion_cajasMinAggregateOutputType = {
    idgeneracion: number | null
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }

  export type Generacion_cajasMaxAggregateOutputType = {
    idgeneracion: number | null
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }

  export type Generacion_cajasCountAggregateOutputType = {
    idgeneracion: number
    desde: number
    hasta: number
    empresa: number
    operador: number
    fecha: number
    _all: number
  }


  export type Generacion_cajasAvgAggregateInputType = {
    idgeneracion?: true
  }

  export type Generacion_cajasSumAggregateInputType = {
    idgeneracion?: true
  }

  export type Generacion_cajasMinAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
  }

  export type Generacion_cajasMaxAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
  }

  export type Generacion_cajasCountAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
    _all?: true
  }

  export type Generacion_cajasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which generacion_cajas to aggregate.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned generacion_cajas
    **/
    _count?: true | Generacion_cajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Generacion_cajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Generacion_cajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Generacion_cajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Generacion_cajasMaxAggregateInputType
  }

  export type GetGeneracion_cajasAggregateType<T extends Generacion_cajasAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneracion_cajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneracion_cajas[P]>
      : GetScalarType<T[P], AggregateGeneracion_cajas[P]>
  }




  export type generacion_cajasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: generacion_cajasWhereInput
    orderBy?: generacion_cajasOrderByWithAggregationInput | generacion_cajasOrderByWithAggregationInput[]
    by: Generacion_cajasScalarFieldEnum[] | Generacion_cajasScalarFieldEnum
    having?: generacion_cajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Generacion_cajasCountAggregateInputType | true
    _avg?: Generacion_cajasAvgAggregateInputType
    _sum?: Generacion_cajasSumAggregateInputType
    _min?: Generacion_cajasMinAggregateInputType
    _max?: Generacion_cajasMaxAggregateInputType
  }


  export type Generacion_cajasGroupByOutputType = {
    idgeneracion: number
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
    _count: Generacion_cajasCountAggregateOutputType | null
    _avg: Generacion_cajasAvgAggregateOutputType | null
    _sum: Generacion_cajasSumAggregateOutputType | null
    _min: Generacion_cajasMinAggregateOutputType | null
    _max: Generacion_cajasMaxAggregateOutputType | null
  }

  type GetGeneracion_cajasGroupByPayload<T extends generacion_cajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Generacion_cajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Generacion_cajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Generacion_cajasGroupByOutputType[P]>
            : GetScalarType<T[P], Generacion_cajasGroupByOutputType[P]>
        }
      >
    >


  export type generacion_cajasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgeneracion?: boolean
    desde?: boolean
    hasta?: boolean
    empresa?: boolean
    operador?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["generacion_cajas"]>

  export type generacion_cajasSelectScalar = {
    idgeneracion?: boolean
    desde?: boolean
    hasta?: boolean
    empresa?: boolean
    operador?: boolean
    fecha?: boolean
  }


  type generacion_cajasGetPayload<S extends boolean | null | undefined | generacion_cajasArgs> = $Types.GetResult<generacion_cajasPayload, S>

  type generacion_cajasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<generacion_cajasFindManyArgs, 'select' | 'include'> & {
      select?: Generacion_cajasCountAggregateInputType | true
    }

  export interface generacion_cajasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['generacion_cajas'], meta: { name: 'generacion_cajas' } }
    /**
     * Find zero or one Generacion_cajas that matches the filter.
     * @param {generacion_cajasFindUniqueArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends generacion_cajasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, generacion_cajasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'generacion_cajas'> extends True ? Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Generacion_cajas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {generacion_cajasFindUniqueOrThrowArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends generacion_cajasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Generacion_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindFirstArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends generacion_cajasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, generacion_cajasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'generacion_cajas'> extends True ? Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Generacion_cajas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindFirstOrThrowArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends generacion_cajasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Generacion_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findMany()
     * 
     * // Get first 10 Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findMany({ take: 10 })
     * 
     * // Only select the `idgeneracion`
     * const generacion_cajasWithIdgeneracionOnly = await prisma.generacion_cajas.findMany({ select: { idgeneracion: true } })
     * 
    **/
    findMany<T extends generacion_cajasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Generacion_cajas.
     * @param {generacion_cajasCreateArgs} args - Arguments to create a Generacion_cajas.
     * @example
     * // Create one Generacion_cajas
     * const Generacion_cajas = await prisma.generacion_cajas.create({
     *   data: {
     *     // ... data to create a Generacion_cajas
     *   }
     * })
     * 
    **/
    create<T extends generacion_cajasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasCreateArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Generacion_cajas.
     *     @param {generacion_cajasCreateManyArgs} args - Arguments to create many Generacion_cajas.
     *     @example
     *     // Create many Generacion_cajas
     *     const generacion_cajas = await prisma.generacion_cajas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends generacion_cajasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Generacion_cajas.
     * @param {generacion_cajasDeleteArgs} args - Arguments to delete one Generacion_cajas.
     * @example
     * // Delete one Generacion_cajas
     * const Generacion_cajas = await prisma.generacion_cajas.delete({
     *   where: {
     *     // ... filter to delete one Generacion_cajas
     *   }
     * })
     * 
    **/
    delete<T extends generacion_cajasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasDeleteArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Generacion_cajas.
     * @param {generacion_cajasUpdateArgs} args - Arguments to update one Generacion_cajas.
     * @example
     * // Update one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends generacion_cajasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpdateArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Generacion_cajas.
     * @param {generacion_cajasDeleteManyArgs} args - Arguments to filter Generacion_cajas to delete.
     * @example
     * // Delete a few Generacion_cajas
     * const { count } = await prisma.generacion_cajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends generacion_cajasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends generacion_cajasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Generacion_cajas.
     * @param {generacion_cajasUpsertArgs} args - Arguments to update or create a Generacion_cajas.
     * @example
     * // Update or create a Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.upsert({
     *   create: {
     *     // ... data to create a Generacion_cajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generacion_cajas we want to update
     *   }
     * })
    **/
    upsert<T extends generacion_cajasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpsertArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasCountArgs} args - Arguments to filter Generacion_cajas to count.
     * @example
     * // Count the number of Generacion_cajas
     * const count = await prisma.generacion_cajas.count({
     *   where: {
     *     // ... the filter for the Generacion_cajas we want to count
     *   }
     * })
    **/
    count<T extends generacion_cajasCountArgs>(
      args?: Subset<T, generacion_cajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Generacion_cajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Generacion_cajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Generacion_cajasAggregateArgs>(args: Subset<T, Generacion_cajasAggregateArgs>): Prisma.PrismaPromise<GetGeneracion_cajasAggregateType<T>>

    /**
     * Group by Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends generacion_cajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: generacion_cajasGroupByArgs['orderBy'] }
        : { orderBy?: generacion_cajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, generacion_cajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneracion_cajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for generacion_cajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__generacion_cajasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * generacion_cajas base type for findUnique actions
   */
  export type generacion_cajasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where: generacion_cajasWhereUniqueInput
  }

  /**
   * generacion_cajas findUnique
   */
  export interface generacion_cajasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends generacion_cajasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * generacion_cajas findUniqueOrThrow
   */
  export type generacion_cajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas base type for findFirst actions
   */
  export type generacion_cajasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generacion_cajas.
     */
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }

  /**
   * generacion_cajas findFirst
   */
  export interface generacion_cajasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends generacion_cajasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * generacion_cajas findFirstOrThrow
   */
  export type generacion_cajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generacion_cajas.
     */
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }


  /**
   * generacion_cajas findMany
   */
  export type generacion_cajasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }


  /**
   * generacion_cajas create
   */
  export type generacion_cajasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The data needed to create a generacion_cajas.
     */
    data?: XOR<generacion_cajasCreateInput, generacion_cajasUncheckedCreateInput>
  }


  /**
   * generacion_cajas createMany
   */
  export type generacion_cajasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many generacion_cajas.
     */
    data: generacion_cajasCreateManyInput | generacion_cajasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * generacion_cajas update
   */
  export type generacion_cajasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The data needed to update a generacion_cajas.
     */
    data: XOR<generacion_cajasUpdateInput, generacion_cajasUncheckedUpdateInput>
    /**
     * Choose, which generacion_cajas to update.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas updateMany
   */
  export type generacion_cajasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update generacion_cajas.
     */
    data: XOR<generacion_cajasUpdateManyMutationInput, generacion_cajasUncheckedUpdateManyInput>
    /**
     * Filter which generacion_cajas to update
     */
    where?: generacion_cajasWhereInput
  }


  /**
   * generacion_cajas upsert
   */
  export type generacion_cajasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The filter to search for the generacion_cajas to update in case it exists.
     */
    where: generacion_cajasWhereUniqueInput
    /**
     * In case the generacion_cajas found by the `where` argument doesn't exist, create a new generacion_cajas with this data.
     */
    create: XOR<generacion_cajasCreateInput, generacion_cajasUncheckedCreateInput>
    /**
     * In case the generacion_cajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<generacion_cajasUpdateInput, generacion_cajasUncheckedUpdateInput>
  }


  /**
   * generacion_cajas delete
   */
  export type generacion_cajasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter which generacion_cajas to delete.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas deleteMany
   */
  export type generacion_cajasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which generacion_cajas to delete
     */
    where?: generacion_cajasWhereInput
  }


  /**
   * generacion_cajas without action
   */
  export type generacion_cajasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
  }



  /**
   * Model historial_autos
   */


  export type AggregateHistorial_autos = {
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  export type Historial_autosAvgAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosSumAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosMinAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosMaxAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosCountAggregateOutputType = {
    idhistorial: number
    patente: number
    idauto: number
    operador: number
    fecha: number
    accion: number
    _all: number
  }


  export type Historial_autosAvgAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosSumAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosMinAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosMaxAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosCountAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
    _all?: true
  }

  export type Historial_autosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_autos to aggregate.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_autos
    **/
    _count?: true | Historial_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_autosMaxAggregateInputType
  }

  export type GetHistorial_autosAggregateType<T extends Historial_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_autos[P]>
      : GetScalarType<T[P], AggregateHistorial_autos[P]>
  }




  export type historial_autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_autosWhereInput
    orderBy?: historial_autosOrderByWithAggregationInput | historial_autosOrderByWithAggregationInput[]
    by: Historial_autosScalarFieldEnum[] | Historial_autosScalarFieldEnum
    having?: historial_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_autosCountAggregateInputType | true
    _avg?: Historial_autosAvgAggregateInputType
    _sum?: Historial_autosSumAggregateInputType
    _min?: Historial_autosMinAggregateInputType
    _max?: Historial_autosMaxAggregateInputType
  }


  export type Historial_autosGroupByOutputType = {
    idhistorial: number
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  type GetHistorial_autosGroupByPayload<T extends historial_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
        }
      >
    >


  export type historial_autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhistorial?: boolean
    patente?: boolean
    idauto?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }, ExtArgs["result"]["historial_autos"]>

  export type historial_autosSelectScalar = {
    idhistorial?: boolean
    patente?: boolean
    idauto?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }


  type historial_autosGetPayload<S extends boolean | null | undefined | historial_autosArgs> = $Types.GetResult<historial_autosPayload, S>

  type historial_autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_autosFindManyArgs, 'select' | 'include'> & {
      select?: Historial_autosCountAggregateInputType | true
    }

  export interface historial_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_autos'], meta: { name: 'historial_autos' } }
    /**
     * Find zero or one Historial_autos that matches the filter.
     * @param {historial_autosFindUniqueArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_autos'> extends True ? Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_autosFindUniqueOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_autos'> extends True ? Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany()
     * 
     * // Get first 10 Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_autosWithIdhistorialOnly = await prisma.historial_autos.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_autos.
     * @param {historial_autosCreateArgs} args - Arguments to create a Historial_autos.
     * @example
     * // Create one Historial_autos
     * const Historial_autos = await prisma.historial_autos.create({
     *   data: {
     *     // ... data to create a Historial_autos
     *   }
     * })
     * 
    **/
    create<T extends historial_autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosCreateArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_autos.
     *     @param {historial_autosCreateManyArgs} args - Arguments to create many Historial_autos.
     *     @example
     *     // Create many Historial_autos
     *     const historial_autos = await prisma.historial_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_autos.
     * @param {historial_autosDeleteArgs} args - Arguments to delete one Historial_autos.
     * @example
     * // Delete one Historial_autos
     * const Historial_autos = await prisma.historial_autos.delete({
     *   where: {
     *     // ... filter to delete one Historial_autos
     *   }
     * })
     * 
    **/
    delete<T extends historial_autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosDeleteArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_autos.
     * @param {historial_autosUpdateArgs} args - Arguments to update one Historial_autos.
     * @example
     * // Update one Historial_autos
     * const historial_autos = await prisma.historial_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpdateArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_autos.
     * @param {historial_autosDeleteManyArgs} args - Arguments to filter Historial_autos to delete.
     * @example
     * // Delete a few Historial_autos
     * const { count } = await prisma.historial_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_autos
     * const historial_autos = await prisma.historial_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_autos.
     * @param {historial_autosUpsertArgs} args - Arguments to update or create a Historial_autos.
     * @example
     * // Update or create a Historial_autos
     * const historial_autos = await prisma.historial_autos.upsert({
     *   create: {
     *     // ... data to create a Historial_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_autos we want to update
     *   }
     * })
    **/
    upsert<T extends historial_autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpsertArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosCountArgs} args - Arguments to filter Historial_autos to count.
     * @example
     * // Count the number of Historial_autos
     * const count = await prisma.historial_autos.count({
     *   where: {
     *     // ... the filter for the Historial_autos we want to count
     *   }
     * })
    **/
    count<T extends historial_autosCountArgs>(
      args?: Subset<T, historial_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_autosAggregateArgs>(args: Subset<T, Historial_autosAggregateArgs>): Prisma.PrismaPromise<GetHistorial_autosAggregateType<T>>

    /**
     * Group by Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_autosGroupByArgs['orderBy'] }
        : { orderBy?: historial_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_autos base type for findUnique actions
   */
  export type historial_autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }

  /**
   * historial_autos findUnique
   */
  export interface historial_autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findUniqueOrThrow
   */
  export type historial_autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos base type for findFirst actions
   */
  export type historial_autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }

  /**
   * historial_autos findFirst
   */
  export interface historial_autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findFirstOrThrow
   */
  export type historial_autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }


  /**
   * historial_autos findMany
   */
  export type historial_autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }


  /**
   * historial_autos create
   */
  export type historial_autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_autos.
     */
    data?: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
  }


  /**
   * historial_autos createMany
   */
  export type historial_autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_autos.
     */
    data: historial_autosCreateManyInput | historial_autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_autos update
   */
  export type historial_autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_autos.
     */
    data: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
    /**
     * Choose, which historial_autos to update.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos updateMany
   */
  export type historial_autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_autos.
     */
    data: XOR<historial_autosUpdateManyMutationInput, historial_autosUncheckedUpdateManyInput>
    /**
     * Filter which historial_autos to update
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos upsert
   */
  export type historial_autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_autos to update in case it exists.
     */
    where: historial_autosWhereUniqueInput
    /**
     * In case the historial_autos found by the `where` argument doesn't exist, create a new historial_autos with this data.
     */
    create: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
    /**
     * In case the historial_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
  }


  /**
   * historial_autos delete
   */
  export type historial_autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter which historial_autos to delete.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos deleteMany
   */
  export type historial_autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_autos to delete
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos without action
   */
  export type historial_autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
  }



  /**
   * Model historial_stock_ataud
   */


  export type AggregateHistorial_stock_ataud = {
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  export type Historial_stock_ataudAvgAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudSumAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudMinAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudMaxAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudCountAggregateOutputType = {
    idhistorial: number
    idataud: number
    fecha_carga: number
    stock_anterior: number
    stock_nuevo: number
    remito: number
    operador: number
    fecha_recepcion: number
    _all: number
  }


  export type Historial_stock_ataudAvgAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudSumAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudMinAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudMaxAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudCountAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
    _all?: true
  }

  export type Historial_stock_ataudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_stock_ataud to aggregate.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_stock_atauds
    **/
    _count?: true | Historial_stock_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_stock_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_stock_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_stock_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_stock_ataudMaxAggregateInputType
  }

  export type GetHistorial_stock_ataudAggregateType<T extends Historial_stock_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_stock_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
      : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
  }




  export type historial_stock_ataudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_stock_ataudWhereInput
    orderBy?: historial_stock_ataudOrderByWithAggregationInput | historial_stock_ataudOrderByWithAggregationInput[]
    by: Historial_stock_ataudScalarFieldEnum[] | Historial_stock_ataudScalarFieldEnum
    having?: historial_stock_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_stock_ataudCountAggregateInputType | true
    _avg?: Historial_stock_ataudAvgAggregateInputType
    _sum?: Historial_stock_ataudSumAggregateInputType
    _min?: Historial_stock_ataudMinAggregateInputType
    _max?: Historial_stock_ataudMaxAggregateInputType
  }


  export type Historial_stock_ataudGroupByOutputType = {
    idhistorial: number
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  type GetHistorial_stock_ataudGroupByPayload<T extends historial_stock_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_stock_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_stock_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
        }
      >
    >


  export type historial_stock_ataudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhistorial?: boolean
    idataud?: boolean
    fecha_carga?: boolean
    stock_anterior?: boolean
    stock_nuevo?: boolean
    remito?: boolean
    operador?: boolean
    fecha_recepcion?: boolean
  }, ExtArgs["result"]["historial_stock_ataud"]>

  export type historial_stock_ataudSelectScalar = {
    idhistorial?: boolean
    idataud?: boolean
    fecha_carga?: boolean
    stock_anterior?: boolean
    stock_nuevo?: boolean
    remito?: boolean
    operador?: boolean
    fecha_recepcion?: boolean
  }


  type historial_stock_ataudGetPayload<S extends boolean | null | undefined | historial_stock_ataudArgs> = $Types.GetResult<historial_stock_ataudPayload, S>

  type historial_stock_ataudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_stock_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Historial_stock_ataudCountAggregateInputType | true
    }

  export interface historial_stock_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_stock_ataud'], meta: { name: 'historial_stock_ataud' } }
    /**
     * Find zero or one Historial_stock_ataud that matches the filter.
     * @param {historial_stock_ataudFindUniqueArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_stock_ataudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_stock_ataudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_stock_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_stock_ataudFindUniqueOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_stock_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_stock_ataudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_stock_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_stock_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
     * 
     * // Get first 10 Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_stock_ataudWithIdhistorialOnly = await prisma.historial_stock_ataud.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_stock_ataudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_stock_ataud.
     * @param {historial_stock_ataudCreateArgs} args - Arguments to create a Historial_stock_ataud.
     * @example
     * // Create one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.create({
     *   data: {
     *     // ... data to create a Historial_stock_ataud
     *   }
     * })
     * 
    **/
    create<T extends historial_stock_ataudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudCreateArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_stock_atauds.
     *     @param {historial_stock_ataudCreateManyArgs} args - Arguments to create many Historial_stock_atauds.
     *     @example
     *     // Create many Historial_stock_atauds
     *     const historial_stock_ataud = await prisma.historial_stock_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_stock_ataudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_stock_ataud.
     * @param {historial_stock_ataudDeleteArgs} args - Arguments to delete one Historial_stock_ataud.
     * @example
     * // Delete one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.delete({
     *   where: {
     *     // ... filter to delete one Historial_stock_ataud
     *   }
     * })
     * 
    **/
    delete<T extends historial_stock_ataudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudDeleteArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpdateArgs} args - Arguments to update one Historial_stock_ataud.
     * @example
     * // Update one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_stock_ataudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpdateArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_stock_atauds.
     * @param {historial_stock_ataudDeleteManyArgs} args - Arguments to filter Historial_stock_atauds to delete.
     * @example
     * // Delete a few Historial_stock_atauds
     * const { count } = await prisma.historial_stock_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_stock_ataudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_stock_atauds
     * const historial_stock_ataud = await prisma.historial_stock_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_stock_ataudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpsertArgs} args - Arguments to update or create a Historial_stock_ataud.
     * @example
     * // Update or create a Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.upsert({
     *   create: {
     *     // ... data to create a Historial_stock_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_stock_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends historial_stock_ataudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpsertArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudCountArgs} args - Arguments to filter Historial_stock_atauds to count.
     * @example
     * // Count the number of Historial_stock_atauds
     * const count = await prisma.historial_stock_ataud.count({
     *   where: {
     *     // ... the filter for the Historial_stock_atauds we want to count
     *   }
     * })
    **/
    count<T extends historial_stock_ataudCountArgs>(
      args?: Subset<T, historial_stock_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_stock_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_stock_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_stock_ataudAggregateArgs>(args: Subset<T, Historial_stock_ataudAggregateArgs>): Prisma.PrismaPromise<GetHistorial_stock_ataudAggregateType<T>>

    /**
     * Group by Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_stock_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_stock_ataudGroupByArgs['orderBy'] }
        : { orderBy?: historial_stock_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_stock_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_stock_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_stock_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_stock_ataudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_stock_ataud base type for findUnique actions
   */
  export type historial_stock_ataudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }

  /**
   * historial_stock_ataud findUnique
   */
  export interface historial_stock_ataudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_stock_ataudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findUniqueOrThrow
   */
  export type historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud base type for findFirst actions
   */
  export type historial_stock_ataudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }

  /**
   * historial_stock_ataud findFirst
   */
  export interface historial_stock_ataudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_stock_ataudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findFirstOrThrow
   */
  export type historial_stock_ataudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }


  /**
   * historial_stock_ataud findMany
   */
  export type historial_stock_ataudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_atauds to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }


  /**
   * historial_stock_ataud create
   */
  export type historial_stock_ataudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_stock_ataud.
     */
    data?: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
  }


  /**
   * historial_stock_ataud createMany
   */
  export type historial_stock_ataudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_stock_atauds.
     */
    data: historial_stock_ataudCreateManyInput | historial_stock_ataudCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_stock_ataud update
   */
  export type historial_stock_ataudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_stock_ataud.
     */
    data: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
    /**
     * Choose, which historial_stock_ataud to update.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud updateMany
   */
  export type historial_stock_ataudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_stock_atauds.
     */
    data: XOR<historial_stock_ataudUpdateManyMutationInput, historial_stock_ataudUncheckedUpdateManyInput>
    /**
     * Filter which historial_stock_atauds to update
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud upsert
   */
  export type historial_stock_ataudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_stock_ataud to update in case it exists.
     */
    where: historial_stock_ataudWhereUniqueInput
    /**
     * In case the historial_stock_ataud found by the `where` argument doesn't exist, create a new historial_stock_ataud with this data.
     */
    create: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
    /**
     * In case the historial_stock_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
  }


  /**
   * historial_stock_ataud delete
   */
  export type historial_stock_ataudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter which historial_stock_ataud to delete.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud deleteMany
   */
  export type historial_stock_ataudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_stock_atauds to delete
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud without action
   */
  export type historial_stock_ataudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
  }



  /**
   * Model honorarios
   */


  export type AggregateHonorarios = {
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  export type HonorariosAvgAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosSumAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMinAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMaxAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosCountAggregateOutputType = {
    idtrabajo: number
    trabajo: number
    dias_habiles: number
    finde: number
    feriado: number
    _all: number
  }


  export type HonorariosAvgAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosSumAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMinAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMaxAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosCountAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
    _all?: true
  }

  export type HonorariosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which honorarios to aggregate.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned honorarios
    **/
    _count?: true | HonorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HonorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HonorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HonorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HonorariosMaxAggregateInputType
  }

  export type GetHonorariosAggregateType<T extends HonorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateHonorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHonorarios[P]>
      : GetScalarType<T[P], AggregateHonorarios[P]>
  }




  export type honorariosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: honorariosWhereInput
    orderBy?: honorariosOrderByWithAggregationInput | honorariosOrderByWithAggregationInput[]
    by: HonorariosScalarFieldEnum[] | HonorariosScalarFieldEnum
    having?: honorariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HonorariosCountAggregateInputType | true
    _avg?: HonorariosAvgAggregateInputType
    _sum?: HonorariosSumAggregateInputType
    _min?: HonorariosMinAggregateInputType
    _max?: HonorariosMaxAggregateInputType
  }


  export type HonorariosGroupByOutputType = {
    idtrabajo: number
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  type GetHonorariosGroupByPayload<T extends honorariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HonorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HonorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
            : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
        }
      >
    >


  export type honorariosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtrabajo?: boolean
    trabajo?: boolean
    dias_habiles?: boolean
    finde?: boolean
    feriado?: boolean
  }, ExtArgs["result"]["honorarios"]>

  export type honorariosSelectScalar = {
    idtrabajo?: boolean
    trabajo?: boolean
    dias_habiles?: boolean
    finde?: boolean
    feriado?: boolean
  }


  type honorariosGetPayload<S extends boolean | null | undefined | honorariosArgs> = $Types.GetResult<honorariosPayload, S>

  type honorariosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<honorariosFindManyArgs, 'select' | 'include'> & {
      select?: HonorariosCountAggregateInputType | true
    }

  export interface honorariosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['honorarios'], meta: { name: 'honorarios' } }
    /**
     * Find zero or one Honorarios that matches the filter.
     * @param {honorariosFindUniqueArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends honorariosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, honorariosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'honorarios'> extends True ? Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Honorarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {honorariosFindUniqueOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends honorariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends honorariosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, honorariosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'honorarios'> extends True ? Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Honorarios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends honorariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Honorarios
     * const honorarios = await prisma.honorarios.findMany()
     * 
     * // Get first 10 Honorarios
     * const honorarios = await prisma.honorarios.findMany({ take: 10 })
     * 
     * // Only select the `idtrabajo`
     * const honorariosWithIdtrabajoOnly = await prisma.honorarios.findMany({ select: { idtrabajo: true } })
     * 
    **/
    findMany<T extends honorariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Honorarios.
     * @param {honorariosCreateArgs} args - Arguments to create a Honorarios.
     * @example
     * // Create one Honorarios
     * const Honorarios = await prisma.honorarios.create({
     *   data: {
     *     // ... data to create a Honorarios
     *   }
     * })
     * 
    **/
    create<T extends honorariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosCreateArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Honorarios.
     *     @param {honorariosCreateManyArgs} args - Arguments to create many Honorarios.
     *     @example
     *     // Create many Honorarios
     *     const honorarios = await prisma.honorarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends honorariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Honorarios.
     * @param {honorariosDeleteArgs} args - Arguments to delete one Honorarios.
     * @example
     * // Delete one Honorarios
     * const Honorarios = await prisma.honorarios.delete({
     *   where: {
     *     // ... filter to delete one Honorarios
     *   }
     * })
     * 
    **/
    delete<T extends honorariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosDeleteArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Honorarios.
     * @param {honorariosUpdateArgs} args - Arguments to update one Honorarios.
     * @example
     * // Update one Honorarios
     * const honorarios = await prisma.honorarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends honorariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpdateArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Honorarios.
     * @param {honorariosDeleteManyArgs} args - Arguments to filter Honorarios to delete.
     * @example
     * // Delete a few Honorarios
     * const { count } = await prisma.honorarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends honorariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Honorarios
     * const honorarios = await prisma.honorarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends honorariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Honorarios.
     * @param {honorariosUpsertArgs} args - Arguments to update or create a Honorarios.
     * @example
     * // Update or create a Honorarios
     * const honorarios = await prisma.honorarios.upsert({
     *   create: {
     *     // ... data to create a Honorarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Honorarios we want to update
     *   }
     * })
    **/
    upsert<T extends honorariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpsertArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosCountArgs} args - Arguments to filter Honorarios to count.
     * @example
     * // Count the number of Honorarios
     * const count = await prisma.honorarios.count({
     *   where: {
     *     // ... the filter for the Honorarios we want to count
     *   }
     * })
    **/
    count<T extends honorariosCountArgs>(
      args?: Subset<T, honorariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HonorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HonorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HonorariosAggregateArgs>(args: Subset<T, HonorariosAggregateArgs>): Prisma.PrismaPromise<GetHonorariosAggregateType<T>>

    /**
     * Group by Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends honorariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: honorariosGroupByArgs['orderBy'] }
        : { orderBy?: honorariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, honorariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHonorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for honorarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__honorariosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * honorarios base type for findUnique actions
   */
  export type honorariosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }

  /**
   * honorarios findUnique
   */
  export interface honorariosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends honorariosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findUniqueOrThrow
   */
  export type honorariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios base type for findFirst actions
   */
  export type honorariosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }

  /**
   * honorarios findFirst
   */
  export interface honorariosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends honorariosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findFirstOrThrow
   */
  export type honorariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }


  /**
   * honorarios findMany
   */
  export type honorariosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }


  /**
   * honorarios create
   */
  export type honorariosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The data needed to create a honorarios.
     */
    data?: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
  }


  /**
   * honorarios createMany
   */
  export type honorariosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many honorarios.
     */
    data: honorariosCreateManyInput | honorariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * honorarios update
   */
  export type honorariosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The data needed to update a honorarios.
     */
    data: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
    /**
     * Choose, which honorarios to update.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios updateMany
   */
  export type honorariosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update honorarios.
     */
    data: XOR<honorariosUpdateManyMutationInput, honorariosUncheckedUpdateManyInput>
    /**
     * Filter which honorarios to update
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios upsert
   */
  export type honorariosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The filter to search for the honorarios to update in case it exists.
     */
    where: honorariosWhereUniqueInput
    /**
     * In case the honorarios found by the `where` argument doesn't exist, create a new honorarios with this data.
     */
    create: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
    /**
     * In case the honorarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
  }


  /**
   * honorarios delete
   */
  export type honorariosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter which honorarios to delete.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios deleteMany
   */
  export type honorariosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which honorarios to delete
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios without action
   */
  export type honorariosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
  }



  /**
   * Model informe_tareas
   */


  export type AggregateInforme_tareas = {
    _count: Informe_tareasCountAggregateOutputType | null
    _avg: Informe_tareasAvgAggregateOutputType | null
    _sum: Informe_tareasSumAggregateOutputType | null
    _min: Informe_tareasMinAggregateOutputType | null
    _max: Informe_tareasMaxAggregateOutputType | null
  }

  export type Informe_tareasAvgAggregateOutputType = {
    idtareas: number | null
    idinforme: number | null
    idservicio: number | null
    horas: number | null
    monto: number | null
  }

  export type Informe_tareasSumAggregateOutputType = {
    idtareas: number | null
    idinforme: number | null
    idservicio: number | null
    horas: number | null
    monto: number | null
  }

  export type Informe_tareasMinAggregateOutputType = {
    idtareas: number | null
    idinforme: number | null
    idservicio: number | null
    operador: string | null
    tarea: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    monto: number | null
    liquidado: boolean | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
  }

  export type Informe_tareasMaxAggregateOutputType = {
    idtareas: number | null
    idinforme: number | null
    idservicio: number | null
    operador: string | null
    tarea: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    monto: number | null
    liquidado: boolean | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
  }

  export type Informe_tareasCountAggregateOutputType = {
    idtareas: number
    idinforme: number
    idservicio: number
    operador: number
    tarea: number
    inicio: number
    fin: number
    horas: number
    monto: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    _all: number
  }


  export type Informe_tareasAvgAggregateInputType = {
    idtareas?: true
    idinforme?: true
    idservicio?: true
    horas?: true
    monto?: true
  }

  export type Informe_tareasSumAggregateInputType = {
    idtareas?: true
    idinforme?: true
    idservicio?: true
    horas?: true
    monto?: true
  }

  export type Informe_tareasMinAggregateInputType = {
    idtareas?: true
    idinforme?: true
    idservicio?: true
    operador?: true
    tarea?: true
    inicio?: true
    fin?: true
    horas?: true
    monto?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
  }

  export type Informe_tareasMaxAggregateInputType = {
    idtareas?: true
    idinforme?: true
    idservicio?: true
    operador?: true
    tarea?: true
    inicio?: true
    fin?: true
    horas?: true
    monto?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
  }

  export type Informe_tareasCountAggregateInputType = {
    idtareas?: true
    idinforme?: true
    idservicio?: true
    operador?: true
    tarea?: true
    inicio?: true
    fin?: true
    horas?: true
    monto?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    _all?: true
  }

  export type Informe_tareasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which informe_tareas to aggregate.
     */
    where?: informe_tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_tareas to fetch.
     */
    orderBy?: informe_tareasOrderByWithRelationInput | informe_tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: informe_tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned informe_tareas
    **/
    _count?: true | Informe_tareasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Informe_tareasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Informe_tareasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Informe_tareasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Informe_tareasMaxAggregateInputType
  }

  export type GetInforme_tareasAggregateType<T extends Informe_tareasAggregateArgs> = {
        [P in keyof T & keyof AggregateInforme_tareas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInforme_tareas[P]>
      : GetScalarType<T[P], AggregateInforme_tareas[P]>
  }




  export type informe_tareasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: informe_tareasWhereInput
    orderBy?: informe_tareasOrderByWithAggregationInput | informe_tareasOrderByWithAggregationInput[]
    by: Informe_tareasScalarFieldEnum[] | Informe_tareasScalarFieldEnum
    having?: informe_tareasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Informe_tareasCountAggregateInputType | true
    _avg?: Informe_tareasAvgAggregateInputType
    _sum?: Informe_tareasSumAggregateInputType
    _min?: Informe_tareasMinAggregateInputType
    _max?: Informe_tareasMaxAggregateInputType
  }


  export type Informe_tareasGroupByOutputType = {
    idtareas: number
    idinforme: number | null
    idservicio: number | null
    operador: string | null
    tarea: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    monto: number | null
    liquidado: boolean | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
    _count: Informe_tareasCountAggregateOutputType | null
    _avg: Informe_tareasAvgAggregateOutputType | null
    _sum: Informe_tareasSumAggregateOutputType | null
    _min: Informe_tareasMinAggregateOutputType | null
    _max: Informe_tareasMaxAggregateOutputType | null
  }

  type GetInforme_tareasGroupByPayload<T extends informe_tareasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Informe_tareasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Informe_tareasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Informe_tareasGroupByOutputType[P]>
            : GetScalarType<T[P], Informe_tareasGroupByOutputType[P]>
        }
      >
    >


  export type informe_tareasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtareas?: boolean
    idinforme?: boolean
    idservicio?: boolean
    operador?: boolean
    tarea?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    monto?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
  }, ExtArgs["result"]["informe_tareas"]>

  export type informe_tareasSelectScalar = {
    idtareas?: boolean
    idinforme?: boolean
    idservicio?: boolean
    operador?: boolean
    tarea?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    monto?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
  }


  type informe_tareasGetPayload<S extends boolean | null | undefined | informe_tareasArgs> = $Types.GetResult<informe_tareasPayload, S>

  type informe_tareasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<informe_tareasFindManyArgs, 'select' | 'include'> & {
      select?: Informe_tareasCountAggregateInputType | true
    }

  export interface informe_tareasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['informe_tareas'], meta: { name: 'informe_tareas' } }
    /**
     * Find zero or one Informe_tareas that matches the filter.
     * @param {informe_tareasFindUniqueArgs} args - Arguments to find a Informe_tareas
     * @example
     * // Get one Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends informe_tareasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, informe_tareasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'informe_tareas'> extends True ? Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Informe_tareas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {informe_tareasFindUniqueOrThrowArgs} args - Arguments to find a Informe_tareas
     * @example
     * // Get one Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends informe_tareasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_tareasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Informe_tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasFindFirstArgs} args - Arguments to find a Informe_tareas
     * @example
     * // Get one Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends informe_tareasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, informe_tareasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'informe_tareas'> extends True ? Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Informe_tareas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasFindFirstOrThrowArgs} args - Arguments to find a Informe_tareas
     * @example
     * // Get one Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends informe_tareasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_tareasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Informe_tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findMany()
     * 
     * // Get first 10 Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.findMany({ take: 10 })
     * 
     * // Only select the `idtareas`
     * const informe_tareasWithIdtareasOnly = await prisma.informe_tareas.findMany({ select: { idtareas: true } })
     * 
    **/
    findMany<T extends informe_tareasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_tareasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Informe_tareas.
     * @param {informe_tareasCreateArgs} args - Arguments to create a Informe_tareas.
     * @example
     * // Create one Informe_tareas
     * const Informe_tareas = await prisma.informe_tareas.create({
     *   data: {
     *     // ... data to create a Informe_tareas
     *   }
     * })
     * 
    **/
    create<T extends informe_tareasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, informe_tareasCreateArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Informe_tareas.
     *     @param {informe_tareasCreateManyArgs} args - Arguments to create many Informe_tareas.
     *     @example
     *     // Create many Informe_tareas
     *     const informe_tareas = await prisma.informe_tareas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends informe_tareasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_tareasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Informe_tareas.
     * @param {informe_tareasDeleteArgs} args - Arguments to delete one Informe_tareas.
     * @example
     * // Delete one Informe_tareas
     * const Informe_tareas = await prisma.informe_tareas.delete({
     *   where: {
     *     // ... filter to delete one Informe_tareas
     *   }
     * })
     * 
    **/
    delete<T extends informe_tareasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, informe_tareasDeleteArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Informe_tareas.
     * @param {informe_tareasUpdateArgs} args - Arguments to update one Informe_tareas.
     * @example
     * // Update one Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends informe_tareasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, informe_tareasUpdateArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Informe_tareas.
     * @param {informe_tareasDeleteManyArgs} args - Arguments to filter Informe_tareas to delete.
     * @example
     * // Delete a few Informe_tareas
     * const { count } = await prisma.informe_tareas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends informe_tareasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_tareasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Informe_tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends informe_tareasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, informe_tareasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Informe_tareas.
     * @param {informe_tareasUpsertArgs} args - Arguments to update or create a Informe_tareas.
     * @example
     * // Update or create a Informe_tareas
     * const informe_tareas = await prisma.informe_tareas.upsert({
     *   create: {
     *     // ... data to create a Informe_tareas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Informe_tareas we want to update
     *   }
     * })
    **/
    upsert<T extends informe_tareasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, informe_tareasUpsertArgs<ExtArgs>>
    ): Prisma__informe_tareasClient<$Types.GetResult<informe_tareasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Informe_tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasCountArgs} args - Arguments to filter Informe_tareas to count.
     * @example
     * // Count the number of Informe_tareas
     * const count = await prisma.informe_tareas.count({
     *   where: {
     *     // ... the filter for the Informe_tareas we want to count
     *   }
     * })
    **/
    count<T extends informe_tareasCountArgs>(
      args?: Subset<T, informe_tareasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Informe_tareasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Informe_tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Informe_tareasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Informe_tareasAggregateArgs>(args: Subset<T, Informe_tareasAggregateArgs>): Prisma.PrismaPromise<GetInforme_tareasAggregateType<T>>

    /**
     * Group by Informe_tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_tareasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends informe_tareasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: informe_tareasGroupByArgs['orderBy'] }
        : { orderBy?: informe_tareasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, informe_tareasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInforme_tareasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for informe_tareas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__informe_tareasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * informe_tareas base type for findUnique actions
   */
  export type informe_tareasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter, which informe_tareas to fetch.
     */
    where: informe_tareasWhereUniqueInput
  }

  /**
   * informe_tareas findUnique
   */
  export interface informe_tareasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends informe_tareasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * informe_tareas findUniqueOrThrow
   */
  export type informe_tareasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter, which informe_tareas to fetch.
     */
    where: informe_tareasWhereUniqueInput
  }


  /**
   * informe_tareas base type for findFirst actions
   */
  export type informe_tareasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter, which informe_tareas to fetch.
     */
    where?: informe_tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_tareas to fetch.
     */
    orderBy?: informe_tareasOrderByWithRelationInput | informe_tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for informe_tareas.
     */
    cursor?: informe_tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of informe_tareas.
     */
    distinct?: Informe_tareasScalarFieldEnum | Informe_tareasScalarFieldEnum[]
  }

  /**
   * informe_tareas findFirst
   */
  export interface informe_tareasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends informe_tareasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * informe_tareas findFirstOrThrow
   */
  export type informe_tareasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter, which informe_tareas to fetch.
     */
    where?: informe_tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_tareas to fetch.
     */
    orderBy?: informe_tareasOrderByWithRelationInput | informe_tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for informe_tareas.
     */
    cursor?: informe_tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of informe_tareas.
     */
    distinct?: Informe_tareasScalarFieldEnum | Informe_tareasScalarFieldEnum[]
  }


  /**
   * informe_tareas findMany
   */
  export type informe_tareasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter, which informe_tareas to fetch.
     */
    where?: informe_tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_tareas to fetch.
     */
    orderBy?: informe_tareasOrderByWithRelationInput | informe_tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing informe_tareas.
     */
    cursor?: informe_tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_tareas.
     */
    skip?: number
    distinct?: Informe_tareasScalarFieldEnum | Informe_tareasScalarFieldEnum[]
  }


  /**
   * informe_tareas create
   */
  export type informe_tareasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * The data needed to create a informe_tareas.
     */
    data?: XOR<informe_tareasCreateInput, informe_tareasUncheckedCreateInput>
  }


  /**
   * informe_tareas createMany
   */
  export type informe_tareasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many informe_tareas.
     */
    data: informe_tareasCreateManyInput | informe_tareasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * informe_tareas update
   */
  export type informe_tareasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * The data needed to update a informe_tareas.
     */
    data: XOR<informe_tareasUpdateInput, informe_tareasUncheckedUpdateInput>
    /**
     * Choose, which informe_tareas to update.
     */
    where: informe_tareasWhereUniqueInput
  }


  /**
   * informe_tareas updateMany
   */
  export type informe_tareasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update informe_tareas.
     */
    data: XOR<informe_tareasUpdateManyMutationInput, informe_tareasUncheckedUpdateManyInput>
    /**
     * Filter which informe_tareas to update
     */
    where?: informe_tareasWhereInput
  }


  /**
   * informe_tareas upsert
   */
  export type informe_tareasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * The filter to search for the informe_tareas to update in case it exists.
     */
    where: informe_tareasWhereUniqueInput
    /**
     * In case the informe_tareas found by the `where` argument doesn't exist, create a new informe_tareas with this data.
     */
    create: XOR<informe_tareasCreateInput, informe_tareasUncheckedCreateInput>
    /**
     * In case the informe_tareas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<informe_tareasUpdateInput, informe_tareasUncheckedUpdateInput>
  }


  /**
   * informe_tareas delete
   */
  export type informe_tareasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
    /**
     * Filter which informe_tareas to delete.
     */
    where: informe_tareasWhereUniqueInput
  }


  /**
   * informe_tareas deleteMany
   */
  export type informe_tareasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which informe_tareas to delete
     */
    where?: informe_tareasWhereInput
  }


  /**
   * informe_tareas without action
   */
  export type informe_tareasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_tareas
     */
    select?: informe_tareasSelect<ExtArgs> | null
  }



  /**
   * Model ingreso_caja
   */


  export type AggregateIngreso_caja = {
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  export type Ingreso_cajaAvgAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaSumAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMinAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMaxAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaCountAggregateOutputType = {
    idingreso: number
    idcaja: number
    concepto: number
    monto: number
    operador: number
    fecha: number
    tipofactura: number
    nfactura: number
    empresa: number
    detalle: number
    ptoventa: number
    _all: number
  }


  export type Ingreso_cajaAvgAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    ptoventa?: true
  }

  export type Ingreso_cajaSumAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMinAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMaxAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaCountAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
    _all?: true
  }

  export type Ingreso_cajaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ingreso_caja to aggregate.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ingreso_cajas
    **/
    _count?: true | Ingreso_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ingreso_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ingreso_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ingreso_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ingreso_cajaMaxAggregateInputType
  }

  export type GetIngreso_cajaAggregateType<T extends Ingreso_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateIngreso_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngreso_caja[P]>
      : GetScalarType<T[P], AggregateIngreso_caja[P]>
  }




  export type ingreso_cajaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ingreso_cajaWhereInput
    orderBy?: ingreso_cajaOrderByWithAggregationInput | ingreso_cajaOrderByWithAggregationInput[]
    by: Ingreso_cajaScalarFieldEnum[] | Ingreso_cajaScalarFieldEnum
    having?: ingreso_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ingreso_cajaCountAggregateInputType | true
    _avg?: Ingreso_cajaAvgAggregateInputType
    _sum?: Ingreso_cajaSumAggregateInputType
    _min?: Ingreso_cajaMinAggregateInputType
    _max?: Ingreso_cajaMaxAggregateInputType
  }


  export type Ingreso_cajaGroupByOutputType = {
    idingreso: number
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  type GetIngreso_cajaGroupByPayload<T extends ingreso_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ingreso_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ingreso_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
        }
      >
    >


  export type ingreso_cajaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idingreso?: boolean
    idcaja?: boolean
    concepto?: boolean
    monto?: boolean
    operador?: boolean
    fecha?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    empresa?: boolean
    detalle?: boolean
    ptoventa?: boolean
  }, ExtArgs["result"]["ingreso_caja"]>

  export type ingreso_cajaSelectScalar = {
    idingreso?: boolean
    idcaja?: boolean
    concepto?: boolean
    monto?: boolean
    operador?: boolean
    fecha?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    empresa?: boolean
    detalle?: boolean
    ptoventa?: boolean
  }


  type ingreso_cajaGetPayload<S extends boolean | null | undefined | ingreso_cajaArgs> = $Types.GetResult<ingreso_cajaPayload, S>

  type ingreso_cajaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ingreso_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Ingreso_cajaCountAggregateInputType | true
    }

  export interface ingreso_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ingreso_caja'], meta: { name: 'ingreso_caja' } }
    /**
     * Find zero or one Ingreso_caja that matches the filter.
     * @param {ingreso_cajaFindUniqueArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ingreso_cajaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ingreso_cajaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ingreso_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ingreso_cajaFindUniqueOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ingreso_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ingreso_cajaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ingreso_cajaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ingreso_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ingreso_cajaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ingreso_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany()
     * 
     * // Get first 10 Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany({ take: 10 })
     * 
     * // Only select the `idingreso`
     * const ingreso_cajaWithIdingresoOnly = await prisma.ingreso_caja.findMany({ select: { idingreso: true } })
     * 
    **/
    findMany<T extends ingreso_cajaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ingreso_caja.
     * @param {ingreso_cajaCreateArgs} args - Arguments to create a Ingreso_caja.
     * @example
     * // Create one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.create({
     *   data: {
     *     // ... data to create a Ingreso_caja
     *   }
     * })
     * 
    **/
    create<T extends ingreso_cajaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaCreateArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ingreso_cajas.
     *     @param {ingreso_cajaCreateManyArgs} args - Arguments to create many Ingreso_cajas.
     *     @example
     *     // Create many Ingreso_cajas
     *     const ingreso_caja = await prisma.ingreso_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ingreso_cajaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingreso_caja.
     * @param {ingreso_cajaDeleteArgs} args - Arguments to delete one Ingreso_caja.
     * @example
     * // Delete one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.delete({
     *   where: {
     *     // ... filter to delete one Ingreso_caja
     *   }
     * })
     * 
    **/
    delete<T extends ingreso_cajaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaDeleteArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ingreso_caja.
     * @param {ingreso_cajaUpdateArgs} args - Arguments to update one Ingreso_caja.
     * @example
     * // Update one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ingreso_cajaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpdateArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ingreso_cajas.
     * @param {ingreso_cajaDeleteManyArgs} args - Arguments to filter Ingreso_cajas to delete.
     * @example
     * // Delete a few Ingreso_cajas
     * const { count } = await prisma.ingreso_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ingreso_cajaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingreso_cajas
     * const ingreso_caja = await prisma.ingreso_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ingreso_cajaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingreso_caja.
     * @param {ingreso_cajaUpsertArgs} args - Arguments to update or create a Ingreso_caja.
     * @example
     * // Update or create a Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.upsert({
     *   create: {
     *     // ... data to create a Ingreso_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingreso_caja we want to update
     *   }
     * })
    **/
    upsert<T extends ingreso_cajaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpsertArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaCountArgs} args - Arguments to filter Ingreso_cajas to count.
     * @example
     * // Count the number of Ingreso_cajas
     * const count = await prisma.ingreso_caja.count({
     *   where: {
     *     // ... the filter for the Ingreso_cajas we want to count
     *   }
     * })
    **/
    count<T extends ingreso_cajaCountArgs>(
      args?: Subset<T, ingreso_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ingreso_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ingreso_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ingreso_cajaAggregateArgs>(args: Subset<T, Ingreso_cajaAggregateArgs>): Prisma.PrismaPromise<GetIngreso_cajaAggregateType<T>>

    /**
     * Group by Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ingreso_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ingreso_cajaGroupByArgs['orderBy'] }
        : { orderBy?: ingreso_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ingreso_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngreso_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ingreso_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ingreso_cajaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ingreso_caja base type for findUnique actions
   */
  export type ingreso_cajaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }

  /**
   * ingreso_caja findUnique
   */
  export interface ingreso_cajaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ingreso_cajaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findUniqueOrThrow
   */
  export type ingreso_cajaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja base type for findFirst actions
   */
  export type ingreso_cajaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }

  /**
   * ingreso_caja findFirst
   */
  export interface ingreso_cajaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ingreso_cajaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findFirstOrThrow
   */
  export type ingreso_cajaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }


  /**
   * ingreso_caja findMany
   */
  export type ingreso_cajaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_cajas to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }


  /**
   * ingreso_caja create
   */
  export type ingreso_cajaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The data needed to create a ingreso_caja.
     */
    data?: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
  }


  /**
   * ingreso_caja createMany
   */
  export type ingreso_cajaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ingreso_cajas.
     */
    data: ingreso_cajaCreateManyInput | ingreso_cajaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ingreso_caja update
   */
  export type ingreso_cajaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The data needed to update a ingreso_caja.
     */
    data: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
    /**
     * Choose, which ingreso_caja to update.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja updateMany
   */
  export type ingreso_cajaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ingreso_cajas.
     */
    data: XOR<ingreso_cajaUpdateManyMutationInput, ingreso_cajaUncheckedUpdateManyInput>
    /**
     * Filter which ingreso_cajas to update
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja upsert
   */
  export type ingreso_cajaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The filter to search for the ingreso_caja to update in case it exists.
     */
    where: ingreso_cajaWhereUniqueInput
    /**
     * In case the ingreso_caja found by the `where` argument doesn't exist, create a new ingreso_caja with this data.
     */
    create: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
    /**
     * In case the ingreso_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
  }


  /**
   * ingreso_caja delete
   */
  export type ingreso_cajaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter which ingreso_caja to delete.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja deleteMany
   */
  export type ingreso_cajaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ingreso_cajas to delete
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja without action
   */
  export type ingreso_cajaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_autos
   */


  export type AggregateLegajo_virtual_autos = {
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_autosAvgAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosSumAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosMinAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosMaxAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosCountAggregateOutputType = {
    idlegajo: number
    patente: number
    archivo: number
    fecha_subida: number
    _all: number
  }


  export type Legajo_virtual_autosAvgAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosSumAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosMinAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosMaxAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosCountAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
    _all?: true
  }

  export type Legajo_virtual_autosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_autos to aggregate.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_autos
    **/
    _count?: true | Legajo_virtual_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }

  export type GetLegajo_virtual_autosAggregateType<T extends Legajo_virtual_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
  }




  export type legajo_virtual_autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_autosWhereInput
    orderBy?: legajo_virtual_autosOrderByWithAggregationInput | legajo_virtual_autosOrderByWithAggregationInput[]
    by: Legajo_virtual_autosScalarFieldEnum[] | Legajo_virtual_autosScalarFieldEnum
    having?: legajo_virtual_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_autosCountAggregateInputType | true
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    _sum?: Legajo_virtual_autosSumAggregateInputType
    _min?: Legajo_virtual_autosMinAggregateInputType
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }


  export type Legajo_virtual_autosGroupByOutputType = {
    idlegajo: number
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_autosGroupByPayload<T extends legajo_virtual_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    patente?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }, ExtArgs["result"]["legajo_virtual_autos"]>

  export type legajo_virtual_autosSelectScalar = {
    idlegajo?: boolean
    patente?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }


  type legajo_virtual_autosGetPayload<S extends boolean | null | undefined | legajo_virtual_autosArgs> = $Types.GetResult<legajo_virtual_autosPayload, S>

  type legajo_virtual_autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_autosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_autosCountAggregateInputType | true
    }

  export interface legajo_virtual_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_autos'], meta: { name: 'legajo_virtual_autos' } }
    /**
     * Find zero or one Legajo_virtual_autos that matches the filter.
     * @param {legajo_virtual_autosFindUniqueArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_autosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
     * 
     * // Get first 10 Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_autosWithIdlegajoOnly = await prisma.legajo_virtual_autos.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_autos.
     * @param {legajo_virtual_autosCreateArgs} args - Arguments to create a Legajo_virtual_autos.
     * @example
     * // Create one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_autos.
     *     @param {legajo_virtual_autosCreateManyArgs} args - Arguments to create many Legajo_virtual_autos.
     *     @example
     *     // Create many Legajo_virtual_autos
     *     const legajo_virtual_autos = await prisma.legajo_virtual_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteArgs} args - Arguments to delete one Legajo_virtual_autos.
     * @example
     * // Delete one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpdateArgs} args - Arguments to update one Legajo_virtual_autos.
     * @example
     * // Update one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteManyArgs} args - Arguments to filter Legajo_virtual_autos to delete.
     * @example
     * // Delete a few Legajo_virtual_autos
     * const { count } = await prisma.legajo_virtual_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpsertArgs} args - Arguments to update or create a Legajo_virtual_autos.
     * @example
     * // Update or create a Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosCountArgs} args - Arguments to filter Legajo_virtual_autos to count.
     * @example
     * // Count the number of Legajo_virtual_autos
     * const count = await prisma.legajo_virtual_autos.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_autosCountArgs>(
      args?: Subset<T, legajo_virtual_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_autosAggregateArgs>(args: Subset<T, Legajo_virtual_autosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_autosAggregateType<T>>

    /**
     * Group by Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_autosGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_autos base type for findUnique actions
   */
  export type legajo_virtual_autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }

  /**
   * legajo_virtual_autos findUnique
   */
  export interface legajo_virtual_autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findUniqueOrThrow
   */
  export type legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos base type for findFirst actions
   */
  export type legajo_virtual_autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }

  /**
   * legajo_virtual_autos findFirst
   */
  export interface legajo_virtual_autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findFirstOrThrow
   */
  export type legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_autos findMany
   */
  export type legajo_virtual_autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_autos create
   */
  export type legajo_virtual_autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_autos.
     */
    data?: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_autos createMany
   */
  export type legajo_virtual_autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_autos.
     */
    data: legajo_virtual_autosCreateManyInput | legajo_virtual_autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_autos update
   */
  export type legajo_virtual_autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_autos to update.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos updateMany
   */
  export type legajo_virtual_autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateManyMutationInput, legajo_virtual_autosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_autos to update
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos upsert
   */
  export type legajo_virtual_autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_autos to update in case it exists.
     */
    where: legajo_virtual_autosWhereUniqueInput
    /**
     * In case the legajo_virtual_autos found by the `where` argument doesn't exist, create a new legajo_virtual_autos with this data.
     */
    create: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_autos delete
   */
  export type legajo_virtual_autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_autos to delete.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos deleteMany
   */
  export type legajo_virtual_autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_autos to delete
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos without action
   */
  export type legajo_virtual_autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_servicios
   */


  export type AggregateLegajo_virtual_servicios = {
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_serviciosAvgAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
  }

  export type Legajo_virtual_serviciosSumAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
  }

  export type Legajo_virtual_serviciosMinAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosMaxAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosCountAggregateOutputType = {
    idlegajo: number
    servicio: number
    archivo: number
    fecha_subida: number
    empresa: number
    _all: number
  }


  export type Legajo_virtual_serviciosAvgAggregateInputType = {
    idlegajo?: true
    servicio?: true
  }

  export type Legajo_virtual_serviciosSumAggregateInputType = {
    idlegajo?: true
    servicio?: true
  }

  export type Legajo_virtual_serviciosMinAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosMaxAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosCountAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    _all?: true
  }

  export type Legajo_virtual_serviciosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_servicios to aggregate.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_servicios
    **/
    _count?: true | Legajo_virtual_serviciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }

  export type GetLegajo_virtual_serviciosAggregateType<T extends Legajo_virtual_serviciosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_servicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
  }




  export type legajo_virtual_serviciosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_serviciosWhereInput
    orderBy?: legajo_virtual_serviciosOrderByWithAggregationInput | legajo_virtual_serviciosOrderByWithAggregationInput[]
    by: Legajo_virtual_serviciosScalarFieldEnum[] | Legajo_virtual_serviciosScalarFieldEnum
    having?: legajo_virtual_serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_serviciosCountAggregateInputType | true
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }


  export type Legajo_virtual_serviciosGroupByOutputType = {
    idlegajo: number
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_serviciosGroupByPayload<T extends legajo_virtual_serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_serviciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_serviciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_serviciosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    servicio?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }, ExtArgs["result"]["legajo_virtual_servicios"]>

  export type legajo_virtual_serviciosSelectScalar = {
    idlegajo?: boolean
    servicio?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }


  type legajo_virtual_serviciosGetPayload<S extends boolean | null | undefined | legajo_virtual_serviciosArgs> = $Types.GetResult<legajo_virtual_serviciosPayload, S>

  type legajo_virtual_serviciosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_serviciosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_serviciosCountAggregateInputType | true
    }

  export interface legajo_virtual_serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_servicios'], meta: { name: 'legajo_virtual_servicios' } }
    /**
     * Find zero or one Legajo_virtual_servicios that matches the filter.
     * @param {legajo_virtual_serviciosFindUniqueArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_serviciosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_serviciosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_serviciosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_serviciosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
     * 
     * // Get first 10 Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_serviciosWithIdlegajoOnly = await prisma.legajo_virtual_servicios.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_serviciosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosCreateArgs} args - Arguments to create a Legajo_virtual_servicios.
     * @example
     * // Create one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_serviciosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_servicios.
     *     @param {legajo_virtual_serviciosCreateManyArgs} args - Arguments to create many Legajo_virtual_servicios.
     *     @example
     *     // Create many Legajo_virtual_servicios
     *     const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_serviciosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteArgs} args - Arguments to delete one Legajo_virtual_servicios.
     * @example
     * // Delete one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_serviciosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpdateArgs} args - Arguments to update one Legajo_virtual_servicios.
     * @example
     * // Update one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_serviciosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteManyArgs} args - Arguments to filter Legajo_virtual_servicios to delete.
     * @example
     * // Delete a few Legajo_virtual_servicios
     * const { count } = await prisma.legajo_virtual_servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_serviciosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_serviciosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpsertArgs} args - Arguments to update or create a Legajo_virtual_servicios.
     * @example
     * // Update or create a Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_serviciosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosCountArgs} args - Arguments to filter Legajo_virtual_servicios to count.
     * @example
     * // Count the number of Legajo_virtual_servicios
     * const count = await prisma.legajo_virtual_servicios.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_serviciosCountArgs>(
      args?: Subset<T, legajo_virtual_serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_serviciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_serviciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_serviciosAggregateArgs>(args: Subset<T, Legajo_virtual_serviciosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_serviciosAggregateType<T>>

    /**
     * Group by Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_serviciosGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_serviciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_serviciosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_servicios base type for findUnique actions
   */
  export type legajo_virtual_serviciosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }

  /**
   * legajo_virtual_servicios findUnique
   */
  export interface legajo_virtual_serviciosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_serviciosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findUniqueOrThrow
   */
  export type legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios base type for findFirst actions
   */
  export type legajo_virtual_serviciosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }

  /**
   * legajo_virtual_servicios findFirst
   */
  export interface legajo_virtual_serviciosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_serviciosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findFirstOrThrow
   */
  export type legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_servicios findMany
   */
  export type legajo_virtual_serviciosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_servicios create
   */
  export type legajo_virtual_serviciosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_servicios.
     */
    data?: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_servicios createMany
   */
  export type legajo_virtual_serviciosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_servicios.
     */
    data: legajo_virtual_serviciosCreateManyInput | legajo_virtual_serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_servicios update
   */
  export type legajo_virtual_serviciosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_servicios to update.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios updateMany
   */
  export type legajo_virtual_serviciosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateManyMutationInput, legajo_virtual_serviciosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_servicios to update
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios upsert
   */
  export type legajo_virtual_serviciosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_servicios to update in case it exists.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
    /**
     * In case the legajo_virtual_servicios found by the `where` argument doesn't exist, create a new legajo_virtual_servicios with this data.
     */
    create: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_servicios delete
   */
  export type legajo_virtual_serviciosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_servicios to delete.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios deleteMany
   */
  export type legajo_virtual_serviciosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_servicios to delete
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios without action
   */
  export type legajo_virtual_serviciosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
  }



  /**
   * Model lic_conducir
   */


  export type AggregateLic_conducir = {
    _count: Lic_conducirCountAggregateOutputType | null
    _avg: Lic_conducirAvgAggregateOutputType | null
    _sum: Lic_conducirSumAggregateOutputType | null
    _min: Lic_conducirMinAggregateOutputType | null
    _max: Lic_conducirMaxAggregateOutputType | null
  }

  export type Lic_conducirAvgAggregateOutputType = {
    NRO_DOC: number | null
    id: number | null
  }

  export type Lic_conducirSumAggregateOutputType = {
    NRO_DOC: number | null
    id: number | null
  }

  export type Lic_conducirMinAggregateOutputType = {
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    FEC_NAC: Date | null
    NRO_CARNET: string | null
    FEC_VENCI: Date | null
    CLASE: string | null
    GRUPO: string | null
    FACTOR_RH: string | null
    id: number | null
  }

  export type Lic_conducirMaxAggregateOutputType = {
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    FEC_NAC: Date | null
    NRO_CARNET: string | null
    FEC_VENCI: Date | null
    CLASE: string | null
    GRUPO: string | null
    FACTOR_RH: string | null
    id: number | null
  }

  export type Lic_conducirCountAggregateOutputType = {
    NRO_DOC: number
    APELLIDOS: number
    NOMBRES: number
    FEC_NAC: number
    NRO_CARNET: number
    FEC_VENCI: number
    CLASE: number
    GRUPO: number
    FACTOR_RH: number
    id: number
    _all: number
  }


  export type Lic_conducirAvgAggregateInputType = {
    NRO_DOC?: true
    id?: true
  }

  export type Lic_conducirSumAggregateInputType = {
    NRO_DOC?: true
    id?: true
  }

  export type Lic_conducirMinAggregateInputType = {
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    FEC_NAC?: true
    NRO_CARNET?: true
    FEC_VENCI?: true
    CLASE?: true
    GRUPO?: true
    FACTOR_RH?: true
    id?: true
  }

  export type Lic_conducirMaxAggregateInputType = {
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    FEC_NAC?: true
    NRO_CARNET?: true
    FEC_VENCI?: true
    CLASE?: true
    GRUPO?: true
    FACTOR_RH?: true
    id?: true
  }

  export type Lic_conducirCountAggregateInputType = {
    NRO_DOC?: true
    APELLIDOS?: true
    NOMBRES?: true
    FEC_NAC?: true
    NRO_CARNET?: true
    FEC_VENCI?: true
    CLASE?: true
    GRUPO?: true
    FACTOR_RH?: true
    id?: true
    _all?: true
  }

  export type Lic_conducirAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which lic_conducir to aggregate.
     */
    where?: lic_conducirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lic_conducirs to fetch.
     */
    orderBy?: lic_conducirOrderByWithRelationInput | lic_conducirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lic_conducirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lic_conducirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lic_conducirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lic_conducirs
    **/
    _count?: true | Lic_conducirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lic_conducirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lic_conducirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lic_conducirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lic_conducirMaxAggregateInputType
  }

  export type GetLic_conducirAggregateType<T extends Lic_conducirAggregateArgs> = {
        [P in keyof T & keyof AggregateLic_conducir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLic_conducir[P]>
      : GetScalarType<T[P], AggregateLic_conducir[P]>
  }




  export type lic_conducirGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: lic_conducirWhereInput
    orderBy?: lic_conducirOrderByWithAggregationInput | lic_conducirOrderByWithAggregationInput[]
    by: Lic_conducirScalarFieldEnum[] | Lic_conducirScalarFieldEnum
    having?: lic_conducirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lic_conducirCountAggregateInputType | true
    _avg?: Lic_conducirAvgAggregateInputType
    _sum?: Lic_conducirSumAggregateInputType
    _min?: Lic_conducirMinAggregateInputType
    _max?: Lic_conducirMaxAggregateInputType
  }


  export type Lic_conducirGroupByOutputType = {
    NRO_DOC: number | null
    APELLIDOS: string | null
    NOMBRES: string | null
    FEC_NAC: Date | null
    NRO_CARNET: string | null
    FEC_VENCI: Date | null
    CLASE: string | null
    GRUPO: string | null
    FACTOR_RH: string | null
    id: number
    _count: Lic_conducirCountAggregateOutputType | null
    _avg: Lic_conducirAvgAggregateOutputType | null
    _sum: Lic_conducirSumAggregateOutputType | null
    _min: Lic_conducirMinAggregateOutputType | null
    _max: Lic_conducirMaxAggregateOutputType | null
  }

  type GetLic_conducirGroupByPayload<T extends lic_conducirGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lic_conducirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lic_conducirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lic_conducirGroupByOutputType[P]>
            : GetScalarType<T[P], Lic_conducirGroupByOutputType[P]>
        }
      >
    >


  export type lic_conducirSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NRO_DOC?: boolean
    APELLIDOS?: boolean
    NOMBRES?: boolean
    FEC_NAC?: boolean
    NRO_CARNET?: boolean
    FEC_VENCI?: boolean
    CLASE?: boolean
    GRUPO?: boolean
    FACTOR_RH?: boolean
    id?: boolean
  }, ExtArgs["result"]["lic_conducir"]>

  export type lic_conducirSelectScalar = {
    NRO_DOC?: boolean
    APELLIDOS?: boolean
    NOMBRES?: boolean
    FEC_NAC?: boolean
    NRO_CARNET?: boolean
    FEC_VENCI?: boolean
    CLASE?: boolean
    GRUPO?: boolean
    FACTOR_RH?: boolean
    id?: boolean
  }


  type lic_conducirGetPayload<S extends boolean | null | undefined | lic_conducirArgs> = $Types.GetResult<lic_conducirPayload, S>

  type lic_conducirCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<lic_conducirFindManyArgs, 'select' | 'include'> & {
      select?: Lic_conducirCountAggregateInputType | true
    }

  export interface lic_conducirDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lic_conducir'], meta: { name: 'lic_conducir' } }
    /**
     * Find zero or one Lic_conducir that matches the filter.
     * @param {lic_conducirFindUniqueArgs} args - Arguments to find a Lic_conducir
     * @example
     * // Get one Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lic_conducirFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lic_conducirFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lic_conducir'> extends True ? Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Lic_conducir that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lic_conducirFindUniqueOrThrowArgs} args - Arguments to find a Lic_conducir
     * @example
     * // Get one Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lic_conducirFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lic_conducirFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Lic_conducir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirFindFirstArgs} args - Arguments to find a Lic_conducir
     * @example
     * // Get one Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lic_conducirFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lic_conducirFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lic_conducir'> extends True ? Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Lic_conducir that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirFindFirstOrThrowArgs} args - Arguments to find a Lic_conducir
     * @example
     * // Get one Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lic_conducirFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lic_conducirFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Lic_conducirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lic_conducirs
     * const lic_conducirs = await prisma.lic_conducir.findMany()
     * 
     * // Get first 10 Lic_conducirs
     * const lic_conducirs = await prisma.lic_conducir.findMany({ take: 10 })
     * 
     * // Only select the `NRO_DOC`
     * const lic_conducirWithNRO_DOCOnly = await prisma.lic_conducir.findMany({ select: { NRO_DOC: true } })
     * 
    **/
    findMany<T extends lic_conducirFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lic_conducirFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Lic_conducir.
     * @param {lic_conducirCreateArgs} args - Arguments to create a Lic_conducir.
     * @example
     * // Create one Lic_conducir
     * const Lic_conducir = await prisma.lic_conducir.create({
     *   data: {
     *     // ... data to create a Lic_conducir
     *   }
     * })
     * 
    **/
    create<T extends lic_conducirCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lic_conducirCreateArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Lic_conducirs.
     *     @param {lic_conducirCreateManyArgs} args - Arguments to create many Lic_conducirs.
     *     @example
     *     // Create many Lic_conducirs
     *     const lic_conducir = await prisma.lic_conducir.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lic_conducirCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lic_conducirCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lic_conducir.
     * @param {lic_conducirDeleteArgs} args - Arguments to delete one Lic_conducir.
     * @example
     * // Delete one Lic_conducir
     * const Lic_conducir = await prisma.lic_conducir.delete({
     *   where: {
     *     // ... filter to delete one Lic_conducir
     *   }
     * })
     * 
    **/
    delete<T extends lic_conducirDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lic_conducirDeleteArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Lic_conducir.
     * @param {lic_conducirUpdateArgs} args - Arguments to update one Lic_conducir.
     * @example
     * // Update one Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lic_conducirUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lic_conducirUpdateArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Lic_conducirs.
     * @param {lic_conducirDeleteManyArgs} args - Arguments to filter Lic_conducirs to delete.
     * @example
     * // Delete a few Lic_conducirs
     * const { count } = await prisma.lic_conducir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lic_conducirDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lic_conducirDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lic_conducirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lic_conducirs
     * const lic_conducir = await prisma.lic_conducir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lic_conducirUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lic_conducirUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lic_conducir.
     * @param {lic_conducirUpsertArgs} args - Arguments to update or create a Lic_conducir.
     * @example
     * // Update or create a Lic_conducir
     * const lic_conducir = await prisma.lic_conducir.upsert({
     *   create: {
     *     // ... data to create a Lic_conducir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lic_conducir we want to update
     *   }
     * })
    **/
    upsert<T extends lic_conducirUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lic_conducirUpsertArgs<ExtArgs>>
    ): Prisma__lic_conducirClient<$Types.GetResult<lic_conducirPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Lic_conducirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirCountArgs} args - Arguments to filter Lic_conducirs to count.
     * @example
     * // Count the number of Lic_conducirs
     * const count = await prisma.lic_conducir.count({
     *   where: {
     *     // ... the filter for the Lic_conducirs we want to count
     *   }
     * })
    **/
    count<T extends lic_conducirCountArgs>(
      args?: Subset<T, lic_conducirCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lic_conducirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lic_conducir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lic_conducirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lic_conducirAggregateArgs>(args: Subset<T, Lic_conducirAggregateArgs>): Prisma.PrismaPromise<GetLic_conducirAggregateType<T>>

    /**
     * Group by Lic_conducir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lic_conducirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lic_conducirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lic_conducirGroupByArgs['orderBy'] }
        : { orderBy?: lic_conducirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lic_conducirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLic_conducirGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for lic_conducir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lic_conducirClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * lic_conducir base type for findUnique actions
   */
  export type lic_conducirFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter, which lic_conducir to fetch.
     */
    where: lic_conducirWhereUniqueInput
  }

  /**
   * lic_conducir findUnique
   */
  export interface lic_conducirFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends lic_conducirFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lic_conducir findUniqueOrThrow
   */
  export type lic_conducirFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter, which lic_conducir to fetch.
     */
    where: lic_conducirWhereUniqueInput
  }


  /**
   * lic_conducir base type for findFirst actions
   */
  export type lic_conducirFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter, which lic_conducir to fetch.
     */
    where?: lic_conducirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lic_conducirs to fetch.
     */
    orderBy?: lic_conducirOrderByWithRelationInput | lic_conducirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lic_conducirs.
     */
    cursor?: lic_conducirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lic_conducirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lic_conducirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lic_conducirs.
     */
    distinct?: Lic_conducirScalarFieldEnum | Lic_conducirScalarFieldEnum[]
  }

  /**
   * lic_conducir findFirst
   */
  export interface lic_conducirFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends lic_conducirFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lic_conducir findFirstOrThrow
   */
  export type lic_conducirFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter, which lic_conducir to fetch.
     */
    where?: lic_conducirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lic_conducirs to fetch.
     */
    orderBy?: lic_conducirOrderByWithRelationInput | lic_conducirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lic_conducirs.
     */
    cursor?: lic_conducirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lic_conducirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lic_conducirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lic_conducirs.
     */
    distinct?: Lic_conducirScalarFieldEnum | Lic_conducirScalarFieldEnum[]
  }


  /**
   * lic_conducir findMany
   */
  export type lic_conducirFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter, which lic_conducirs to fetch.
     */
    where?: lic_conducirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lic_conducirs to fetch.
     */
    orderBy?: lic_conducirOrderByWithRelationInput | lic_conducirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lic_conducirs.
     */
    cursor?: lic_conducirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lic_conducirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lic_conducirs.
     */
    skip?: number
    distinct?: Lic_conducirScalarFieldEnum | Lic_conducirScalarFieldEnum[]
  }


  /**
   * lic_conducir create
   */
  export type lic_conducirCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * The data needed to create a lic_conducir.
     */
    data?: XOR<lic_conducirCreateInput, lic_conducirUncheckedCreateInput>
  }


  /**
   * lic_conducir createMany
   */
  export type lic_conducirCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lic_conducirs.
     */
    data: lic_conducirCreateManyInput | lic_conducirCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lic_conducir update
   */
  export type lic_conducirUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * The data needed to update a lic_conducir.
     */
    data: XOR<lic_conducirUpdateInput, lic_conducirUncheckedUpdateInput>
    /**
     * Choose, which lic_conducir to update.
     */
    where: lic_conducirWhereUniqueInput
  }


  /**
   * lic_conducir updateMany
   */
  export type lic_conducirUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lic_conducirs.
     */
    data: XOR<lic_conducirUpdateManyMutationInput, lic_conducirUncheckedUpdateManyInput>
    /**
     * Filter which lic_conducirs to update
     */
    where?: lic_conducirWhereInput
  }


  /**
   * lic_conducir upsert
   */
  export type lic_conducirUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * The filter to search for the lic_conducir to update in case it exists.
     */
    where: lic_conducirWhereUniqueInput
    /**
     * In case the lic_conducir found by the `where` argument doesn't exist, create a new lic_conducir with this data.
     */
    create: XOR<lic_conducirCreateInput, lic_conducirUncheckedCreateInput>
    /**
     * In case the lic_conducir was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lic_conducirUpdateInput, lic_conducirUncheckedUpdateInput>
  }


  /**
   * lic_conducir delete
   */
  export type lic_conducirDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
    /**
     * Filter which lic_conducir to delete.
     */
    where: lic_conducirWhereUniqueInput
  }


  /**
   * lic_conducir deleteMany
   */
  export type lic_conducirDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which lic_conducirs to delete
     */
    where?: lic_conducirWhereInput
  }


  /**
   * lic_conducir without action
   */
  export type lic_conducirArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lic_conducir
     */
    select?: lic_conducirSelect<ExtArgs> | null
  }



  /**
   * Model novedades
   */


  export type AggregateNovedades = {
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  export type NovedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesMinAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesMaxAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesCountAggregateOutputType = {
    idnovedad: number
    novedad: number
    fecha: number
    operador: number
    _all: number
  }


  export type NovedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesMinAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesMaxAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesCountAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
    _all?: true
  }

  export type NovedadesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to aggregate.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned novedades
    **/
    _count?: true | NovedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovedadesMaxAggregateInputType
  }

  export type GetNovedadesAggregateType<T extends NovedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateNovedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovedades[P]>
      : GetScalarType<T[P], AggregateNovedades[P]>
  }




  export type novedadesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: novedadesWhereInput
    orderBy?: novedadesOrderByWithAggregationInput | novedadesOrderByWithAggregationInput[]
    by: NovedadesScalarFieldEnum[] | NovedadesScalarFieldEnum
    having?: novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovedadesCountAggregateInputType | true
    _avg?: NovedadesAvgAggregateInputType
    _sum?: NovedadesSumAggregateInputType
    _min?: NovedadesMinAggregateInputType
    _max?: NovedadesMaxAggregateInputType
  }


  export type NovedadesGroupByOutputType = {
    idnovedad: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  type GetNovedadesGroupByPayload<T extends novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
            : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
        }
      >
    >


  export type novedadesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovedad?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
  }, ExtArgs["result"]["novedades"]>

  export type novedadesSelectScalar = {
    idnovedad?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
  }


  type novedadesGetPayload<S extends boolean | null | undefined | novedadesArgs> = $Types.GetResult<novedadesPayload, S>

  type novedadesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<novedadesFindManyArgs, 'select' | 'include'> & {
      select?: NovedadesCountAggregateInputType | true
    }

  export interface novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['novedades'], meta: { name: 'novedades' } }
    /**
     * Find zero or one Novedades that matches the filter.
     * @param {novedadesFindUniqueArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends novedadesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, novedadesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {novedadesFindUniqueOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends novedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends novedadesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, novedadesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends novedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Novedades
     * const novedades = await prisma.novedades.findMany()
     * 
     * // Get first 10 Novedades
     * const novedades = await prisma.novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const novedadesWithIdnovedadOnly = await prisma.novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends novedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Novedades.
     * @param {novedadesCreateArgs} args - Arguments to create a Novedades.
     * @example
     * // Create one Novedades
     * const Novedades = await prisma.novedades.create({
     *   data: {
     *     // ... data to create a Novedades
     *   }
     * })
     * 
    **/
    create<T extends novedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesCreateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Novedades.
     *     @param {novedadesCreateManyArgs} args - Arguments to create many Novedades.
     *     @example
     *     // Create many Novedades
     *     const novedades = await prisma.novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends novedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Novedades.
     * @param {novedadesDeleteArgs} args - Arguments to delete one Novedades.
     * @example
     * // Delete one Novedades
     * const Novedades = await prisma.novedades.delete({
     *   where: {
     *     // ... filter to delete one Novedades
     *   }
     * })
     * 
    **/
    delete<T extends novedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesDeleteArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Novedades.
     * @param {novedadesUpdateArgs} args - Arguments to update one Novedades.
     * @example
     * // Update one Novedades
     * const novedades = await prisma.novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends novedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Novedades.
     * @param {novedadesDeleteManyArgs} args - Arguments to filter Novedades to delete.
     * @example
     * // Delete a few Novedades
     * const { count } = await prisma.novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends novedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Novedades
     * const novedades = await prisma.novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends novedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Novedades.
     * @param {novedadesUpsertArgs} args - Arguments to update or create a Novedades.
     * @example
     * // Update or create a Novedades
     * const novedades = await prisma.novedades.upsert({
     *   create: {
     *     // ... data to create a Novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Novedades we want to update
     *   }
     * })
    **/
    upsert<T extends novedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpsertArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesCountArgs} args - Arguments to filter Novedades to count.
     * @example
     * // Count the number of Novedades
     * const count = await prisma.novedades.count({
     *   where: {
     *     // ... the filter for the Novedades we want to count
     *   }
     * })
    **/
    count<T extends novedadesCountArgs>(
      args?: Subset<T, novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovedadesAggregateArgs>(args: Subset<T, NovedadesAggregateArgs>): Prisma.PrismaPromise<GetNovedadesAggregateType<T>>

    /**
     * Group by Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: novedadesGroupByArgs['orderBy'] }
        : { orderBy?: novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__novedadesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * novedades base type for findUnique actions
   */
  export type novedadesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }

  /**
   * novedades findUnique
   */
  export interface novedadesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findUniqueOrThrow
   */
  export type novedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades base type for findFirst actions
   */
  export type novedadesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }

  /**
   * novedades findFirst
   */
  export interface novedadesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findFirstOrThrow
   */
  export type novedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades findMany
   */
  export type novedadesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades create
   */
  export type novedadesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a novedades.
     */
    data?: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
  }


  /**
   * novedades createMany
   */
  export type novedadesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many novedades.
     */
    data: novedadesCreateManyInput | novedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * novedades update
   */
  export type novedadesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a novedades.
     */
    data: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
    /**
     * Choose, which novedades to update.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades updateMany
   */
  export type novedadesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update novedades.
     */
    data: XOR<novedadesUpdateManyMutationInput, novedadesUncheckedUpdateManyInput>
    /**
     * Filter which novedades to update
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades upsert
   */
  export type novedadesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the novedades to update in case it exists.
     */
    where: novedadesWhereUniqueInput
    /**
     * In case the novedades found by the `where` argument doesn't exist, create a new novedades with this data.
     */
    create: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
    /**
     * In case the novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
  }


  /**
   * novedades delete
   */
  export type novedadesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter which novedades to delete.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades deleteMany
   */
  export type novedadesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to delete
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades without action
   */
  export type novedadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
  }



  /**
   * Model operadorsep
   */


  export type AggregateOperadorsep = {
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  export type OperadorsepAvgAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepSumAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepMinAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepMaxAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepCountAggregateOutputType = {
    idoperador: number
    operador: number
    _all: number
  }


  export type OperadorsepAvgAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepSumAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepMinAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepMaxAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepCountAggregateInputType = {
    idoperador?: true
    operador?: true
    _all?: true
  }

  export type OperadorsepAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operadorsep to aggregate.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operadorseps
    **/
    _count?: true | OperadorsepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperadorsepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperadorsepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperadorsepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperadorsepMaxAggregateInputType
  }

  export type GetOperadorsepAggregateType<T extends OperadorsepAggregateArgs> = {
        [P in keyof T & keyof AggregateOperadorsep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperadorsep[P]>
      : GetScalarType<T[P], AggregateOperadorsep[P]>
  }




  export type operadorsepGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: operadorsepWhereInput
    orderBy?: operadorsepOrderByWithAggregationInput | operadorsepOrderByWithAggregationInput[]
    by: OperadorsepScalarFieldEnum[] | OperadorsepScalarFieldEnum
    having?: operadorsepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperadorsepCountAggregateInputType | true
    _avg?: OperadorsepAvgAggregateInputType
    _sum?: OperadorsepSumAggregateInputType
    _min?: OperadorsepMinAggregateInputType
    _max?: OperadorsepMaxAggregateInputType
  }


  export type OperadorsepGroupByOutputType = {
    idoperador: number
    operador: string | null
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  type GetOperadorsepGroupByPayload<T extends operadorsepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperadorsepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperadorsepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
            : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
        }
      >
    >


  export type operadorsepSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idoperador?: boolean
    operador?: boolean
  }, ExtArgs["result"]["operadorsep"]>

  export type operadorsepSelectScalar = {
    idoperador?: boolean
    operador?: boolean
  }


  type operadorsepGetPayload<S extends boolean | null | undefined | operadorsepArgs> = $Types.GetResult<operadorsepPayload, S>

  type operadorsepCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<operadorsepFindManyArgs, 'select' | 'include'> & {
      select?: OperadorsepCountAggregateInputType | true
    }

  export interface operadorsepDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operadorsep'], meta: { name: 'operadorsep' } }
    /**
     * Find zero or one Operadorsep that matches the filter.
     * @param {operadorsepFindUniqueArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operadorsepFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operadorsepFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operadorsep'> extends True ? Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Operadorsep that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operadorsepFindUniqueOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operadorsepFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Operadorsep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operadorsepFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operadorsepFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operadorsep'> extends True ? Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Operadorsep that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operadorsepFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Operadorseps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany()
     * 
     * // Get first 10 Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany({ take: 10 })
     * 
     * // Only select the `idoperador`
     * const operadorsepWithIdoperadorOnly = await prisma.operadorsep.findMany({ select: { idoperador: true } })
     * 
    **/
    findMany<T extends operadorsepFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Operadorsep.
     * @param {operadorsepCreateArgs} args - Arguments to create a Operadorsep.
     * @example
     * // Create one Operadorsep
     * const Operadorsep = await prisma.operadorsep.create({
     *   data: {
     *     // ... data to create a Operadorsep
     *   }
     * })
     * 
    **/
    create<T extends operadorsepCreateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepCreateArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Operadorseps.
     *     @param {operadorsepCreateManyArgs} args - Arguments to create many Operadorseps.
     *     @example
     *     // Create many Operadorseps
     *     const operadorsep = await prisma.operadorsep.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operadorsepCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operadorsep.
     * @param {operadorsepDeleteArgs} args - Arguments to delete one Operadorsep.
     * @example
     * // Delete one Operadorsep
     * const Operadorsep = await prisma.operadorsep.delete({
     *   where: {
     *     // ... filter to delete one Operadorsep
     *   }
     * })
     * 
    **/
    delete<T extends operadorsepDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepDeleteArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Operadorsep.
     * @param {operadorsepUpdateArgs} args - Arguments to update one Operadorsep.
     * @example
     * // Update one Operadorsep
     * const operadorsep = await prisma.operadorsep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operadorsepUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpdateArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Operadorseps.
     * @param {operadorsepDeleteManyArgs} args - Arguments to filter Operadorseps to delete.
     * @example
     * // Delete a few Operadorseps
     * const { count } = await prisma.operadorsep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operadorsepDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operadorseps
     * const operadorsep = await prisma.operadorsep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operadorsepUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operadorsep.
     * @param {operadorsepUpsertArgs} args - Arguments to update or create a Operadorsep.
     * @example
     * // Update or create a Operadorsep
     * const operadorsep = await prisma.operadorsep.upsert({
     *   create: {
     *     // ... data to create a Operadorsep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operadorsep we want to update
     *   }
     * })
    **/
    upsert<T extends operadorsepUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpsertArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepCountArgs} args - Arguments to filter Operadorseps to count.
     * @example
     * // Count the number of Operadorseps
     * const count = await prisma.operadorsep.count({
     *   where: {
     *     // ... the filter for the Operadorseps we want to count
     *   }
     * })
    **/
    count<T extends operadorsepCountArgs>(
      args?: Subset<T, operadorsepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperadorsepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperadorsepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperadorsepAggregateArgs>(args: Subset<T, OperadorsepAggregateArgs>): Prisma.PrismaPromise<GetOperadorsepAggregateType<T>>

    /**
     * Group by Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operadorsepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operadorsepGroupByArgs['orderBy'] }
        : { orderBy?: operadorsepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operadorsepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperadorsepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operadorsep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operadorsepClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operadorsep base type for findUnique actions
   */
  export type operadorsepFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }

  /**
   * operadorsep findUnique
   */
  export interface operadorsepFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorsepFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findUniqueOrThrow
   */
  export type operadorsepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep base type for findFirst actions
   */
  export type operadorsepFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }

  /**
   * operadorsep findFirst
   */
  export interface operadorsepFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorsepFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findFirstOrThrow
   */
  export type operadorsepFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }


  /**
   * operadorsep findMany
   */
  export type operadorsepFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorseps to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }


  /**
   * operadorsep create
   */
  export type operadorsepCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The data needed to create a operadorsep.
     */
    data?: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
  }


  /**
   * operadorsep createMany
   */
  export type operadorsepCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operadorseps.
     */
    data: operadorsepCreateManyInput | operadorsepCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * operadorsep update
   */
  export type operadorsepUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The data needed to update a operadorsep.
     */
    data: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
    /**
     * Choose, which operadorsep to update.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep updateMany
   */
  export type operadorsepUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operadorseps.
     */
    data: XOR<operadorsepUpdateManyMutationInput, operadorsepUncheckedUpdateManyInput>
    /**
     * Filter which operadorseps to update
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep upsert
   */
  export type operadorsepUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The filter to search for the operadorsep to update in case it exists.
     */
    where: operadorsepWhereUniqueInput
    /**
     * In case the operadorsep found by the `where` argument doesn't exist, create a new operadorsep with this data.
     */
    create: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
    /**
     * In case the operadorsep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
  }


  /**
   * operadorsep delete
   */
  export type operadorsepDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter which operadorsep to delete.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep deleteMany
   */
  export type operadorsepDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operadorseps to delete
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep without action
   */
  export type operadorsepArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
  }



  /**
   * Model parcelas
   */


  export type AggregateParcelas = {
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  export type ParcelasAvgAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasSumAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasMinAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasMaxAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasCountAggregateOutputType = {
    idparcela: number
    idservicio: number
    dni_extinto: number
    ficha: number
    parcela: number
    mza: number
    lote: number
    asignada: number
    fecha: number
    cementerio: number
    operador: number
    fecha_alta: number
    operador_asignacion: number
    fecha_asignacion: number
    lugares: number
    _all: number
  }


  export type ParcelasAvgAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasSumAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasMinAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasMaxAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasCountAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
    _all?: true
  }

  export type ParcelasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas to aggregate.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parcelas
    **/
    _count?: true | ParcelasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParcelasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParcelasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcelasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcelasMaxAggregateInputType
  }

  export type GetParcelasAggregateType<T extends ParcelasAggregateArgs> = {
        [P in keyof T & keyof AggregateParcelas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcelas[P]>
      : GetScalarType<T[P], AggregateParcelas[P]>
  }




  export type parcelasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: parcelasWhereInput
    orderBy?: parcelasOrderByWithAggregationInput | parcelasOrderByWithAggregationInput[]
    by: ParcelasScalarFieldEnum[] | ParcelasScalarFieldEnum
    having?: parcelasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcelasCountAggregateInputType | true
    _avg?: ParcelasAvgAggregateInputType
    _sum?: ParcelasSumAggregateInputType
    _min?: ParcelasMinAggregateInputType
    _max?: ParcelasMaxAggregateInputType
  }


  export type ParcelasGroupByOutputType = {
    idparcela: number
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  type GetParcelasGroupByPayload<T extends parcelasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParcelasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcelasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
        }
      >
    >


  export type parcelasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idparcela?: boolean
    idservicio?: boolean
    dni_extinto?: boolean
    ficha?: boolean
    parcela?: boolean
    mza?: boolean
    lote?: boolean
    asignada?: boolean
    fecha?: boolean
    cementerio?: boolean
    operador?: boolean
    fecha_alta?: boolean
    operador_asignacion?: boolean
    fecha_asignacion?: boolean
    lugares?: boolean
  }, ExtArgs["result"]["parcelas"]>

  export type parcelasSelectScalar = {
    idparcela?: boolean
    idservicio?: boolean
    dni_extinto?: boolean
    ficha?: boolean
    parcela?: boolean
    mza?: boolean
    lote?: boolean
    asignada?: boolean
    fecha?: boolean
    cementerio?: boolean
    operador?: boolean
    fecha_alta?: boolean
    operador_asignacion?: boolean
    fecha_asignacion?: boolean
    lugares?: boolean
  }


  type parcelasGetPayload<S extends boolean | null | undefined | parcelasArgs> = $Types.GetResult<parcelasPayload, S>

  type parcelasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<parcelasFindManyArgs, 'select' | 'include'> & {
      select?: ParcelasCountAggregateInputType | true
    }

  export interface parcelasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parcelas'], meta: { name: 'parcelas' } }
    /**
     * Find zero or one Parcelas that matches the filter.
     * @param {parcelasFindUniqueArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parcelasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parcelasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parcelas'> extends True ? Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parcelas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parcelasFindUniqueOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parcelasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parcelasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parcelasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parcelas'> extends True ? Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parcelas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parcelasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas
     * const parcelas = await prisma.parcelas.findMany()
     * 
     * // Get first 10 Parcelas
     * const parcelas = await prisma.parcelas.findMany({ take: 10 })
     * 
     * // Only select the `idparcela`
     * const parcelasWithIdparcelaOnly = await prisma.parcelas.findMany({ select: { idparcela: true } })
     * 
    **/
    findMany<T extends parcelasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parcelas.
     * @param {parcelasCreateArgs} args - Arguments to create a Parcelas.
     * @example
     * // Create one Parcelas
     * const Parcelas = await prisma.parcelas.create({
     *   data: {
     *     // ... data to create a Parcelas
     *   }
     * })
     * 
    **/
    create<T extends parcelasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasCreateArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parcelas.
     *     @param {parcelasCreateManyArgs} args - Arguments to create many Parcelas.
     *     @example
     *     // Create many Parcelas
     *     const parcelas = await prisma.parcelas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends parcelasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcelas.
     * @param {parcelasDeleteArgs} args - Arguments to delete one Parcelas.
     * @example
     * // Delete one Parcelas
     * const Parcelas = await prisma.parcelas.delete({
     *   where: {
     *     // ... filter to delete one Parcelas
     *   }
     * })
     * 
    **/
    delete<T extends parcelasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasDeleteArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parcelas.
     * @param {parcelasUpdateArgs} args - Arguments to update one Parcelas.
     * @example
     * // Update one Parcelas
     * const parcelas = await prisma.parcelas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parcelasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpdateArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parcelas.
     * @param {parcelasDeleteManyArgs} args - Arguments to filter Parcelas to delete.
     * @example
     * // Delete a few Parcelas
     * const { count } = await prisma.parcelas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parcelasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas
     * const parcelas = await prisma.parcelas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parcelasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcelas.
     * @param {parcelasUpsertArgs} args - Arguments to update or create a Parcelas.
     * @example
     * // Update or create a Parcelas
     * const parcelas = await prisma.parcelas.upsert({
     *   create: {
     *     // ... data to create a Parcelas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcelas we want to update
     *   }
     * })
    **/
    upsert<T extends parcelasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpsertArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasCountArgs} args - Arguments to filter Parcelas to count.
     * @example
     * // Count the number of Parcelas
     * const count = await prisma.parcelas.count({
     *   where: {
     *     // ... the filter for the Parcelas we want to count
     *   }
     * })
    **/
    count<T extends parcelasCountArgs>(
      args?: Subset<T, parcelasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcelasAggregateArgs>(args: Subset<T, ParcelasAggregateArgs>): Prisma.PrismaPromise<GetParcelasAggregateType<T>>

    /**
     * Group by Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parcelasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parcelasGroupByArgs['orderBy'] }
        : { orderBy?: parcelasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parcelasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parcelas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parcelasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parcelas base type for findUnique actions
   */
  export type parcelasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }

  /**
   * parcelas findUnique
   */
  export interface parcelasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findUniqueOrThrow
   */
  export type parcelasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas base type for findFirst actions
   */
  export type parcelasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }

  /**
   * parcelas findFirst
   */
  export interface parcelasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findFirstOrThrow
   */
  export type parcelasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }


  /**
   * parcelas findMany
   */
  export type parcelasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }


  /**
   * parcelas create
   */
  export type parcelasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The data needed to create a parcelas.
     */
    data?: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
  }


  /**
   * parcelas createMany
   */
  export type parcelasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parcelas.
     */
    data: parcelasCreateManyInput | parcelasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * parcelas update
   */
  export type parcelasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The data needed to update a parcelas.
     */
    data: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
    /**
     * Choose, which parcelas to update.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas updateMany
   */
  export type parcelasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parcelas.
     */
    data: XOR<parcelasUpdateManyMutationInput, parcelasUncheckedUpdateManyInput>
    /**
     * Filter which parcelas to update
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas upsert
   */
  export type parcelasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The filter to search for the parcelas to update in case it exists.
     */
    where: parcelasWhereUniqueInput
    /**
     * In case the parcelas found by the `where` argument doesn't exist, create a new parcelas with this data.
     */
    create: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
    /**
     * In case the parcelas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
  }


  /**
   * parcelas delete
   */
  export type parcelasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter which parcelas to delete.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas deleteMany
   */
  export type parcelasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas to delete
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas without action
   */
  export type parcelasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
  }



  /**
   * Model parcelas_lugares
   */


  export type AggregateParcelas_lugares = {
    _count: Parcelas_lugaresCountAggregateOutputType | null
    _avg: Parcelas_lugaresAvgAggregateOutputType | null
    _sum: Parcelas_lugaresSumAggregateOutputType | null
    _min: Parcelas_lugaresMinAggregateOutputType | null
    _max: Parcelas_lugaresMaxAggregateOutputType | null
  }

  export type Parcelas_lugaresAvgAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
  }

  export type Parcelas_lugaresSumAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
  }

  export type Parcelas_lugaresMinAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }

  export type Parcelas_lugaresMaxAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }

  export type Parcelas_lugaresCountAggregateOutputType = {
    idlugar: number
    idparcela: number
    idservicio: number
    lugar: number
    contrato: number
    dni: number
    fecha: number
    operador: number
    _all: number
  }


  export type Parcelas_lugaresAvgAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
  }

  export type Parcelas_lugaresSumAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
  }

  export type Parcelas_lugaresMinAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
  }

  export type Parcelas_lugaresMaxAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
  }

  export type Parcelas_lugaresCountAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
    _all?: true
  }

  export type Parcelas_lugaresAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas_lugares to aggregate.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parcelas_lugares
    **/
    _count?: true | Parcelas_lugaresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parcelas_lugaresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parcelas_lugaresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parcelas_lugaresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parcelas_lugaresMaxAggregateInputType
  }

  export type GetParcelas_lugaresAggregateType<T extends Parcelas_lugaresAggregateArgs> = {
        [P in keyof T & keyof AggregateParcelas_lugares]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcelas_lugares[P]>
      : GetScalarType<T[P], AggregateParcelas_lugares[P]>
  }




  export type parcelas_lugaresGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: parcelas_lugaresWhereInput
    orderBy?: parcelas_lugaresOrderByWithAggregationInput | parcelas_lugaresOrderByWithAggregationInput[]
    by: Parcelas_lugaresScalarFieldEnum[] | Parcelas_lugaresScalarFieldEnum
    having?: parcelas_lugaresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parcelas_lugaresCountAggregateInputType | true
    _avg?: Parcelas_lugaresAvgAggregateInputType
    _sum?: Parcelas_lugaresSumAggregateInputType
    _min?: Parcelas_lugaresMinAggregateInputType
    _max?: Parcelas_lugaresMaxAggregateInputType
  }


  export type Parcelas_lugaresGroupByOutputType = {
    idlugar: number
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
    _count: Parcelas_lugaresCountAggregateOutputType | null
    _avg: Parcelas_lugaresAvgAggregateOutputType | null
    _sum: Parcelas_lugaresSumAggregateOutputType | null
    _min: Parcelas_lugaresMinAggregateOutputType | null
    _max: Parcelas_lugaresMaxAggregateOutputType | null
  }

  type GetParcelas_lugaresGroupByPayload<T extends parcelas_lugaresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parcelas_lugaresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parcelas_lugaresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parcelas_lugaresGroupByOutputType[P]>
            : GetScalarType<T[P], Parcelas_lugaresGroupByOutputType[P]>
        }
      >
    >


  export type parcelas_lugaresSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlugar?: boolean
    idparcela?: boolean
    idservicio?: boolean
    lugar?: boolean
    contrato?: boolean
    dni?: boolean
    fecha?: boolean
    operador?: boolean
  }, ExtArgs["result"]["parcelas_lugares"]>

  export type parcelas_lugaresSelectScalar = {
    idlugar?: boolean
    idparcela?: boolean
    idservicio?: boolean
    lugar?: boolean
    contrato?: boolean
    dni?: boolean
    fecha?: boolean
    operador?: boolean
  }


  type parcelas_lugaresGetPayload<S extends boolean | null | undefined | parcelas_lugaresArgs> = $Types.GetResult<parcelas_lugaresPayload, S>

  type parcelas_lugaresCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<parcelas_lugaresFindManyArgs, 'select' | 'include'> & {
      select?: Parcelas_lugaresCountAggregateInputType | true
    }

  export interface parcelas_lugaresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parcelas_lugares'], meta: { name: 'parcelas_lugares' } }
    /**
     * Find zero or one Parcelas_lugares that matches the filter.
     * @param {parcelas_lugaresFindUniqueArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parcelas_lugaresFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parcelas_lugaresFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parcelas_lugares'> extends True ? Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parcelas_lugares that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parcelas_lugaresFindUniqueOrThrowArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parcelas_lugares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindFirstArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parcelas_lugaresFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parcelas_lugaresFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parcelas_lugares'> extends True ? Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parcelas_lugares that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindFirstOrThrowArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parcelas_lugares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findMany()
     * 
     * // Get first 10 Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findMany({ take: 10 })
     * 
     * // Only select the `idlugar`
     * const parcelas_lugaresWithIdlugarOnly = await prisma.parcelas_lugares.findMany({ select: { idlugar: true } })
     * 
    **/
    findMany<T extends parcelas_lugaresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parcelas_lugares.
     * @param {parcelas_lugaresCreateArgs} args - Arguments to create a Parcelas_lugares.
     * @example
     * // Create one Parcelas_lugares
     * const Parcelas_lugares = await prisma.parcelas_lugares.create({
     *   data: {
     *     // ... data to create a Parcelas_lugares
     *   }
     * })
     * 
    **/
    create<T extends parcelas_lugaresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresCreateArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parcelas_lugares.
     *     @param {parcelas_lugaresCreateManyArgs} args - Arguments to create many Parcelas_lugares.
     *     @example
     *     // Create many Parcelas_lugares
     *     const parcelas_lugares = await prisma.parcelas_lugares.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends parcelas_lugaresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcelas_lugares.
     * @param {parcelas_lugaresDeleteArgs} args - Arguments to delete one Parcelas_lugares.
     * @example
     * // Delete one Parcelas_lugares
     * const Parcelas_lugares = await prisma.parcelas_lugares.delete({
     *   where: {
     *     // ... filter to delete one Parcelas_lugares
     *   }
     * })
     * 
    **/
    delete<T extends parcelas_lugaresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresDeleteArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parcelas_lugares.
     * @param {parcelas_lugaresUpdateArgs} args - Arguments to update one Parcelas_lugares.
     * @example
     * // Update one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parcelas_lugaresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpdateArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parcelas_lugares.
     * @param {parcelas_lugaresDeleteManyArgs} args - Arguments to filter Parcelas_lugares to delete.
     * @example
     * // Delete a few Parcelas_lugares
     * const { count } = await prisma.parcelas_lugares.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parcelas_lugaresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parcelas_lugaresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcelas_lugares.
     * @param {parcelas_lugaresUpsertArgs} args - Arguments to update or create a Parcelas_lugares.
     * @example
     * // Update or create a Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.upsert({
     *   create: {
     *     // ... data to create a Parcelas_lugares
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcelas_lugares we want to update
     *   }
     * })
    **/
    upsert<T extends parcelas_lugaresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpsertArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresCountArgs} args - Arguments to filter Parcelas_lugares to count.
     * @example
     * // Count the number of Parcelas_lugares
     * const count = await prisma.parcelas_lugares.count({
     *   where: {
     *     // ... the filter for the Parcelas_lugares we want to count
     *   }
     * })
    **/
    count<T extends parcelas_lugaresCountArgs>(
      args?: Subset<T, parcelas_lugaresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parcelas_lugaresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parcelas_lugaresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parcelas_lugaresAggregateArgs>(args: Subset<T, Parcelas_lugaresAggregateArgs>): Prisma.PrismaPromise<GetParcelas_lugaresAggregateType<T>>

    /**
     * Group by Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parcelas_lugaresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parcelas_lugaresGroupByArgs['orderBy'] }
        : { orderBy?: parcelas_lugaresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parcelas_lugaresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelas_lugaresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parcelas_lugares.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parcelas_lugaresClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parcelas_lugares base type for findUnique actions
   */
  export type parcelas_lugaresFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where: parcelas_lugaresWhereUniqueInput
  }

  /**
   * parcelas_lugares findUnique
   */
  export interface parcelas_lugaresFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelas_lugaresFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas_lugares findUniqueOrThrow
   */
  export type parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares base type for findFirst actions
   */
  export type parcelas_lugaresFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas_lugares.
     */
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }

  /**
   * parcelas_lugares findFirst
   */
  export interface parcelas_lugaresFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelas_lugaresFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas_lugares findFirstOrThrow
   */
  export type parcelas_lugaresFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas_lugares.
     */
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }


  /**
   * parcelas_lugares findMany
   */
  export type parcelas_lugaresFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }


  /**
   * parcelas_lugares create
   */
  export type parcelas_lugaresCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The data needed to create a parcelas_lugares.
     */
    data?: XOR<parcelas_lugaresCreateInput, parcelas_lugaresUncheckedCreateInput>
  }


  /**
   * parcelas_lugares createMany
   */
  export type parcelas_lugaresCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parcelas_lugares.
     */
    data: parcelas_lugaresCreateManyInput | parcelas_lugaresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * parcelas_lugares update
   */
  export type parcelas_lugaresUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The data needed to update a parcelas_lugares.
     */
    data: XOR<parcelas_lugaresUpdateInput, parcelas_lugaresUncheckedUpdateInput>
    /**
     * Choose, which parcelas_lugares to update.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares updateMany
   */
  export type parcelas_lugaresUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parcelas_lugares.
     */
    data: XOR<parcelas_lugaresUpdateManyMutationInput, parcelas_lugaresUncheckedUpdateManyInput>
    /**
     * Filter which parcelas_lugares to update
     */
    where?: parcelas_lugaresWhereInput
  }


  /**
   * parcelas_lugares upsert
   */
  export type parcelas_lugaresUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The filter to search for the parcelas_lugares to update in case it exists.
     */
    where: parcelas_lugaresWhereUniqueInput
    /**
     * In case the parcelas_lugares found by the `where` argument doesn't exist, create a new parcelas_lugares with this data.
     */
    create: XOR<parcelas_lugaresCreateInput, parcelas_lugaresUncheckedCreateInput>
    /**
     * In case the parcelas_lugares was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelas_lugaresUpdateInput, parcelas_lugaresUncheckedUpdateInput>
  }


  /**
   * parcelas_lugares delete
   */
  export type parcelas_lugaresDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter which parcelas_lugares to delete.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares deleteMany
   */
  export type parcelas_lugaresDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas_lugares to delete
     */
    where?: parcelas_lugaresWhereInput
  }


  /**
   * parcelas_lugares without action
   */
  export type parcelas_lugaresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
  }



  /**
   * Model precio_servicio
   */


  export type AggregatePrecio_servicio = {
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  export type Precio_servicioAvgAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioSumAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioMinAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioMaxAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioCountAggregateOutputType = {
    idprecio: number
    codigo: number
    contado: number
    contado_cremacion: number
    descuento1: number
    descuento1_cremacion: number
    descuento2: number
    descuento2_cremacion: number
    fecha_vigencia: number
    _all: number
  }


  export type Precio_servicioAvgAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioSumAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioMinAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioMaxAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioCountAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
    _all?: true
  }

  export type Precio_servicioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which precio_servicio to aggregate.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned precio_servicios
    **/
    _count?: true | Precio_servicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Precio_servicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Precio_servicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Precio_servicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Precio_servicioMaxAggregateInputType
  }

  export type GetPrecio_servicioAggregateType<T extends Precio_servicioAggregateArgs> = {
        [P in keyof T & keyof AggregatePrecio_servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrecio_servicio[P]>
      : GetScalarType<T[P], AggregatePrecio_servicio[P]>
  }




  export type precio_servicioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: precio_servicioWhereInput
    orderBy?: precio_servicioOrderByWithAggregationInput | precio_servicioOrderByWithAggregationInput[]
    by: Precio_servicioScalarFieldEnum[] | Precio_servicioScalarFieldEnum
    having?: precio_servicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Precio_servicioCountAggregateInputType | true
    _avg?: Precio_servicioAvgAggregateInputType
    _sum?: Precio_servicioSumAggregateInputType
    _min?: Precio_servicioMinAggregateInputType
    _max?: Precio_servicioMaxAggregateInputType
  }


  export type Precio_servicioGroupByOutputType = {
    idprecio: number
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  type GetPrecio_servicioGroupByPayload<T extends precio_servicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Precio_servicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Precio_servicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
            : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
        }
      >
    >


  export type precio_servicioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprecio?: boolean
    codigo?: boolean
    contado?: boolean
    contado_cremacion?: boolean
    descuento1?: boolean
    descuento1_cremacion?: boolean
    descuento2?: boolean
    descuento2_cremacion?: boolean
    fecha_vigencia?: boolean
  }, ExtArgs["result"]["precio_servicio"]>

  export type precio_servicioSelectScalar = {
    idprecio?: boolean
    codigo?: boolean
    contado?: boolean
    contado_cremacion?: boolean
    descuento1?: boolean
    descuento1_cremacion?: boolean
    descuento2?: boolean
    descuento2_cremacion?: boolean
    fecha_vigencia?: boolean
  }


  type precio_servicioGetPayload<S extends boolean | null | undefined | precio_servicioArgs> = $Types.GetResult<precio_servicioPayload, S>

  type precio_servicioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<precio_servicioFindManyArgs, 'select' | 'include'> & {
      select?: Precio_servicioCountAggregateInputType | true
    }

  export interface precio_servicioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['precio_servicio'], meta: { name: 'precio_servicio' } }
    /**
     * Find zero or one Precio_servicio that matches the filter.
     * @param {precio_servicioFindUniqueArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends precio_servicioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, precio_servicioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Precio_servicio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {precio_servicioFindUniqueOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends precio_servicioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Precio_servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends precio_servicioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, precio_servicioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Precio_servicio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends precio_servicioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Precio_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany()
     * 
     * // Get first 10 Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const precio_servicioWithIdprecioOnly = await prisma.precio_servicio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends precio_servicioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Precio_servicio.
     * @param {precio_servicioCreateArgs} args - Arguments to create a Precio_servicio.
     * @example
     * // Create one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.create({
     *   data: {
     *     // ... data to create a Precio_servicio
     *   }
     * })
     * 
    **/
    create<T extends precio_servicioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioCreateArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Precio_servicios.
     *     @param {precio_servicioCreateManyArgs} args - Arguments to create many Precio_servicios.
     *     @example
     *     // Create many Precio_servicios
     *     const precio_servicio = await prisma.precio_servicio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends precio_servicioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Precio_servicio.
     * @param {precio_servicioDeleteArgs} args - Arguments to delete one Precio_servicio.
     * @example
     * // Delete one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.delete({
     *   where: {
     *     // ... filter to delete one Precio_servicio
     *   }
     * })
     * 
    **/
    delete<T extends precio_servicioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioDeleteArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Precio_servicio.
     * @param {precio_servicioUpdateArgs} args - Arguments to update one Precio_servicio.
     * @example
     * // Update one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends precio_servicioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpdateArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Precio_servicios.
     * @param {precio_servicioDeleteManyArgs} args - Arguments to filter Precio_servicios to delete.
     * @example
     * // Delete a few Precio_servicios
     * const { count } = await prisma.precio_servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends precio_servicioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Precio_servicios
     * const precio_servicio = await prisma.precio_servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends precio_servicioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Precio_servicio.
     * @param {precio_servicioUpsertArgs} args - Arguments to update or create a Precio_servicio.
     * @example
     * // Update or create a Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.upsert({
     *   create: {
     *     // ... data to create a Precio_servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Precio_servicio we want to update
     *   }
     * })
    **/
    upsert<T extends precio_servicioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpsertArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioCountArgs} args - Arguments to filter Precio_servicios to count.
     * @example
     * // Count the number of Precio_servicios
     * const count = await prisma.precio_servicio.count({
     *   where: {
     *     // ... the filter for the Precio_servicios we want to count
     *   }
     * })
    **/
    count<T extends precio_servicioCountArgs>(
      args?: Subset<T, precio_servicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Precio_servicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Precio_servicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Precio_servicioAggregateArgs>(args: Subset<T, Precio_servicioAggregateArgs>): Prisma.PrismaPromise<GetPrecio_servicioAggregateType<T>>

    /**
     * Group by Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends precio_servicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: precio_servicioGroupByArgs['orderBy'] }
        : { orderBy?: precio_servicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, precio_servicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrecio_servicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for precio_servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__precio_servicioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * precio_servicio base type for findUnique actions
   */
  export type precio_servicioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }

  /**
   * precio_servicio findUnique
   */
  export interface precio_servicioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends precio_servicioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findUniqueOrThrow
   */
  export type precio_servicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio base type for findFirst actions
   */
  export type precio_servicioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }

  /**
   * precio_servicio findFirst
   */
  export interface precio_servicioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends precio_servicioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findFirstOrThrow
   */
  export type precio_servicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }


  /**
   * precio_servicio findMany
   */
  export type precio_servicioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicios to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }


  /**
   * precio_servicio create
   */
  export type precio_servicioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The data needed to create a precio_servicio.
     */
    data?: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
  }


  /**
   * precio_servicio createMany
   */
  export type precio_servicioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many precio_servicios.
     */
    data: precio_servicioCreateManyInput | precio_servicioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * precio_servicio update
   */
  export type precio_servicioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The data needed to update a precio_servicio.
     */
    data: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
    /**
     * Choose, which precio_servicio to update.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio updateMany
   */
  export type precio_servicioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update precio_servicios.
     */
    data: XOR<precio_servicioUpdateManyMutationInput, precio_servicioUncheckedUpdateManyInput>
    /**
     * Filter which precio_servicios to update
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio upsert
   */
  export type precio_servicioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The filter to search for the precio_servicio to update in case it exists.
     */
    where: precio_servicioWhereUniqueInput
    /**
     * In case the precio_servicio found by the `where` argument doesn't exist, create a new precio_servicio with this data.
     */
    create: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
    /**
     * In case the precio_servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
  }


  /**
   * precio_servicio delete
   */
  export type precio_servicioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter which precio_servicio to delete.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio deleteMany
   */
  export type precio_servicioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which precio_servicios to delete
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio without action
   */
  export type precio_servicioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
  }



  /**
   * Model proveedores
   */


  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresCountAggregateOutputType = {
    idproveedor: number
    razon: number
    cuit: number
    domicilio: number
    telefonos: number
    estado: number
    operador: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresSumAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresMinAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresCountAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to aggregate.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type proveedoresGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: proveedoresWhereInput
    orderBy?: proveedoresOrderByWithAggregationInput | proveedoresOrderByWithAggregationInput[]
    by: ProveedoresScalarFieldEnum[] | ProveedoresScalarFieldEnum
    having?: proveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }


  export type ProveedoresGroupByOutputType = {
    idproveedor: number
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends proveedoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type proveedoresSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idproveedor?: boolean
    razon?: boolean
    cuit?: boolean
    domicilio?: boolean
    telefonos?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["proveedores"]>

  export type proveedoresSelectScalar = {
    idproveedor?: boolean
    razon?: boolean
    cuit?: boolean
    domicilio?: boolean
    telefonos?: boolean
    estado?: boolean
    operador?: boolean
  }


  type proveedoresGetPayload<S extends boolean | null | undefined | proveedoresArgs> = $Types.GetResult<proveedoresPayload, S>

  type proveedoresCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<proveedoresFindManyArgs, 'select' | 'include'> & {
      select?: ProveedoresCountAggregateInputType | true
    }

  export interface proveedoresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedores'], meta: { name: 'proveedores' } }
    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {proveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proveedoresFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, proveedoresFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'proveedores'> extends True ? Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Proveedores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {proveedoresFindUniqueOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends proveedoresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proveedoresFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, proveedoresFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'proveedores'> extends True ? Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends proveedoresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `idproveedor`
     * const proveedoresWithIdproveedorOnly = await prisma.proveedores.findMany({ select: { idproveedor: true } })
     * 
    **/
    findMany<T extends proveedoresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Proveedores.
     * @param {proveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
    **/
    create<T extends proveedoresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresCreateArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Proveedores.
     *     @param {proveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     *     @example
     *     // Create many Proveedores
     *     const proveedores = await prisma.proveedores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proveedoresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedores.
     * @param {proveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
    **/
    delete<T extends proveedoresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresDeleteArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Proveedores.
     * @param {proveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proveedoresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpdateArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Proveedores.
     * @param {proveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proveedoresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proveedoresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {proveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
    **/
    upsert<T extends proveedoresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpsertArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends proveedoresCountArgs>(
      args?: Subset<T, proveedoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): Prisma.PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedoresGroupByArgs['orderBy'] }
        : { orderBy?: proveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__proveedoresClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * proveedores base type for findUnique actions
   */
  export type proveedoresFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores findUnique
   */
  export interface proveedoresFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends proveedoresFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findUniqueOrThrow
   */
  export type proveedoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores base type for findFirst actions
   */
  export type proveedoresFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * proveedores findFirst
   */
  export interface proveedoresFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends proveedoresFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findFirstOrThrow
   */
  export type proveedoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }


  /**
   * proveedores findMany
   */
  export type proveedoresFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }


  /**
   * proveedores create
   */
  export type proveedoresCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The data needed to create a proveedores.
     */
    data?: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
  }


  /**
   * proveedores createMany
   */
  export type proveedoresCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedores.
     */
    data: proveedoresCreateManyInput | proveedoresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * proveedores update
   */
  export type proveedoresUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The data needed to update a proveedores.
     */
    data: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
    /**
     * Choose, which proveedores to update.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores updateMany
   */
  export type proveedoresUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedores.
     */
    data: XOR<proveedoresUpdateManyMutationInput, proveedoresUncheckedUpdateManyInput>
    /**
     * Filter which proveedores to update
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores upsert
   */
  export type proveedoresUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The filter to search for the proveedores to update in case it exists.
     */
    where: proveedoresWhereUniqueInput
    /**
     * In case the proveedores found by the `where` argument doesn't exist, create a new proveedores with this data.
     */
    create: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
    /**
     * In case the proveedores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
  }


  /**
   * proveedores delete
   */
  export type proveedoresDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter which proveedores to delete.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores deleteMany
   */
  export type proveedoresDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to delete
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores without action
   */
  export type proveedoresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
  }



  /**
   * Model rodados
   */


  export type AggregateRodados = {
    _count: RodadosCountAggregateOutputType | null
    _avg: RodadosAvgAggregateOutputType | null
    _sum: RodadosSumAggregateOutputType | null
    _min: RodadosMinAggregateOutputType | null
    _max: RodadosMaxAggregateOutputType | null
  }

  export type RodadosAvgAggregateOutputType = {
    id: number | null
  }

  export type RodadosSumAggregateOutputType = {
    id: number | null
  }

  export type RodadosMinAggregateOutputType = {
    patente: string | null
    descripcion: string | null
    km: string | null
    responsable: string | null
    n_poliza: string | null
    emp_poliza: string | null
    n_motor: string | null
    n_chasis: string | null
    ano_fabri: string | null
    desde: Date | null
    hasta: Date | null
    id: number | null
  }

  export type RodadosMaxAggregateOutputType = {
    patente: string | null
    descripcion: string | null
    km: string | null
    responsable: string | null
    n_poliza: string | null
    emp_poliza: string | null
    n_motor: string | null
    n_chasis: string | null
    ano_fabri: string | null
    desde: Date | null
    hasta: Date | null
    id: number | null
  }

  export type RodadosCountAggregateOutputType = {
    patente: number
    descripcion: number
    km: number
    responsable: number
    n_poliza: number
    emp_poliza: number
    n_motor: number
    n_chasis: number
    ano_fabri: number
    desde: number
    hasta: number
    id: number
    _all: number
  }


  export type RodadosAvgAggregateInputType = {
    id?: true
  }

  export type RodadosSumAggregateInputType = {
    id?: true
  }

  export type RodadosMinAggregateInputType = {
    patente?: true
    descripcion?: true
    km?: true
    responsable?: true
    n_poliza?: true
    emp_poliza?: true
    n_motor?: true
    n_chasis?: true
    ano_fabri?: true
    desde?: true
    hasta?: true
    id?: true
  }

  export type RodadosMaxAggregateInputType = {
    patente?: true
    descripcion?: true
    km?: true
    responsable?: true
    n_poliza?: true
    emp_poliza?: true
    n_motor?: true
    n_chasis?: true
    ano_fabri?: true
    desde?: true
    hasta?: true
    id?: true
  }

  export type RodadosCountAggregateInputType = {
    patente?: true
    descripcion?: true
    km?: true
    responsable?: true
    n_poliza?: true
    emp_poliza?: true
    n_motor?: true
    n_chasis?: true
    ano_fabri?: true
    desde?: true
    hasta?: true
    id?: true
    _all?: true
  }

  export type RodadosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rodados to aggregate.
     */
    where?: rodadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rodados to fetch.
     */
    orderBy?: rodadosOrderByWithRelationInput | rodadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rodadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rodados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rodados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rodados
    **/
    _count?: true | RodadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RodadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RodadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RodadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RodadosMaxAggregateInputType
  }

  export type GetRodadosAggregateType<T extends RodadosAggregateArgs> = {
        [P in keyof T & keyof AggregateRodados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRodados[P]>
      : GetScalarType<T[P], AggregateRodados[P]>
  }




  export type rodadosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: rodadosWhereInput
    orderBy?: rodadosOrderByWithAggregationInput | rodadosOrderByWithAggregationInput[]
    by: RodadosScalarFieldEnum[] | RodadosScalarFieldEnum
    having?: rodadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RodadosCountAggregateInputType | true
    _avg?: RodadosAvgAggregateInputType
    _sum?: RodadosSumAggregateInputType
    _min?: RodadosMinAggregateInputType
    _max?: RodadosMaxAggregateInputType
  }


  export type RodadosGroupByOutputType = {
    patente: string | null
    descripcion: string | null
    km: string | null
    responsable: string | null
    n_poliza: string | null
    emp_poliza: string | null
    n_motor: string | null
    n_chasis: string | null
    ano_fabri: string | null
    desde: Date | null
    hasta: Date | null
    id: number
    _count: RodadosCountAggregateOutputType | null
    _avg: RodadosAvgAggregateOutputType | null
    _sum: RodadosSumAggregateOutputType | null
    _min: RodadosMinAggregateOutputType | null
    _max: RodadosMaxAggregateOutputType | null
  }

  type GetRodadosGroupByPayload<T extends rodadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RodadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RodadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RodadosGroupByOutputType[P]>
            : GetScalarType<T[P], RodadosGroupByOutputType[P]>
        }
      >
    >


  export type rodadosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patente?: boolean
    descripcion?: boolean
    km?: boolean
    responsable?: boolean
    n_poliza?: boolean
    emp_poliza?: boolean
    n_motor?: boolean
    n_chasis?: boolean
    ano_fabri?: boolean
    desde?: boolean
    hasta?: boolean
    id?: boolean
  }, ExtArgs["result"]["rodados"]>

  export type rodadosSelectScalar = {
    patente?: boolean
    descripcion?: boolean
    km?: boolean
    responsable?: boolean
    n_poliza?: boolean
    emp_poliza?: boolean
    n_motor?: boolean
    n_chasis?: boolean
    ano_fabri?: boolean
    desde?: boolean
    hasta?: boolean
    id?: boolean
  }


  type rodadosGetPayload<S extends boolean | null | undefined | rodadosArgs> = $Types.GetResult<rodadosPayload, S>

  type rodadosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<rodadosFindManyArgs, 'select' | 'include'> & {
      select?: RodadosCountAggregateInputType | true
    }

  export interface rodadosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rodados'], meta: { name: 'rodados' } }
    /**
     * Find zero or one Rodados that matches the filter.
     * @param {rodadosFindUniqueArgs} args - Arguments to find a Rodados
     * @example
     * // Get one Rodados
     * const rodados = await prisma.rodados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rodadosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rodadosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'rodados'> extends True ? Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Rodados that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rodadosFindUniqueOrThrowArgs} args - Arguments to find a Rodados
     * @example
     * // Get one Rodados
     * const rodados = await prisma.rodados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rodadosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rodadosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Rodados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosFindFirstArgs} args - Arguments to find a Rodados
     * @example
     * // Get one Rodados
     * const rodados = await prisma.rodados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rodadosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rodadosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'rodados'> extends True ? Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Rodados that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosFindFirstOrThrowArgs} args - Arguments to find a Rodados
     * @example
     * // Get one Rodados
     * const rodados = await prisma.rodados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rodadosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rodadosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Rodados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rodados
     * const rodados = await prisma.rodados.findMany()
     * 
     * // Get first 10 Rodados
     * const rodados = await prisma.rodados.findMany({ take: 10 })
     * 
     * // Only select the `patente`
     * const rodadosWithPatenteOnly = await prisma.rodados.findMany({ select: { patente: true } })
     * 
    **/
    findMany<T extends rodadosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rodadosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Rodados.
     * @param {rodadosCreateArgs} args - Arguments to create a Rodados.
     * @example
     * // Create one Rodados
     * const Rodados = await prisma.rodados.create({
     *   data: {
     *     // ... data to create a Rodados
     *   }
     * })
     * 
    **/
    create<T extends rodadosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rodadosCreateArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Rodados.
     *     @param {rodadosCreateManyArgs} args - Arguments to create many Rodados.
     *     @example
     *     // Create many Rodados
     *     const rodados = await prisma.rodados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rodadosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rodadosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rodados.
     * @param {rodadosDeleteArgs} args - Arguments to delete one Rodados.
     * @example
     * // Delete one Rodados
     * const Rodados = await prisma.rodados.delete({
     *   where: {
     *     // ... filter to delete one Rodados
     *   }
     * })
     * 
    **/
    delete<T extends rodadosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rodadosDeleteArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Rodados.
     * @param {rodadosUpdateArgs} args - Arguments to update one Rodados.
     * @example
     * // Update one Rodados
     * const rodados = await prisma.rodados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rodadosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rodadosUpdateArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Rodados.
     * @param {rodadosDeleteManyArgs} args - Arguments to filter Rodados to delete.
     * @example
     * // Delete a few Rodados
     * const { count } = await prisma.rodados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rodadosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rodadosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rodados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rodados
     * const rodados = await prisma.rodados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rodadosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rodadosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rodados.
     * @param {rodadosUpsertArgs} args - Arguments to update or create a Rodados.
     * @example
     * // Update or create a Rodados
     * const rodados = await prisma.rodados.upsert({
     *   create: {
     *     // ... data to create a Rodados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rodados we want to update
     *   }
     * })
    **/
    upsert<T extends rodadosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rodadosUpsertArgs<ExtArgs>>
    ): Prisma__rodadosClient<$Types.GetResult<rodadosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Rodados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosCountArgs} args - Arguments to filter Rodados to count.
     * @example
     * // Count the number of Rodados
     * const count = await prisma.rodados.count({
     *   where: {
     *     // ... the filter for the Rodados we want to count
     *   }
     * })
    **/
    count<T extends rodadosCountArgs>(
      args?: Subset<T, rodadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RodadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rodados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RodadosAggregateArgs>(args: Subset<T, RodadosAggregateArgs>): Prisma.PrismaPromise<GetRodadosAggregateType<T>>

    /**
     * Group by Rodados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rodadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rodadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rodadosGroupByArgs['orderBy'] }
        : { orderBy?: rodadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rodadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRodadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for rodados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rodadosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * rodados base type for findUnique actions
   */
  export type rodadosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter, which rodados to fetch.
     */
    where: rodadosWhereUniqueInput
  }

  /**
   * rodados findUnique
   */
  export interface rodadosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rodadosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rodados findUniqueOrThrow
   */
  export type rodadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter, which rodados to fetch.
     */
    where: rodadosWhereUniqueInput
  }


  /**
   * rodados base type for findFirst actions
   */
  export type rodadosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter, which rodados to fetch.
     */
    where?: rodadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rodados to fetch.
     */
    orderBy?: rodadosOrderByWithRelationInput | rodadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rodados.
     */
    cursor?: rodadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rodados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rodados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rodados.
     */
    distinct?: RodadosScalarFieldEnum | RodadosScalarFieldEnum[]
  }

  /**
   * rodados findFirst
   */
  export interface rodadosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends rodadosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * rodados findFirstOrThrow
   */
  export type rodadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter, which rodados to fetch.
     */
    where?: rodadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rodados to fetch.
     */
    orderBy?: rodadosOrderByWithRelationInput | rodadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rodados.
     */
    cursor?: rodadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rodados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rodados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rodados.
     */
    distinct?: RodadosScalarFieldEnum | RodadosScalarFieldEnum[]
  }


  /**
   * rodados findMany
   */
  export type rodadosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter, which rodados to fetch.
     */
    where?: rodadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rodados to fetch.
     */
    orderBy?: rodadosOrderByWithRelationInput | rodadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rodados.
     */
    cursor?: rodadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rodados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rodados.
     */
    skip?: number
    distinct?: RodadosScalarFieldEnum | RodadosScalarFieldEnum[]
  }


  /**
   * rodados create
   */
  export type rodadosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * The data needed to create a rodados.
     */
    data?: XOR<rodadosCreateInput, rodadosUncheckedCreateInput>
  }


  /**
   * rodados createMany
   */
  export type rodadosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rodados.
     */
    data: rodadosCreateManyInput | rodadosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rodados update
   */
  export type rodadosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * The data needed to update a rodados.
     */
    data: XOR<rodadosUpdateInput, rodadosUncheckedUpdateInput>
    /**
     * Choose, which rodados to update.
     */
    where: rodadosWhereUniqueInput
  }


  /**
   * rodados updateMany
   */
  export type rodadosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rodados.
     */
    data: XOR<rodadosUpdateManyMutationInput, rodadosUncheckedUpdateManyInput>
    /**
     * Filter which rodados to update
     */
    where?: rodadosWhereInput
  }


  /**
   * rodados upsert
   */
  export type rodadosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * The filter to search for the rodados to update in case it exists.
     */
    where: rodadosWhereUniqueInput
    /**
     * In case the rodados found by the `where` argument doesn't exist, create a new rodados with this data.
     */
    create: XOR<rodadosCreateInput, rodadosUncheckedCreateInput>
    /**
     * In case the rodados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rodadosUpdateInput, rodadosUncheckedUpdateInput>
  }


  /**
   * rodados delete
   */
  export type rodadosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
    /**
     * Filter which rodados to delete.
     */
    where: rodadosWhereUniqueInput
  }


  /**
   * rodados deleteMany
   */
  export type rodadosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which rodados to delete
     */
    where?: rodadosWhereInput
  }


  /**
   * rodados without action
   */
  export type rodadosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rodados
     */
    select?: rodadosSelect<ExtArgs> | null
  }



  /**
   * Model servicio_informes
   */


  export type AggregateServicio_informes = {
    _count: Servicio_informesCountAggregateOutputType | null
    _avg: Servicio_informesAvgAggregateOutputType | null
    _sum: Servicio_informesSumAggregateOutputType | null
    _min: Servicio_informesMinAggregateOutputType | null
    _max: Servicio_informesMaxAggregateOutputType | null
  }

  export type Servicio_informesAvgAggregateOutputType = {
    idinforme: number | null
    idservicio: number | null
  }

  export type Servicio_informesSumAggregateOutputType = {
    idinforme: number | null
    idservicio: number | null
  }

  export type Servicio_informesMinAggregateOutputType = {
    idinforme: number | null
    idservicio: number | null
    fecha: Date | null
    aprobado: boolean | null
    fecha_aprobado: Date | null
    operador_aprobado: string | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operador_liquidado: string | null
  }

  export type Servicio_informesMaxAggregateOutputType = {
    idinforme: number | null
    idservicio: number | null
    fecha: Date | null
    aprobado: boolean | null
    fecha_aprobado: Date | null
    operador_aprobado: string | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operador_liquidado: string | null
  }

  export type Servicio_informesCountAggregateOutputType = {
    idinforme: number
    idservicio: number
    fecha: number
    aprobado: number
    fecha_aprobado: number
    operador_aprobado: number
    liquidado: number
    fecha_liquidado: number
    operador_liquidado: number
    _all: number
  }


  export type Servicio_informesAvgAggregateInputType = {
    idinforme?: true
    idservicio?: true
  }

  export type Servicio_informesSumAggregateInputType = {
    idinforme?: true
    idservicio?: true
  }

  export type Servicio_informesMinAggregateInputType = {
    idinforme?: true
    idservicio?: true
    fecha?: true
    aprobado?: true
    fecha_aprobado?: true
    operador_aprobado?: true
    liquidado?: true
    fecha_liquidado?: true
    operador_liquidado?: true
  }

  export type Servicio_informesMaxAggregateInputType = {
    idinforme?: true
    idservicio?: true
    fecha?: true
    aprobado?: true
    fecha_aprobado?: true
    operador_aprobado?: true
    liquidado?: true
    fecha_liquidado?: true
    operador_liquidado?: true
  }

  export type Servicio_informesCountAggregateInputType = {
    idinforme?: true
    idservicio?: true
    fecha?: true
    aprobado?: true
    fecha_aprobado?: true
    operador_aprobado?: true
    liquidado?: true
    fecha_liquidado?: true
    operador_liquidado?: true
    _all?: true
  }

  export type Servicio_informesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_informes to aggregate.
     */
    where?: servicio_informesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_informes to fetch.
     */
    orderBy?: servicio_informesOrderByWithRelationInput | servicio_informesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_informesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_informes
    **/
    _count?: true | Servicio_informesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_informesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_informesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_informesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_informesMaxAggregateInputType
  }

  export type GetServicio_informesAggregateType<T extends Servicio_informesAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_informes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_informes[P]>
      : GetScalarType<T[P], AggregateServicio_informes[P]>
  }




  export type servicio_informesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_informesWhereInput
    orderBy?: servicio_informesOrderByWithAggregationInput | servicio_informesOrderByWithAggregationInput[]
    by: Servicio_informesScalarFieldEnum[] | Servicio_informesScalarFieldEnum
    having?: servicio_informesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_informesCountAggregateInputType | true
    _avg?: Servicio_informesAvgAggregateInputType
    _sum?: Servicio_informesSumAggregateInputType
    _min?: Servicio_informesMinAggregateInputType
    _max?: Servicio_informesMaxAggregateInputType
  }


  export type Servicio_informesGroupByOutputType = {
    idinforme: number
    idservicio: number | null
    fecha: Date | null
    aprobado: boolean | null
    fecha_aprobado: Date | null
    operador_aprobado: string | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operador_liquidado: string | null
    _count: Servicio_informesCountAggregateOutputType | null
    _avg: Servicio_informesAvgAggregateOutputType | null
    _sum: Servicio_informesSumAggregateOutputType | null
    _min: Servicio_informesMinAggregateOutputType | null
    _max: Servicio_informesMaxAggregateOutputType | null
  }

  type GetServicio_informesGroupByPayload<T extends servicio_informesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_informesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_informesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_informesGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_informesGroupByOutputType[P]>
        }
      >
    >


  export type servicio_informesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idinforme?: boolean
    idservicio?: boolean
    fecha?: boolean
    aprobado?: boolean
    fecha_aprobado?: boolean
    operador_aprobado?: boolean
    liquidado?: boolean
    fecha_liquidado?: boolean
    operador_liquidado?: boolean
  }, ExtArgs["result"]["servicio_informes"]>

  export type servicio_informesSelectScalar = {
    idinforme?: boolean
    idservicio?: boolean
    fecha?: boolean
    aprobado?: boolean
    fecha_aprobado?: boolean
    operador_aprobado?: boolean
    liquidado?: boolean
    fecha_liquidado?: boolean
    operador_liquidado?: boolean
  }


  type servicio_informesGetPayload<S extends boolean | null | undefined | servicio_informesArgs> = $Types.GetResult<servicio_informesPayload, S>

  type servicio_informesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_informesFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_informesCountAggregateInputType | true
    }

  export interface servicio_informesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_informes'], meta: { name: 'servicio_informes' } }
    /**
     * Find zero or one Servicio_informes that matches the filter.
     * @param {servicio_informesFindUniqueArgs} args - Arguments to find a Servicio_informes
     * @example
     * // Get one Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_informesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_informesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_informes'> extends True ? Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_informes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_informesFindUniqueOrThrowArgs} args - Arguments to find a Servicio_informes
     * @example
     * // Get one Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_informesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_informesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_informes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesFindFirstArgs} args - Arguments to find a Servicio_informes
     * @example
     * // Get one Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_informesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_informesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_informes'> extends True ? Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_informes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesFindFirstOrThrowArgs} args - Arguments to find a Servicio_informes
     * @example
     * // Get one Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_informesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_informesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_informes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findMany()
     * 
     * // Get first 10 Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.findMany({ take: 10 })
     * 
     * // Only select the `idinforme`
     * const servicio_informesWithIdinformeOnly = await prisma.servicio_informes.findMany({ select: { idinforme: true } })
     * 
    **/
    findMany<T extends servicio_informesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_informesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_informes.
     * @param {servicio_informesCreateArgs} args - Arguments to create a Servicio_informes.
     * @example
     * // Create one Servicio_informes
     * const Servicio_informes = await prisma.servicio_informes.create({
     *   data: {
     *     // ... data to create a Servicio_informes
     *   }
     * })
     * 
    **/
    create<T extends servicio_informesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_informesCreateArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_informes.
     *     @param {servicio_informesCreateManyArgs} args - Arguments to create many Servicio_informes.
     *     @example
     *     // Create many Servicio_informes
     *     const servicio_informes = await prisma.servicio_informes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_informesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_informesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_informes.
     * @param {servicio_informesDeleteArgs} args - Arguments to delete one Servicio_informes.
     * @example
     * // Delete one Servicio_informes
     * const Servicio_informes = await prisma.servicio_informes.delete({
     *   where: {
     *     // ... filter to delete one Servicio_informes
     *   }
     * })
     * 
    **/
    delete<T extends servicio_informesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_informesDeleteArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_informes.
     * @param {servicio_informesUpdateArgs} args - Arguments to update one Servicio_informes.
     * @example
     * // Update one Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_informesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_informesUpdateArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_informes.
     * @param {servicio_informesDeleteManyArgs} args - Arguments to filter Servicio_informes to delete.
     * @example
     * // Delete a few Servicio_informes
     * const { count } = await prisma.servicio_informes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_informesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_informesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_informesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_informesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_informes.
     * @param {servicio_informesUpsertArgs} args - Arguments to update or create a Servicio_informes.
     * @example
     * // Update or create a Servicio_informes
     * const servicio_informes = await prisma.servicio_informes.upsert({
     *   create: {
     *     // ... data to create a Servicio_informes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_informes we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_informesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_informesUpsertArgs<ExtArgs>>
    ): Prisma__servicio_informesClient<$Types.GetResult<servicio_informesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesCountArgs} args - Arguments to filter Servicio_informes to count.
     * @example
     * // Count the number of Servicio_informes
     * const count = await prisma.servicio_informes.count({
     *   where: {
     *     // ... the filter for the Servicio_informes we want to count
     *   }
     * })
    **/
    count<T extends servicio_informesCountArgs>(
      args?: Subset<T, servicio_informesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_informesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_informesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_informesAggregateArgs>(args: Subset<T, Servicio_informesAggregateArgs>): Prisma.PrismaPromise<GetServicio_informesAggregateType<T>>

    /**
     * Group by Servicio_informes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_informesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_informesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_informesGroupByArgs['orderBy'] }
        : { orderBy?: servicio_informesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_informesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_informesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_informes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_informesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_informes base type for findUnique actions
   */
  export type servicio_informesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_informes to fetch.
     */
    where: servicio_informesWhereUniqueInput
  }

  /**
   * servicio_informes findUnique
   */
  export interface servicio_informesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_informesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_informes findUniqueOrThrow
   */
  export type servicio_informesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_informes to fetch.
     */
    where: servicio_informesWhereUniqueInput
  }


  /**
   * servicio_informes base type for findFirst actions
   */
  export type servicio_informesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_informes to fetch.
     */
    where?: servicio_informesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_informes to fetch.
     */
    orderBy?: servicio_informesOrderByWithRelationInput | servicio_informesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_informes.
     */
    cursor?: servicio_informesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_informes.
     */
    distinct?: Servicio_informesScalarFieldEnum | Servicio_informesScalarFieldEnum[]
  }

  /**
   * servicio_informes findFirst
   */
  export interface servicio_informesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_informesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_informes findFirstOrThrow
   */
  export type servicio_informesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_informes to fetch.
     */
    where?: servicio_informesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_informes to fetch.
     */
    orderBy?: servicio_informesOrderByWithRelationInput | servicio_informesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_informes.
     */
    cursor?: servicio_informesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_informes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_informes.
     */
    distinct?: Servicio_informesScalarFieldEnum | Servicio_informesScalarFieldEnum[]
  }


  /**
   * servicio_informes findMany
   */
  export type servicio_informesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_informes to fetch.
     */
    where?: servicio_informesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_informes to fetch.
     */
    orderBy?: servicio_informesOrderByWithRelationInput | servicio_informesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_informes.
     */
    cursor?: servicio_informesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_informes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_informes.
     */
    skip?: number
    distinct?: Servicio_informesScalarFieldEnum | Servicio_informesScalarFieldEnum[]
  }


  /**
   * servicio_informes create
   */
  export type servicio_informesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_informes.
     */
    data?: XOR<servicio_informesCreateInput, servicio_informesUncheckedCreateInput>
  }


  /**
   * servicio_informes createMany
   */
  export type servicio_informesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_informes.
     */
    data: servicio_informesCreateManyInput | servicio_informesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_informes update
   */
  export type servicio_informesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_informes.
     */
    data: XOR<servicio_informesUpdateInput, servicio_informesUncheckedUpdateInput>
    /**
     * Choose, which servicio_informes to update.
     */
    where: servicio_informesWhereUniqueInput
  }


  /**
   * servicio_informes updateMany
   */
  export type servicio_informesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_informes.
     */
    data: XOR<servicio_informesUpdateManyMutationInput, servicio_informesUncheckedUpdateManyInput>
    /**
     * Filter which servicio_informes to update
     */
    where?: servicio_informesWhereInput
  }


  /**
   * servicio_informes upsert
   */
  export type servicio_informesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_informes to update in case it exists.
     */
    where: servicio_informesWhereUniqueInput
    /**
     * In case the servicio_informes found by the `where` argument doesn't exist, create a new servicio_informes with this data.
     */
    create: XOR<servicio_informesCreateInput, servicio_informesUncheckedCreateInput>
    /**
     * In case the servicio_informes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_informesUpdateInput, servicio_informesUncheckedUpdateInput>
  }


  /**
   * servicio_informes delete
   */
  export type servicio_informesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
    /**
     * Filter which servicio_informes to delete.
     */
    where: servicio_informesWhereUniqueInput
  }


  /**
   * servicio_informes deleteMany
   */
  export type servicio_informesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_informes to delete
     */
    where?: servicio_informesWhereInput
  }


  /**
   * servicio_informes without action
   */
  export type servicio_informesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_informes
     */
    select?: servicio_informesSelect<ExtArgs> | null
  }



  /**
   * Model servicio_venta
   */


  export type AggregateServicio_venta = {
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  export type Servicio_ventaAvgAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaSumAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaMinAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaMaxAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaCountAggregateOutputType = {
    idventa: number
    idservicio: number
    monto: number
    operador: number
    fecha_venta: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    parentesco: number
    operador_venta: number
    liquidado: number
    operadorliq: number
    fecha_liquidacion: number
    aprobado: number
    operadorap: number
    fecha_aprobacion: number
    comision: number
    fecha_carga: number
    valor_cuota: number
    plan_cuota: number
    monto_financiacion: number
    financiacion: number
    efectivo: number
    _all: number
  }


  export type Servicio_ventaAvgAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaSumAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMinAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMaxAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaCountAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
    _all?: true
  }

  export type Servicio_ventaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_venta to aggregate.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_ventas
    **/
    _count?: true | Servicio_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_ventaMaxAggregateInputType
  }

  export type GetServicio_ventaAggregateType<T extends Servicio_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_venta[P]>
      : GetScalarType<T[P], AggregateServicio_venta[P]>
  }




  export type servicio_ventaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_ventaWhereInput
    orderBy?: servicio_ventaOrderByWithAggregationInput | servicio_ventaOrderByWithAggregationInput[]
    by: Servicio_ventaScalarFieldEnum[] | Servicio_ventaScalarFieldEnum
    having?: servicio_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_ventaCountAggregateInputType | true
    _avg?: Servicio_ventaAvgAggregateInputType
    _sum?: Servicio_ventaSumAggregateInputType
    _min?: Servicio_ventaMinAggregateInputType
    _max?: Servicio_ventaMaxAggregateInputType
  }


  export type Servicio_ventaGroupByOutputType = {
    idventa: number
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  type GetServicio_ventaGroupByPayload<T extends servicio_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
        }
      >
    >


  export type servicio_ventaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idventa?: boolean
    idservicio?: boolean
    monto?: boolean
    operador?: boolean
    fecha_venta?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    parentesco?: boolean
    operador_venta?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
    comision?: boolean
    fecha_carga?: boolean
    valor_cuota?: boolean
    plan_cuota?: boolean
    monto_financiacion?: boolean
    financiacion?: boolean
    efectivo?: boolean
  }, ExtArgs["result"]["servicio_venta"]>

  export type servicio_ventaSelectScalar = {
    idventa?: boolean
    idservicio?: boolean
    monto?: boolean
    operador?: boolean
    fecha_venta?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    parentesco?: boolean
    operador_venta?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
    comision?: boolean
    fecha_carga?: boolean
    valor_cuota?: boolean
    plan_cuota?: boolean
    monto_financiacion?: boolean
    financiacion?: boolean
    efectivo?: boolean
  }


  type servicio_ventaGetPayload<S extends boolean | null | undefined | servicio_ventaArgs> = $Types.GetResult<servicio_ventaPayload, S>

  type servicio_ventaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_ventaCountAggregateInputType | true
    }

  export interface servicio_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_venta'], meta: { name: 'servicio_venta' } }
    /**
     * Find zero or one Servicio_venta that matches the filter.
     * @param {servicio_ventaFindUniqueArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_ventaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_ventaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_ventaFindUniqueOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_ventaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_ventaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_ventaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_ventaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany()
     * 
     * // Get first 10 Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany({ take: 10 })
     * 
     * // Only select the `idventa`
     * const servicio_ventaWithIdventaOnly = await prisma.servicio_venta.findMany({ select: { idventa: true } })
     * 
    **/
    findMany<T extends servicio_ventaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_venta.
     * @param {servicio_ventaCreateArgs} args - Arguments to create a Servicio_venta.
     * @example
     * // Create one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.create({
     *   data: {
     *     // ... data to create a Servicio_venta
     *   }
     * })
     * 
    **/
    create<T extends servicio_ventaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaCreateArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_ventas.
     *     @param {servicio_ventaCreateManyArgs} args - Arguments to create many Servicio_ventas.
     *     @example
     *     // Create many Servicio_ventas
     *     const servicio_venta = await prisma.servicio_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_ventaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_venta.
     * @param {servicio_ventaDeleteArgs} args - Arguments to delete one Servicio_venta.
     * @example
     * // Delete one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.delete({
     *   where: {
     *     // ... filter to delete one Servicio_venta
     *   }
     * })
     * 
    **/
    delete<T extends servicio_ventaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaDeleteArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_venta.
     * @param {servicio_ventaUpdateArgs} args - Arguments to update one Servicio_venta.
     * @example
     * // Update one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_ventaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpdateArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_ventas.
     * @param {servicio_ventaDeleteManyArgs} args - Arguments to filter Servicio_ventas to delete.
     * @example
     * // Delete a few Servicio_ventas
     * const { count } = await prisma.servicio_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_ventaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_ventas
     * const servicio_venta = await prisma.servicio_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_ventaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_venta.
     * @param {servicio_ventaUpsertArgs} args - Arguments to update or create a Servicio_venta.
     * @example
     * // Update or create a Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.upsert({
     *   create: {
     *     // ... data to create a Servicio_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_venta we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_ventaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpsertArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaCountArgs} args - Arguments to filter Servicio_ventas to count.
     * @example
     * // Count the number of Servicio_ventas
     * const count = await prisma.servicio_venta.count({
     *   where: {
     *     // ... the filter for the Servicio_ventas we want to count
     *   }
     * })
    **/
    count<T extends servicio_ventaCountArgs>(
      args?: Subset<T, servicio_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_ventaAggregateArgs>(args: Subset<T, Servicio_ventaAggregateArgs>): Prisma.PrismaPromise<GetServicio_ventaAggregateType<T>>

    /**
     * Group by Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_ventaGroupByArgs['orderBy'] }
        : { orderBy?: servicio_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_ventaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_venta base type for findUnique actions
   */
  export type servicio_ventaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }

  /**
   * servicio_venta findUnique
   */
  export interface servicio_ventaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_ventaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findUniqueOrThrow
   */
  export type servicio_ventaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta base type for findFirst actions
   */
  export type servicio_ventaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }

  /**
   * servicio_venta findFirst
   */
  export interface servicio_ventaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_ventaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findFirstOrThrow
   */
  export type servicio_ventaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }


  /**
   * servicio_venta findMany
   */
  export type servicio_ventaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_ventas to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }


  /**
   * servicio_venta create
   */
  export type servicio_ventaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_venta.
     */
    data?: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
  }


  /**
   * servicio_venta createMany
   */
  export type servicio_ventaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_ventas.
     */
    data: servicio_ventaCreateManyInput | servicio_ventaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_venta update
   */
  export type servicio_ventaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_venta.
     */
    data: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
    /**
     * Choose, which servicio_venta to update.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta updateMany
   */
  export type servicio_ventaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_ventas.
     */
    data: XOR<servicio_ventaUpdateManyMutationInput, servicio_ventaUncheckedUpdateManyInput>
    /**
     * Filter which servicio_ventas to update
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta upsert
   */
  export type servicio_ventaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_venta to update in case it exists.
     */
    where: servicio_ventaWhereUniqueInput
    /**
     * In case the servicio_venta found by the `where` argument doesn't exist, create a new servicio_venta with this data.
     */
    create: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
    /**
     * In case the servicio_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
  }


  /**
   * servicio_venta delete
   */
  export type servicio_ventaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter which servicio_venta to delete.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta deleteMany
   */
  export type servicio_ventaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_ventas to delete
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta without action
   */
  export type servicio_ventaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
  }



  /**
   * Model servicios
   */


  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
    importe_servicio: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
    importe_servicio: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    detalle_corona: string | null
    religion: string | null
    estado_civil: string | null
    importe_servicio: number | null
    telefono: string | null
    movil: string | null
    gasto_luto: string | null
    conyugue: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    detalle_corona: string | null
    religion: string | null
    estado_civil: string | null
    importe_servicio: number | null
    telefono: string | null
    movil: string | null
    gasto_luto: string | null
    conyugue: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    idservicio: number
    empresa: number
    dni: number
    apellido: number
    nombre: number
    edad: number
    fecha_fallecimiento: number
    lugar_fallecimiento: number
    tipo_servicio: number
    casa_mortuaria: number
    fecha_inhumacion: number
    hora_inhumacion: number
    cementerio: number
    estado: number
    contrato: number
    fecha_recepcion: number
    sucursal: number
    motivo: number
    retiro: number
    solicitado: number
    parentesco: number
    altura: number
    peso: number
    dni_nuevotitular: number
    operador: number
    idataud: number
    dni_solicitante: number
    impactado: number
    cremacion: number
    idparcela: number
    liquidado: number
    fecha_liquidacion: number
    gastos_cargados: number
    obra_soc: number
    importe: number
    donacion: number
    domicilio_solicitante: number
    detalle_corona: number
    religion: number
    estado_civil: number
    importe_servicio: number
    telefono: number
    movil: number
    gasto_luto: number
    conyugue: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
    importe_servicio?: true
  }

  export type ServiciosSumAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
    importe_servicio?: true
  }

  export type ServiciosMinAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
    detalle_corona?: true
    religion?: true
    estado_civil?: true
    importe_servicio?: true
    telefono?: true
    movil?: true
    gasto_luto?: true
    conyugue?: true
  }

  export type ServiciosMaxAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
    detalle_corona?: true
    religion?: true
    estado_civil?: true
    importe_servicio?: true
    telefono?: true
    movil?: true
    gasto_luto?: true
    conyugue?: true
  }

  export type ServiciosCountAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
    detalle_corona?: true
    religion?: true
    estado_civil?: true
    importe_servicio?: true
    telefono?: true
    movil?: true
    gasto_luto?: true
    conyugue?: true
    _all?: true
  }

  export type ServiciosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to aggregate.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type serviciosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: serviciosWhereInput
    orderBy?: serviciosOrderByWithAggregationInput | serviciosOrderByWithAggregationInput[]
    by: ServiciosScalarFieldEnum[] | ServiciosScalarFieldEnum
    having?: serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }


  export type ServiciosGroupByOutputType = {
    idservicio: number
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    detalle_corona: string | null
    religion: string | null
    estado_civil: string | null
    importe_servicio: number | null
    telefono: string | null
    movil: string | null
    gasto_luto: string | null
    conyugue: string | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type serviciosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idservicio?: boolean
    empresa?: boolean
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    fecha_fallecimiento?: boolean
    lugar_fallecimiento?: boolean
    tipo_servicio?: boolean
    casa_mortuaria?: boolean
    fecha_inhumacion?: boolean
    hora_inhumacion?: boolean
    cementerio?: boolean
    estado?: boolean
    contrato?: boolean
    fecha_recepcion?: boolean
    sucursal?: boolean
    motivo?: boolean
    retiro?: boolean
    solicitado?: boolean
    parentesco?: boolean
    altura?: boolean
    peso?: boolean
    dni_nuevotitular?: boolean
    operador?: boolean
    idataud?: boolean
    dni_solicitante?: boolean
    impactado?: boolean
    cremacion?: boolean
    idparcela?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    gastos_cargados?: boolean
    obra_soc?: boolean
    importe?: boolean
    donacion?: boolean
    domicilio_solicitante?: boolean
    detalle_corona?: boolean
    religion?: boolean
    estado_civil?: boolean
    importe_servicio?: boolean
    telefono?: boolean
    movil?: boolean
    gasto_luto?: boolean
    conyugue?: boolean
  }, ExtArgs["result"]["servicios"]>

  export type serviciosSelectScalar = {
    idservicio?: boolean
    empresa?: boolean
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    fecha_fallecimiento?: boolean
    lugar_fallecimiento?: boolean
    tipo_servicio?: boolean
    casa_mortuaria?: boolean
    fecha_inhumacion?: boolean
    hora_inhumacion?: boolean
    cementerio?: boolean
    estado?: boolean
    contrato?: boolean
    fecha_recepcion?: boolean
    sucursal?: boolean
    motivo?: boolean
    retiro?: boolean
    solicitado?: boolean
    parentesco?: boolean
    altura?: boolean
    peso?: boolean
    dni_nuevotitular?: boolean
    operador?: boolean
    idataud?: boolean
    dni_solicitante?: boolean
    impactado?: boolean
    cremacion?: boolean
    idparcela?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    gastos_cargados?: boolean
    obra_soc?: boolean
    importe?: boolean
    donacion?: boolean
    domicilio_solicitante?: boolean
    detalle_corona?: boolean
    religion?: boolean
    estado_civil?: boolean
    importe_servicio?: boolean
    telefono?: boolean
    movil?: boolean
    gasto_luto?: boolean
    conyugue?: boolean
  }


  type serviciosGetPayload<S extends boolean | null | undefined | serviciosArgs> = $Types.GetResult<serviciosPayload, S>

  type serviciosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<serviciosFindManyArgs, 'select' | 'include'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios'], meta: { name: 'servicios' } }
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {serviciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviciosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviciosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios'> extends True ? Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serviciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serviciosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviciosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviciosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios'> extends True ? Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serviciosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `idservicio`
     * const serviciosWithIdservicioOnly = await prisma.servicios.findMany({ select: { idservicio: true } })
     * 
    **/
    findMany<T extends serviciosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicios.
     * @param {serviciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
    **/
    create<T extends serviciosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosCreateArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios.
     *     @param {serviciosCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicios = await prisma.servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serviciosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {serviciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
    **/
    delete<T extends serviciosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosDeleteArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicios.
     * @param {serviciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviciosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpdateArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {serviciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviciosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviciosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {serviciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
    **/
    upsert<T extends serviciosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpsertArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends serviciosCountArgs>(
      args?: Subset<T, serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviciosGroupByArgs['orderBy'] }
        : { orderBy?: serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviciosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios base type for findUnique actions
   */
  export type serviciosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios findUnique
   */
  export interface serviciosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviciosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findUniqueOrThrow
   */
  export type serviciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios base type for findFirst actions
   */
  export type serviciosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * servicios findFirst
   */
  export interface serviciosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviciosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findFirstOrThrow
   */
  export type serviciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * servicios findMany
   */
  export type serviciosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * servicios create
   */
  export type serviciosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The data needed to create a servicios.
     */
    data?: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
  }


  /**
   * servicios createMany
   */
  export type serviciosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios.
     */
    data: serviciosCreateManyInput | serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicios update
   */
  export type serviciosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The data needed to update a servicios.
     */
    data: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
    /**
     * Choose, which servicios to update.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios updateMany
   */
  export type serviciosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios.
     */
    data: XOR<serviciosUpdateManyMutationInput, serviciosUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios upsert
   */
  export type serviciosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The filter to search for the servicios to update in case it exists.
     */
    where: serviciosWhereUniqueInput
    /**
     * In case the servicios found by the `where` argument doesn't exist, create a new servicios with this data.
     */
    create: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
    /**
     * In case the servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
  }


  /**
   * servicios delete
   */
  export type serviciosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter which servicios to delete.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios deleteMany
   */
  export type serviciosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to delete
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios without action
   */
  export type serviciosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
  }



  /**
   * Model servicios_historico
   */


  export type AggregateServicios_historico = {
    _count: Servicios_historicoCountAggregateOutputType | null
    _avg: Servicios_historicoAvgAggregateOutputType | null
    _sum: Servicios_historicoSumAggregateOutputType | null
    _min: Servicios_historicoMinAggregateOutputType | null
    _max: Servicios_historicoMaxAggregateOutputType | null
  }

  export type Servicios_historicoAvgAggregateOutputType = {
    NRO_NOTACR: number | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    CONTRATO: number | null
    COD_ATAUD: number | null
    DIFE_KM: number | null
    CARROZA: number | null
    AUTO_DUELO: number | null
    ADICIO_PAG: number | null
    GASTO_ASOC: number | null
    OPE_ANUL: number | null
    ANULAR: number | null
    CREDITO: number | null
    TOTA_NUM: number | null
    DNI_SOLI: number | null
    DNI_GARANT: number | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    INFO_CRE: number | null
    OPERADOR: number | null
    id: number | null
  }

  export type Servicios_historicoSumAggregateOutputType = {
    NRO_NOTACR: number | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    CONTRATO: number | null
    COD_ATAUD: number | null
    DIFE_KM: number | null
    CARROZA: number | null
    AUTO_DUELO: number | null
    ADICIO_PAG: number | null
    GASTO_ASOC: number | null
    OPE_ANUL: number | null
    ANULAR: number | null
    CREDITO: number | null
    TOTA_NUM: number | null
    DNI_SOLI: number | null
    DNI_GARANT: number | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    INFO_CRE: number | null
    OPERADOR: number | null
    id: number | null
  }

  export type Servicios_historicoMinAggregateOutputType = {
    NRO_NOTACR: number | null
    FEC_CREDIT: Date | null
    EXINTO: string | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    FEC_FALLEC: Date | null
    LUGAR: string | null
    TIPO_SERV: string | null
    PLAN: string | null
    SUB_PLAN: string | null
    CONTRATO: number | null
    CASA_MORT: string | null
    FEC_INHU: Date | null
    HORA: string | null
    CEMENTERIO: string | null
    DONDE_ENTI: string | null
    ATAUD_TIPO: string | null
    COD_ATAUD: number | null
    DETALLE: string | null
    RETI_CUER: string | null
    TRASLADO_A: string | null
    DIFE_KM: number | null
    CAPI_DOMI: string | null
    GRAB_PLACA: string | null
    TRAMITES: string | null
    AVISO_TELR: string | null
    CARROZA: number | null
    PORTACORO: string | null
    AUTO_DUELO: number | null
    SALA_VELAT: string | null
    ADICIONAL: string | null
    ADICIO_PAG: number | null
    OBSERVA0: string | null
    PARCELA: string | null
    SEC: string | null
    PARC: string | null
    SECC: string | null
    GASTO_ASOC: number | null
    GASTO_PAMI: string | null
    OBSERVA1: string | null
    OPE_ANUL: number | null
    ANULAR: number | null
    FEC_ANULA: Date | null
    CREDITO: number | null
    TOTA_LETRA: string | null
    TOTA_NUM: number | null
    FORMA_PAGO: string | null
    DOCUMENTO: string | null
    SOLI_CRED: string | null
    GARANT_CRE: string | null
    DNI_SOLI: number | null
    TEL_SOLI: string | null
    DOMI_SOLI: string | null
    DNI_GARANT: number | null
    TEL_GARANT: string | null
    DOMI_GARAN: string | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    FECANU_CRE: Date | null
    INFO_CRE: number | null
    SUCURSAL: string | null
    OPERADOR: number | null
    TRASPASO: Date | null
    EMPRESA: string | null
    id: number | null
  }

  export type Servicios_historicoMaxAggregateOutputType = {
    NRO_NOTACR: number | null
    FEC_CREDIT: Date | null
    EXINTO: string | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    FEC_FALLEC: Date | null
    LUGAR: string | null
    TIPO_SERV: string | null
    PLAN: string | null
    SUB_PLAN: string | null
    CONTRATO: number | null
    CASA_MORT: string | null
    FEC_INHU: Date | null
    HORA: string | null
    CEMENTERIO: string | null
    DONDE_ENTI: string | null
    ATAUD_TIPO: string | null
    COD_ATAUD: number | null
    DETALLE: string | null
    RETI_CUER: string | null
    TRASLADO_A: string | null
    DIFE_KM: number | null
    CAPI_DOMI: string | null
    GRAB_PLACA: string | null
    TRAMITES: string | null
    AVISO_TELR: string | null
    CARROZA: number | null
    PORTACORO: string | null
    AUTO_DUELO: number | null
    SALA_VELAT: string | null
    ADICIONAL: string | null
    ADICIO_PAG: number | null
    OBSERVA0: string | null
    PARCELA: string | null
    SEC: string | null
    PARC: string | null
    SECC: string | null
    GASTO_ASOC: number | null
    GASTO_PAMI: string | null
    OBSERVA1: string | null
    OPE_ANUL: number | null
    ANULAR: number | null
    FEC_ANULA: Date | null
    CREDITO: number | null
    TOTA_LETRA: string | null
    TOTA_NUM: number | null
    FORMA_PAGO: string | null
    DOCUMENTO: string | null
    SOLI_CRED: string | null
    GARANT_CRE: string | null
    DNI_SOLI: number | null
    TEL_SOLI: string | null
    DOMI_SOLI: string | null
    DNI_GARANT: number | null
    TEL_GARANT: string | null
    DOMI_GARAN: string | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    FECANU_CRE: Date | null
    INFO_CRE: number | null
    SUCURSAL: string | null
    OPERADOR: number | null
    TRASPASO: Date | null
    EMPRESA: string | null
    id: number | null
  }

  export type Servicios_historicoCountAggregateOutputType = {
    NRO_NOTACR: number
    FEC_CREDIT: number
    EXINTO: number
    DNI_EXIN: number
    EDAD_EXIN: number
    FEC_FALLEC: number
    LUGAR: number
    TIPO_SERV: number
    PLAN: number
    SUB_PLAN: number
    CONTRATO: number
    CASA_MORT: number
    FEC_INHU: number
    HORA: number
    CEMENTERIO: number
    DONDE_ENTI: number
    ATAUD_TIPO: number
    COD_ATAUD: number
    DETALLE: number
    RETI_CUER: number
    TRASLADO_A: number
    DIFE_KM: number
    CAPI_DOMI: number
    GRAB_PLACA: number
    TRAMITES: number
    AVISO_TELR: number
    CARROZA: number
    PORTACORO: number
    AUTO_DUELO: number
    SALA_VELAT: number
    ADICIONAL: number
    ADICIO_PAG: number
    OBSERVA0: number
    PARCELA: number
    SEC: number
    PARC: number
    SECC: number
    GASTO_ASOC: number
    GASTO_PAMI: number
    OBSERVA1: number
    OPE_ANUL: number
    ANULAR: number
    FEC_ANULA: number
    CREDITO: number
    TOTA_LETRA: number
    TOTA_NUM: number
    FORMA_PAGO: number
    DOCUMENTO: number
    SOLI_CRED: number
    GARANT_CRE: number
    DNI_SOLI: number
    TEL_SOLI: number
    DOMI_SOLI: number
    DNI_GARANT: number
    TEL_GARANT: number
    DOMI_GARAN: number
    OPE_ANUCRE: number
    ANULA_CRE: number
    FECANU_CRE: number
    INFO_CRE: number
    SUCURSAL: number
    OPERADOR: number
    TRASPASO: number
    EMPRESA: number
    id: number
    _all: number
  }


  export type Servicios_historicoAvgAggregateInputType = {
    NRO_NOTACR?: true
    DNI_EXIN?: true
    EDAD_EXIN?: true
    CONTRATO?: true
    COD_ATAUD?: true
    DIFE_KM?: true
    CARROZA?: true
    AUTO_DUELO?: true
    ADICIO_PAG?: true
    GASTO_ASOC?: true
    OPE_ANUL?: true
    ANULAR?: true
    CREDITO?: true
    TOTA_NUM?: true
    DNI_SOLI?: true
    DNI_GARANT?: true
    OPE_ANUCRE?: true
    ANULA_CRE?: true
    INFO_CRE?: true
    OPERADOR?: true
    id?: true
  }

  export type Servicios_historicoSumAggregateInputType = {
    NRO_NOTACR?: true
    DNI_EXIN?: true
    EDAD_EXIN?: true
    CONTRATO?: true
    COD_ATAUD?: true
    DIFE_KM?: true
    CARROZA?: true
    AUTO_DUELO?: true
    ADICIO_PAG?: true
    GASTO_ASOC?: true
    OPE_ANUL?: true
    ANULAR?: true
    CREDITO?: true
    TOTA_NUM?: true
    DNI_SOLI?: true
    DNI_GARANT?: true
    OPE_ANUCRE?: true
    ANULA_CRE?: true
    INFO_CRE?: true
    OPERADOR?: true
    id?: true
  }

  export type Servicios_historicoMinAggregateInputType = {
    NRO_NOTACR?: true
    FEC_CREDIT?: true
    EXINTO?: true
    DNI_EXIN?: true
    EDAD_EXIN?: true
    FEC_FALLEC?: true
    LUGAR?: true
    TIPO_SERV?: true
    PLAN?: true
    SUB_PLAN?: true
    CONTRATO?: true
    CASA_MORT?: true
    FEC_INHU?: true
    HORA?: true
    CEMENTERIO?: true
    DONDE_ENTI?: true
    ATAUD_TIPO?: true
    COD_ATAUD?: true
    DETALLE?: true
    RETI_CUER?: true
    TRASLADO_A?: true
    DIFE_KM?: true
    CAPI_DOMI?: true
    GRAB_PLACA?: true
    TRAMITES?: true
    AVISO_TELR?: true
    CARROZA?: true
    PORTACORO?: true
    AUTO_DUELO?: true
    SALA_VELAT?: true
    ADICIONAL?: true
    ADICIO_PAG?: true
    OBSERVA0?: true
    PARCELA?: true
    SEC?: true
    PARC?: true
    SECC?: true
    GASTO_ASOC?: true
    GASTO_PAMI?: true
    OBSERVA1?: true
    OPE_ANUL?: true
    ANULAR?: true
    FEC_ANULA?: true
    CREDITO?: true
    TOTA_LETRA?: true
    TOTA_NUM?: true
    FORMA_PAGO?: true
    DOCUMENTO?: true
    SOLI_CRED?: true
    GARANT_CRE?: true
    DNI_SOLI?: true
    TEL_SOLI?: true
    DOMI_SOLI?: true
    DNI_GARANT?: true
    TEL_GARANT?: true
    DOMI_GARAN?: true
    OPE_ANUCRE?: true
    ANULA_CRE?: true
    FECANU_CRE?: true
    INFO_CRE?: true
    SUCURSAL?: true
    OPERADOR?: true
    TRASPASO?: true
    EMPRESA?: true
    id?: true
  }

  export type Servicios_historicoMaxAggregateInputType = {
    NRO_NOTACR?: true
    FEC_CREDIT?: true
    EXINTO?: true
    DNI_EXIN?: true
    EDAD_EXIN?: true
    FEC_FALLEC?: true
    LUGAR?: true
    TIPO_SERV?: true
    PLAN?: true
    SUB_PLAN?: true
    CONTRATO?: true
    CASA_MORT?: true
    FEC_INHU?: true
    HORA?: true
    CEMENTERIO?: true
    DONDE_ENTI?: true
    ATAUD_TIPO?: true
    COD_ATAUD?: true
    DETALLE?: true
    RETI_CUER?: true
    TRASLADO_A?: true
    DIFE_KM?: true
    CAPI_DOMI?: true
    GRAB_PLACA?: true
    TRAMITES?: true
    AVISO_TELR?: true
    CARROZA?: true
    PORTACORO?: true
    AUTO_DUELO?: true
    SALA_VELAT?: true
    ADICIONAL?: true
    ADICIO_PAG?: true
    OBSERVA0?: true
    PARCELA?: true
    SEC?: true
    PARC?: true
    SECC?: true
    GASTO_ASOC?: true
    GASTO_PAMI?: true
    OBSERVA1?: true
    OPE_ANUL?: true
    ANULAR?: true
    FEC_ANULA?: true
    CREDITO?: true
    TOTA_LETRA?: true
    TOTA_NUM?: true
    FORMA_PAGO?: true
    DOCUMENTO?: true
    SOLI_CRED?: true
    GARANT_CRE?: true
    DNI_SOLI?: true
    TEL_SOLI?: true
    DOMI_SOLI?: true
    DNI_GARANT?: true
    TEL_GARANT?: true
    DOMI_GARAN?: true
    OPE_ANUCRE?: true
    ANULA_CRE?: true
    FECANU_CRE?: true
    INFO_CRE?: true
    SUCURSAL?: true
    OPERADOR?: true
    TRASPASO?: true
    EMPRESA?: true
    id?: true
  }

  export type Servicios_historicoCountAggregateInputType = {
    NRO_NOTACR?: true
    FEC_CREDIT?: true
    EXINTO?: true
    DNI_EXIN?: true
    EDAD_EXIN?: true
    FEC_FALLEC?: true
    LUGAR?: true
    TIPO_SERV?: true
    PLAN?: true
    SUB_PLAN?: true
    CONTRATO?: true
    CASA_MORT?: true
    FEC_INHU?: true
    HORA?: true
    CEMENTERIO?: true
    DONDE_ENTI?: true
    ATAUD_TIPO?: true
    COD_ATAUD?: true
    DETALLE?: true
    RETI_CUER?: true
    TRASLADO_A?: true
    DIFE_KM?: true
    CAPI_DOMI?: true
    GRAB_PLACA?: true
    TRAMITES?: true
    AVISO_TELR?: true
    CARROZA?: true
    PORTACORO?: true
    AUTO_DUELO?: true
    SALA_VELAT?: true
    ADICIONAL?: true
    ADICIO_PAG?: true
    OBSERVA0?: true
    PARCELA?: true
    SEC?: true
    PARC?: true
    SECC?: true
    GASTO_ASOC?: true
    GASTO_PAMI?: true
    OBSERVA1?: true
    OPE_ANUL?: true
    ANULAR?: true
    FEC_ANULA?: true
    CREDITO?: true
    TOTA_LETRA?: true
    TOTA_NUM?: true
    FORMA_PAGO?: true
    DOCUMENTO?: true
    SOLI_CRED?: true
    GARANT_CRE?: true
    DNI_SOLI?: true
    TEL_SOLI?: true
    DOMI_SOLI?: true
    DNI_GARANT?: true
    TEL_GARANT?: true
    DOMI_GARAN?: true
    OPE_ANUCRE?: true
    ANULA_CRE?: true
    FECANU_CRE?: true
    INFO_CRE?: true
    SUCURSAL?: true
    OPERADOR?: true
    TRASPASO?: true
    EMPRESA?: true
    id?: true
    _all?: true
  }

  export type Servicios_historicoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_historico to aggregate.
     */
    where?: servicios_historicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_historicos to fetch.
     */
    orderBy?: servicios_historicoOrderByWithRelationInput | servicios_historicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicios_historicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_historicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_historicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios_historicos
    **/
    _count?: true | Servicios_historicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicios_historicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicios_historicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicios_historicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicios_historicoMaxAggregateInputType
  }

  export type GetServicios_historicoAggregateType<T extends Servicios_historicoAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios_historico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios_historico[P]>
      : GetScalarType<T[P], AggregateServicios_historico[P]>
  }




  export type servicios_historicoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicios_historicoWhereInput
    orderBy?: servicios_historicoOrderByWithAggregationInput | servicios_historicoOrderByWithAggregationInput[]
    by: Servicios_historicoScalarFieldEnum[] | Servicios_historicoScalarFieldEnum
    having?: servicios_historicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicios_historicoCountAggregateInputType | true
    _avg?: Servicios_historicoAvgAggregateInputType
    _sum?: Servicios_historicoSumAggregateInputType
    _min?: Servicios_historicoMinAggregateInputType
    _max?: Servicios_historicoMaxAggregateInputType
  }


  export type Servicios_historicoGroupByOutputType = {
    NRO_NOTACR: number | null
    FEC_CREDIT: Date | null
    EXINTO: string | null
    DNI_EXIN: number | null
    EDAD_EXIN: number | null
    FEC_FALLEC: Date | null
    LUGAR: string | null
    TIPO_SERV: string | null
    PLAN: string | null
    SUB_PLAN: string | null
    CONTRATO: number | null
    CASA_MORT: string | null
    FEC_INHU: Date | null
    HORA: string | null
    CEMENTERIO: string | null
    DONDE_ENTI: string | null
    ATAUD_TIPO: string | null
    COD_ATAUD: number | null
    DETALLE: string | null
    RETI_CUER: string | null
    TRASLADO_A: string | null
    DIFE_KM: number | null
    CAPI_DOMI: string | null
    GRAB_PLACA: string | null
    TRAMITES: string | null
    AVISO_TELR: string | null
    CARROZA: number | null
    PORTACORO: string | null
    AUTO_DUELO: number | null
    SALA_VELAT: string | null
    ADICIONAL: string | null
    ADICIO_PAG: number | null
    OBSERVA0: string | null
    PARCELA: string | null
    SEC: string | null
    PARC: string | null
    SECC: string | null
    GASTO_ASOC: number | null
    GASTO_PAMI: string | null
    OBSERVA1: string | null
    OPE_ANUL: number | null
    ANULAR: number | null
    FEC_ANULA: Date | null
    CREDITO: number | null
    TOTA_LETRA: string | null
    TOTA_NUM: number | null
    FORMA_PAGO: string | null
    DOCUMENTO: string | null
    SOLI_CRED: string | null
    GARANT_CRE: string | null
    DNI_SOLI: number | null
    TEL_SOLI: string | null
    DOMI_SOLI: string | null
    DNI_GARANT: number | null
    TEL_GARANT: string | null
    DOMI_GARAN: string | null
    OPE_ANUCRE: number | null
    ANULA_CRE: number | null
    FECANU_CRE: Date | null
    INFO_CRE: number | null
    SUCURSAL: string | null
    OPERADOR: number | null
    TRASPASO: Date | null
    EMPRESA: string | null
    id: number
    _count: Servicios_historicoCountAggregateOutputType | null
    _avg: Servicios_historicoAvgAggregateOutputType | null
    _sum: Servicios_historicoSumAggregateOutputType | null
    _min: Servicios_historicoMinAggregateOutputType | null
    _max: Servicios_historicoMaxAggregateOutputType | null
  }

  type GetServicios_historicoGroupByPayload<T extends servicios_historicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicios_historicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicios_historicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicios_historicoGroupByOutputType[P]>
            : GetScalarType<T[P], Servicios_historicoGroupByOutputType[P]>
        }
      >
    >


  export type servicios_historicoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NRO_NOTACR?: boolean
    FEC_CREDIT?: boolean
    EXINTO?: boolean
    DNI_EXIN?: boolean
    EDAD_EXIN?: boolean
    FEC_FALLEC?: boolean
    LUGAR?: boolean
    TIPO_SERV?: boolean
    PLAN?: boolean
    SUB_PLAN?: boolean
    CONTRATO?: boolean
    CASA_MORT?: boolean
    FEC_INHU?: boolean
    HORA?: boolean
    CEMENTERIO?: boolean
    DONDE_ENTI?: boolean
    ATAUD_TIPO?: boolean
    COD_ATAUD?: boolean
    DETALLE?: boolean
    RETI_CUER?: boolean
    TRASLADO_A?: boolean
    DIFE_KM?: boolean
    CAPI_DOMI?: boolean
    GRAB_PLACA?: boolean
    TRAMITES?: boolean
    AVISO_TELR?: boolean
    CARROZA?: boolean
    PORTACORO?: boolean
    AUTO_DUELO?: boolean
    SALA_VELAT?: boolean
    ADICIONAL?: boolean
    ADICIO_PAG?: boolean
    OBSERVA0?: boolean
    PARCELA?: boolean
    SEC?: boolean
    PARC?: boolean
    SECC?: boolean
    GASTO_ASOC?: boolean
    GASTO_PAMI?: boolean
    OBSERVA1?: boolean
    OPE_ANUL?: boolean
    ANULAR?: boolean
    FEC_ANULA?: boolean
    CREDITO?: boolean
    TOTA_LETRA?: boolean
    TOTA_NUM?: boolean
    FORMA_PAGO?: boolean
    DOCUMENTO?: boolean
    SOLI_CRED?: boolean
    GARANT_CRE?: boolean
    DNI_SOLI?: boolean
    TEL_SOLI?: boolean
    DOMI_SOLI?: boolean
    DNI_GARANT?: boolean
    TEL_GARANT?: boolean
    DOMI_GARAN?: boolean
    OPE_ANUCRE?: boolean
    ANULA_CRE?: boolean
    FECANU_CRE?: boolean
    INFO_CRE?: boolean
    SUCURSAL?: boolean
    OPERADOR?: boolean
    TRASPASO?: boolean
    EMPRESA?: boolean
    id?: boolean
  }, ExtArgs["result"]["servicios_historico"]>

  export type servicios_historicoSelectScalar = {
    NRO_NOTACR?: boolean
    FEC_CREDIT?: boolean
    EXINTO?: boolean
    DNI_EXIN?: boolean
    EDAD_EXIN?: boolean
    FEC_FALLEC?: boolean
    LUGAR?: boolean
    TIPO_SERV?: boolean
    PLAN?: boolean
    SUB_PLAN?: boolean
    CONTRATO?: boolean
    CASA_MORT?: boolean
    FEC_INHU?: boolean
    HORA?: boolean
    CEMENTERIO?: boolean
    DONDE_ENTI?: boolean
    ATAUD_TIPO?: boolean
    COD_ATAUD?: boolean
    DETALLE?: boolean
    RETI_CUER?: boolean
    TRASLADO_A?: boolean
    DIFE_KM?: boolean
    CAPI_DOMI?: boolean
    GRAB_PLACA?: boolean
    TRAMITES?: boolean
    AVISO_TELR?: boolean
    CARROZA?: boolean
    PORTACORO?: boolean
    AUTO_DUELO?: boolean
    SALA_VELAT?: boolean
    ADICIONAL?: boolean
    ADICIO_PAG?: boolean
    OBSERVA0?: boolean
    PARCELA?: boolean
    SEC?: boolean
    PARC?: boolean
    SECC?: boolean
    GASTO_ASOC?: boolean
    GASTO_PAMI?: boolean
    OBSERVA1?: boolean
    OPE_ANUL?: boolean
    ANULAR?: boolean
    FEC_ANULA?: boolean
    CREDITO?: boolean
    TOTA_LETRA?: boolean
    TOTA_NUM?: boolean
    FORMA_PAGO?: boolean
    DOCUMENTO?: boolean
    SOLI_CRED?: boolean
    GARANT_CRE?: boolean
    DNI_SOLI?: boolean
    TEL_SOLI?: boolean
    DOMI_SOLI?: boolean
    DNI_GARANT?: boolean
    TEL_GARANT?: boolean
    DOMI_GARAN?: boolean
    OPE_ANUCRE?: boolean
    ANULA_CRE?: boolean
    FECANU_CRE?: boolean
    INFO_CRE?: boolean
    SUCURSAL?: boolean
    OPERADOR?: boolean
    TRASPASO?: boolean
    EMPRESA?: boolean
    id?: boolean
  }


  type servicios_historicoGetPayload<S extends boolean | null | undefined | servicios_historicoArgs> = $Types.GetResult<servicios_historicoPayload, S>

  type servicios_historicoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicios_historicoFindManyArgs, 'select' | 'include'> & {
      select?: Servicios_historicoCountAggregateInputType | true
    }

  export interface servicios_historicoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios_historico'], meta: { name: 'servicios_historico' } }
    /**
     * Find zero or one Servicios_historico that matches the filter.
     * @param {servicios_historicoFindUniqueArgs} args - Arguments to find a Servicios_historico
     * @example
     * // Get one Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicios_historicoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicios_historicoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios_historico'> extends True ? Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicios_historico that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicios_historicoFindUniqueOrThrowArgs} args - Arguments to find a Servicios_historico
     * @example
     * // Get one Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicios_historicoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_historicoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicios_historico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoFindFirstArgs} args - Arguments to find a Servicios_historico
     * @example
     * // Get one Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicios_historicoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicios_historicoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios_historico'> extends True ? Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicios_historico that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoFindFirstOrThrowArgs} args - Arguments to find a Servicios_historico
     * @example
     * // Get one Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicios_historicoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_historicoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios_historicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios_historicos
     * const servicios_historicos = await prisma.servicios_historico.findMany()
     * 
     * // Get first 10 Servicios_historicos
     * const servicios_historicos = await prisma.servicios_historico.findMany({ take: 10 })
     * 
     * // Only select the `NRO_NOTACR`
     * const servicios_historicoWithNRO_NOTACROnly = await prisma.servicios_historico.findMany({ select: { NRO_NOTACR: true } })
     * 
    **/
    findMany<T extends servicios_historicoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_historicoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicios_historico.
     * @param {servicios_historicoCreateArgs} args - Arguments to create a Servicios_historico.
     * @example
     * // Create one Servicios_historico
     * const Servicios_historico = await prisma.servicios_historico.create({
     *   data: {
     *     // ... data to create a Servicios_historico
     *   }
     * })
     * 
    **/
    create<T extends servicios_historicoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_historicoCreateArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios_historicos.
     *     @param {servicios_historicoCreateManyArgs} args - Arguments to create many Servicios_historicos.
     *     @example
     *     // Create many Servicios_historicos
     *     const servicios_historico = await prisma.servicios_historico.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicios_historicoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_historicoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios_historico.
     * @param {servicios_historicoDeleteArgs} args - Arguments to delete one Servicios_historico.
     * @example
     * // Delete one Servicios_historico
     * const Servicios_historico = await prisma.servicios_historico.delete({
     *   where: {
     *     // ... filter to delete one Servicios_historico
     *   }
     * })
     * 
    **/
    delete<T extends servicios_historicoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_historicoDeleteArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicios_historico.
     * @param {servicios_historicoUpdateArgs} args - Arguments to update one Servicios_historico.
     * @example
     * // Update one Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicios_historicoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_historicoUpdateArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios_historicos.
     * @param {servicios_historicoDeleteManyArgs} args - Arguments to filter Servicios_historicos to delete.
     * @example
     * // Delete a few Servicios_historicos
     * const { count } = await prisma.servicios_historico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicios_historicoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_historicoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios_historicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios_historicos
     * const servicios_historico = await prisma.servicios_historico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicios_historicoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_historicoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios_historico.
     * @param {servicios_historicoUpsertArgs} args - Arguments to update or create a Servicios_historico.
     * @example
     * // Update or create a Servicios_historico
     * const servicios_historico = await prisma.servicios_historico.upsert({
     *   create: {
     *     // ... data to create a Servicios_historico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios_historico we want to update
     *   }
     * })
    **/
    upsert<T extends servicios_historicoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_historicoUpsertArgs<ExtArgs>>
    ): Prisma__servicios_historicoClient<$Types.GetResult<servicios_historicoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicios_historicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoCountArgs} args - Arguments to filter Servicios_historicos to count.
     * @example
     * // Count the number of Servicios_historicos
     * const count = await prisma.servicios_historico.count({
     *   where: {
     *     // ... the filter for the Servicios_historicos we want to count
     *   }
     * })
    **/
    count<T extends servicios_historicoCountArgs>(
      args?: Subset<T, servicios_historicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicios_historicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios_historico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicios_historicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicios_historicoAggregateArgs>(args: Subset<T, Servicios_historicoAggregateArgs>): Prisma.PrismaPromise<GetServicios_historicoAggregateType<T>>

    /**
     * Group by Servicios_historico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_historicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicios_historicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicios_historicoGroupByArgs['orderBy'] }
        : { orderBy?: servicios_historicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicios_historicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicios_historicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios_historico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicios_historicoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios_historico base type for findUnique actions
   */
  export type servicios_historicoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter, which servicios_historico to fetch.
     */
    where: servicios_historicoWhereUniqueInput
  }

  /**
   * servicios_historico findUnique
   */
  export interface servicios_historicoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_historicoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_historico findUniqueOrThrow
   */
  export type servicios_historicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter, which servicios_historico to fetch.
     */
    where: servicios_historicoWhereUniqueInput
  }


  /**
   * servicios_historico base type for findFirst actions
   */
  export type servicios_historicoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter, which servicios_historico to fetch.
     */
    where?: servicios_historicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_historicos to fetch.
     */
    orderBy?: servicios_historicoOrderByWithRelationInput | servicios_historicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_historicos.
     */
    cursor?: servicios_historicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_historicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_historicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_historicos.
     */
    distinct?: Servicios_historicoScalarFieldEnum | Servicios_historicoScalarFieldEnum[]
  }

  /**
   * servicios_historico findFirst
   */
  export interface servicios_historicoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_historicoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_historico findFirstOrThrow
   */
  export type servicios_historicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter, which servicios_historico to fetch.
     */
    where?: servicios_historicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_historicos to fetch.
     */
    orderBy?: servicios_historicoOrderByWithRelationInput | servicios_historicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_historicos.
     */
    cursor?: servicios_historicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_historicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_historicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_historicos.
     */
    distinct?: Servicios_historicoScalarFieldEnum | Servicios_historicoScalarFieldEnum[]
  }


  /**
   * servicios_historico findMany
   */
  export type servicios_historicoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter, which servicios_historicos to fetch.
     */
    where?: servicios_historicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_historicos to fetch.
     */
    orderBy?: servicios_historicoOrderByWithRelationInput | servicios_historicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios_historicos.
     */
    cursor?: servicios_historicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_historicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_historicos.
     */
    skip?: number
    distinct?: Servicios_historicoScalarFieldEnum | Servicios_historicoScalarFieldEnum[]
  }


  /**
   * servicios_historico create
   */
  export type servicios_historicoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * The data needed to create a servicios_historico.
     */
    data?: XOR<servicios_historicoCreateInput, servicios_historicoUncheckedCreateInput>
  }


  /**
   * servicios_historico createMany
   */
  export type servicios_historicoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios_historicos.
     */
    data: servicios_historicoCreateManyInput | servicios_historicoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicios_historico update
   */
  export type servicios_historicoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * The data needed to update a servicios_historico.
     */
    data: XOR<servicios_historicoUpdateInput, servicios_historicoUncheckedUpdateInput>
    /**
     * Choose, which servicios_historico to update.
     */
    where: servicios_historicoWhereUniqueInput
  }


  /**
   * servicios_historico updateMany
   */
  export type servicios_historicoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios_historicos.
     */
    data: XOR<servicios_historicoUpdateManyMutationInput, servicios_historicoUncheckedUpdateManyInput>
    /**
     * Filter which servicios_historicos to update
     */
    where?: servicios_historicoWhereInput
  }


  /**
   * servicios_historico upsert
   */
  export type servicios_historicoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * The filter to search for the servicios_historico to update in case it exists.
     */
    where: servicios_historicoWhereUniqueInput
    /**
     * In case the servicios_historico found by the `where` argument doesn't exist, create a new servicios_historico with this data.
     */
    create: XOR<servicios_historicoCreateInput, servicios_historicoUncheckedCreateInput>
    /**
     * In case the servicios_historico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicios_historicoUpdateInput, servicios_historicoUncheckedUpdateInput>
  }


  /**
   * servicios_historico delete
   */
  export type servicios_historicoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
    /**
     * Filter which servicios_historico to delete.
     */
    where: servicios_historicoWhereUniqueInput
  }


  /**
   * servicios_historico deleteMany
   */
  export type servicios_historicoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_historicos to delete
     */
    where?: servicios_historicoWhereInput
  }


  /**
   * servicios_historico without action
   */
  export type servicios_historicoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_historico
     */
    select?: servicios_historicoSelect<ExtArgs> | null
  }



  /**
   * Model tareas
   */


  export type AggregateTareas = {
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  export type TareasAvgAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type TareasSumAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type TareasMinAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }

  export type TareasMaxAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }

  export type TareasCountAggregateOutputType = {
    idevents: number
    title: number
    allDay: number
    start: number
    end: number
    priority: number
    _all: number
  }


  export type TareasAvgAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type TareasSumAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type TareasMinAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasMaxAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasCountAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    _all?: true
  }

  export type TareasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas to aggregate.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas
    **/
    _count?: true | TareasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TareasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TareasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TareasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TareasMaxAggregateInputType
  }

  export type GetTareasAggregateType<T extends TareasAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas[P]>
      : GetScalarType<T[P], AggregateTareas[P]>
  }




  export type tareasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tareasWhereInput
    orderBy?: tareasOrderByWithAggregationInput | tareasOrderByWithAggregationInput[]
    by: TareasScalarFieldEnum[] | TareasScalarFieldEnum
    having?: tareasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TareasCountAggregateInputType | true
    _avg?: TareasAvgAggregateInputType
    _sum?: TareasSumAggregateInputType
    _min?: TareasMinAggregateInputType
    _max?: TareasMaxAggregateInputType
  }


  export type TareasGroupByOutputType = {
    idevents: number
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  type GetTareasGroupByPayload<T extends tareasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TareasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TareasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TareasGroupByOutputType[P]>
            : GetScalarType<T[P], TareasGroupByOutputType[P]>
        }
      >
    >


  export type tareasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
  }, ExtArgs["result"]["tareas"]>

  export type tareasSelectScalar = {
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
  }


  type tareasGetPayload<S extends boolean | null | undefined | tareasArgs> = $Types.GetResult<tareasPayload, S>

  type tareasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tareasFindManyArgs, 'select' | 'include'> & {
      select?: TareasCountAggregateInputType | true
    }

  export interface tareasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tareas'], meta: { name: 'tareas' } }
    /**
     * Find zero or one Tareas that matches the filter.
     * @param {tareasFindUniqueArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas'> extends True ? Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tareas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareasFindUniqueOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas'> extends True ? Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tareas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas
     * const tareas = await prisma.tareas.findMany()
     * 
     * // Get first 10 Tareas
     * const tareas = await prisma.tareas.findMany({ take: 10 })
     * 
     * // Only select the `idevents`
     * const tareasWithIdeventsOnly = await prisma.tareas.findMany({ select: { idevents: true } })
     * 
    **/
    findMany<T extends tareasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tareas.
     * @param {tareasCreateArgs} args - Arguments to create a Tareas.
     * @example
     * // Create one Tareas
     * const Tareas = await prisma.tareas.create({
     *   data: {
     *     // ... data to create a Tareas
     *   }
     * })
     * 
    **/
    create<T extends tareasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tareasCreateArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tareas.
     *     @param {tareasCreateManyArgs} args - Arguments to create many Tareas.
     *     @example
     *     // Create many Tareas
     *     const tareas = await prisma.tareas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas.
     * @param {tareasDeleteArgs} args - Arguments to delete one Tareas.
     * @example
     * // Delete one Tareas
     * const Tareas = await prisma.tareas.delete({
     *   where: {
     *     // ... filter to delete one Tareas
     *   }
     * })
     * 
    **/
    delete<T extends tareasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tareasDeleteArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tareas.
     * @param {tareasUpdateArgs} args - Arguments to update one Tareas.
     * @example
     * // Update one Tareas
     * const tareas = await prisma.tareas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpdateArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tareas.
     * @param {tareasDeleteManyArgs} args - Arguments to filter Tareas to delete.
     * @example
     * // Delete a few Tareas
     * const { count } = await prisma.tareas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas
     * const tareas = await prisma.tareas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas.
     * @param {tareasUpsertArgs} args - Arguments to update or create a Tareas.
     * @example
     * // Update or create a Tareas
     * const tareas = await prisma.tareas.upsert({
     *   create: {
     *     // ... data to create a Tareas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas we want to update
     *   }
     * })
    **/
    upsert<T extends tareasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpsertArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasCountArgs} args - Arguments to filter Tareas to count.
     * @example
     * // Count the number of Tareas
     * const count = await prisma.tareas.count({
     *   where: {
     *     // ... the filter for the Tareas we want to count
     *   }
     * })
    **/
    count<T extends tareasCountArgs>(
      args?: Subset<T, tareasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TareasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TareasAggregateArgs>(args: Subset<T, TareasAggregateArgs>): Prisma.PrismaPromise<GetTareasAggregateType<T>>

    /**
     * Group by Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tareasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tareasGroupByArgs['orderBy'] }
        : { orderBy?: tareasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tareasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas base type for findUnique actions
   */
  export type tareasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }

  /**
   * tareas findUnique
   */
  export interface tareasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findUniqueOrThrow
   */
  export type tareasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas base type for findFirst actions
   */
  export type tareasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }

  /**
   * tareas findFirst
   */
  export interface tareasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findFirstOrThrow
   */
  export type tareasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }


  /**
   * tareas findMany
   */
  export type tareasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }


  /**
   * tareas create
   */
  export type tareasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The data needed to create a tareas.
     */
    data?: XOR<tareasCreateInput, tareasUncheckedCreateInput>
  }


  /**
   * tareas createMany
   */
  export type tareasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tareas.
     */
    data: tareasCreateManyInput | tareasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tareas update
   */
  export type tareasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The data needed to update a tareas.
     */
    data: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
    /**
     * Choose, which tareas to update.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas updateMany
   */
  export type tareasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tareas.
     */
    data: XOR<tareasUpdateManyMutationInput, tareasUncheckedUpdateManyInput>
    /**
     * Filter which tareas to update
     */
    where?: tareasWhereInput
  }


  /**
   * tareas upsert
   */
  export type tareasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The filter to search for the tareas to update in case it exists.
     */
    where: tareasWhereUniqueInput
    /**
     * In case the tareas found by the `where` argument doesn't exist, create a new tareas with this data.
     */
    create: XOR<tareasCreateInput, tareasUncheckedCreateInput>
    /**
     * In case the tareas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
  }


  /**
   * tareas delete
   */
  export type tareasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter which tareas to delete.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas deleteMany
   */
  export type tareasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas to delete
     */
    where?: tareasWhereInput
  }


  /**
   * tareas without action
   */
  export type tareasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
  }



  /**
   * Model visitantes
   */


  export type AggregateVisitantes = {
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  export type VisitantesAvgAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesSumAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesMinAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesMaxAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesCountAggregateOutputType = {
    idvisitante: number
    idservicio: number
    nombre: number
    apellido: number
    dni: number
    telefono: number
    parentezco: number
    operador: number
    fecha: number
    temperatura: number
    _all: number
  }


  export type VisitantesAvgAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesSumAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesMinAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesMaxAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesCountAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
    _all?: true
  }

  export type VisitantesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitantes to aggregate.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned visitantes
    **/
    _count?: true | VisitantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitantesMaxAggregateInputType
  }

  export type GetVisitantesAggregateType<T extends VisitantesAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitantes[P]>
      : GetScalarType<T[P], AggregateVisitantes[P]>
  }




  export type visitantesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: visitantesWhereInput
    orderBy?: visitantesOrderByWithAggregationInput | visitantesOrderByWithAggregationInput[]
    by: VisitantesScalarFieldEnum[] | VisitantesScalarFieldEnum
    having?: visitantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitantesCountAggregateInputType | true
    _avg?: VisitantesAvgAggregateInputType
    _sum?: VisitantesSumAggregateInputType
    _min?: VisitantesMinAggregateInputType
    _max?: VisitantesMaxAggregateInputType
  }


  export type VisitantesGroupByOutputType = {
    idvisitante: number
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  type GetVisitantesGroupByPayload<T extends visitantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
            : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
        }
      >
    >


  export type visitantesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idvisitante?: boolean
    idservicio?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    operador?: boolean
    fecha?: boolean
    temperatura?: boolean
  }, ExtArgs["result"]["visitantes"]>

  export type visitantesSelectScalar = {
    idvisitante?: boolean
    idservicio?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    operador?: boolean
    fecha?: boolean
    temperatura?: boolean
  }


  type visitantesGetPayload<S extends boolean | null | undefined | visitantesArgs> = $Types.GetResult<visitantesPayload, S>

  type visitantesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<visitantesFindManyArgs, 'select' | 'include'> & {
      select?: VisitantesCountAggregateInputType | true
    }

  export interface visitantesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['visitantes'], meta: { name: 'visitantes' } }
    /**
     * Find zero or one Visitantes that matches the filter.
     * @param {visitantesFindUniqueArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends visitantesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, visitantesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'visitantes'> extends True ? Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Visitantes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {visitantesFindUniqueOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends visitantesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends visitantesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, visitantesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'visitantes'> extends True ? Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Visitantes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends visitantesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitantes
     * const visitantes = await prisma.visitantes.findMany()
     * 
     * // Get first 10 Visitantes
     * const visitantes = await prisma.visitantes.findMany({ take: 10 })
     * 
     * // Only select the `idvisitante`
     * const visitantesWithIdvisitanteOnly = await prisma.visitantes.findMany({ select: { idvisitante: true } })
     * 
    **/
    findMany<T extends visitantesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Visitantes.
     * @param {visitantesCreateArgs} args - Arguments to create a Visitantes.
     * @example
     * // Create one Visitantes
     * const Visitantes = await prisma.visitantes.create({
     *   data: {
     *     // ... data to create a Visitantes
     *   }
     * })
     * 
    **/
    create<T extends visitantesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesCreateArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Visitantes.
     *     @param {visitantesCreateManyArgs} args - Arguments to create many Visitantes.
     *     @example
     *     // Create many Visitantes
     *     const visitantes = await prisma.visitantes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends visitantesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitantes.
     * @param {visitantesDeleteArgs} args - Arguments to delete one Visitantes.
     * @example
     * // Delete one Visitantes
     * const Visitantes = await prisma.visitantes.delete({
     *   where: {
     *     // ... filter to delete one Visitantes
     *   }
     * })
     * 
    **/
    delete<T extends visitantesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesDeleteArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Visitantes.
     * @param {visitantesUpdateArgs} args - Arguments to update one Visitantes.
     * @example
     * // Update one Visitantes
     * const visitantes = await prisma.visitantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends visitantesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpdateArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Visitantes.
     * @param {visitantesDeleteManyArgs} args - Arguments to filter Visitantes to delete.
     * @example
     * // Delete a few Visitantes
     * const { count } = await prisma.visitantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends visitantesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitantes
     * const visitantes = await prisma.visitantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends visitantesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitantes.
     * @param {visitantesUpsertArgs} args - Arguments to update or create a Visitantes.
     * @example
     * // Update or create a Visitantes
     * const visitantes = await prisma.visitantes.upsert({
     *   create: {
     *     // ... data to create a Visitantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitantes we want to update
     *   }
     * })
    **/
    upsert<T extends visitantesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpsertArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesCountArgs} args - Arguments to filter Visitantes to count.
     * @example
     * // Count the number of Visitantes
     * const count = await prisma.visitantes.count({
     *   where: {
     *     // ... the filter for the Visitantes we want to count
     *   }
     * })
    **/
    count<T extends visitantesCountArgs>(
      args?: Subset<T, visitantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitantesAggregateArgs>(args: Subset<T, VisitantesAggregateArgs>): Prisma.PrismaPromise<GetVisitantesAggregateType<T>>

    /**
     * Group by Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends visitantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: visitantesGroupByArgs['orderBy'] }
        : { orderBy?: visitantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, visitantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for visitantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__visitantesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * visitantes base type for findUnique actions
   */
  export type visitantesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }

  /**
   * visitantes findUnique
   */
  export interface visitantesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends visitantesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findUniqueOrThrow
   */
  export type visitantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes base type for findFirst actions
   */
  export type visitantesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }

  /**
   * visitantes findFirst
   */
  export interface visitantesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends visitantesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findFirstOrThrow
   */
  export type visitantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }


  /**
   * visitantes findMany
   */
  export type visitantesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }


  /**
   * visitantes create
   */
  export type visitantesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The data needed to create a visitantes.
     */
    data?: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
  }


  /**
   * visitantes createMany
   */
  export type visitantesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many visitantes.
     */
    data: visitantesCreateManyInput | visitantesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * visitantes update
   */
  export type visitantesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The data needed to update a visitantes.
     */
    data: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
    /**
     * Choose, which visitantes to update.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes updateMany
   */
  export type visitantesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update visitantes.
     */
    data: XOR<visitantesUpdateManyMutationInput, visitantesUncheckedUpdateManyInput>
    /**
     * Filter which visitantes to update
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes upsert
   */
  export type visitantesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The filter to search for the visitantes to update in case it exists.
     */
    where: visitantesWhereUniqueInput
    /**
     * In case the visitantes found by the `where` argument doesn't exist, create a new visitantes with this data.
     */
    create: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
    /**
     * In case the visitantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
  }


  /**
   * visitantes delete
   */
  export type visitantesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter which visitantes to delete.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes deleteMany
   */
  export type visitantesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitantes to delete
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes without action
   */
  export type visitantesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
  }



  /**
   * Model informe_gastos
   */


  export type AggregateInforme_gastos = {
    _count: Informe_gastosCountAggregateOutputType | null
    _avg: Informe_gastosAvgAggregateOutputType | null
    _sum: Informe_gastosSumAggregateOutputType | null
    _min: Informe_gastosMinAggregateOutputType | null
    _max: Informe_gastosMaxAggregateOutputType | null
  }

  export type Informe_gastosAvgAggregateOutputType = {
    idgastos: number | null
    idinforme: number | null
    idservicio: number | null
    importe: number | null
  }

  export type Informe_gastosSumAggregateOutputType = {
    idgastos: number | null
    idinforme: number | null
    idservicio: number | null
    importe: number | null
  }

  export type Informe_gastosMinAggregateOutputType = {
    idgastos: number | null
    idinforme: number | null
    idservicio: number | null
    gasto: string | null
    observacion: string | null
    importe: number | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operadorliq: string | null
  }

  export type Informe_gastosMaxAggregateOutputType = {
    idgastos: number | null
    idinforme: number | null
    idservicio: number | null
    gasto: string | null
    observacion: string | null
    importe: number | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operadorliq: string | null
  }

  export type Informe_gastosCountAggregateOutputType = {
    idgastos: number
    idinforme: number
    idservicio: number
    gasto: number
    observacion: number
    importe: number
    liquidado: number
    fecha_liquidado: number
    operadorliq: number
    _all: number
  }


  export type Informe_gastosAvgAggregateInputType = {
    idgastos?: true
    idinforme?: true
    idservicio?: true
    importe?: true
  }

  export type Informe_gastosSumAggregateInputType = {
    idgastos?: true
    idinforme?: true
    idservicio?: true
    importe?: true
  }

  export type Informe_gastosMinAggregateInputType = {
    idgastos?: true
    idinforme?: true
    idservicio?: true
    gasto?: true
    observacion?: true
    importe?: true
    liquidado?: true
    fecha_liquidado?: true
    operadorliq?: true
  }

  export type Informe_gastosMaxAggregateInputType = {
    idgastos?: true
    idinforme?: true
    idservicio?: true
    gasto?: true
    observacion?: true
    importe?: true
    liquidado?: true
    fecha_liquidado?: true
    operadorliq?: true
  }

  export type Informe_gastosCountAggregateInputType = {
    idgastos?: true
    idinforme?: true
    idservicio?: true
    gasto?: true
    observacion?: true
    importe?: true
    liquidado?: true
    fecha_liquidado?: true
    operadorliq?: true
    _all?: true
  }

  export type Informe_gastosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which informe_gastos to aggregate.
     */
    where?: informe_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_gastos to fetch.
     */
    orderBy?: informe_gastosOrderByWithRelationInput | informe_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: informe_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned informe_gastos
    **/
    _count?: true | Informe_gastosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Informe_gastosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Informe_gastosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Informe_gastosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Informe_gastosMaxAggregateInputType
  }

  export type GetInforme_gastosAggregateType<T extends Informe_gastosAggregateArgs> = {
        [P in keyof T & keyof AggregateInforme_gastos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInforme_gastos[P]>
      : GetScalarType<T[P], AggregateInforme_gastos[P]>
  }




  export type informe_gastosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: informe_gastosWhereInput
    orderBy?: informe_gastosOrderByWithAggregationInput | informe_gastosOrderByWithAggregationInput[]
    by: Informe_gastosScalarFieldEnum[] | Informe_gastosScalarFieldEnum
    having?: informe_gastosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Informe_gastosCountAggregateInputType | true
    _avg?: Informe_gastosAvgAggregateInputType
    _sum?: Informe_gastosSumAggregateInputType
    _min?: Informe_gastosMinAggregateInputType
    _max?: Informe_gastosMaxAggregateInputType
  }


  export type Informe_gastosGroupByOutputType = {
    idgastos: number
    idinforme: number | null
    idservicio: number | null
    gasto: string | null
    observacion: string | null
    importe: number | null
    liquidado: boolean | null
    fecha_liquidado: Date | null
    operadorliq: string | null
    _count: Informe_gastosCountAggregateOutputType | null
    _avg: Informe_gastosAvgAggregateOutputType | null
    _sum: Informe_gastosSumAggregateOutputType | null
    _min: Informe_gastosMinAggregateOutputType | null
    _max: Informe_gastosMaxAggregateOutputType | null
  }

  type GetInforme_gastosGroupByPayload<T extends informe_gastosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Informe_gastosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Informe_gastosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Informe_gastosGroupByOutputType[P]>
            : GetScalarType<T[P], Informe_gastosGroupByOutputType[P]>
        }
      >
    >


  export type informe_gastosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    idinforme?: boolean
    idservicio?: boolean
    gasto?: boolean
    observacion?: boolean
    importe?: boolean
    liquidado?: boolean
    fecha_liquidado?: boolean
    operadorliq?: boolean
  }, ExtArgs["result"]["informe_gastos"]>

  export type informe_gastosSelectScalar = {
    idgastos?: boolean
    idinforme?: boolean
    idservicio?: boolean
    gasto?: boolean
    observacion?: boolean
    importe?: boolean
    liquidado?: boolean
    fecha_liquidado?: boolean
    operadorliq?: boolean
  }


  type informe_gastosGetPayload<S extends boolean | null | undefined | informe_gastosArgs> = $Types.GetResult<informe_gastosPayload, S>

  type informe_gastosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<informe_gastosFindManyArgs, 'select' | 'include'> & {
      select?: Informe_gastosCountAggregateInputType | true
    }

  export interface informe_gastosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['informe_gastos'], meta: { name: 'informe_gastos' } }
    /**
     * Find zero or one Informe_gastos that matches the filter.
     * @param {informe_gastosFindUniqueArgs} args - Arguments to find a Informe_gastos
     * @example
     * // Get one Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends informe_gastosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, informe_gastosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'informe_gastos'> extends True ? Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Informe_gastos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {informe_gastosFindUniqueOrThrowArgs} args - Arguments to find a Informe_gastos
     * @example
     * // Get one Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends informe_gastosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_gastosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Informe_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosFindFirstArgs} args - Arguments to find a Informe_gastos
     * @example
     * // Get one Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends informe_gastosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, informe_gastosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'informe_gastos'> extends True ? Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Informe_gastos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosFindFirstOrThrowArgs} args - Arguments to find a Informe_gastos
     * @example
     * // Get one Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends informe_gastosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_gastosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Informe_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findMany()
     * 
     * // Get first 10 Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const informe_gastosWithIdgastosOnly = await prisma.informe_gastos.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends informe_gastosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_gastosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Informe_gastos.
     * @param {informe_gastosCreateArgs} args - Arguments to create a Informe_gastos.
     * @example
     * // Create one Informe_gastos
     * const Informe_gastos = await prisma.informe_gastos.create({
     *   data: {
     *     // ... data to create a Informe_gastos
     *   }
     * })
     * 
    **/
    create<T extends informe_gastosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, informe_gastosCreateArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Informe_gastos.
     *     @param {informe_gastosCreateManyArgs} args - Arguments to create many Informe_gastos.
     *     @example
     *     // Create many Informe_gastos
     *     const informe_gastos = await prisma.informe_gastos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends informe_gastosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_gastosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Informe_gastos.
     * @param {informe_gastosDeleteArgs} args - Arguments to delete one Informe_gastos.
     * @example
     * // Delete one Informe_gastos
     * const Informe_gastos = await prisma.informe_gastos.delete({
     *   where: {
     *     // ... filter to delete one Informe_gastos
     *   }
     * })
     * 
    **/
    delete<T extends informe_gastosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, informe_gastosDeleteArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Informe_gastos.
     * @param {informe_gastosUpdateArgs} args - Arguments to update one Informe_gastos.
     * @example
     * // Update one Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends informe_gastosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, informe_gastosUpdateArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Informe_gastos.
     * @param {informe_gastosDeleteManyArgs} args - Arguments to filter Informe_gastos to delete.
     * @example
     * // Delete a few Informe_gastos
     * const { count } = await prisma.informe_gastos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends informe_gastosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, informe_gastosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Informe_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends informe_gastosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, informe_gastosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Informe_gastos.
     * @param {informe_gastosUpsertArgs} args - Arguments to update or create a Informe_gastos.
     * @example
     * // Update or create a Informe_gastos
     * const informe_gastos = await prisma.informe_gastos.upsert({
     *   create: {
     *     // ... data to create a Informe_gastos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Informe_gastos we want to update
     *   }
     * })
    **/
    upsert<T extends informe_gastosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, informe_gastosUpsertArgs<ExtArgs>>
    ): Prisma__informe_gastosClient<$Types.GetResult<informe_gastosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Informe_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosCountArgs} args - Arguments to filter Informe_gastos to count.
     * @example
     * // Count the number of Informe_gastos
     * const count = await prisma.informe_gastos.count({
     *   where: {
     *     // ... the filter for the Informe_gastos we want to count
     *   }
     * })
    **/
    count<T extends informe_gastosCountArgs>(
      args?: Subset<T, informe_gastosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Informe_gastosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Informe_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Informe_gastosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Informe_gastosAggregateArgs>(args: Subset<T, Informe_gastosAggregateArgs>): Prisma.PrismaPromise<GetInforme_gastosAggregateType<T>>

    /**
     * Group by Informe_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {informe_gastosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends informe_gastosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: informe_gastosGroupByArgs['orderBy'] }
        : { orderBy?: informe_gastosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, informe_gastosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInforme_gastosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for informe_gastos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__informe_gastosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * informe_gastos base type for findUnique actions
   */
  export type informe_gastosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter, which informe_gastos to fetch.
     */
    where: informe_gastosWhereUniqueInput
  }

  /**
   * informe_gastos findUnique
   */
  export interface informe_gastosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends informe_gastosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * informe_gastos findUniqueOrThrow
   */
  export type informe_gastosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter, which informe_gastos to fetch.
     */
    where: informe_gastosWhereUniqueInput
  }


  /**
   * informe_gastos base type for findFirst actions
   */
  export type informe_gastosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter, which informe_gastos to fetch.
     */
    where?: informe_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_gastos to fetch.
     */
    orderBy?: informe_gastosOrderByWithRelationInput | informe_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for informe_gastos.
     */
    cursor?: informe_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of informe_gastos.
     */
    distinct?: Informe_gastosScalarFieldEnum | Informe_gastosScalarFieldEnum[]
  }

  /**
   * informe_gastos findFirst
   */
  export interface informe_gastosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends informe_gastosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * informe_gastos findFirstOrThrow
   */
  export type informe_gastosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter, which informe_gastos to fetch.
     */
    where?: informe_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_gastos to fetch.
     */
    orderBy?: informe_gastosOrderByWithRelationInput | informe_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for informe_gastos.
     */
    cursor?: informe_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of informe_gastos.
     */
    distinct?: Informe_gastosScalarFieldEnum | Informe_gastosScalarFieldEnum[]
  }


  /**
   * informe_gastos findMany
   */
  export type informe_gastosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter, which informe_gastos to fetch.
     */
    where?: informe_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of informe_gastos to fetch.
     */
    orderBy?: informe_gastosOrderByWithRelationInput | informe_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing informe_gastos.
     */
    cursor?: informe_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` informe_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` informe_gastos.
     */
    skip?: number
    distinct?: Informe_gastosScalarFieldEnum | Informe_gastosScalarFieldEnum[]
  }


  /**
   * informe_gastos create
   */
  export type informe_gastosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * The data needed to create a informe_gastos.
     */
    data?: XOR<informe_gastosCreateInput, informe_gastosUncheckedCreateInput>
  }


  /**
   * informe_gastos createMany
   */
  export type informe_gastosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many informe_gastos.
     */
    data: informe_gastosCreateManyInput | informe_gastosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * informe_gastos update
   */
  export type informe_gastosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * The data needed to update a informe_gastos.
     */
    data: XOR<informe_gastosUpdateInput, informe_gastosUncheckedUpdateInput>
    /**
     * Choose, which informe_gastos to update.
     */
    where: informe_gastosWhereUniqueInput
  }


  /**
   * informe_gastos updateMany
   */
  export type informe_gastosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update informe_gastos.
     */
    data: XOR<informe_gastosUpdateManyMutationInput, informe_gastosUncheckedUpdateManyInput>
    /**
     * Filter which informe_gastos to update
     */
    where?: informe_gastosWhereInput
  }


  /**
   * informe_gastos upsert
   */
  export type informe_gastosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * The filter to search for the informe_gastos to update in case it exists.
     */
    where: informe_gastosWhereUniqueInput
    /**
     * In case the informe_gastos found by the `where` argument doesn't exist, create a new informe_gastos with this data.
     */
    create: XOR<informe_gastosCreateInput, informe_gastosUncheckedCreateInput>
    /**
     * In case the informe_gastos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<informe_gastosUpdateInput, informe_gastosUncheckedUpdateInput>
  }


  /**
   * informe_gastos delete
   */
  export type informe_gastosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
    /**
     * Filter which informe_gastos to delete.
     */
    where: informe_gastosWhereUniqueInput
  }


  /**
   * informe_gastos deleteMany
   */
  export type informe_gastosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which informe_gastos to delete
     */
    where?: informe_gastosWhereInput
  }


  /**
   * informe_gastos without action
   */
  export type informe_gastosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the informe_gastos
     */
    select?: informe_gastosSelect<ExtArgs> | null
  }



  /**
   * Model servicios_gastos
   */


  export type AggregateServicios_gastos = {
    _count: Servicios_gastosCountAggregateOutputType | null
    _avg: Servicios_gastosAvgAggregateOutputType | null
    _sum: Servicios_gastosSumAggregateOutputType | null
    _min: Servicios_gastosMinAggregateOutputType | null
    _max: Servicios_gastosMaxAggregateOutputType | null
  }

  export type Servicios_gastosAvgAggregateOutputType = {
    idgastos: number | null
  }

  export type Servicios_gastosSumAggregateOutputType = {
    idgastos: number | null
  }

  export type Servicios_gastosMinAggregateOutputType = {
    idgastos: number | null
    gastos: string | null
    observacion: string | null
  }

  export type Servicios_gastosMaxAggregateOutputType = {
    idgastos: number | null
    gastos: string | null
    observacion: string | null
  }

  export type Servicios_gastosCountAggregateOutputType = {
    idgastos: number
    gastos: number
    observacion: number
    _all: number
  }


  export type Servicios_gastosAvgAggregateInputType = {
    idgastos?: true
  }

  export type Servicios_gastosSumAggregateInputType = {
    idgastos?: true
  }

  export type Servicios_gastosMinAggregateInputType = {
    idgastos?: true
    gastos?: true
    observacion?: true
  }

  export type Servicios_gastosMaxAggregateInputType = {
    idgastos?: true
    gastos?: true
    observacion?: true
  }

  export type Servicios_gastosCountAggregateInputType = {
    idgastos?: true
    gastos?: true
    observacion?: true
    _all?: true
  }

  export type Servicios_gastosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_gastos to aggregate.
     */
    where?: servicios_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_gastos to fetch.
     */
    orderBy?: servicios_gastosOrderByWithRelationInput | servicios_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicios_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios_gastos
    **/
    _count?: true | Servicios_gastosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicios_gastosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicios_gastosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicios_gastosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicios_gastosMaxAggregateInputType
  }

  export type GetServicios_gastosAggregateType<T extends Servicios_gastosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios_gastos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios_gastos[P]>
      : GetScalarType<T[P], AggregateServicios_gastos[P]>
  }




  export type servicios_gastosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicios_gastosWhereInput
    orderBy?: servicios_gastosOrderByWithAggregationInput | servicios_gastosOrderByWithAggregationInput[]
    by: Servicios_gastosScalarFieldEnum[] | Servicios_gastosScalarFieldEnum
    having?: servicios_gastosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicios_gastosCountAggregateInputType | true
    _avg?: Servicios_gastosAvgAggregateInputType
    _sum?: Servicios_gastosSumAggregateInputType
    _min?: Servicios_gastosMinAggregateInputType
    _max?: Servicios_gastosMaxAggregateInputType
  }


  export type Servicios_gastosGroupByOutputType = {
    idgastos: number
    gastos: string | null
    observacion: string | null
    _count: Servicios_gastosCountAggregateOutputType | null
    _avg: Servicios_gastosAvgAggregateOutputType | null
    _sum: Servicios_gastosSumAggregateOutputType | null
    _min: Servicios_gastosMinAggregateOutputType | null
    _max: Servicios_gastosMaxAggregateOutputType | null
  }

  type GetServicios_gastosGroupByPayload<T extends servicios_gastosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicios_gastosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicios_gastosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicios_gastosGroupByOutputType[P]>
            : GetScalarType<T[P], Servicios_gastosGroupByOutputType[P]>
        }
      >
    >


  export type servicios_gastosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    gastos?: boolean
    observacion?: boolean
  }, ExtArgs["result"]["servicios_gastos"]>

  export type servicios_gastosSelectScalar = {
    idgastos?: boolean
    gastos?: boolean
    observacion?: boolean
  }


  type servicios_gastosGetPayload<S extends boolean | null | undefined | servicios_gastosArgs> = $Types.GetResult<servicios_gastosPayload, S>

  type servicios_gastosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicios_gastosFindManyArgs, 'select' | 'include'> & {
      select?: Servicios_gastosCountAggregateInputType | true
    }

  export interface servicios_gastosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios_gastos'], meta: { name: 'servicios_gastos' } }
    /**
     * Find zero or one Servicios_gastos that matches the filter.
     * @param {servicios_gastosFindUniqueArgs} args - Arguments to find a Servicios_gastos
     * @example
     * // Get one Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicios_gastosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicios_gastosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios_gastos'> extends True ? Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicios_gastos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicios_gastosFindUniqueOrThrowArgs} args - Arguments to find a Servicios_gastos
     * @example
     * // Get one Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicios_gastosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_gastosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicios_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosFindFirstArgs} args - Arguments to find a Servicios_gastos
     * @example
     * // Get one Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicios_gastosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicios_gastosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios_gastos'> extends True ? Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicios_gastos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosFindFirstOrThrowArgs} args - Arguments to find a Servicios_gastos
     * @example
     * // Get one Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicios_gastosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_gastosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findMany()
     * 
     * // Get first 10 Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const servicios_gastosWithIdgastosOnly = await prisma.servicios_gastos.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends servicios_gastosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_gastosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicios_gastos.
     * @param {servicios_gastosCreateArgs} args - Arguments to create a Servicios_gastos.
     * @example
     * // Create one Servicios_gastos
     * const Servicios_gastos = await prisma.servicios_gastos.create({
     *   data: {
     *     // ... data to create a Servicios_gastos
     *   }
     * })
     * 
    **/
    create<T extends servicios_gastosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_gastosCreateArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios_gastos.
     *     @param {servicios_gastosCreateManyArgs} args - Arguments to create many Servicios_gastos.
     *     @example
     *     // Create many Servicios_gastos
     *     const servicios_gastos = await prisma.servicios_gastos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicios_gastosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_gastosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios_gastos.
     * @param {servicios_gastosDeleteArgs} args - Arguments to delete one Servicios_gastos.
     * @example
     * // Delete one Servicios_gastos
     * const Servicios_gastos = await prisma.servicios_gastos.delete({
     *   where: {
     *     // ... filter to delete one Servicios_gastos
     *   }
     * })
     * 
    **/
    delete<T extends servicios_gastosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_gastosDeleteArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicios_gastos.
     * @param {servicios_gastosUpdateArgs} args - Arguments to update one Servicios_gastos.
     * @example
     * // Update one Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicios_gastosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_gastosUpdateArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios_gastos.
     * @param {servicios_gastosDeleteManyArgs} args - Arguments to filter Servicios_gastos to delete.
     * @example
     * // Delete a few Servicios_gastos
     * const { count } = await prisma.servicios_gastos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicios_gastosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_gastosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicios_gastosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_gastosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios_gastos.
     * @param {servicios_gastosUpsertArgs} args - Arguments to update or create a Servicios_gastos.
     * @example
     * // Update or create a Servicios_gastos
     * const servicios_gastos = await prisma.servicios_gastos.upsert({
     *   create: {
     *     // ... data to create a Servicios_gastos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios_gastos we want to update
     *   }
     * })
    **/
    upsert<T extends servicios_gastosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_gastosUpsertArgs<ExtArgs>>
    ): Prisma__servicios_gastosClient<$Types.GetResult<servicios_gastosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicios_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosCountArgs} args - Arguments to filter Servicios_gastos to count.
     * @example
     * // Count the number of Servicios_gastos
     * const count = await prisma.servicios_gastos.count({
     *   where: {
     *     // ... the filter for the Servicios_gastos we want to count
     *   }
     * })
    **/
    count<T extends servicios_gastosCountArgs>(
      args?: Subset<T, servicios_gastosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicios_gastosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicios_gastosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicios_gastosAggregateArgs>(args: Subset<T, Servicios_gastosAggregateArgs>): Prisma.PrismaPromise<GetServicios_gastosAggregateType<T>>

    /**
     * Group by Servicios_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_gastosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicios_gastosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicios_gastosGroupByArgs['orderBy'] }
        : { orderBy?: servicios_gastosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicios_gastosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicios_gastosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios_gastos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicios_gastosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios_gastos base type for findUnique actions
   */
  export type servicios_gastosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicios_gastos to fetch.
     */
    where: servicios_gastosWhereUniqueInput
  }

  /**
   * servicios_gastos findUnique
   */
  export interface servicios_gastosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_gastosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_gastos findUniqueOrThrow
   */
  export type servicios_gastosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicios_gastos to fetch.
     */
    where: servicios_gastosWhereUniqueInput
  }


  /**
   * servicios_gastos base type for findFirst actions
   */
  export type servicios_gastosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicios_gastos to fetch.
     */
    where?: servicios_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_gastos to fetch.
     */
    orderBy?: servicios_gastosOrderByWithRelationInput | servicios_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_gastos.
     */
    cursor?: servicios_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_gastos.
     */
    distinct?: Servicios_gastosScalarFieldEnum | Servicios_gastosScalarFieldEnum[]
  }

  /**
   * servicios_gastos findFirst
   */
  export interface servicios_gastosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_gastosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_gastos findFirstOrThrow
   */
  export type servicios_gastosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicios_gastos to fetch.
     */
    where?: servicios_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_gastos to fetch.
     */
    orderBy?: servicios_gastosOrderByWithRelationInput | servicios_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_gastos.
     */
    cursor?: servicios_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_gastos.
     */
    distinct?: Servicios_gastosScalarFieldEnum | Servicios_gastosScalarFieldEnum[]
  }


  /**
   * servicios_gastos findMany
   */
  export type servicios_gastosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicios_gastos to fetch.
     */
    where?: servicios_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_gastos to fetch.
     */
    orderBy?: servicios_gastosOrderByWithRelationInput | servicios_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios_gastos.
     */
    cursor?: servicios_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_gastos.
     */
    skip?: number
    distinct?: Servicios_gastosScalarFieldEnum | Servicios_gastosScalarFieldEnum[]
  }


  /**
   * servicios_gastos create
   */
  export type servicios_gastosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * The data needed to create a servicios_gastos.
     */
    data?: XOR<servicios_gastosCreateInput, servicios_gastosUncheckedCreateInput>
  }


  /**
   * servicios_gastos createMany
   */
  export type servicios_gastosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios_gastos.
     */
    data: servicios_gastosCreateManyInput | servicios_gastosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicios_gastos update
   */
  export type servicios_gastosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * The data needed to update a servicios_gastos.
     */
    data: XOR<servicios_gastosUpdateInput, servicios_gastosUncheckedUpdateInput>
    /**
     * Choose, which servicios_gastos to update.
     */
    where: servicios_gastosWhereUniqueInput
  }


  /**
   * servicios_gastos updateMany
   */
  export type servicios_gastosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios_gastos.
     */
    data: XOR<servicios_gastosUpdateManyMutationInput, servicios_gastosUncheckedUpdateManyInput>
    /**
     * Filter which servicios_gastos to update
     */
    where?: servicios_gastosWhereInput
  }


  /**
   * servicios_gastos upsert
   */
  export type servicios_gastosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * The filter to search for the servicios_gastos to update in case it exists.
     */
    where: servicios_gastosWhereUniqueInput
    /**
     * In case the servicios_gastos found by the `where` argument doesn't exist, create a new servicios_gastos with this data.
     */
    create: XOR<servicios_gastosCreateInput, servicios_gastosUncheckedCreateInput>
    /**
     * In case the servicios_gastos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicios_gastosUpdateInput, servicios_gastosUncheckedUpdateInput>
  }


  /**
   * servicios_gastos delete
   */
  export type servicios_gastosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
    /**
     * Filter which servicios_gastos to delete.
     */
    where: servicios_gastosWhereUniqueInput
  }


  /**
   * servicios_gastos deleteMany
   */
  export type servicios_gastosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_gastos to delete
     */
    where?: servicios_gastosWhereInput
  }


  /**
   * servicios_gastos without action
   */
  export type servicios_gastosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_gastos
     */
    select?: servicios_gastosSelect<ExtArgs> | null
  }



  /**
   * Model liquidacion_guardias
   */


  export type AggregateLiquidacion_guardias = {
    _count: Liquidacion_guardiasCountAggregateOutputType | null
    _avg: Liquidacion_guardiasAvgAggregateOutputType | null
    _sum: Liquidacion_guardiasSumAggregateOutputType | null
    _min: Liquidacion_guardiasMinAggregateOutputType | null
    _max: Liquidacion_guardiasMaxAggregateOutputType | null
  }

  export type Liquidacion_guardiasAvgAggregateOutputType = {
    idturno: number | null
    horas: number | null
    mes: number | null
    ano: number | null
    liquidado: number | null
    aprobado: number | null
    importe: number | null
  }

  export type Liquidacion_guardiasSumAggregateOutputType = {
    idturno: number | null
    horas: number | null
    mes: number | null
    ano: number | null
    liquidado: number | null
    aprobado: number | null
    importe: number | null
  }

  export type Liquidacion_guardiasMinAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    operador: string | null
    mes: number | null
    ano: number | null
    feriado: boolean | null
    liquidado: number | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
    aprobado: number | null
    fecha_aprobacion: Date | null
    operadorap: string | null
    importe: number | null
  }

  export type Liquidacion_guardiasMaxAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    operador: string | null
    mes: number | null
    ano: number | null
    feriado: boolean | null
    liquidado: number | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
    aprobado: number | null
    fecha_aprobacion: Date | null
    operadorap: string | null
    importe: number | null
  }

  export type Liquidacion_guardiasCountAggregateOutputType = {
    idturno: number
    lugar: number
    inicio: number
    fin: number
    horas: number
    operador: number
    mes: number
    ano: number
    feriado: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    aprobado: number
    fecha_aprobacion: number
    operadorap: number
    importe: number
    _all: number
  }


  export type Liquidacion_guardiasAvgAggregateInputType = {
    idturno?: true
    horas?: true
    mes?: true
    ano?: true
    liquidado?: true
    aprobado?: true
    importe?: true
  }

  export type Liquidacion_guardiasSumAggregateInputType = {
    idturno?: true
    horas?: true
    mes?: true
    ano?: true
    liquidado?: true
    aprobado?: true
    importe?: true
  }

  export type Liquidacion_guardiasMinAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes?: true
    ano?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    importe?: true
  }

  export type Liquidacion_guardiasMaxAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes?: true
    ano?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    importe?: true
  }

  export type Liquidacion_guardiasCountAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes?: true
    ano?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    importe?: true
    _all?: true
  }

  export type Liquidacion_guardiasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liquidacion_guardias to aggregate.
     */
    where?: liquidacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_guardias to fetch.
     */
    orderBy?: liquidacion_guardiasOrderByWithRelationInput | liquidacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: liquidacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned liquidacion_guardias
    **/
    _count?: true | Liquidacion_guardiasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Liquidacion_guardiasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Liquidacion_guardiasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Liquidacion_guardiasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Liquidacion_guardiasMaxAggregateInputType
  }

  export type GetLiquidacion_guardiasAggregateType<T extends Liquidacion_guardiasAggregateArgs> = {
        [P in keyof T & keyof AggregateLiquidacion_guardias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiquidacion_guardias[P]>
      : GetScalarType<T[P], AggregateLiquidacion_guardias[P]>
  }




  export type liquidacion_guardiasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: liquidacion_guardiasWhereInput
    orderBy?: liquidacion_guardiasOrderByWithAggregationInput | liquidacion_guardiasOrderByWithAggregationInput[]
    by: Liquidacion_guardiasScalarFieldEnum[] | Liquidacion_guardiasScalarFieldEnum
    having?: liquidacion_guardiasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Liquidacion_guardiasCountAggregateInputType | true
    _avg?: Liquidacion_guardiasAvgAggregateInputType
    _sum?: Liquidacion_guardiasSumAggregateInputType
    _min?: Liquidacion_guardiasMinAggregateInputType
    _max?: Liquidacion_guardiasMaxAggregateInputType
  }


  export type Liquidacion_guardiasGroupByOutputType = {
    idturno: number
    lugar: string | null
    inicio: string | null
    fin: string | null
    horas: number | null
    operador: string | null
    mes: number | null
    ano: number | null
    feriado: boolean | null
    liquidado: number | null
    fecha_liquidacion: Date | null
    operadorliq: string | null
    aprobado: number | null
    fecha_aprobacion: Date | null
    operadorap: string | null
    importe: number | null
    _count: Liquidacion_guardiasCountAggregateOutputType | null
    _avg: Liquidacion_guardiasAvgAggregateOutputType | null
    _sum: Liquidacion_guardiasSumAggregateOutputType | null
    _min: Liquidacion_guardiasMinAggregateOutputType | null
    _max: Liquidacion_guardiasMaxAggregateOutputType | null
  }

  type GetLiquidacion_guardiasGroupByPayload<T extends liquidacion_guardiasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Liquidacion_guardiasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Liquidacion_guardiasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Liquidacion_guardiasGroupByOutputType[P]>
            : GetScalarType<T[P], Liquidacion_guardiasGroupByOutputType[P]>
        }
      >
    >


  export type liquidacion_guardiasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idturno?: boolean
    lugar?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    operador?: boolean
    mes?: boolean
    ano?: boolean
    feriado?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    importe?: boolean
  }, ExtArgs["result"]["liquidacion_guardias"]>

  export type liquidacion_guardiasSelectScalar = {
    idturno?: boolean
    lugar?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    operador?: boolean
    mes?: boolean
    ano?: boolean
    feriado?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    importe?: boolean
  }


  type liquidacion_guardiasGetPayload<S extends boolean | null | undefined | liquidacion_guardiasArgs> = $Types.GetResult<liquidacion_guardiasPayload, S>

  type liquidacion_guardiasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<liquidacion_guardiasFindManyArgs, 'select' | 'include'> & {
      select?: Liquidacion_guardiasCountAggregateInputType | true
    }

  export interface liquidacion_guardiasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['liquidacion_guardias'], meta: { name: 'liquidacion_guardias' } }
    /**
     * Find zero or one Liquidacion_guardias that matches the filter.
     * @param {liquidacion_guardiasFindUniqueArgs} args - Arguments to find a Liquidacion_guardias
     * @example
     * // Get one Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends liquidacion_guardiasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, liquidacion_guardiasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'liquidacion_guardias'> extends True ? Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Liquidacion_guardias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {liquidacion_guardiasFindUniqueOrThrowArgs} args - Arguments to find a Liquidacion_guardias
     * @example
     * // Get one Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends liquidacion_guardiasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_guardiasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Liquidacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasFindFirstArgs} args - Arguments to find a Liquidacion_guardias
     * @example
     * // Get one Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends liquidacion_guardiasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, liquidacion_guardiasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'liquidacion_guardias'> extends True ? Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Liquidacion_guardias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasFindFirstOrThrowArgs} args - Arguments to find a Liquidacion_guardias
     * @example
     * // Get one Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends liquidacion_guardiasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_guardiasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Liquidacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findMany()
     * 
     * // Get first 10 Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.findMany({ take: 10 })
     * 
     * // Only select the `idturno`
     * const liquidacion_guardiasWithIdturnoOnly = await prisma.liquidacion_guardias.findMany({ select: { idturno: true } })
     * 
    **/
    findMany<T extends liquidacion_guardiasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_guardiasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Liquidacion_guardias.
     * @param {liquidacion_guardiasCreateArgs} args - Arguments to create a Liquidacion_guardias.
     * @example
     * // Create one Liquidacion_guardias
     * const Liquidacion_guardias = await prisma.liquidacion_guardias.create({
     *   data: {
     *     // ... data to create a Liquidacion_guardias
     *   }
     * })
     * 
    **/
    create<T extends liquidacion_guardiasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_guardiasCreateArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Liquidacion_guardias.
     *     @param {liquidacion_guardiasCreateManyArgs} args - Arguments to create many Liquidacion_guardias.
     *     @example
     *     // Create many Liquidacion_guardias
     *     const liquidacion_guardias = await prisma.liquidacion_guardias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends liquidacion_guardiasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_guardiasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Liquidacion_guardias.
     * @param {liquidacion_guardiasDeleteArgs} args - Arguments to delete one Liquidacion_guardias.
     * @example
     * // Delete one Liquidacion_guardias
     * const Liquidacion_guardias = await prisma.liquidacion_guardias.delete({
     *   where: {
     *     // ... filter to delete one Liquidacion_guardias
     *   }
     * })
     * 
    **/
    delete<T extends liquidacion_guardiasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_guardiasDeleteArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Liquidacion_guardias.
     * @param {liquidacion_guardiasUpdateArgs} args - Arguments to update one Liquidacion_guardias.
     * @example
     * // Update one Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends liquidacion_guardiasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_guardiasUpdateArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Liquidacion_guardias.
     * @param {liquidacion_guardiasDeleteManyArgs} args - Arguments to filter Liquidacion_guardias to delete.
     * @example
     * // Delete a few Liquidacion_guardias
     * const { count } = await prisma.liquidacion_guardias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends liquidacion_guardiasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_guardiasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liquidacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends liquidacion_guardiasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_guardiasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Liquidacion_guardias.
     * @param {liquidacion_guardiasUpsertArgs} args - Arguments to update or create a Liquidacion_guardias.
     * @example
     * // Update or create a Liquidacion_guardias
     * const liquidacion_guardias = await prisma.liquidacion_guardias.upsert({
     *   create: {
     *     // ... data to create a Liquidacion_guardias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liquidacion_guardias we want to update
     *   }
     * })
    **/
    upsert<T extends liquidacion_guardiasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_guardiasUpsertArgs<ExtArgs>>
    ): Prisma__liquidacion_guardiasClient<$Types.GetResult<liquidacion_guardiasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Liquidacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasCountArgs} args - Arguments to filter Liquidacion_guardias to count.
     * @example
     * // Count the number of Liquidacion_guardias
     * const count = await prisma.liquidacion_guardias.count({
     *   where: {
     *     // ... the filter for the Liquidacion_guardias we want to count
     *   }
     * })
    **/
    count<T extends liquidacion_guardiasCountArgs>(
      args?: Subset<T, liquidacion_guardiasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Liquidacion_guardiasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liquidacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liquidacion_guardiasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Liquidacion_guardiasAggregateArgs>(args: Subset<T, Liquidacion_guardiasAggregateArgs>): Prisma.PrismaPromise<GetLiquidacion_guardiasAggregateType<T>>

    /**
     * Group by Liquidacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_guardiasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends liquidacion_guardiasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: liquidacion_guardiasGroupByArgs['orderBy'] }
        : { orderBy?: liquidacion_guardiasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, liquidacion_guardiasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiquidacion_guardiasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for liquidacion_guardias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__liquidacion_guardiasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * liquidacion_guardias base type for findUnique actions
   */
  export type liquidacion_guardiasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_guardias to fetch.
     */
    where: liquidacion_guardiasWhereUniqueInput
  }

  /**
   * liquidacion_guardias findUnique
   */
  export interface liquidacion_guardiasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liquidacion_guardiasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liquidacion_guardias findUniqueOrThrow
   */
  export type liquidacion_guardiasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_guardias to fetch.
     */
    where: liquidacion_guardiasWhereUniqueInput
  }


  /**
   * liquidacion_guardias base type for findFirst actions
   */
  export type liquidacion_guardiasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_guardias to fetch.
     */
    where?: liquidacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_guardias to fetch.
     */
    orderBy?: liquidacion_guardiasOrderByWithRelationInput | liquidacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liquidacion_guardias.
     */
    cursor?: liquidacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liquidacion_guardias.
     */
    distinct?: Liquidacion_guardiasScalarFieldEnum | Liquidacion_guardiasScalarFieldEnum[]
  }

  /**
   * liquidacion_guardias findFirst
   */
  export interface liquidacion_guardiasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liquidacion_guardiasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liquidacion_guardias findFirstOrThrow
   */
  export type liquidacion_guardiasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_guardias to fetch.
     */
    where?: liquidacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_guardias to fetch.
     */
    orderBy?: liquidacion_guardiasOrderByWithRelationInput | liquidacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liquidacion_guardias.
     */
    cursor?: liquidacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liquidacion_guardias.
     */
    distinct?: Liquidacion_guardiasScalarFieldEnum | Liquidacion_guardiasScalarFieldEnum[]
  }


  /**
   * liquidacion_guardias findMany
   */
  export type liquidacion_guardiasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_guardias to fetch.
     */
    where?: liquidacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_guardias to fetch.
     */
    orderBy?: liquidacion_guardiasOrderByWithRelationInput | liquidacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing liquidacion_guardias.
     */
    cursor?: liquidacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_guardias.
     */
    skip?: number
    distinct?: Liquidacion_guardiasScalarFieldEnum | Liquidacion_guardiasScalarFieldEnum[]
  }


  /**
   * liquidacion_guardias create
   */
  export type liquidacion_guardiasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * The data needed to create a liquidacion_guardias.
     */
    data?: XOR<liquidacion_guardiasCreateInput, liquidacion_guardiasUncheckedCreateInput>
  }


  /**
   * liquidacion_guardias createMany
   */
  export type liquidacion_guardiasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many liquidacion_guardias.
     */
    data: liquidacion_guardiasCreateManyInput | liquidacion_guardiasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * liquidacion_guardias update
   */
  export type liquidacion_guardiasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * The data needed to update a liquidacion_guardias.
     */
    data: XOR<liquidacion_guardiasUpdateInput, liquidacion_guardiasUncheckedUpdateInput>
    /**
     * Choose, which liquidacion_guardias to update.
     */
    where: liquidacion_guardiasWhereUniqueInput
  }


  /**
   * liquidacion_guardias updateMany
   */
  export type liquidacion_guardiasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update liquidacion_guardias.
     */
    data: XOR<liquidacion_guardiasUpdateManyMutationInput, liquidacion_guardiasUncheckedUpdateManyInput>
    /**
     * Filter which liquidacion_guardias to update
     */
    where?: liquidacion_guardiasWhereInput
  }


  /**
   * liquidacion_guardias upsert
   */
  export type liquidacion_guardiasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * The filter to search for the liquidacion_guardias to update in case it exists.
     */
    where: liquidacion_guardiasWhereUniqueInput
    /**
     * In case the liquidacion_guardias found by the `where` argument doesn't exist, create a new liquidacion_guardias with this data.
     */
    create: XOR<liquidacion_guardiasCreateInput, liquidacion_guardiasUncheckedCreateInput>
    /**
     * In case the liquidacion_guardias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<liquidacion_guardiasUpdateInput, liquidacion_guardiasUncheckedUpdateInput>
  }


  /**
   * liquidacion_guardias delete
   */
  export type liquidacion_guardiasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter which liquidacion_guardias to delete.
     */
    where: liquidacion_guardiasWhereUniqueInput
  }


  /**
   * liquidacion_guardias deleteMany
   */
  export type liquidacion_guardiasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liquidacion_guardias to delete
     */
    where?: liquidacion_guardiasWhereInput
  }


  /**
   * liquidacion_guardias without action
   */
  export type liquidacion_guardiasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_guardias
     */
    select?: liquidacion_guardiasSelect<ExtArgs> | null
  }



  /**
   * Model liquidacion_registro
   */


  export type AggregateLiquidacion_registro = {
    _count: Liquidacion_registroCountAggregateOutputType | null
    _avg: Liquidacion_registroAvgAggregateOutputType | null
    _sum: Liquidacion_registroSumAggregateOutputType | null
    _min: Liquidacion_registroMinAggregateOutputType | null
    _max: Liquidacion_registroMaxAggregateOutputType | null
  }

  export type Liquidacion_registroAvgAggregateOutputType = {
    idliquidacion: number | null
    importe: number | null
  }

  export type Liquidacion_registroSumAggregateOutputType = {
    idliquidacion: number | null
    importe: number | null
  }

  export type Liquidacion_registroMinAggregateOutputType = {
    idliquidacion: number | null
    fecha: Date | null
    empleado: string | null
    concepto: string | null
    fecha_concepto: Date | null
    importe: number | null
    operador: string | null
  }

  export type Liquidacion_registroMaxAggregateOutputType = {
    idliquidacion: number | null
    fecha: Date | null
    empleado: string | null
    concepto: string | null
    fecha_concepto: Date | null
    importe: number | null
    operador: string | null
  }

  export type Liquidacion_registroCountAggregateOutputType = {
    idliquidacion: number
    fecha: number
    empleado: number
    concepto: number
    fecha_concepto: number
    importe: number
    operador: number
    _all: number
  }


  export type Liquidacion_registroAvgAggregateInputType = {
    idliquidacion?: true
    importe?: true
  }

  export type Liquidacion_registroSumAggregateInputType = {
    idliquidacion?: true
    importe?: true
  }

  export type Liquidacion_registroMinAggregateInputType = {
    idliquidacion?: true
    fecha?: true
    empleado?: true
    concepto?: true
    fecha_concepto?: true
    importe?: true
    operador?: true
  }

  export type Liquidacion_registroMaxAggregateInputType = {
    idliquidacion?: true
    fecha?: true
    empleado?: true
    concepto?: true
    fecha_concepto?: true
    importe?: true
    operador?: true
  }

  export type Liquidacion_registroCountAggregateInputType = {
    idliquidacion?: true
    fecha?: true
    empleado?: true
    concepto?: true
    fecha_concepto?: true
    importe?: true
    operador?: true
    _all?: true
  }

  export type Liquidacion_registroAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liquidacion_registro to aggregate.
     */
    where?: liquidacion_registroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_registros to fetch.
     */
    orderBy?: liquidacion_registroOrderByWithRelationInput | liquidacion_registroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: liquidacion_registroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_registros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_registros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned liquidacion_registros
    **/
    _count?: true | Liquidacion_registroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Liquidacion_registroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Liquidacion_registroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Liquidacion_registroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Liquidacion_registroMaxAggregateInputType
  }

  export type GetLiquidacion_registroAggregateType<T extends Liquidacion_registroAggregateArgs> = {
        [P in keyof T & keyof AggregateLiquidacion_registro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiquidacion_registro[P]>
      : GetScalarType<T[P], AggregateLiquidacion_registro[P]>
  }




  export type liquidacion_registroGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: liquidacion_registroWhereInput
    orderBy?: liquidacion_registroOrderByWithAggregationInput | liquidacion_registroOrderByWithAggregationInput[]
    by: Liquidacion_registroScalarFieldEnum[] | Liquidacion_registroScalarFieldEnum
    having?: liquidacion_registroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Liquidacion_registroCountAggregateInputType | true
    _avg?: Liquidacion_registroAvgAggregateInputType
    _sum?: Liquidacion_registroSumAggregateInputType
    _min?: Liquidacion_registroMinAggregateInputType
    _max?: Liquidacion_registroMaxAggregateInputType
  }


  export type Liquidacion_registroGroupByOutputType = {
    idliquidacion: number
    fecha: Date | null
    empleado: string | null
    concepto: string | null
    fecha_concepto: Date | null
    importe: number | null
    operador: string | null
    _count: Liquidacion_registroCountAggregateOutputType | null
    _avg: Liquidacion_registroAvgAggregateOutputType | null
    _sum: Liquidacion_registroSumAggregateOutputType | null
    _min: Liquidacion_registroMinAggregateOutputType | null
    _max: Liquidacion_registroMaxAggregateOutputType | null
  }

  type GetLiquidacion_registroGroupByPayload<T extends liquidacion_registroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Liquidacion_registroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Liquidacion_registroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Liquidacion_registroGroupByOutputType[P]>
            : GetScalarType<T[P], Liquidacion_registroGroupByOutputType[P]>
        }
      >
    >


  export type liquidacion_registroSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idliquidacion?: boolean
    fecha?: boolean
    empleado?: boolean
    concepto?: boolean
    fecha_concepto?: boolean
    importe?: boolean
    operador?: boolean
  }, ExtArgs["result"]["liquidacion_registro"]>

  export type liquidacion_registroSelectScalar = {
    idliquidacion?: boolean
    fecha?: boolean
    empleado?: boolean
    concepto?: boolean
    fecha_concepto?: boolean
    importe?: boolean
    operador?: boolean
  }


  type liquidacion_registroGetPayload<S extends boolean | null | undefined | liquidacion_registroArgs> = $Types.GetResult<liquidacion_registroPayload, S>

  type liquidacion_registroCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<liquidacion_registroFindManyArgs, 'select' | 'include'> & {
      select?: Liquidacion_registroCountAggregateInputType | true
    }

  export interface liquidacion_registroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['liquidacion_registro'], meta: { name: 'liquidacion_registro' } }
    /**
     * Find zero or one Liquidacion_registro that matches the filter.
     * @param {liquidacion_registroFindUniqueArgs} args - Arguments to find a Liquidacion_registro
     * @example
     * // Get one Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends liquidacion_registroFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, liquidacion_registroFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'liquidacion_registro'> extends True ? Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Liquidacion_registro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {liquidacion_registroFindUniqueOrThrowArgs} args - Arguments to find a Liquidacion_registro
     * @example
     * // Get one Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends liquidacion_registroFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_registroFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Liquidacion_registro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroFindFirstArgs} args - Arguments to find a Liquidacion_registro
     * @example
     * // Get one Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends liquidacion_registroFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, liquidacion_registroFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'liquidacion_registro'> extends True ? Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Liquidacion_registro that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroFindFirstOrThrowArgs} args - Arguments to find a Liquidacion_registro
     * @example
     * // Get one Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends liquidacion_registroFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_registroFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Liquidacion_registros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liquidacion_registros
     * const liquidacion_registros = await prisma.liquidacion_registro.findMany()
     * 
     * // Get first 10 Liquidacion_registros
     * const liquidacion_registros = await prisma.liquidacion_registro.findMany({ take: 10 })
     * 
     * // Only select the `idliquidacion`
     * const liquidacion_registroWithIdliquidacionOnly = await prisma.liquidacion_registro.findMany({ select: { idliquidacion: true } })
     * 
    **/
    findMany<T extends liquidacion_registroFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_registroFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Liquidacion_registro.
     * @param {liquidacion_registroCreateArgs} args - Arguments to create a Liquidacion_registro.
     * @example
     * // Create one Liquidacion_registro
     * const Liquidacion_registro = await prisma.liquidacion_registro.create({
     *   data: {
     *     // ... data to create a Liquidacion_registro
     *   }
     * })
     * 
    **/
    create<T extends liquidacion_registroCreateArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_registroCreateArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Liquidacion_registros.
     *     @param {liquidacion_registroCreateManyArgs} args - Arguments to create many Liquidacion_registros.
     *     @example
     *     // Create many Liquidacion_registros
     *     const liquidacion_registro = await prisma.liquidacion_registro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends liquidacion_registroCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_registroCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Liquidacion_registro.
     * @param {liquidacion_registroDeleteArgs} args - Arguments to delete one Liquidacion_registro.
     * @example
     * // Delete one Liquidacion_registro
     * const Liquidacion_registro = await prisma.liquidacion_registro.delete({
     *   where: {
     *     // ... filter to delete one Liquidacion_registro
     *   }
     * })
     * 
    **/
    delete<T extends liquidacion_registroDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_registroDeleteArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Liquidacion_registro.
     * @param {liquidacion_registroUpdateArgs} args - Arguments to update one Liquidacion_registro.
     * @example
     * // Update one Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends liquidacion_registroUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_registroUpdateArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Liquidacion_registros.
     * @param {liquidacion_registroDeleteManyArgs} args - Arguments to filter Liquidacion_registros to delete.
     * @example
     * // Delete a few Liquidacion_registros
     * const { count } = await prisma.liquidacion_registro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends liquidacion_registroDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, liquidacion_registroDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liquidacion_registros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liquidacion_registros
     * const liquidacion_registro = await prisma.liquidacion_registro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends liquidacion_registroUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_registroUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Liquidacion_registro.
     * @param {liquidacion_registroUpsertArgs} args - Arguments to update or create a Liquidacion_registro.
     * @example
     * // Update or create a Liquidacion_registro
     * const liquidacion_registro = await prisma.liquidacion_registro.upsert({
     *   create: {
     *     // ... data to create a Liquidacion_registro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liquidacion_registro we want to update
     *   }
     * })
    **/
    upsert<T extends liquidacion_registroUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, liquidacion_registroUpsertArgs<ExtArgs>>
    ): Prisma__liquidacion_registroClient<$Types.GetResult<liquidacion_registroPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Liquidacion_registros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroCountArgs} args - Arguments to filter Liquidacion_registros to count.
     * @example
     * // Count the number of Liquidacion_registros
     * const count = await prisma.liquidacion_registro.count({
     *   where: {
     *     // ... the filter for the Liquidacion_registros we want to count
     *   }
     * })
    **/
    count<T extends liquidacion_registroCountArgs>(
      args?: Subset<T, liquidacion_registroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Liquidacion_registroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liquidacion_registro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Liquidacion_registroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Liquidacion_registroAggregateArgs>(args: Subset<T, Liquidacion_registroAggregateArgs>): Prisma.PrismaPromise<GetLiquidacion_registroAggregateType<T>>

    /**
     * Group by Liquidacion_registro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {liquidacion_registroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends liquidacion_registroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: liquidacion_registroGroupByArgs['orderBy'] }
        : { orderBy?: liquidacion_registroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, liquidacion_registroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiquidacion_registroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for liquidacion_registro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__liquidacion_registroClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * liquidacion_registro base type for findUnique actions
   */
  export type liquidacion_registroFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_registro to fetch.
     */
    where: liquidacion_registroWhereUniqueInput
  }

  /**
   * liquidacion_registro findUnique
   */
  export interface liquidacion_registroFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liquidacion_registroFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liquidacion_registro findUniqueOrThrow
   */
  export type liquidacion_registroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_registro to fetch.
     */
    where: liquidacion_registroWhereUniqueInput
  }


  /**
   * liquidacion_registro base type for findFirst actions
   */
  export type liquidacion_registroFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_registro to fetch.
     */
    where?: liquidacion_registroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_registros to fetch.
     */
    orderBy?: liquidacion_registroOrderByWithRelationInput | liquidacion_registroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liquidacion_registros.
     */
    cursor?: liquidacion_registroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_registros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_registros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liquidacion_registros.
     */
    distinct?: Liquidacion_registroScalarFieldEnum | Liquidacion_registroScalarFieldEnum[]
  }

  /**
   * liquidacion_registro findFirst
   */
  export interface liquidacion_registroFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends liquidacion_registroFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * liquidacion_registro findFirstOrThrow
   */
  export type liquidacion_registroFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_registro to fetch.
     */
    where?: liquidacion_registroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_registros to fetch.
     */
    orderBy?: liquidacion_registroOrderByWithRelationInput | liquidacion_registroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for liquidacion_registros.
     */
    cursor?: liquidacion_registroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_registros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_registros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of liquidacion_registros.
     */
    distinct?: Liquidacion_registroScalarFieldEnum | Liquidacion_registroScalarFieldEnum[]
  }


  /**
   * liquidacion_registro findMany
   */
  export type liquidacion_registroFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter, which liquidacion_registros to fetch.
     */
    where?: liquidacion_registroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of liquidacion_registros to fetch.
     */
    orderBy?: liquidacion_registroOrderByWithRelationInput | liquidacion_registroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing liquidacion_registros.
     */
    cursor?: liquidacion_registroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` liquidacion_registros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` liquidacion_registros.
     */
    skip?: number
    distinct?: Liquidacion_registroScalarFieldEnum | Liquidacion_registroScalarFieldEnum[]
  }


  /**
   * liquidacion_registro create
   */
  export type liquidacion_registroCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * The data needed to create a liquidacion_registro.
     */
    data?: XOR<liquidacion_registroCreateInput, liquidacion_registroUncheckedCreateInput>
  }


  /**
   * liquidacion_registro createMany
   */
  export type liquidacion_registroCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many liquidacion_registros.
     */
    data: liquidacion_registroCreateManyInput | liquidacion_registroCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * liquidacion_registro update
   */
  export type liquidacion_registroUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * The data needed to update a liquidacion_registro.
     */
    data: XOR<liquidacion_registroUpdateInput, liquidacion_registroUncheckedUpdateInput>
    /**
     * Choose, which liquidacion_registro to update.
     */
    where: liquidacion_registroWhereUniqueInput
  }


  /**
   * liquidacion_registro updateMany
   */
  export type liquidacion_registroUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update liquidacion_registros.
     */
    data: XOR<liquidacion_registroUpdateManyMutationInput, liquidacion_registroUncheckedUpdateManyInput>
    /**
     * Filter which liquidacion_registros to update
     */
    where?: liquidacion_registroWhereInput
  }


  /**
   * liquidacion_registro upsert
   */
  export type liquidacion_registroUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * The filter to search for the liquidacion_registro to update in case it exists.
     */
    where: liquidacion_registroWhereUniqueInput
    /**
     * In case the liquidacion_registro found by the `where` argument doesn't exist, create a new liquidacion_registro with this data.
     */
    create: XOR<liquidacion_registroCreateInput, liquidacion_registroUncheckedCreateInput>
    /**
     * In case the liquidacion_registro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<liquidacion_registroUpdateInput, liquidacion_registroUncheckedUpdateInput>
  }


  /**
   * liquidacion_registro delete
   */
  export type liquidacion_registroDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
    /**
     * Filter which liquidacion_registro to delete.
     */
    where: liquidacion_registroWhereUniqueInput
  }


  /**
   * liquidacion_registro deleteMany
   */
  export type liquidacion_registroDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which liquidacion_registros to delete
     */
    where?: liquidacion_registroWhereInput
  }


  /**
   * liquidacion_registro without action
   */
  export type liquidacion_registroArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the liquidacion_registro
     */
    select?: liquidacion_registroSelect<ExtArgs> | null
  }



  /**
   * Model gastos_caja_copy
   */


  export type AggregateGastos_caja_copy = {
    _count: Gastos_caja_copyCountAggregateOutputType | null
    _avg: Gastos_caja_copyAvgAggregateOutputType | null
    _sum: Gastos_caja_copySumAggregateOutputType | null
    _min: Gastos_caja_copyMinAggregateOutputType | null
    _max: Gastos_caja_copyMaxAggregateOutputType | null
  }

  export type Gastos_caja_copyAvgAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_caja_copySumAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_caja_copyMinAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_caja_copyMaxAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_caja_copyCountAggregateOutputType = {
    idgastos: number
    idcaja: number
    concepto: number
    tipofactura: number
    nfactura: number
    fecha: number
    operadorgestion: number
    operadortramite: number
    ptoventa: number
    porciva: number
    montoiva: number
    retiibb: number
    retggcias: number
    perciva: number
    detalle: number
    mediopago: number
    proveedor: number
    empresa: number
    total: number
    idservicio: number
    _all: number
  }


  export type Gastos_caja_copyAvgAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_caja_copySumAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_caja_copyMinAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_caja_copyMaxAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_caja_copyCountAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
    _all?: true
  }

  export type Gastos_caja_copyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_caja_copy to aggregate.
     */
    where?: gastos_caja_copyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_caja_copies to fetch.
     */
    orderBy?: gastos_caja_copyOrderByWithRelationInput | gastos_caja_copyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gastos_caja_copyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_caja_copies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_caja_copies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastos_caja_copies
    **/
    _count?: true | Gastos_caja_copyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gastos_caja_copyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gastos_caja_copySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gastos_caja_copyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gastos_caja_copyMaxAggregateInputType
  }

  export type GetGastos_caja_copyAggregateType<T extends Gastos_caja_copyAggregateArgs> = {
        [P in keyof T & keyof AggregateGastos_caja_copy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastos_caja_copy[P]>
      : GetScalarType<T[P], AggregateGastos_caja_copy[P]>
  }




  export type gastos_caja_copyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gastos_caja_copyWhereInput
    orderBy?: gastos_caja_copyOrderByWithAggregationInput | gastos_caja_copyOrderByWithAggregationInput[]
    by: Gastos_caja_copyScalarFieldEnum[] | Gastos_caja_copyScalarFieldEnum
    having?: gastos_caja_copyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gastos_caja_copyCountAggregateInputType | true
    _avg?: Gastos_caja_copyAvgAggregateInputType
    _sum?: Gastos_caja_copySumAggregateInputType
    _min?: Gastos_caja_copyMinAggregateInputType
    _max?: Gastos_caja_copyMaxAggregateInputType
  }


  export type Gastos_caja_copyGroupByOutputType = {
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
    _count: Gastos_caja_copyCountAggregateOutputType | null
    _avg: Gastos_caja_copyAvgAggregateOutputType | null
    _sum: Gastos_caja_copySumAggregateOutputType | null
    _min: Gastos_caja_copyMinAggregateOutputType | null
    _max: Gastos_caja_copyMaxAggregateOutputType | null
  }

  type GetGastos_caja_copyGroupByPayload<T extends gastos_caja_copyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gastos_caja_copyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gastos_caja_copyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gastos_caja_copyGroupByOutputType[P]>
            : GetScalarType<T[P], Gastos_caja_copyGroupByOutputType[P]>
        }
      >
    >


  export type gastos_caja_copySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }, ExtArgs["result"]["gastos_caja_copy"]>

  export type gastos_caja_copySelectScalar = {
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }


  type gastos_caja_copyGetPayload<S extends boolean | null | undefined | gastos_caja_copyArgs> = $Types.GetResult<gastos_caja_copyPayload, S>

  type gastos_caja_copyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gastos_caja_copyFindManyArgs, 'select' | 'include'> & {
      select?: Gastos_caja_copyCountAggregateInputType | true
    }

  export interface gastos_caja_copyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gastos_caja_copy'], meta: { name: 'gastos_caja_copy' } }
    /**
     * Find zero or one Gastos_caja_copy that matches the filter.
     * @param {gastos_caja_copyFindUniqueArgs} args - Arguments to find a Gastos_caja_copy
     * @example
     * // Get one Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastos_caja_copyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastos_caja_copyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastos_caja_copy'> extends True ? Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gastos_caja_copy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gastos_caja_copyFindUniqueOrThrowArgs} args - Arguments to find a Gastos_caja_copy
     * @example
     * // Get one Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gastos_caja_copyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_caja_copyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gastos_caja_copy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyFindFirstArgs} args - Arguments to find a Gastos_caja_copy
     * @example
     * // Get one Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastos_caja_copyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastos_caja_copyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastos_caja_copy'> extends True ? Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gastos_caja_copy that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyFindFirstOrThrowArgs} args - Arguments to find a Gastos_caja_copy
     * @example
     * // Get one Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gastos_caja_copyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_caja_copyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gastos_caja_copies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastos_caja_copies
     * const gastos_caja_copies = await prisma.gastos_caja_copy.findMany()
     * 
     * // Get first 10 Gastos_caja_copies
     * const gastos_caja_copies = await prisma.gastos_caja_copy.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const gastos_caja_copyWithIdgastosOnly = await prisma.gastos_caja_copy.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends gastos_caja_copyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_caja_copyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gastos_caja_copy.
     * @param {gastos_caja_copyCreateArgs} args - Arguments to create a Gastos_caja_copy.
     * @example
     * // Create one Gastos_caja_copy
     * const Gastos_caja_copy = await prisma.gastos_caja_copy.create({
     *   data: {
     *     // ... data to create a Gastos_caja_copy
     *   }
     * })
     * 
    **/
    create<T extends gastos_caja_copyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_caja_copyCreateArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gastos_caja_copies.
     *     @param {gastos_caja_copyCreateManyArgs} args - Arguments to create many Gastos_caja_copies.
     *     @example
     *     // Create many Gastos_caja_copies
     *     const gastos_caja_copy = await prisma.gastos_caja_copy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastos_caja_copyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_caja_copyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gastos_caja_copy.
     * @param {gastos_caja_copyDeleteArgs} args - Arguments to delete one Gastos_caja_copy.
     * @example
     * // Delete one Gastos_caja_copy
     * const Gastos_caja_copy = await prisma.gastos_caja_copy.delete({
     *   where: {
     *     // ... filter to delete one Gastos_caja_copy
     *   }
     * })
     * 
    **/
    delete<T extends gastos_caja_copyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_caja_copyDeleteArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gastos_caja_copy.
     * @param {gastos_caja_copyUpdateArgs} args - Arguments to update one Gastos_caja_copy.
     * @example
     * // Update one Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastos_caja_copyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_caja_copyUpdateArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gastos_caja_copies.
     * @param {gastos_caja_copyDeleteManyArgs} args - Arguments to filter Gastos_caja_copies to delete.
     * @example
     * // Delete a few Gastos_caja_copies
     * const { count } = await prisma.gastos_caja_copy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastos_caja_copyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_caja_copyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastos_caja_copies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastos_caja_copies
     * const gastos_caja_copy = await prisma.gastos_caja_copy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastos_caja_copyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_caja_copyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastos_caja_copy.
     * @param {gastos_caja_copyUpsertArgs} args - Arguments to update or create a Gastos_caja_copy.
     * @example
     * // Update or create a Gastos_caja_copy
     * const gastos_caja_copy = await prisma.gastos_caja_copy.upsert({
     *   create: {
     *     // ... data to create a Gastos_caja_copy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastos_caja_copy we want to update
     *   }
     * })
    **/
    upsert<T extends gastos_caja_copyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_caja_copyUpsertArgs<ExtArgs>>
    ): Prisma__gastos_caja_copyClient<$Types.GetResult<gastos_caja_copyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gastos_caja_copies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyCountArgs} args - Arguments to filter Gastos_caja_copies to count.
     * @example
     * // Count the number of Gastos_caja_copies
     * const count = await prisma.gastos_caja_copy.count({
     *   where: {
     *     // ... the filter for the Gastos_caja_copies we want to count
     *   }
     * })
    **/
    count<T extends gastos_caja_copyCountArgs>(
      args?: Subset<T, gastos_caja_copyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gastos_caja_copyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastos_caja_copy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gastos_caja_copyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gastos_caja_copyAggregateArgs>(args: Subset<T, Gastos_caja_copyAggregateArgs>): Prisma.PrismaPromise<GetGastos_caja_copyAggregateType<T>>

    /**
     * Group by Gastos_caja_copy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_caja_copyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gastos_caja_copyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gastos_caja_copyGroupByArgs['orderBy'] }
        : { orderBy?: gastos_caja_copyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gastos_caja_copyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastos_caja_copyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gastos_caja_copy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastos_caja_copyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gastos_caja_copy base type for findUnique actions
   */
  export type gastos_caja_copyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja_copy to fetch.
     */
    where: gastos_caja_copyWhereUniqueInput
  }

  /**
   * gastos_caja_copy findUnique
   */
  export interface gastos_caja_copyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_caja_copyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja_copy findUniqueOrThrow
   */
  export type gastos_caja_copyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja_copy to fetch.
     */
    where: gastos_caja_copyWhereUniqueInput
  }


  /**
   * gastos_caja_copy base type for findFirst actions
   */
  export type gastos_caja_copyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja_copy to fetch.
     */
    where?: gastos_caja_copyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_caja_copies to fetch.
     */
    orderBy?: gastos_caja_copyOrderByWithRelationInput | gastos_caja_copyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_caja_copies.
     */
    cursor?: gastos_caja_copyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_caja_copies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_caja_copies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_caja_copies.
     */
    distinct?: Gastos_caja_copyScalarFieldEnum | Gastos_caja_copyScalarFieldEnum[]
  }

  /**
   * gastos_caja_copy findFirst
   */
  export interface gastos_caja_copyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_caja_copyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja_copy findFirstOrThrow
   */
  export type gastos_caja_copyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja_copy to fetch.
     */
    where?: gastos_caja_copyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_caja_copies to fetch.
     */
    orderBy?: gastos_caja_copyOrderByWithRelationInput | gastos_caja_copyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_caja_copies.
     */
    cursor?: gastos_caja_copyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_caja_copies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_caja_copies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_caja_copies.
     */
    distinct?: Gastos_caja_copyScalarFieldEnum | Gastos_caja_copyScalarFieldEnum[]
  }


  /**
   * gastos_caja_copy findMany
   */
  export type gastos_caja_copyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja_copies to fetch.
     */
    where?: gastos_caja_copyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_caja_copies to fetch.
     */
    orderBy?: gastos_caja_copyOrderByWithRelationInput | gastos_caja_copyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastos_caja_copies.
     */
    cursor?: gastos_caja_copyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_caja_copies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_caja_copies.
     */
    skip?: number
    distinct?: Gastos_caja_copyScalarFieldEnum | Gastos_caja_copyScalarFieldEnum[]
  }


  /**
   * gastos_caja_copy create
   */
  export type gastos_caja_copyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * The data needed to create a gastos_caja_copy.
     */
    data?: XOR<gastos_caja_copyCreateInput, gastos_caja_copyUncheckedCreateInput>
  }


  /**
   * gastos_caja_copy createMany
   */
  export type gastos_caja_copyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gastos_caja_copies.
     */
    data: gastos_caja_copyCreateManyInput | gastos_caja_copyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gastos_caja_copy update
   */
  export type gastos_caja_copyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * The data needed to update a gastos_caja_copy.
     */
    data: XOR<gastos_caja_copyUpdateInput, gastos_caja_copyUncheckedUpdateInput>
    /**
     * Choose, which gastos_caja_copy to update.
     */
    where: gastos_caja_copyWhereUniqueInput
  }


  /**
   * gastos_caja_copy updateMany
   */
  export type gastos_caja_copyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gastos_caja_copies.
     */
    data: XOR<gastos_caja_copyUpdateManyMutationInput, gastos_caja_copyUncheckedUpdateManyInput>
    /**
     * Filter which gastos_caja_copies to update
     */
    where?: gastos_caja_copyWhereInput
  }


  /**
   * gastos_caja_copy upsert
   */
  export type gastos_caja_copyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * The filter to search for the gastos_caja_copy to update in case it exists.
     */
    where: gastos_caja_copyWhereUniqueInput
    /**
     * In case the gastos_caja_copy found by the `where` argument doesn't exist, create a new gastos_caja_copy with this data.
     */
    create: XOR<gastos_caja_copyCreateInput, gastos_caja_copyUncheckedCreateInput>
    /**
     * In case the gastos_caja_copy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gastos_caja_copyUpdateInput, gastos_caja_copyUncheckedUpdateInput>
  }


  /**
   * gastos_caja_copy delete
   */
  export type gastos_caja_copyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
    /**
     * Filter which gastos_caja_copy to delete.
     */
    where: gastos_caja_copyWhereUniqueInput
  }


  /**
   * gastos_caja_copy deleteMany
   */
  export type gastos_caja_copyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_caja_copies to delete
     */
    where?: gastos_caja_copyWhereInput
  }


  /**
   * gastos_caja_copy without action
   */
  export type gastos_caja_copyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja_copy
     */
    select?: gastos_caja_copySelect<ExtArgs> | null
  }



  /**
   * Model servicio_presupuesto
   */


  export type AggregateServicio_presupuesto = {
    _count: Servicio_presupuestoCountAggregateOutputType | null
    _avg: Servicio_presupuestoAvgAggregateOutputType | null
    _sum: Servicio_presupuestoSumAggregateOutputType | null
    _min: Servicio_presupuestoMinAggregateOutputType | null
    _max: Servicio_presupuestoMaxAggregateOutputType | null
  }

  export type Servicio_presupuestoAvgAggregateOutputType = {
    idpresupuesto: number | null
    idservicio: number | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
  }

  export type Servicio_presupuestoSumAggregateOutputType = {
    idpresupuesto: number | null
    idservicio: number | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
  }

  export type Servicio_presupuestoMinAggregateOutputType = {
    idpresupuesto: number | null
    idservicio: number | null
    fecha: Date | null
    apoderado: string | null
    domicilio: string | null
    telefono: string | null
    detalle: string | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
    operador: string | null
  }

  export type Servicio_presupuestoMaxAggregateOutputType = {
    idpresupuesto: number | null
    idservicio: number | null
    fecha: Date | null
    apoderado: string | null
    domicilio: string | null
    telefono: string | null
    detalle: string | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
    operador: string | null
  }

  export type Servicio_presupuestoCountAggregateOutputType = {
    idpresupuesto: number
    idservicio: number
    fecha: number
    apoderado: number
    domicilio: number
    telefono: number
    detalle: number
    total: number
    anticipo: number
    cuotas: number
    saldo: number
    operador: number
    _all: number
  }


  export type Servicio_presupuestoAvgAggregateInputType = {
    idpresupuesto?: true
    idservicio?: true
    total?: true
    anticipo?: true
    cuotas?: true
    saldo?: true
  }

  export type Servicio_presupuestoSumAggregateInputType = {
    idpresupuesto?: true
    idservicio?: true
    total?: true
    anticipo?: true
    cuotas?: true
    saldo?: true
  }

  export type Servicio_presupuestoMinAggregateInputType = {
    idpresupuesto?: true
    idservicio?: true
    fecha?: true
    apoderado?: true
    domicilio?: true
    telefono?: true
    detalle?: true
    total?: true
    anticipo?: true
    cuotas?: true
    saldo?: true
    operador?: true
  }

  export type Servicio_presupuestoMaxAggregateInputType = {
    idpresupuesto?: true
    idservicio?: true
    fecha?: true
    apoderado?: true
    domicilio?: true
    telefono?: true
    detalle?: true
    total?: true
    anticipo?: true
    cuotas?: true
    saldo?: true
    operador?: true
  }

  export type Servicio_presupuestoCountAggregateInputType = {
    idpresupuesto?: true
    idservicio?: true
    fecha?: true
    apoderado?: true
    domicilio?: true
    telefono?: true
    detalle?: true
    total?: true
    anticipo?: true
    cuotas?: true
    saldo?: true
    operador?: true
    _all?: true
  }

  export type Servicio_presupuestoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_presupuesto to aggregate.
     */
    where?: servicio_presupuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_presupuestos to fetch.
     */
    orderBy?: servicio_presupuestoOrderByWithRelationInput | servicio_presupuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_presupuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_presupuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_presupuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_presupuestos
    **/
    _count?: true | Servicio_presupuestoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_presupuestoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_presupuestoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_presupuestoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_presupuestoMaxAggregateInputType
  }

  export type GetServicio_presupuestoAggregateType<T extends Servicio_presupuestoAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_presupuesto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_presupuesto[P]>
      : GetScalarType<T[P], AggregateServicio_presupuesto[P]>
  }




  export type servicio_presupuestoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_presupuestoWhereInput
    orderBy?: servicio_presupuestoOrderByWithAggregationInput | servicio_presupuestoOrderByWithAggregationInput[]
    by: Servicio_presupuestoScalarFieldEnum[] | Servicio_presupuestoScalarFieldEnum
    having?: servicio_presupuestoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_presupuestoCountAggregateInputType | true
    _avg?: Servicio_presupuestoAvgAggregateInputType
    _sum?: Servicio_presupuestoSumAggregateInputType
    _min?: Servicio_presupuestoMinAggregateInputType
    _max?: Servicio_presupuestoMaxAggregateInputType
  }


  export type Servicio_presupuestoGroupByOutputType = {
    idpresupuesto: number
    idservicio: number | null
    fecha: Date | null
    apoderado: string | null
    domicilio: string | null
    telefono: string | null
    detalle: string | null
    total: number | null
    anticipo: number | null
    cuotas: number | null
    saldo: number | null
    operador: string | null
    _count: Servicio_presupuestoCountAggregateOutputType | null
    _avg: Servicio_presupuestoAvgAggregateOutputType | null
    _sum: Servicio_presupuestoSumAggregateOutputType | null
    _min: Servicio_presupuestoMinAggregateOutputType | null
    _max: Servicio_presupuestoMaxAggregateOutputType | null
  }

  type GetServicio_presupuestoGroupByPayload<T extends servicio_presupuestoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_presupuestoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_presupuestoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_presupuestoGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_presupuestoGroupByOutputType[P]>
        }
      >
    >


  export type servicio_presupuestoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpresupuesto?: boolean
    idservicio?: boolean
    fecha?: boolean
    apoderado?: boolean
    domicilio?: boolean
    telefono?: boolean
    detalle?: boolean
    total?: boolean
    anticipo?: boolean
    cuotas?: boolean
    saldo?: boolean
    operador?: boolean
  }, ExtArgs["result"]["servicio_presupuesto"]>

  export type servicio_presupuestoSelectScalar = {
    idpresupuesto?: boolean
    idservicio?: boolean
    fecha?: boolean
    apoderado?: boolean
    domicilio?: boolean
    telefono?: boolean
    detalle?: boolean
    total?: boolean
    anticipo?: boolean
    cuotas?: boolean
    saldo?: boolean
    operador?: boolean
  }


  type servicio_presupuestoGetPayload<S extends boolean | null | undefined | servicio_presupuestoArgs> = $Types.GetResult<servicio_presupuestoPayload, S>

  type servicio_presupuestoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_presupuestoFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_presupuestoCountAggregateInputType | true
    }

  export interface servicio_presupuestoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_presupuesto'], meta: { name: 'servicio_presupuesto' } }
    /**
     * Find zero or one Servicio_presupuesto that matches the filter.
     * @param {servicio_presupuestoFindUniqueArgs} args - Arguments to find a Servicio_presupuesto
     * @example
     * // Get one Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_presupuestoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_presupuestoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_presupuesto'> extends True ? Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_presupuesto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_presupuestoFindUniqueOrThrowArgs} args - Arguments to find a Servicio_presupuesto
     * @example
     * // Get one Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_presupuestoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_presupuestoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_presupuesto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoFindFirstArgs} args - Arguments to find a Servicio_presupuesto
     * @example
     * // Get one Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_presupuestoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_presupuestoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_presupuesto'> extends True ? Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_presupuesto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoFindFirstOrThrowArgs} args - Arguments to find a Servicio_presupuesto
     * @example
     * // Get one Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_presupuestoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_presupuestoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_presupuestos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_presupuestos
     * const servicio_presupuestos = await prisma.servicio_presupuesto.findMany()
     * 
     * // Get first 10 Servicio_presupuestos
     * const servicio_presupuestos = await prisma.servicio_presupuesto.findMany({ take: 10 })
     * 
     * // Only select the `idpresupuesto`
     * const servicio_presupuestoWithIdpresupuestoOnly = await prisma.servicio_presupuesto.findMany({ select: { idpresupuesto: true } })
     * 
    **/
    findMany<T extends servicio_presupuestoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_presupuestoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_presupuesto.
     * @param {servicio_presupuestoCreateArgs} args - Arguments to create a Servicio_presupuesto.
     * @example
     * // Create one Servicio_presupuesto
     * const Servicio_presupuesto = await prisma.servicio_presupuesto.create({
     *   data: {
     *     // ... data to create a Servicio_presupuesto
     *   }
     * })
     * 
    **/
    create<T extends servicio_presupuestoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_presupuestoCreateArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_presupuestos.
     *     @param {servicio_presupuestoCreateManyArgs} args - Arguments to create many Servicio_presupuestos.
     *     @example
     *     // Create many Servicio_presupuestos
     *     const servicio_presupuesto = await prisma.servicio_presupuesto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_presupuestoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_presupuestoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_presupuesto.
     * @param {servicio_presupuestoDeleteArgs} args - Arguments to delete one Servicio_presupuesto.
     * @example
     * // Delete one Servicio_presupuesto
     * const Servicio_presupuesto = await prisma.servicio_presupuesto.delete({
     *   where: {
     *     // ... filter to delete one Servicio_presupuesto
     *   }
     * })
     * 
    **/
    delete<T extends servicio_presupuestoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_presupuestoDeleteArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_presupuesto.
     * @param {servicio_presupuestoUpdateArgs} args - Arguments to update one Servicio_presupuesto.
     * @example
     * // Update one Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_presupuestoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_presupuestoUpdateArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_presupuestos.
     * @param {servicio_presupuestoDeleteManyArgs} args - Arguments to filter Servicio_presupuestos to delete.
     * @example
     * // Delete a few Servicio_presupuestos
     * const { count } = await prisma.servicio_presupuesto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_presupuestoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_presupuestoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_presupuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_presupuestos
     * const servicio_presupuesto = await prisma.servicio_presupuesto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_presupuestoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_presupuestoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_presupuesto.
     * @param {servicio_presupuestoUpsertArgs} args - Arguments to update or create a Servicio_presupuesto.
     * @example
     * // Update or create a Servicio_presupuesto
     * const servicio_presupuesto = await prisma.servicio_presupuesto.upsert({
     *   create: {
     *     // ... data to create a Servicio_presupuesto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_presupuesto we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_presupuestoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_presupuestoUpsertArgs<ExtArgs>>
    ): Prisma__servicio_presupuestoClient<$Types.GetResult<servicio_presupuestoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_presupuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoCountArgs} args - Arguments to filter Servicio_presupuestos to count.
     * @example
     * // Count the number of Servicio_presupuestos
     * const count = await prisma.servicio_presupuesto.count({
     *   where: {
     *     // ... the filter for the Servicio_presupuestos we want to count
     *   }
     * })
    **/
    count<T extends servicio_presupuestoCountArgs>(
      args?: Subset<T, servicio_presupuestoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_presupuestoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_presupuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_presupuestoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_presupuestoAggregateArgs>(args: Subset<T, Servicio_presupuestoAggregateArgs>): Prisma.PrismaPromise<GetServicio_presupuestoAggregateType<T>>

    /**
     * Group by Servicio_presupuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_presupuestoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_presupuestoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_presupuestoGroupByArgs['orderBy'] }
        : { orderBy?: servicio_presupuestoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_presupuestoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_presupuestoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_presupuesto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_presupuestoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_presupuesto base type for findUnique actions
   */
  export type servicio_presupuestoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter, which servicio_presupuesto to fetch.
     */
    where: servicio_presupuestoWhereUniqueInput
  }

  /**
   * servicio_presupuesto findUnique
   */
  export interface servicio_presupuestoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_presupuestoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_presupuesto findUniqueOrThrow
   */
  export type servicio_presupuestoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter, which servicio_presupuesto to fetch.
     */
    where: servicio_presupuestoWhereUniqueInput
  }


  /**
   * servicio_presupuesto base type for findFirst actions
   */
  export type servicio_presupuestoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter, which servicio_presupuesto to fetch.
     */
    where?: servicio_presupuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_presupuestos to fetch.
     */
    orderBy?: servicio_presupuestoOrderByWithRelationInput | servicio_presupuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_presupuestos.
     */
    cursor?: servicio_presupuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_presupuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_presupuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_presupuestos.
     */
    distinct?: Servicio_presupuestoScalarFieldEnum | Servicio_presupuestoScalarFieldEnum[]
  }

  /**
   * servicio_presupuesto findFirst
   */
  export interface servicio_presupuestoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_presupuestoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_presupuesto findFirstOrThrow
   */
  export type servicio_presupuestoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter, which servicio_presupuesto to fetch.
     */
    where?: servicio_presupuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_presupuestos to fetch.
     */
    orderBy?: servicio_presupuestoOrderByWithRelationInput | servicio_presupuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_presupuestos.
     */
    cursor?: servicio_presupuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_presupuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_presupuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_presupuestos.
     */
    distinct?: Servicio_presupuestoScalarFieldEnum | Servicio_presupuestoScalarFieldEnum[]
  }


  /**
   * servicio_presupuesto findMany
   */
  export type servicio_presupuestoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter, which servicio_presupuestos to fetch.
     */
    where?: servicio_presupuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_presupuestos to fetch.
     */
    orderBy?: servicio_presupuestoOrderByWithRelationInput | servicio_presupuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_presupuestos.
     */
    cursor?: servicio_presupuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_presupuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_presupuestos.
     */
    skip?: number
    distinct?: Servicio_presupuestoScalarFieldEnum | Servicio_presupuestoScalarFieldEnum[]
  }


  /**
   * servicio_presupuesto create
   */
  export type servicio_presupuestoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_presupuesto.
     */
    data?: XOR<servicio_presupuestoCreateInput, servicio_presupuestoUncheckedCreateInput>
  }


  /**
   * servicio_presupuesto createMany
   */
  export type servicio_presupuestoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_presupuestos.
     */
    data: servicio_presupuestoCreateManyInput | servicio_presupuestoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_presupuesto update
   */
  export type servicio_presupuestoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_presupuesto.
     */
    data: XOR<servicio_presupuestoUpdateInput, servicio_presupuestoUncheckedUpdateInput>
    /**
     * Choose, which servicio_presupuesto to update.
     */
    where: servicio_presupuestoWhereUniqueInput
  }


  /**
   * servicio_presupuesto updateMany
   */
  export type servicio_presupuestoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_presupuestos.
     */
    data: XOR<servicio_presupuestoUpdateManyMutationInput, servicio_presupuestoUncheckedUpdateManyInput>
    /**
     * Filter which servicio_presupuestos to update
     */
    where?: servicio_presupuestoWhereInput
  }


  /**
   * servicio_presupuesto upsert
   */
  export type servicio_presupuestoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_presupuesto to update in case it exists.
     */
    where: servicio_presupuestoWhereUniqueInput
    /**
     * In case the servicio_presupuesto found by the `where` argument doesn't exist, create a new servicio_presupuesto with this data.
     */
    create: XOR<servicio_presupuestoCreateInput, servicio_presupuestoUncheckedCreateInput>
    /**
     * In case the servicio_presupuesto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_presupuestoUpdateInput, servicio_presupuestoUncheckedUpdateInput>
  }


  /**
   * servicio_presupuesto delete
   */
  export type servicio_presupuestoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
    /**
     * Filter which servicio_presupuesto to delete.
     */
    where: servicio_presupuestoWhereUniqueInput
  }


  /**
   * servicio_presupuesto deleteMany
   */
  export type servicio_presupuestoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_presupuestos to delete
     */
    where?: servicio_presupuestoWhereInput
  }


  /**
   * servicio_presupuesto without action
   */
  export type servicio_presupuestoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_presupuesto
     */
    select?: servicio_presupuestoSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Ataud_precioScalarFieldEnum: {
    idprecio: 'idprecio',
    idataud: 'idataud',
    codigo: 'codigo',
    ataud: 'ataud',
    precio: 'precio',
    pri_desc: 'pri_desc',
    sec_desc: 'sec_desc',
    fecha: 'fecha',
    operador: 'operador',
    estado: 'estado'
  };

  export type Ataud_precioScalarFieldEnum = (typeof Ataud_precioScalarFieldEnum)[keyof typeof Ataud_precioScalarFieldEnum]


  export const Ataud_ventaScalarFieldEnum: {
    idataudventa: 'idataudventa',
    idataud: 'idataud',
    contrato: 'contrato',
    apellido_fall: 'apellido_fall',
    nombre_fall: 'nombre_fall',
    dni_fall: 'dni_fall',
    dom_fall: 'dom_fall',
    ndom_fall: 'ndom_fall',
    barrio_fall: 'barrio_fall',
    telefono_fall: 'telefono_fall',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    telefono_sol: 'telefono_sol',
    fecha: 'fecha',
    operador: 'operador',
    ataud: 'ataud'
  };

  export type Ataud_ventaScalarFieldEnum = (typeof Ataud_ventaScalarFieldEnum)[keyof typeof Ataud_ventaScalarFieldEnum]


  export const AtaudesScalarFieldEnum: {
    idataud: 'idataud',
    nombre: 'nombre',
    tipo: 'tipo',
    medidas: 'medidas',
    uso: 'uso',
    fabricante: 'fabricante',
    codigo: 'codigo',
    fecha_alta: 'fecha_alta',
    stock: 'stock',
    fecha_reposicion: 'fecha_reposicion',
    fecha_baja: 'fecha_baja',
    observaciones: 'observaciones',
    estado: 'estado',
    operador: 'operador'
  };

  export type AtaudesScalarFieldEnum = (typeof AtaudesScalarFieldEnum)[keyof typeof AtaudesScalarFieldEnum]


  export const Auto_usosScalarFieldEnum: {
    FECHA: 'FECHA',
    PATENTE: 'PATENTE',
    DESCRIP: 'DESCRIP',
    NOMB_OPE: 'NOMB_OPE',
    CHOFER: 'CHOFER',
    HORA1: 'HORA1',
    HORA2: 'HORA2',
    TAREA: 'TAREA',
    OBSERVA_1: 'OBSERVA_1',
    OBSERVA_2: 'OBSERVA_2',
    OPE_LLEGA: 'OPE_LLEGA',
    KILO_SAL: 'KILO_SAL',
    KILO_LLE: 'KILO_LLE',
    idusos: 'idusos'
  };

  export type Auto_usosScalarFieldEnum = (typeof Auto_usosScalarFieldEnum)[keyof typeof Auto_usosScalarFieldEnum]


  export const AutosScalarFieldEnum: {
    patente: 'patente',
    auto: 'auto',
    kilometros: 'kilometros',
    responsable: 'responsable',
    nro_poliza: 'nro_poliza',
    empresa: 'empresa',
    vencimiento: 'vencimiento',
    motor: 'motor',
    chasis: 'chasis',
    modelo: 'modelo',
    cobertura: 'cobertura',
    idauto: 'idauto',
    estado: 'estado',
    operador: 'operador'
  };

  export type AutosScalarFieldEnum = (typeof AutosScalarFieldEnum)[keyof typeof AutosScalarFieldEnum]


  export const Autos_hoja_rutaScalarFieldEnum: {
    idhojaruta: 'idhojaruta',
    patente: 'patente',
    auto: 'auto',
    conductor: 'conductor',
    idservicio: 'idservicio',
    fecha_salida: 'fecha_salida',
    km_salida: 'km_salida',
    fecha_llegada: 'fecha_llegada',
    km_llegada: 'km_llegada',
    fecha_registro: 'fecha_registro',
    operador: 'operador'
  };

  export type Autos_hoja_rutaScalarFieldEnum = (typeof Autos_hoja_rutaScalarFieldEnum)[keyof typeof Autos_hoja_rutaScalarFieldEnum]


  export const Autos_novedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    patente: 'patente',
    fecha: 'fecha',
    novedad: 'novedad',
    operador: 'operador',
    auto: 'auto'
  };

  export type Autos_novedadesScalarFieldEnum = (typeof Autos_novedadesScalarFieldEnum)[keyof typeof Autos_novedadesScalarFieldEnum]


  export const Autos_pago_patenteScalarFieldEnum: {
    idpago: 'idpago',
    patente: 'patente',
    mes: 'mes',
    ano: 'ano',
    importe: 'importe',
    cod_pago: 'cod_pago',
    idauto: 'idauto',
    operador: 'operador'
  };

  export type Autos_pago_patenteScalarFieldEnum = (typeof Autos_pago_patenteScalarFieldEnum)[keyof typeof Autos_pago_patenteScalarFieldEnum]


  export const Caja_saScalarFieldEnum: {
    idcaja: 'idcaja',
    codigo: 'codigo',
    cuenta: 'cuenta',
    tipo: 'tipo',
    serie: 'serie',
    factura: 'factura',
    importe: 'importe',
    comentarios: 'comentarios',
    nro_caja: 'nro_caja',
    movim: 'movim',
    fecha: 'fecha',
    puesto: 'puesto',
    operador: 'operador',
    cuit: 'cuit',
    proveedor: 'proveedor',
    sucursal: 'sucursal'
  };

  export type Caja_saScalarFieldEnum = (typeof Caja_saScalarFieldEnum)[keyof typeof Caja_saScalarFieldEnum]


  export const Caja_sepelioScalarFieldEnum: {
    idcaja: 'idcaja',
    operador: 'operador',
    detalle: 'detalle',
    monto: 'monto',
    estado: 'estado',
    fecha: 'fecha',
    gastos: 'gastos',
    totalcaja: 'totalcaja',
    empresa: 'empresa',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    ptoventa: 'ptoventa',
    concepto: 'concepto',
    cierre: 'cierre',
    ultimacarga: 'ultimacarga'
  };

  export type Caja_sepelioScalarFieldEnum = (typeof Caja_sepelioScalarFieldEnum)[keyof typeof Caja_sepelioScalarFieldEnum]


  export const Caja_srlScalarFieldEnum: {
    idcaja: 'idcaja',
    codigo: 'codigo',
    cuenta: 'cuenta',
    tipo: 'tipo',
    serie: 'serie',
    factura: 'factura',
    importe: 'importe',
    comentarios: 'comentarios',
    nro_caja: 'nro_caja',
    movim: 'movim',
    fecha: 'fecha',
    puesto: 'puesto',
    operador: 'operador',
    cuit: 'cuit',
    proveedor: 'proveedor',
    sucursal: 'sucursal'
  };

  export type Caja_srlScalarFieldEnum = (typeof Caja_srlScalarFieldEnum)[keyof typeof Caja_srlScalarFieldEnum]


  export const ConceptosScalarFieldEnum: {
    idconcepto: 'idconcepto',
    concepto: 'concepto',
    tipo: 'tipo'
  };

  export type ConceptosScalarFieldEnum = (typeof ConceptosScalarFieldEnum)[keyof typeof ConceptosScalarFieldEnum]


  export const Conceptos_sepelio_cuentasScalarFieldEnum: {
    idconcepto: 'idconcepto',
    idempresa: 'idempresa',
    sc_descripcion: 'sc_descripcion',
    sc_cuenta: 'sc_cuenta',
    id: 'id'
  };

  export type Conceptos_sepelio_cuentasScalarFieldEnum = (typeof Conceptos_sepelio_cuentasScalarFieldEnum)[keyof typeof Conceptos_sepelio_cuentasScalarFieldEnum]


  export const Fabricante_ataudScalarFieldEnum: {
    idfabricante: 'idfabricante',
    fabricante: 'fabricante'
  };

  export type Fabricante_ataudScalarFieldEnum = (typeof Fabricante_ataudScalarFieldEnum)[keyof typeof Fabricante_ataudScalarFieldEnum]


  export const Gasto_lutoScalarFieldEnum: {
    idgastoluto: 'idgastoluto',
    idservicio: 'idservicio',
    contrato: 'contrato',
    dni_extinto: 'dni_extinto',
    extinto: 'extinto',
    gasto_luto: 'gasto_luto',
    idataud: 'idataud',
    apellido_ben: 'apellido_ben',
    nombre_ben: 'nombre_ben',
    telefono_ben: 'telefono_ben',
    fecha: 'fecha',
    operador: 'operador',
    parentezco: 'parentezco'
  };

  export type Gasto_lutoScalarFieldEnum = (typeof Gasto_lutoScalarFieldEnum)[keyof typeof Gasto_lutoScalarFieldEnum]


  export const Gastos_cajaScalarFieldEnum: {
    idgastos: 'idgastos',
    idcaja: 'idcaja',
    concepto: 'concepto',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    fecha: 'fecha',
    operadorgestion: 'operadorgestion',
    operadortramite: 'operadortramite',
    ptoventa: 'ptoventa',
    porciva: 'porciva',
    montoiva: 'montoiva',
    retiibb: 'retiibb',
    retggcias: 'retggcias',
    perciva: 'perciva',
    detalle: 'detalle',
    mediopago: 'mediopago',
    proveedor: 'proveedor',
    empresa: 'empresa',
    total: 'total',
    idservicio: 'idservicio'
  };

  export type Gastos_cajaScalarFieldEnum = (typeof Gastos_cajaScalarFieldEnum)[keyof typeof Gastos_cajaScalarFieldEnum]


  export const Generacion_cajasScalarFieldEnum: {
    idgeneracion: 'idgeneracion',
    desde: 'desde',
    hasta: 'hasta',
    empresa: 'empresa',
    operador: 'operador',
    fecha: 'fecha'
  };

  export type Generacion_cajasScalarFieldEnum = (typeof Generacion_cajasScalarFieldEnum)[keyof typeof Generacion_cajasScalarFieldEnum]


  export const Historial_autosScalarFieldEnum: {
    idhistorial: 'idhistorial',
    patente: 'patente',
    idauto: 'idauto',
    operador: 'operador',
    fecha: 'fecha',
    accion: 'accion'
  };

  export type Historial_autosScalarFieldEnum = (typeof Historial_autosScalarFieldEnum)[keyof typeof Historial_autosScalarFieldEnum]


  export const Historial_stock_ataudScalarFieldEnum: {
    idhistorial: 'idhistorial',
    idataud: 'idataud',
    fecha_carga: 'fecha_carga',
    stock_anterior: 'stock_anterior',
    stock_nuevo: 'stock_nuevo',
    remito: 'remito',
    operador: 'operador',
    fecha_recepcion: 'fecha_recepcion'
  };

  export type Historial_stock_ataudScalarFieldEnum = (typeof Historial_stock_ataudScalarFieldEnum)[keyof typeof Historial_stock_ataudScalarFieldEnum]


  export const HonorariosScalarFieldEnum: {
    idtrabajo: 'idtrabajo',
    trabajo: 'trabajo',
    dias_habiles: 'dias_habiles',
    finde: 'finde',
    feriado: 'feriado'
  };

  export type HonorariosScalarFieldEnum = (typeof HonorariosScalarFieldEnum)[keyof typeof HonorariosScalarFieldEnum]


  export const Informe_tareasScalarFieldEnum: {
    idtareas: 'idtareas',
    idinforme: 'idinforme',
    idservicio: 'idservicio',
    operador: 'operador',
    tarea: 'tarea',
    inicio: 'inicio',
    fin: 'fin',
    horas: 'horas',
    monto: 'monto',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq'
  };

  export type Informe_tareasScalarFieldEnum = (typeof Informe_tareasScalarFieldEnum)[keyof typeof Informe_tareasScalarFieldEnum]


  export const Ingreso_cajaScalarFieldEnum: {
    idingreso: 'idingreso',
    idcaja: 'idcaja',
    concepto: 'concepto',
    monto: 'monto',
    operador: 'operador',
    fecha: 'fecha',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    empresa: 'empresa',
    detalle: 'detalle',
    ptoventa: 'ptoventa'
  };

  export type Ingreso_cajaScalarFieldEnum = (typeof Ingreso_cajaScalarFieldEnum)[keyof typeof Ingreso_cajaScalarFieldEnum]


  export const Legajo_virtual_autosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    patente: 'patente',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida'
  };

  export type Legajo_virtual_autosScalarFieldEnum = (typeof Legajo_virtual_autosScalarFieldEnum)[keyof typeof Legajo_virtual_autosScalarFieldEnum]


  export const Legajo_virtual_serviciosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    servicio: 'servicio',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa'
  };

  export type Legajo_virtual_serviciosScalarFieldEnum = (typeof Legajo_virtual_serviciosScalarFieldEnum)[keyof typeof Legajo_virtual_serviciosScalarFieldEnum]


  export const Lic_conducirScalarFieldEnum: {
    NRO_DOC: 'NRO_DOC',
    APELLIDOS: 'APELLIDOS',
    NOMBRES: 'NOMBRES',
    FEC_NAC: 'FEC_NAC',
    NRO_CARNET: 'NRO_CARNET',
    FEC_VENCI: 'FEC_VENCI',
    CLASE: 'CLASE',
    GRUPO: 'GRUPO',
    FACTOR_RH: 'FACTOR_RH',
    id: 'id'
  };

  export type Lic_conducirScalarFieldEnum = (typeof Lic_conducirScalarFieldEnum)[keyof typeof Lic_conducirScalarFieldEnum]


  export const NovedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    novedad: 'novedad',
    fecha: 'fecha',
    operador: 'operador'
  };

  export type NovedadesScalarFieldEnum = (typeof NovedadesScalarFieldEnum)[keyof typeof NovedadesScalarFieldEnum]


  export const OperadorsepScalarFieldEnum: {
    idoperador: 'idoperador',
    operador: 'operador'
  };

  export type OperadorsepScalarFieldEnum = (typeof OperadorsepScalarFieldEnum)[keyof typeof OperadorsepScalarFieldEnum]


  export const ParcelasScalarFieldEnum: {
    idparcela: 'idparcela',
    idservicio: 'idservicio',
    dni_extinto: 'dni_extinto',
    ficha: 'ficha',
    parcela: 'parcela',
    mza: 'mza',
    lote: 'lote',
    asignada: 'asignada',
    fecha: 'fecha',
    cementerio: 'cementerio',
    operador: 'operador',
    fecha_alta: 'fecha_alta',
    operador_asignacion: 'operador_asignacion',
    fecha_asignacion: 'fecha_asignacion',
    lugares: 'lugares'
  };

  export type ParcelasScalarFieldEnum = (typeof ParcelasScalarFieldEnum)[keyof typeof ParcelasScalarFieldEnum]


  export const Parcelas_lugaresScalarFieldEnum: {
    idlugar: 'idlugar',
    idparcela: 'idparcela',
    idservicio: 'idservicio',
    lugar: 'lugar',
    contrato: 'contrato',
    dni: 'dni',
    fecha: 'fecha',
    operador: 'operador'
  };

  export type Parcelas_lugaresScalarFieldEnum = (typeof Parcelas_lugaresScalarFieldEnum)[keyof typeof Parcelas_lugaresScalarFieldEnum]


  export const Precio_servicioScalarFieldEnum: {
    idprecio: 'idprecio',
    codigo: 'codigo',
    contado: 'contado',
    contado_cremacion: 'contado_cremacion',
    descuento1: 'descuento1',
    descuento1_cremacion: 'descuento1_cremacion',
    descuento2: 'descuento2',
    descuento2_cremacion: 'descuento2_cremacion',
    fecha_vigencia: 'fecha_vigencia'
  };

  export type Precio_servicioScalarFieldEnum = (typeof Precio_servicioScalarFieldEnum)[keyof typeof Precio_servicioScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    idproveedor: 'idproveedor',
    razon: 'razon',
    cuit: 'cuit',
    domicilio: 'domicilio',
    telefonos: 'telefonos',
    estado: 'estado',
    operador: 'operador'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const RodadosScalarFieldEnum: {
    patente: 'patente',
    descripcion: 'descripcion',
    km: 'km',
    responsable: 'responsable',
    n_poliza: 'n_poliza',
    emp_poliza: 'emp_poliza',
    n_motor: 'n_motor',
    n_chasis: 'n_chasis',
    ano_fabri: 'ano_fabri',
    desde: 'desde',
    hasta: 'hasta',
    id: 'id'
  };

  export type RodadosScalarFieldEnum = (typeof RodadosScalarFieldEnum)[keyof typeof RodadosScalarFieldEnum]


  export const Servicio_informesScalarFieldEnum: {
    idinforme: 'idinforme',
    idservicio: 'idservicio',
    fecha: 'fecha',
    aprobado: 'aprobado',
    fecha_aprobado: 'fecha_aprobado',
    operador_aprobado: 'operador_aprobado',
    liquidado: 'liquidado',
    fecha_liquidado: 'fecha_liquidado',
    operador_liquidado: 'operador_liquidado'
  };

  export type Servicio_informesScalarFieldEnum = (typeof Servicio_informesScalarFieldEnum)[keyof typeof Servicio_informesScalarFieldEnum]


  export const Servicio_ventaScalarFieldEnum: {
    idventa: 'idventa',
    idservicio: 'idservicio',
    monto: 'monto',
    operador: 'operador',
    fecha_venta: 'fecha_venta',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    parentesco: 'parentesco',
    operador_venta: 'operador_venta',
    liquidado: 'liquidado',
    operadorliq: 'operadorliq',
    fecha_liquidacion: 'fecha_liquidacion',
    aprobado: 'aprobado',
    operadorap: 'operadorap',
    fecha_aprobacion: 'fecha_aprobacion',
    comision: 'comision',
    fecha_carga: 'fecha_carga',
    valor_cuota: 'valor_cuota',
    plan_cuota: 'plan_cuota',
    monto_financiacion: 'monto_financiacion',
    financiacion: 'financiacion',
    efectivo: 'efectivo'
  };

  export type Servicio_ventaScalarFieldEnum = (typeof Servicio_ventaScalarFieldEnum)[keyof typeof Servicio_ventaScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    idservicio: 'idservicio',
    empresa: 'empresa',
    dni: 'dni',
    apellido: 'apellido',
    nombre: 'nombre',
    edad: 'edad',
    fecha_fallecimiento: 'fecha_fallecimiento',
    lugar_fallecimiento: 'lugar_fallecimiento',
    tipo_servicio: 'tipo_servicio',
    casa_mortuaria: 'casa_mortuaria',
    fecha_inhumacion: 'fecha_inhumacion',
    hora_inhumacion: 'hora_inhumacion',
    cementerio: 'cementerio',
    estado: 'estado',
    contrato: 'contrato',
    fecha_recepcion: 'fecha_recepcion',
    sucursal: 'sucursal',
    motivo: 'motivo',
    retiro: 'retiro',
    solicitado: 'solicitado',
    parentesco: 'parentesco',
    altura: 'altura',
    peso: 'peso',
    dni_nuevotitular: 'dni_nuevotitular',
    operador: 'operador',
    idataud: 'idataud',
    dni_solicitante: 'dni_solicitante',
    impactado: 'impactado',
    cremacion: 'cremacion',
    idparcela: 'idparcela',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    gastos_cargados: 'gastos_cargados',
    obra_soc: 'obra_soc',
    importe: 'importe',
    donacion: 'donacion',
    domicilio_solicitante: 'domicilio_solicitante',
    detalle_corona: 'detalle_corona',
    religion: 'religion',
    estado_civil: 'estado_civil',
    importe_servicio: 'importe_servicio',
    telefono: 'telefono',
    movil: 'movil',
    gasto_luto: 'gasto_luto',
    conyugue: 'conyugue'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const Servicios_historicoScalarFieldEnum: {
    NRO_NOTACR: 'NRO_NOTACR',
    FEC_CREDIT: 'FEC_CREDIT',
    EXINTO: 'EXINTO',
    DNI_EXIN: 'DNI_EXIN',
    EDAD_EXIN: 'EDAD_EXIN',
    FEC_FALLEC: 'FEC_FALLEC',
    LUGAR: 'LUGAR',
    TIPO_SERV: 'TIPO_SERV',
    PLAN: 'PLAN',
    SUB_PLAN: 'SUB_PLAN',
    CONTRATO: 'CONTRATO',
    CASA_MORT: 'CASA_MORT',
    FEC_INHU: 'FEC_INHU',
    HORA: 'HORA',
    CEMENTERIO: 'CEMENTERIO',
    DONDE_ENTI: 'DONDE_ENTI',
    ATAUD_TIPO: 'ATAUD_TIPO',
    COD_ATAUD: 'COD_ATAUD',
    DETALLE: 'DETALLE',
    RETI_CUER: 'RETI_CUER',
    TRASLADO_A: 'TRASLADO_A',
    DIFE_KM: 'DIFE_KM',
    CAPI_DOMI: 'CAPI_DOMI',
    GRAB_PLACA: 'GRAB_PLACA',
    TRAMITES: 'TRAMITES',
    AVISO_TELR: 'AVISO_TELR',
    CARROZA: 'CARROZA',
    PORTACORO: 'PORTACORO',
    AUTO_DUELO: 'AUTO_DUELO',
    SALA_VELAT: 'SALA_VELAT',
    ADICIONAL: 'ADICIONAL',
    ADICIO_PAG: 'ADICIO_PAG',
    OBSERVA0: 'OBSERVA0',
    PARCELA: 'PARCELA',
    SEC: 'SEC',
    PARC: 'PARC',
    SECC: 'SECC',
    GASTO_ASOC: 'GASTO_ASOC',
    GASTO_PAMI: 'GASTO_PAMI',
    OBSERVA1: 'OBSERVA1',
    OPE_ANUL: 'OPE_ANUL',
    ANULAR: 'ANULAR',
    FEC_ANULA: 'FEC_ANULA',
    CREDITO: 'CREDITO',
    TOTA_LETRA: 'TOTA_LETRA',
    TOTA_NUM: 'TOTA_NUM',
    FORMA_PAGO: 'FORMA_PAGO',
    DOCUMENTO: 'DOCUMENTO',
    SOLI_CRED: 'SOLI_CRED',
    GARANT_CRE: 'GARANT_CRE',
    DNI_SOLI: 'DNI_SOLI',
    TEL_SOLI: 'TEL_SOLI',
    DOMI_SOLI: 'DOMI_SOLI',
    DNI_GARANT: 'DNI_GARANT',
    TEL_GARANT: 'TEL_GARANT',
    DOMI_GARAN: 'DOMI_GARAN',
    OPE_ANUCRE: 'OPE_ANUCRE',
    ANULA_CRE: 'ANULA_CRE',
    FECANU_CRE: 'FECANU_CRE',
    INFO_CRE: 'INFO_CRE',
    SUCURSAL: 'SUCURSAL',
    OPERADOR: 'OPERADOR',
    TRASPASO: 'TRASPASO',
    EMPRESA: 'EMPRESA',
    id: 'id'
  };

  export type Servicios_historicoScalarFieldEnum = (typeof Servicios_historicoScalarFieldEnum)[keyof typeof Servicios_historicoScalarFieldEnum]


  export const TareasScalarFieldEnum: {
    idevents: 'idevents',
    title: 'title',
    allDay: 'allDay',
    start: 'start',
    end: 'end',
    priority: 'priority'
  };

  export type TareasScalarFieldEnum = (typeof TareasScalarFieldEnum)[keyof typeof TareasScalarFieldEnum]


  export const VisitantesScalarFieldEnum: {
    idvisitante: 'idvisitante',
    idservicio: 'idservicio',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    telefono: 'telefono',
    parentezco: 'parentezco',
    operador: 'operador',
    fecha: 'fecha',
    temperatura: 'temperatura'
  };

  export type VisitantesScalarFieldEnum = (typeof VisitantesScalarFieldEnum)[keyof typeof VisitantesScalarFieldEnum]


  export const Informe_gastosScalarFieldEnum: {
    idgastos: 'idgastos',
    idinforme: 'idinforme',
    idservicio: 'idservicio',
    gasto: 'gasto',
    observacion: 'observacion',
    importe: 'importe',
    liquidado: 'liquidado',
    fecha_liquidado: 'fecha_liquidado',
    operadorliq: 'operadorliq'
  };

  export type Informe_gastosScalarFieldEnum = (typeof Informe_gastosScalarFieldEnum)[keyof typeof Informe_gastosScalarFieldEnum]


  export const Servicios_gastosScalarFieldEnum: {
    idgastos: 'idgastos',
    gastos: 'gastos',
    observacion: 'observacion'
  };

  export type Servicios_gastosScalarFieldEnum = (typeof Servicios_gastosScalarFieldEnum)[keyof typeof Servicios_gastosScalarFieldEnum]


  export const Liquidacion_guardiasScalarFieldEnum: {
    idturno: 'idturno',
    lugar: 'lugar',
    inicio: 'inicio',
    fin: 'fin',
    horas: 'horas',
    operador: 'operador',
    mes: 'mes',
    ano: 'ano',
    feriado: 'feriado',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    operadorap: 'operadorap',
    importe: 'importe'
  };

  export type Liquidacion_guardiasScalarFieldEnum = (typeof Liquidacion_guardiasScalarFieldEnum)[keyof typeof Liquidacion_guardiasScalarFieldEnum]


  export const Liquidacion_registroScalarFieldEnum: {
    idliquidacion: 'idliquidacion',
    fecha: 'fecha',
    empleado: 'empleado',
    concepto: 'concepto',
    fecha_concepto: 'fecha_concepto',
    importe: 'importe',
    operador: 'operador'
  };

  export type Liquidacion_registroScalarFieldEnum = (typeof Liquidacion_registroScalarFieldEnum)[keyof typeof Liquidacion_registroScalarFieldEnum]


  export const Gastos_caja_copyScalarFieldEnum: {
    idgastos: 'idgastos',
    idcaja: 'idcaja',
    concepto: 'concepto',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    fecha: 'fecha',
    operadorgestion: 'operadorgestion',
    operadortramite: 'operadortramite',
    ptoventa: 'ptoventa',
    porciva: 'porciva',
    montoiva: 'montoiva',
    retiibb: 'retiibb',
    retggcias: 'retggcias',
    perciva: 'perciva',
    detalle: 'detalle',
    mediopago: 'mediopago',
    proveedor: 'proveedor',
    empresa: 'empresa',
    total: 'total',
    idservicio: 'idservicio'
  };

  export type Gastos_caja_copyScalarFieldEnum = (typeof Gastos_caja_copyScalarFieldEnum)[keyof typeof Gastos_caja_copyScalarFieldEnum]


  export const Servicio_presupuestoScalarFieldEnum: {
    idpresupuesto: 'idpresupuesto',
    idservicio: 'idservicio',
    fecha: 'fecha',
    apoderado: 'apoderado',
    domicilio: 'domicilio',
    telefono: 'telefono',
    detalle: 'detalle',
    total: 'total',
    anticipo: 'anticipo',
    cuotas: 'cuotas',
    saldo: 'saldo',
    operador: 'operador'
  };

  export type Servicio_presupuestoScalarFieldEnum = (typeof Servicio_presupuestoScalarFieldEnum)[keyof typeof Servicio_presupuestoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type ataud_precioWhereInput = {
    AND?: ataud_precioWhereInput | ataud_precioWhereInput[]
    OR?: ataud_precioWhereInput[]
    NOT?: ataud_precioWhereInput | ataud_precioWhereInput[]
    idprecio?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    ataud?: StringNullableFilter | string | null
    precio?: FloatNullableFilter | number | null
    pri_desc?: FloatNullableFilter | number | null
    sec_desc?: FloatNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type ataud_precioOrderByWithRelationInput = {
    idprecio?: SortOrder
    idataud?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    pri_desc?: SortOrderInput | SortOrder
    sec_desc?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type ataud_precioWhereUniqueInput = {
    idprecio?: number
  }

  export type ataud_precioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    idataud?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    pri_desc?: SortOrderInput | SortOrder
    sec_desc?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: ataud_precioCountOrderByAggregateInput
    _avg?: ataud_precioAvgOrderByAggregateInput
    _max?: ataud_precioMaxOrderByAggregateInput
    _min?: ataud_precioMinOrderByAggregateInput
    _sum?: ataud_precioSumOrderByAggregateInput
  }

  export type ataud_precioScalarWhereWithAggregatesInput = {
    AND?: ataud_precioScalarWhereWithAggregatesInput | ataud_precioScalarWhereWithAggregatesInput[]
    OR?: ataud_precioScalarWhereWithAggregatesInput[]
    NOT?: ataud_precioScalarWhereWithAggregatesInput | ataud_precioScalarWhereWithAggregatesInput[]
    idprecio?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    ataud?: StringNullableWithAggregatesFilter | string | null
    precio?: FloatNullableWithAggregatesFilter | number | null
    pri_desc?: FloatNullableWithAggregatesFilter | number | null
    sec_desc?: FloatNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ataud_ventaWhereInput = {
    AND?: ataud_ventaWhereInput | ataud_ventaWhereInput[]
    OR?: ataud_ventaWhereInput[]
    NOT?: ataud_ventaWhereInput | ataud_ventaWhereInput[]
    idataudventa?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    apellido_fall?: StringNullableFilter | string | null
    nombre_fall?: StringNullableFilter | string | null
    dni_fall?: IntNullableFilter | number | null
    dom_fall?: StringNullableFilter | string | null
    ndom_fall?: IntNullableFilter | number | null
    barrio_fall?: StringNullableFilter | string | null
    telefono_fall?: StringNullableFilter | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    telefono_sol?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    ataud?: StringNullableFilter | string | null
  }

  export type ataud_ventaOrderByWithRelationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido_fall?: SortOrderInput | SortOrder
    nombre_fall?: SortOrderInput | SortOrder
    dni_fall?: SortOrderInput | SortOrder
    dom_fall?: SortOrderInput | SortOrder
    ndom_fall?: SortOrderInput | SortOrder
    barrio_fall?: SortOrderInput | SortOrder
    telefono_fall?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
  }

  export type ataud_ventaWhereUniqueInput = {
    idataudventa?: number
  }

  export type ataud_ventaOrderByWithAggregationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido_fall?: SortOrderInput | SortOrder
    nombre_fall?: SortOrderInput | SortOrder
    dni_fall?: SortOrderInput | SortOrder
    dom_fall?: SortOrderInput | SortOrder
    ndom_fall?: SortOrderInput | SortOrder
    barrio_fall?: SortOrderInput | SortOrder
    telefono_fall?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    _count?: ataud_ventaCountOrderByAggregateInput
    _avg?: ataud_ventaAvgOrderByAggregateInput
    _max?: ataud_ventaMaxOrderByAggregateInput
    _min?: ataud_ventaMinOrderByAggregateInput
    _sum?: ataud_ventaSumOrderByAggregateInput
  }

  export type ataud_ventaScalarWhereWithAggregatesInput = {
    AND?: ataud_ventaScalarWhereWithAggregatesInput | ataud_ventaScalarWhereWithAggregatesInput[]
    OR?: ataud_ventaScalarWhereWithAggregatesInput[]
    NOT?: ataud_ventaScalarWhereWithAggregatesInput | ataud_ventaScalarWhereWithAggregatesInput[]
    idataudventa?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    apellido_fall?: StringNullableWithAggregatesFilter | string | null
    nombre_fall?: StringNullableWithAggregatesFilter | string | null
    dni_fall?: IntNullableWithAggregatesFilter | number | null
    dom_fall?: StringNullableWithAggregatesFilter | string | null
    ndom_fall?: IntNullableWithAggregatesFilter | number | null
    barrio_fall?: StringNullableWithAggregatesFilter | string | null
    telefono_fall?: StringNullableWithAggregatesFilter | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    telefono_sol?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    ataud?: StringNullableWithAggregatesFilter | string | null
  }

  export type ataudesWhereInput = {
    AND?: ataudesWhereInput | ataudesWhereInput[]
    OR?: ataudesWhereInput[]
    NOT?: ataudesWhereInput | ataudesWhereInput[]
    idataud?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    medidas?: StringNullableFilter | string | null
    uso?: StringNullableFilter | string | null
    fabricante?: StringNullableFilter | string | null
    codigo?: IntNullableFilter | number | null
    fecha_alta?: DateTimeNullableFilter | Date | string | null
    stock?: IntNullableFilter | number | null
    fecha_reposicion?: DateTimeNullableFilter | Date | string | null
    fecha_baja?: DateTimeNullableFilter | Date | string | null
    observaciones?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type ataudesOrderByWithRelationInput = {
    idataud?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    medidas?: SortOrderInput | SortOrder
    uso?: SortOrderInput | SortOrder
    fabricante?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    fecha_baja?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type ataudesWhereUniqueInput = {
    idataud?: number
  }

  export type ataudesOrderByWithAggregationInput = {
    idataud?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    medidas?: SortOrderInput | SortOrder
    uso?: SortOrderInput | SortOrder
    fabricante?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    fecha_baja?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: ataudesCountOrderByAggregateInput
    _avg?: ataudesAvgOrderByAggregateInput
    _max?: ataudesMaxOrderByAggregateInput
    _min?: ataudesMinOrderByAggregateInput
    _sum?: ataudesSumOrderByAggregateInput
  }

  export type ataudesScalarWhereWithAggregatesInput = {
    AND?: ataudesScalarWhereWithAggregatesInput | ataudesScalarWhereWithAggregatesInput[]
    OR?: ataudesScalarWhereWithAggregatesInput[]
    NOT?: ataudesScalarWhereWithAggregatesInput | ataudesScalarWhereWithAggregatesInput[]
    idataud?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    medidas?: StringNullableWithAggregatesFilter | string | null
    uso?: StringNullableWithAggregatesFilter | string | null
    fabricante?: StringNullableWithAggregatesFilter | string | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    fecha_alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock?: IntNullableWithAggregatesFilter | number | null
    fecha_reposicion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha_baja?: DateTimeNullableWithAggregatesFilter | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type auto_usosWhereInput = {
    AND?: auto_usosWhereInput | auto_usosWhereInput[]
    OR?: auto_usosWhereInput[]
    NOT?: auto_usosWhereInput | auto_usosWhereInput[]
    FECHA?: DateTimeNullableFilter | Date | string | null
    PATENTE?: StringNullableFilter | string | null
    DESCRIP?: StringNullableFilter | string | null
    NOMB_OPE?: StringNullableFilter | string | null
    CHOFER?: StringNullableFilter | string | null
    HORA1?: StringNullableFilter | string | null
    HORA2?: StringNullableFilter | string | null
    TAREA?: StringNullableFilter | string | null
    OBSERVA_1?: StringNullableFilter | string | null
    OBSERVA_2?: StringNullableFilter | string | null
    OPE_LLEGA?: StringNullableFilter | string | null
    KILO_SAL?: FloatNullableFilter | number | null
    KILO_LLE?: FloatNullableFilter | number | null
    idusos?: IntFilter | number
  }

  export type auto_usosOrderByWithRelationInput = {
    FECHA?: SortOrderInput | SortOrder
    PATENTE?: SortOrderInput | SortOrder
    DESCRIP?: SortOrderInput | SortOrder
    NOMB_OPE?: SortOrderInput | SortOrder
    CHOFER?: SortOrderInput | SortOrder
    HORA1?: SortOrderInput | SortOrder
    HORA2?: SortOrderInput | SortOrder
    TAREA?: SortOrderInput | SortOrder
    OBSERVA_1?: SortOrderInput | SortOrder
    OBSERVA_2?: SortOrderInput | SortOrder
    OPE_LLEGA?: SortOrderInput | SortOrder
    KILO_SAL?: SortOrderInput | SortOrder
    KILO_LLE?: SortOrderInput | SortOrder
    idusos?: SortOrder
  }

  export type auto_usosWhereUniqueInput = {
    idusos?: number
  }

  export type auto_usosOrderByWithAggregationInput = {
    FECHA?: SortOrderInput | SortOrder
    PATENTE?: SortOrderInput | SortOrder
    DESCRIP?: SortOrderInput | SortOrder
    NOMB_OPE?: SortOrderInput | SortOrder
    CHOFER?: SortOrderInput | SortOrder
    HORA1?: SortOrderInput | SortOrder
    HORA2?: SortOrderInput | SortOrder
    TAREA?: SortOrderInput | SortOrder
    OBSERVA_1?: SortOrderInput | SortOrder
    OBSERVA_2?: SortOrderInput | SortOrder
    OPE_LLEGA?: SortOrderInput | SortOrder
    KILO_SAL?: SortOrderInput | SortOrder
    KILO_LLE?: SortOrderInput | SortOrder
    idusos?: SortOrder
    _count?: auto_usosCountOrderByAggregateInput
    _avg?: auto_usosAvgOrderByAggregateInput
    _max?: auto_usosMaxOrderByAggregateInput
    _min?: auto_usosMinOrderByAggregateInput
    _sum?: auto_usosSumOrderByAggregateInput
  }

  export type auto_usosScalarWhereWithAggregatesInput = {
    AND?: auto_usosScalarWhereWithAggregatesInput | auto_usosScalarWhereWithAggregatesInput[]
    OR?: auto_usosScalarWhereWithAggregatesInput[]
    NOT?: auto_usosScalarWhereWithAggregatesInput | auto_usosScalarWhereWithAggregatesInput[]
    FECHA?: DateTimeNullableWithAggregatesFilter | Date | string | null
    PATENTE?: StringNullableWithAggregatesFilter | string | null
    DESCRIP?: StringNullableWithAggregatesFilter | string | null
    NOMB_OPE?: StringNullableWithAggregatesFilter | string | null
    CHOFER?: StringNullableWithAggregatesFilter | string | null
    HORA1?: StringNullableWithAggregatesFilter | string | null
    HORA2?: StringNullableWithAggregatesFilter | string | null
    TAREA?: StringNullableWithAggregatesFilter | string | null
    OBSERVA_1?: StringNullableWithAggregatesFilter | string | null
    OBSERVA_2?: StringNullableWithAggregatesFilter | string | null
    OPE_LLEGA?: StringNullableWithAggregatesFilter | string | null
    KILO_SAL?: FloatNullableWithAggregatesFilter | number | null
    KILO_LLE?: FloatNullableWithAggregatesFilter | number | null
    idusos?: IntWithAggregatesFilter | number
  }

  export type autosWhereInput = {
    AND?: autosWhereInput | autosWhereInput[]
    OR?: autosWhereInput[]
    NOT?: autosWhereInput | autosWhereInput[]
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    kilometros?: FloatNullableFilter | number | null
    responsable?: StringNullableFilter | string | null
    nro_poliza?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    vencimiento?: DateTimeNullableFilter | Date | string | null
    motor?: StringNullableFilter | string | null
    chasis?: StringNullableFilter | string | null
    modelo?: IntNullableFilter | number | null
    cobertura?: StringNullableFilter | string | null
    idauto?: IntFilter | number
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type autosOrderByWithRelationInput = {
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    kilometros?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    nro_poliza?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    vencimiento?: SortOrderInput | SortOrder
    motor?: SortOrderInput | SortOrder
    chasis?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    idauto?: SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autosWhereUniqueInput = {
    idauto?: number
  }

  export type autosOrderByWithAggregationInput = {
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    kilometros?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    nro_poliza?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    vencimiento?: SortOrderInput | SortOrder
    motor?: SortOrderInput | SortOrder
    chasis?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    idauto?: SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autosCountOrderByAggregateInput
    _avg?: autosAvgOrderByAggregateInput
    _max?: autosMaxOrderByAggregateInput
    _min?: autosMinOrderByAggregateInput
    _sum?: autosSumOrderByAggregateInput
  }

  export type autosScalarWhereWithAggregatesInput = {
    AND?: autosScalarWhereWithAggregatesInput | autosScalarWhereWithAggregatesInput[]
    OR?: autosScalarWhereWithAggregatesInput[]
    NOT?: autosScalarWhereWithAggregatesInput | autosScalarWhereWithAggregatesInput[]
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    kilometros?: FloatNullableWithAggregatesFilter | number | null
    responsable?: StringNullableWithAggregatesFilter | string | null
    nro_poliza?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    vencimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    motor?: StringNullableWithAggregatesFilter | string | null
    chasis?: StringNullableWithAggregatesFilter | string | null
    modelo?: IntNullableWithAggregatesFilter | number | null
    cobertura?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntWithAggregatesFilter | number
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_hoja_rutaWhereInput = {
    AND?: autos_hoja_rutaWhereInput | autos_hoja_rutaWhereInput[]
    OR?: autos_hoja_rutaWhereInput[]
    NOT?: autos_hoja_rutaWhereInput | autos_hoja_rutaWhereInput[]
    idhojaruta?: IntFilter | number
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    conductor?: StringNullableFilter | string | null
    idservicio?: IntNullableFilter | number | null
    fecha_salida?: DateTimeNullableFilter | Date | string | null
    km_salida?: IntNullableFilter | number | null
    fecha_llegada?: DateTimeNullableFilter | Date | string | null
    km_llegada?: IntNullableFilter | number | null
    fecha_registro?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_hoja_rutaOrderByWithRelationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    conductor?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    km_salida?: SortOrderInput | SortOrder
    fecha_llegada?: SortOrderInput | SortOrder
    km_llegada?: SortOrderInput | SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autos_hoja_rutaWhereUniqueInput = {
    idhojaruta?: number
  }

  export type autos_hoja_rutaOrderByWithAggregationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    conductor?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    km_salida?: SortOrderInput | SortOrder
    fecha_llegada?: SortOrderInput | SortOrder
    km_llegada?: SortOrderInput | SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autos_hoja_rutaCountOrderByAggregateInput
    _avg?: autos_hoja_rutaAvgOrderByAggregateInput
    _max?: autos_hoja_rutaMaxOrderByAggregateInput
    _min?: autos_hoja_rutaMinOrderByAggregateInput
    _sum?: autos_hoja_rutaSumOrderByAggregateInput
  }

  export type autos_hoja_rutaScalarWhereWithAggregatesInput = {
    AND?: autos_hoja_rutaScalarWhereWithAggregatesInput | autos_hoja_rutaScalarWhereWithAggregatesInput[]
    OR?: autos_hoja_rutaScalarWhereWithAggregatesInput[]
    NOT?: autos_hoja_rutaScalarWhereWithAggregatesInput | autos_hoja_rutaScalarWhereWithAggregatesInput[]
    idhojaruta?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    conductor?: StringNullableWithAggregatesFilter | string | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    fecha_salida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_salida?: IntNullableWithAggregatesFilter | number | null
    fecha_llegada?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_llegada?: IntNullableWithAggregatesFilter | number | null
    fecha_registro?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_novedadesWhereInput = {
    AND?: autos_novedadesWhereInput | autos_novedadesWhereInput[]
    OR?: autos_novedadesWhereInput[]
    NOT?: autos_novedadesWhereInput | autos_novedadesWhereInput[]
    idnovedad?: IntFilter | number
    patente?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    novedad?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
  }

  export type autos_novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    patente?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    novedad?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
  }

  export type autos_novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type autos_novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    patente?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    novedad?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    _count?: autos_novedadesCountOrderByAggregateInput
    _avg?: autos_novedadesAvgOrderByAggregateInput
    _max?: autos_novedadesMaxOrderByAggregateInput
    _min?: autos_novedadesMinOrderByAggregateInput
    _sum?: autos_novedadesSumOrderByAggregateInput
  }

  export type autos_novedadesScalarWhereWithAggregatesInput = {
    AND?: autos_novedadesScalarWhereWithAggregatesInput | autos_novedadesScalarWhereWithAggregatesInput[]
    OR?: autos_novedadesScalarWhereWithAggregatesInput[]
    NOT?: autos_novedadesScalarWhereWithAggregatesInput | autos_novedadesScalarWhereWithAggregatesInput[]
    idnovedad?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    novedad?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_pago_patenteWhereInput = {
    AND?: autos_pago_patenteWhereInput | autos_pago_patenteWhereInput[]
    OR?: autos_pago_patenteWhereInput[]
    NOT?: autos_pago_patenteWhereInput | autos_pago_patenteWhereInput[]
    idpago?: IntFilter | number
    patente?: StringNullableFilter | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    cod_pago?: IntNullableFilter | number | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_pago_patenteOrderByWithRelationInput = {
    idpago?: SortOrder
    patente?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    cod_pago?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autos_pago_patenteWhereUniqueInput = {
    idpago?: number
  }

  export type autos_pago_patenteOrderByWithAggregationInput = {
    idpago?: SortOrder
    patente?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    cod_pago?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autos_pago_patenteCountOrderByAggregateInput
    _avg?: autos_pago_patenteAvgOrderByAggregateInput
    _max?: autos_pago_patenteMaxOrderByAggregateInput
    _min?: autos_pago_patenteMinOrderByAggregateInput
    _sum?: autos_pago_patenteSumOrderByAggregateInput
  }

  export type autos_pago_patenteScalarWhereWithAggregatesInput = {
    AND?: autos_pago_patenteScalarWhereWithAggregatesInput | autos_pago_patenteScalarWhereWithAggregatesInput[]
    OR?: autos_pago_patenteScalarWhereWithAggregatesInput[]
    NOT?: autos_pago_patenteScalarWhereWithAggregatesInput | autos_pago_patenteScalarWhereWithAggregatesInput[]
    idpago?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    cod_pago?: IntNullableWithAggregatesFilter | number | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_saWhereInput = {
    AND?: caja_saWhereInput | caja_saWhereInput[]
    OR?: caja_saWhereInput[]
    NOT?: caja_saWhereInput | caja_saWhereInput[]
    idcaja?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    cuenta?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    serie?: IntNullableFilter | number | null
    factura?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    comentarios?: StringNullableFilter | string | null
    nro_caja?: IntNullableFilter | number | null
    movim?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    puesto?: IntNullableFilter | number | null
    operador?: IntNullableFilter | number | null
    cuit?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
  }

  export type caja_saOrderByWithRelationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
  }

  export type caja_saWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_saOrderByWithAggregationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    _count?: caja_saCountOrderByAggregateInput
    _avg?: caja_saAvgOrderByAggregateInput
    _max?: caja_saMaxOrderByAggregateInput
    _min?: caja_saMinOrderByAggregateInput
    _sum?: caja_saSumOrderByAggregateInput
  }

  export type caja_saScalarWhereWithAggregatesInput = {
    AND?: caja_saScalarWhereWithAggregatesInput | caja_saScalarWhereWithAggregatesInput[]
    OR?: caja_saScalarWhereWithAggregatesInput[]
    NOT?: caja_saScalarWhereWithAggregatesInput | caja_saScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    cuenta?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    serie?: IntNullableWithAggregatesFilter | number | null
    factura?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    comentarios?: StringNullableWithAggregatesFilter | string | null
    nro_caja?: IntNullableWithAggregatesFilter | number | null
    movim?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    puesto?: IntNullableWithAggregatesFilter | number | null
    operador?: IntNullableWithAggregatesFilter | number | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_sepelioWhereInput = {
    AND?: caja_sepelioWhereInput | caja_sepelioWhereInput[]
    OR?: caja_sepelioWhereInput[]
    NOT?: caja_sepelioWhereInput | caja_sepelioWhereInput[]
    idcaja?: IntFilter | number
    operador?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    estado?: BoolNullableFilter | boolean | null
    fecha?: DateTimeNullableFilter | Date | string | null
    gastos?: FloatNullableFilter | number | null
    totalcaja?: FloatNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: IntNullableFilter | number | null
    ptoventa?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    cierre?: DateTimeNullableFilter | Date | string | null
    ultimacarga?: DateTimeNullableFilter | Date | string | null
  }

  export type caja_sepelioOrderByWithRelationInput = {
    idcaja?: SortOrder
    operador?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    gastos?: SortOrderInput | SortOrder
    totalcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    cierre?: SortOrderInput | SortOrder
    ultimacarga?: SortOrderInput | SortOrder
  }

  export type caja_sepelioWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_sepelioOrderByWithAggregationInput = {
    idcaja?: SortOrder
    operador?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    gastos?: SortOrderInput | SortOrder
    totalcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    cierre?: SortOrderInput | SortOrder
    ultimacarga?: SortOrderInput | SortOrder
    _count?: caja_sepelioCountOrderByAggregateInput
    _avg?: caja_sepelioAvgOrderByAggregateInput
    _max?: caja_sepelioMaxOrderByAggregateInput
    _min?: caja_sepelioMinOrderByAggregateInput
    _sum?: caja_sepelioSumOrderByAggregateInput
  }

  export type caja_sepelioScalarWhereWithAggregatesInput = {
    AND?: caja_sepelioScalarWhereWithAggregatesInput | caja_sepelioScalarWhereWithAggregatesInput[]
    OR?: caja_sepelioScalarWhereWithAggregatesInput[]
    NOT?: caja_sepelioScalarWhereWithAggregatesInput | caja_sepelioScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gastos?: FloatNullableWithAggregatesFilter | number | null
    totalcaja?: FloatNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: IntNullableWithAggregatesFilter | number | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    cierre?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ultimacarga?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type caja_srlWhereInput = {
    AND?: caja_srlWhereInput | caja_srlWhereInput[]
    OR?: caja_srlWhereInput[]
    NOT?: caja_srlWhereInput | caja_srlWhereInput[]
    idcaja?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    cuenta?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    serie?: IntNullableFilter | number | null
    factura?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    comentarios?: StringNullableFilter | string | null
    nro_caja?: IntNullableFilter | number | null
    movim?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    puesto?: IntNullableFilter | number | null
    operador?: IntNullableFilter | number | null
    cuit?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
  }

  export type caja_srlOrderByWithRelationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
  }

  export type caja_srlWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_srlOrderByWithAggregationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    _count?: caja_srlCountOrderByAggregateInput
    _avg?: caja_srlAvgOrderByAggregateInput
    _max?: caja_srlMaxOrderByAggregateInput
    _min?: caja_srlMinOrderByAggregateInput
    _sum?: caja_srlSumOrderByAggregateInput
  }

  export type caja_srlScalarWhereWithAggregatesInput = {
    AND?: caja_srlScalarWhereWithAggregatesInput | caja_srlScalarWhereWithAggregatesInput[]
    OR?: caja_srlScalarWhereWithAggregatesInput[]
    NOT?: caja_srlScalarWhereWithAggregatesInput | caja_srlScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    cuenta?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    serie?: IntNullableWithAggregatesFilter | number | null
    factura?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    comentarios?: StringNullableWithAggregatesFilter | string | null
    nro_caja?: IntNullableWithAggregatesFilter | number | null
    movim?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    puesto?: IntNullableWithAggregatesFilter | number | null
    operador?: IntNullableWithAggregatesFilter | number | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
  }

  export type conceptosWhereInput = {
    AND?: conceptosWhereInput | conceptosWhereInput[]
    OR?: conceptosWhereInput[]
    NOT?: conceptosWhereInput | conceptosWhereInput[]
    idconcepto?: IntFilter | number
    concepto?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
  }

  export type conceptosOrderByWithRelationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type conceptosWhereUniqueInput = {
    idconcepto?: number
  }

  export type conceptosOrderByWithAggregationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: conceptosCountOrderByAggregateInput
    _avg?: conceptosAvgOrderByAggregateInput
    _max?: conceptosMaxOrderByAggregateInput
    _min?: conceptosMinOrderByAggregateInput
    _sum?: conceptosSumOrderByAggregateInput
  }

  export type conceptosScalarWhereWithAggregatesInput = {
    AND?: conceptosScalarWhereWithAggregatesInput | conceptosScalarWhereWithAggregatesInput[]
    OR?: conceptosScalarWhereWithAggregatesInput[]
    NOT?: conceptosScalarWhereWithAggregatesInput | conceptosScalarWhereWithAggregatesInput[]
    idconcepto?: IntWithAggregatesFilter | number
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type conceptos_sepelio_cuentasWhereInput = {
    AND?: conceptos_sepelio_cuentasWhereInput | conceptos_sepelio_cuentasWhereInput[]
    OR?: conceptos_sepelio_cuentasWhereInput[]
    NOT?: conceptos_sepelio_cuentasWhereInput | conceptos_sepelio_cuentasWhereInput[]
    idconcepto?: IntNullableFilter | number | null
    idempresa?: IntNullableFilter | number | null
    sc_descripcion?: StringNullableFilter | string | null
    sc_cuenta?: IntNullableFilter | number | null
    id?: IntFilter | number
  }

  export type conceptos_sepelio_cuentasOrderByWithRelationInput = {
    idconcepto?: SortOrderInput | SortOrder
    idempresa?: SortOrderInput | SortOrder
    sc_descripcion?: SortOrderInput | SortOrder
    sc_cuenta?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type conceptos_sepelio_cuentasWhereUniqueInput = {
    id?: number
  }

  export type conceptos_sepelio_cuentasOrderByWithAggregationInput = {
    idconcepto?: SortOrderInput | SortOrder
    idempresa?: SortOrderInput | SortOrder
    sc_descripcion?: SortOrderInput | SortOrder
    sc_cuenta?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: conceptos_sepelio_cuentasCountOrderByAggregateInput
    _avg?: conceptos_sepelio_cuentasAvgOrderByAggregateInput
    _max?: conceptos_sepelio_cuentasMaxOrderByAggregateInput
    _min?: conceptos_sepelio_cuentasMinOrderByAggregateInput
    _sum?: conceptos_sepelio_cuentasSumOrderByAggregateInput
  }

  export type conceptos_sepelio_cuentasScalarWhereWithAggregatesInput = {
    AND?: conceptos_sepelio_cuentasScalarWhereWithAggregatesInput | conceptos_sepelio_cuentasScalarWhereWithAggregatesInput[]
    OR?: conceptos_sepelio_cuentasScalarWhereWithAggregatesInput[]
    NOT?: conceptos_sepelio_cuentasScalarWhereWithAggregatesInput | conceptos_sepelio_cuentasScalarWhereWithAggregatesInput[]
    idconcepto?: IntNullableWithAggregatesFilter | number | null
    idempresa?: IntNullableWithAggregatesFilter | number | null
    sc_descripcion?: StringNullableWithAggregatesFilter | string | null
    sc_cuenta?: IntNullableWithAggregatesFilter | number | null
    id?: IntWithAggregatesFilter | number
  }

  export type fabricante_ataudWhereInput = {
    AND?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    OR?: fabricante_ataudWhereInput[]
    NOT?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    idfabricante?: IntFilter | number
    fabricante?: StringNullableFilter | string | null
  }

  export type fabricante_ataudOrderByWithRelationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
  }

  export type fabricante_ataudWhereUniqueInput = {
    idfabricante?: number
  }

  export type fabricante_ataudOrderByWithAggregationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
    _count?: fabricante_ataudCountOrderByAggregateInput
    _avg?: fabricante_ataudAvgOrderByAggregateInput
    _max?: fabricante_ataudMaxOrderByAggregateInput
    _min?: fabricante_ataudMinOrderByAggregateInput
    _sum?: fabricante_ataudSumOrderByAggregateInput
  }

  export type fabricante_ataudScalarWhereWithAggregatesInput = {
    AND?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    OR?: fabricante_ataudScalarWhereWithAggregatesInput[]
    NOT?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    idfabricante?: IntWithAggregatesFilter | number
    fabricante?: StringNullableWithAggregatesFilter | string | null
  }

  export type gasto_lutoWhereInput = {
    AND?: gasto_lutoWhereInput | gasto_lutoWhereInput[]
    OR?: gasto_lutoWhereInput[]
    NOT?: gasto_lutoWhereInput | gasto_lutoWhereInput[]
    idgastoluto?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    extinto?: StringNullableFilter | string | null
    gasto_luto?: FloatNullableFilter | number | null
    idataud?: IntNullableFilter | number | null
    apellido_ben?: StringNullableFilter | string | null
    nombre_ben?: StringNullableFilter | string | null
    telefono_ben?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    parentezco?: StringNullableFilter | string | null
  }

  export type gasto_lutoOrderByWithRelationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    extinto?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
  }

  export type gasto_lutoWhereUniqueInput = {
    idgastoluto?: number
  }

  export type gasto_lutoOrderByWithAggregationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    extinto?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    _count?: gasto_lutoCountOrderByAggregateInput
    _avg?: gasto_lutoAvgOrderByAggregateInput
    _max?: gasto_lutoMaxOrderByAggregateInput
    _min?: gasto_lutoMinOrderByAggregateInput
    _sum?: gasto_lutoSumOrderByAggregateInput
  }

  export type gasto_lutoScalarWhereWithAggregatesInput = {
    AND?: gasto_lutoScalarWhereWithAggregatesInput | gasto_lutoScalarWhereWithAggregatesInput[]
    OR?: gasto_lutoScalarWhereWithAggregatesInput[]
    NOT?: gasto_lutoScalarWhereWithAggregatesInput | gasto_lutoScalarWhereWithAggregatesInput[]
    idgastoluto?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    extinto?: StringNullableWithAggregatesFilter | string | null
    gasto_luto?: FloatNullableWithAggregatesFilter | number | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    apellido_ben?: StringNullableWithAggregatesFilter | string | null
    nombre_ben?: StringNullableWithAggregatesFilter | string | null
    telefono_ben?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
  }

  export type gastos_cajaWhereInput = {
    AND?: gastos_cajaWhereInput | gastos_cajaWhereInput[]
    OR?: gastos_cajaWhereInput[]
    NOT?: gastos_cajaWhereInput | gastos_cajaWhereInput[]
    idgastos?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operadorgestion?: StringNullableFilter | string | null
    operadortramite?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
    porciva?: StringNullableFilter | string | null
    montoiva?: IntNullableFilter | number | null
    retiibb?: FloatNullableFilter | number | null
    retggcias?: FloatNullableFilter | number | null
    perciva?: FloatNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    mediopago?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
  }

  export type gastos_cajaOrderByWithRelationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
  }

  export type gastos_cajaWhereUniqueInput = {
    idgastos?: number
  }

  export type gastos_cajaOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    _count?: gastos_cajaCountOrderByAggregateInput
    _avg?: gastos_cajaAvgOrderByAggregateInput
    _max?: gastos_cajaMaxOrderByAggregateInput
    _min?: gastos_cajaMinOrderByAggregateInput
    _sum?: gastos_cajaSumOrderByAggregateInput
  }

  export type gastos_cajaScalarWhereWithAggregatesInput = {
    AND?: gastos_cajaScalarWhereWithAggregatesInput | gastos_cajaScalarWhereWithAggregatesInput[]
    OR?: gastos_cajaScalarWhereWithAggregatesInput[]
    NOT?: gastos_cajaScalarWhereWithAggregatesInput | gastos_cajaScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorgestion?: StringNullableWithAggregatesFilter | string | null
    operadortramite?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    porciva?: StringNullableWithAggregatesFilter | string | null
    montoiva?: IntNullableWithAggregatesFilter | number | null
    retiibb?: FloatNullableWithAggregatesFilter | number | null
    retggcias?: FloatNullableWithAggregatesFilter | number | null
    perciva?: FloatNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    mediopago?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
  }

  export type generacion_cajasWhereInput = {
    AND?: generacion_cajasWhereInput | generacion_cajasWhereInput[]
    OR?: generacion_cajasWhereInput[]
    NOT?: generacion_cajasWhereInput | generacion_cajasWhereInput[]
    idgeneracion?: IntFilter | number
    desde?: DateTimeNullableFilter | Date | string | null
    hasta?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
  }

  export type generacion_cajasOrderByWithRelationInput = {
    idgeneracion?: SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type generacion_cajasWhereUniqueInput = {
    idgeneracion?: number
  }

  export type generacion_cajasOrderByWithAggregationInput = {
    idgeneracion?: SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: generacion_cajasCountOrderByAggregateInput
    _avg?: generacion_cajasAvgOrderByAggregateInput
    _max?: generacion_cajasMaxOrderByAggregateInput
    _min?: generacion_cajasMinOrderByAggregateInput
    _sum?: generacion_cajasSumOrderByAggregateInput
  }

  export type generacion_cajasScalarWhereWithAggregatesInput = {
    AND?: generacion_cajasScalarWhereWithAggregatesInput | generacion_cajasScalarWhereWithAggregatesInput[]
    OR?: generacion_cajasScalarWhereWithAggregatesInput[]
    NOT?: generacion_cajasScalarWhereWithAggregatesInput | generacion_cajasScalarWhereWithAggregatesInput[]
    idgeneracion?: IntWithAggregatesFilter | number
    desde?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hasta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type historial_autosWhereInput = {
    AND?: historial_autosWhereInput | historial_autosWhereInput[]
    OR?: historial_autosWhereInput[]
    NOT?: historial_autosWhereInput | historial_autosWhereInput[]
    idhistorial?: IntFilter | number
    patente?: StringNullableFilter | string | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    accion?: StringNullableFilter | string | null
  }

  export type historial_autosOrderByWithRelationInput = {
    idhistorial?: SortOrder
    patente?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
  }

  export type historial_autosWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_autosOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    patente?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    _count?: historial_autosCountOrderByAggregateInput
    _avg?: historial_autosAvgOrderByAggregateInput
    _max?: historial_autosMaxOrderByAggregateInput
    _min?: historial_autosMinOrderByAggregateInput
    _sum?: historial_autosSumOrderByAggregateInput
  }

  export type historial_autosScalarWhereWithAggregatesInput = {
    AND?: historial_autosScalarWhereWithAggregatesInput | historial_autosScalarWhereWithAggregatesInput[]
    OR?: historial_autosScalarWhereWithAggregatesInput[]
    NOT?: historial_autosScalarWhereWithAggregatesInput | historial_autosScalarWhereWithAggregatesInput[]
    idhistorial?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
  }

  export type historial_stock_ataudWhereInput = {
    AND?: historial_stock_ataudWhereInput | historial_stock_ataudWhereInput[]
    OR?: historial_stock_ataudWhereInput[]
    NOT?: historial_stock_ataudWhereInput | historial_stock_ataudWhereInput[]
    idhistorial?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    stock_anterior?: IntNullableFilter | number | null
    stock_nuevo?: IntNullableFilter | number | null
    remito?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_recepcion?: DateTimeNullableFilter | Date | string | null
  }

  export type historial_stock_ataudOrderByWithRelationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    stock_anterior?: SortOrderInput | SortOrder
    stock_nuevo?: SortOrderInput | SortOrder
    remito?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
  }

  export type historial_stock_ataudWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_stock_ataudOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    stock_anterior?: SortOrderInput | SortOrder
    stock_nuevo?: SortOrderInput | SortOrder
    remito?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    _count?: historial_stock_ataudCountOrderByAggregateInput
    _avg?: historial_stock_ataudAvgOrderByAggregateInput
    _max?: historial_stock_ataudMaxOrderByAggregateInput
    _min?: historial_stock_ataudMinOrderByAggregateInput
    _sum?: historial_stock_ataudSumOrderByAggregateInput
  }

  export type historial_stock_ataudScalarWhereWithAggregatesInput = {
    AND?: historial_stock_ataudScalarWhereWithAggregatesInput | historial_stock_ataudScalarWhereWithAggregatesInput[]
    OR?: historial_stock_ataudScalarWhereWithAggregatesInput[]
    NOT?: historial_stock_ataudScalarWhereWithAggregatesInput | historial_stock_ataudScalarWhereWithAggregatesInput[]
    idhistorial?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock_anterior?: IntNullableWithAggregatesFilter | number | null
    stock_nuevo?: IntNullableWithAggregatesFilter | number | null
    remito?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_recepcion?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type honorariosWhereInput = {
    AND?: honorariosWhereInput | honorariosWhereInput[]
    OR?: honorariosWhereInput[]
    NOT?: honorariosWhereInput | honorariosWhereInput[]
    idtrabajo?: IntFilter | number
    trabajo?: StringNullableFilter | string | null
    dias_habiles?: IntNullableFilter | number | null
    finde?: IntNullableFilter | number | null
    feriado?: IntNullableFilter | number | null
  }

  export type honorariosOrderByWithRelationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrderInput | SortOrder
    dias_habiles?: SortOrderInput | SortOrder
    finde?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
  }

  export type honorariosWhereUniqueInput = {
    idtrabajo?: number
  }

  export type honorariosOrderByWithAggregationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrderInput | SortOrder
    dias_habiles?: SortOrderInput | SortOrder
    finde?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    _count?: honorariosCountOrderByAggregateInput
    _avg?: honorariosAvgOrderByAggregateInput
    _max?: honorariosMaxOrderByAggregateInput
    _min?: honorariosMinOrderByAggregateInput
    _sum?: honorariosSumOrderByAggregateInput
  }

  export type honorariosScalarWhereWithAggregatesInput = {
    AND?: honorariosScalarWhereWithAggregatesInput | honorariosScalarWhereWithAggregatesInput[]
    OR?: honorariosScalarWhereWithAggregatesInput[]
    NOT?: honorariosScalarWhereWithAggregatesInput | honorariosScalarWhereWithAggregatesInput[]
    idtrabajo?: IntWithAggregatesFilter | number
    trabajo?: StringNullableWithAggregatesFilter | string | null
    dias_habiles?: IntNullableWithAggregatesFilter | number | null
    finde?: IntNullableWithAggregatesFilter | number | null
    feriado?: IntNullableWithAggregatesFilter | number | null
  }

  export type informe_tareasWhereInput = {
    AND?: informe_tareasWhereInput | informe_tareasWhereInput[]
    OR?: informe_tareasWhereInput[]
    NOT?: informe_tareasWhereInput | informe_tareasWhereInput[]
    idtareas?: IntFilter | number
    idinforme?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    tarea?: StringNullableFilter | string | null
    inicio?: StringNullableFilter | string | null
    fin?: StringNullableFilter | string | null
    horas?: IntNullableFilter | number | null
    monto?: FloatNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: DateTimeNullableFilter | Date | string | null
    operadorliq?: StringNullableFilter | string | null
  }

  export type informe_tareasOrderByWithRelationInput = {
    idtareas?: SortOrder
    idinforme?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
  }

  export type informe_tareasWhereUniqueInput = {
    idtareas?: number
  }

  export type informe_tareasOrderByWithAggregationInput = {
    idtareas?: SortOrder
    idinforme?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    _count?: informe_tareasCountOrderByAggregateInput
    _avg?: informe_tareasAvgOrderByAggregateInput
    _max?: informe_tareasMaxOrderByAggregateInput
    _min?: informe_tareasMinOrderByAggregateInput
    _sum?: informe_tareasSumOrderByAggregateInput
  }

  export type informe_tareasScalarWhereWithAggregatesInput = {
    AND?: informe_tareasScalarWhereWithAggregatesInput | informe_tareasScalarWhereWithAggregatesInput[]
    OR?: informe_tareasScalarWhereWithAggregatesInput[]
    NOT?: informe_tareasScalarWhereWithAggregatesInput | informe_tareasScalarWhereWithAggregatesInput[]
    idtareas?: IntWithAggregatesFilter | number
    idinforme?: IntNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    tarea?: StringNullableWithAggregatesFilter | string | null
    inicio?: StringNullableWithAggregatesFilter | string | null
    fin?: StringNullableWithAggregatesFilter | string | null
    horas?: IntNullableWithAggregatesFilter | number | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
  }

  export type ingreso_cajaWhereInput = {
    AND?: ingreso_cajaWhereInput | ingreso_cajaWhereInput[]
    OR?: ingreso_cajaWhereInput[]
    NOT?: ingreso_cajaWhereInput | ingreso_cajaWhereInput[]
    idingreso?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
  }

  export type ingreso_cajaOrderByWithRelationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
  }

  export type ingreso_cajaWhereUniqueInput = {
    idingreso?: number
  }

  export type ingreso_cajaOrderByWithAggregationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    _count?: ingreso_cajaCountOrderByAggregateInput
    _avg?: ingreso_cajaAvgOrderByAggregateInput
    _max?: ingreso_cajaMaxOrderByAggregateInput
    _min?: ingreso_cajaMinOrderByAggregateInput
    _sum?: ingreso_cajaSumOrderByAggregateInput
  }

  export type ingreso_cajaScalarWhereWithAggregatesInput = {
    AND?: ingreso_cajaScalarWhereWithAggregatesInput | ingreso_cajaScalarWhereWithAggregatesInput[]
    OR?: ingreso_cajaScalarWhereWithAggregatesInput[]
    NOT?: ingreso_cajaScalarWhereWithAggregatesInput | ingreso_cajaScalarWhereWithAggregatesInput[]
    idingreso?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
  }

  export type legajo_virtual_autosWhereInput = {
    AND?: legajo_virtual_autosWhereInput | legajo_virtual_autosWhereInput[]
    OR?: legajo_virtual_autosWhereInput[]
    NOT?: legajo_virtual_autosWhereInput | legajo_virtual_autosWhereInput[]
    idlegajo?: IntFilter | number
    patente?: StringNullableFilter | string | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
  }

  export type legajo_virtual_autosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    patente?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_autosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_autosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    patente?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    _count?: legajo_virtual_autosCountOrderByAggregateInput
    _avg?: legajo_virtual_autosAvgOrderByAggregateInput
    _max?: legajo_virtual_autosMaxOrderByAggregateInput
    _min?: legajo_virtual_autosMinOrderByAggregateInput
    _sum?: legajo_virtual_autosSumOrderByAggregateInput
  }

  export type legajo_virtual_autosScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_autosScalarWhereWithAggregatesInput | legajo_virtual_autosScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_autosScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_autosScalarWhereWithAggregatesInput | legajo_virtual_autosScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type legajo_virtual_serviciosWhereInput = {
    AND?: legajo_virtual_serviciosWhereInput | legajo_virtual_serviciosWhereInput[]
    OR?: legajo_virtual_serviciosWhereInput[]
    NOT?: legajo_virtual_serviciosWhereInput | legajo_virtual_serviciosWhereInput[]
    idlegajo?: IntFilter | number
    servicio?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
  }

  export type legajo_virtual_serviciosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_serviciosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_serviciosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    _count?: legajo_virtual_serviciosCountOrderByAggregateInput
    _avg?: legajo_virtual_serviciosAvgOrderByAggregateInput
    _max?: legajo_virtual_serviciosMaxOrderByAggregateInput
    _min?: legajo_virtual_serviciosMinOrderByAggregateInput
    _sum?: legajo_virtual_serviciosSumOrderByAggregateInput
  }

  export type legajo_virtual_serviciosScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_serviciosScalarWhereWithAggregatesInput | legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_serviciosScalarWhereWithAggregatesInput | legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    servicio?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type lic_conducirWhereInput = {
    AND?: lic_conducirWhereInput | lic_conducirWhereInput[]
    OR?: lic_conducirWhereInput[]
    NOT?: lic_conducirWhereInput | lic_conducirWhereInput[]
    NRO_DOC?: IntNullableFilter | number | null
    APELLIDOS?: StringNullableFilter | string | null
    NOMBRES?: StringNullableFilter | string | null
    FEC_NAC?: DateTimeNullableFilter | Date | string | null
    NRO_CARNET?: StringNullableFilter | string | null
    FEC_VENCI?: DateTimeNullableFilter | Date | string | null
    CLASE?: StringNullableFilter | string | null
    GRUPO?: StringNullableFilter | string | null
    FACTOR_RH?: StringNullableFilter | string | null
    id?: IntFilter | number
  }

  export type lic_conducirOrderByWithRelationInput = {
    NRO_DOC?: SortOrderInput | SortOrder
    APELLIDOS?: SortOrderInput | SortOrder
    NOMBRES?: SortOrderInput | SortOrder
    FEC_NAC?: SortOrderInput | SortOrder
    NRO_CARNET?: SortOrderInput | SortOrder
    FEC_VENCI?: SortOrderInput | SortOrder
    CLASE?: SortOrderInput | SortOrder
    GRUPO?: SortOrderInput | SortOrder
    FACTOR_RH?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type lic_conducirWhereUniqueInput = {
    id?: number
  }

  export type lic_conducirOrderByWithAggregationInput = {
    NRO_DOC?: SortOrderInput | SortOrder
    APELLIDOS?: SortOrderInput | SortOrder
    NOMBRES?: SortOrderInput | SortOrder
    FEC_NAC?: SortOrderInput | SortOrder
    NRO_CARNET?: SortOrderInput | SortOrder
    FEC_VENCI?: SortOrderInput | SortOrder
    CLASE?: SortOrderInput | SortOrder
    GRUPO?: SortOrderInput | SortOrder
    FACTOR_RH?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: lic_conducirCountOrderByAggregateInput
    _avg?: lic_conducirAvgOrderByAggregateInput
    _max?: lic_conducirMaxOrderByAggregateInput
    _min?: lic_conducirMinOrderByAggregateInput
    _sum?: lic_conducirSumOrderByAggregateInput
  }

  export type lic_conducirScalarWhereWithAggregatesInput = {
    AND?: lic_conducirScalarWhereWithAggregatesInput | lic_conducirScalarWhereWithAggregatesInput[]
    OR?: lic_conducirScalarWhereWithAggregatesInput[]
    NOT?: lic_conducirScalarWhereWithAggregatesInput | lic_conducirScalarWhereWithAggregatesInput[]
    NRO_DOC?: IntNullableWithAggregatesFilter | number | null
    APELLIDOS?: StringNullableWithAggregatesFilter | string | null
    NOMBRES?: StringNullableWithAggregatesFilter | string | null
    FEC_NAC?: DateTimeNullableWithAggregatesFilter | Date | string | null
    NRO_CARNET?: StringNullableWithAggregatesFilter | string | null
    FEC_VENCI?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CLASE?: StringNullableWithAggregatesFilter | string | null
    GRUPO?: StringNullableWithAggregatesFilter | string | null
    FACTOR_RH?: StringNullableWithAggregatesFilter | string | null
    id?: IntWithAggregatesFilter | number
  }

  export type novedadesWhereInput = {
    AND?: novedadesWhereInput | novedadesWhereInput[]
    OR?: novedadesWhereInput[]
    NOT?: novedadesWhereInput | novedadesWhereInput[]
    idnovedad?: IntFilter | number
    novedad?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: novedadesCountOrderByAggregateInput
    _avg?: novedadesAvgOrderByAggregateInput
    _max?: novedadesMaxOrderByAggregateInput
    _min?: novedadesMinOrderByAggregateInput
    _sum?: novedadesSumOrderByAggregateInput
  }

  export type novedadesScalarWhereWithAggregatesInput = {
    AND?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    OR?: novedadesScalarWhereWithAggregatesInput[]
    NOT?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    idnovedad?: IntWithAggregatesFilter | number
    novedad?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type operadorsepWhereInput = {
    AND?: operadorsepWhereInput | operadorsepWhereInput[]
    OR?: operadorsepWhereInput[]
    NOT?: operadorsepWhereInput | operadorsepWhereInput[]
    idoperador?: IntFilter | number
    operador?: StringNullableFilter | string | null
  }

  export type operadorsepOrderByWithRelationInput = {
    idoperador?: SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type operadorsepWhereUniqueInput = {
    idoperador?: number
  }

  export type operadorsepOrderByWithAggregationInput = {
    idoperador?: SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: operadorsepCountOrderByAggregateInput
    _avg?: operadorsepAvgOrderByAggregateInput
    _max?: operadorsepMaxOrderByAggregateInput
    _min?: operadorsepMinOrderByAggregateInput
    _sum?: operadorsepSumOrderByAggregateInput
  }

  export type operadorsepScalarWhereWithAggregatesInput = {
    AND?: operadorsepScalarWhereWithAggregatesInput | operadorsepScalarWhereWithAggregatesInput[]
    OR?: operadorsepScalarWhereWithAggregatesInput[]
    NOT?: operadorsepScalarWhereWithAggregatesInput | operadorsepScalarWhereWithAggregatesInput[]
    idoperador?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type parcelasWhereInput = {
    AND?: parcelasWhereInput | parcelasWhereInput[]
    OR?: parcelasWhereInput[]
    NOT?: parcelasWhereInput | parcelasWhereInput[]
    idparcela?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    ficha?: IntNullableFilter | number | null
    parcela?: StringNullableFilter | string | null
    mza?: IntNullableFilter | number | null
    lote?: IntNullableFilter | number | null
    asignada?: BoolNullableFilter | boolean | null
    fecha?: StringNullableFilter | string | null
    cementerio?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_alta?: StringNullableFilter | string | null
    operador_asignacion?: StringNullableFilter | string | null
    fecha_asignacion?: StringNullableFilter | string | null
    lugares?: IntNullableFilter | number | null
  }

  export type parcelasOrderByWithRelationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    ficha?: SortOrderInput | SortOrder
    parcela?: SortOrderInput | SortOrder
    mza?: SortOrderInput | SortOrder
    lote?: SortOrderInput | SortOrder
    asignada?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    operador_asignacion?: SortOrderInput | SortOrder
    fecha_asignacion?: SortOrderInput | SortOrder
    lugares?: SortOrderInput | SortOrder
  }

  export type parcelasWhereUniqueInput = {
    idparcela?: number
  }

  export type parcelasOrderByWithAggregationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    ficha?: SortOrderInput | SortOrder
    parcela?: SortOrderInput | SortOrder
    mza?: SortOrderInput | SortOrder
    lote?: SortOrderInput | SortOrder
    asignada?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    operador_asignacion?: SortOrderInput | SortOrder
    fecha_asignacion?: SortOrderInput | SortOrder
    lugares?: SortOrderInput | SortOrder
    _count?: parcelasCountOrderByAggregateInput
    _avg?: parcelasAvgOrderByAggregateInput
    _max?: parcelasMaxOrderByAggregateInput
    _min?: parcelasMinOrderByAggregateInput
    _sum?: parcelasSumOrderByAggregateInput
  }

  export type parcelasScalarWhereWithAggregatesInput = {
    AND?: parcelasScalarWhereWithAggregatesInput | parcelasScalarWhereWithAggregatesInput[]
    OR?: parcelasScalarWhereWithAggregatesInput[]
    NOT?: parcelasScalarWhereWithAggregatesInput | parcelasScalarWhereWithAggregatesInput[]
    idparcela?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    ficha?: IntNullableWithAggregatesFilter | number | null
    parcela?: StringNullableWithAggregatesFilter | string | null
    mza?: IntNullableWithAggregatesFilter | number | null
    lote?: IntNullableWithAggregatesFilter | number | null
    asignada?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_alta?: StringNullableWithAggregatesFilter | string | null
    operador_asignacion?: StringNullableWithAggregatesFilter | string | null
    fecha_asignacion?: StringNullableWithAggregatesFilter | string | null
    lugares?: IntNullableWithAggregatesFilter | number | null
  }

  export type parcelas_lugaresWhereInput = {
    AND?: parcelas_lugaresWhereInput | parcelas_lugaresWhereInput[]
    OR?: parcelas_lugaresWhereInput[]
    NOT?: parcelas_lugaresWhereInput | parcelas_lugaresWhereInput[]
    idlugar?: IntFilter | number
    idparcela?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    lugar?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    dni?: IntNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type parcelas_lugaresOrderByWithRelationInput = {
    idlugar?: SortOrder
    idparcela?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type parcelas_lugaresWhereUniqueInput = {
    idlugar?: number
  }

  export type parcelas_lugaresOrderByWithAggregationInput = {
    idlugar?: SortOrder
    idparcela?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: parcelas_lugaresCountOrderByAggregateInput
    _avg?: parcelas_lugaresAvgOrderByAggregateInput
    _max?: parcelas_lugaresMaxOrderByAggregateInput
    _min?: parcelas_lugaresMinOrderByAggregateInput
    _sum?: parcelas_lugaresSumOrderByAggregateInput
  }

  export type parcelas_lugaresScalarWhereWithAggregatesInput = {
    AND?: parcelas_lugaresScalarWhereWithAggregatesInput | parcelas_lugaresScalarWhereWithAggregatesInput[]
    OR?: parcelas_lugaresScalarWhereWithAggregatesInput[]
    NOT?: parcelas_lugaresScalarWhereWithAggregatesInput | parcelas_lugaresScalarWhereWithAggregatesInput[]
    idlugar?: IntWithAggregatesFilter | number
    idparcela?: IntNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    lugar?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    dni?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type precio_servicioWhereInput = {
    AND?: precio_servicioWhereInput | precio_servicioWhereInput[]
    OR?: precio_servicioWhereInput[]
    NOT?: precio_servicioWhereInput | precio_servicioWhereInput[]
    idprecio?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    contado?: IntNullableFilter | number | null
    contado_cremacion?: IntNullableFilter | number | null
    descuento1?: IntNullableFilter | number | null
    descuento1_cremacion?: IntNullableFilter | number | null
    descuento2?: IntNullableFilter | number | null
    descuento2_cremacion?: IntNullableFilter | number | null
    fecha_vigencia?: DateTimeNullableFilter | Date | string | null
  }

  export type precio_servicioOrderByWithRelationInput = {
    idprecio?: SortOrder
    codigo?: SortOrderInput | SortOrder
    contado?: SortOrderInput | SortOrder
    contado_cremacion?: SortOrderInput | SortOrder
    descuento1?: SortOrderInput | SortOrder
    descuento1_cremacion?: SortOrderInput | SortOrder
    descuento2?: SortOrderInput | SortOrder
    descuento2_cremacion?: SortOrderInput | SortOrder
    fecha_vigencia?: SortOrderInput | SortOrder
  }

  export type precio_servicioWhereUniqueInput = {
    idprecio?: number
  }

  export type precio_servicioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    codigo?: SortOrderInput | SortOrder
    contado?: SortOrderInput | SortOrder
    contado_cremacion?: SortOrderInput | SortOrder
    descuento1?: SortOrderInput | SortOrder
    descuento1_cremacion?: SortOrderInput | SortOrder
    descuento2?: SortOrderInput | SortOrder
    descuento2_cremacion?: SortOrderInput | SortOrder
    fecha_vigencia?: SortOrderInput | SortOrder
    _count?: precio_servicioCountOrderByAggregateInput
    _avg?: precio_servicioAvgOrderByAggregateInput
    _max?: precio_servicioMaxOrderByAggregateInput
    _min?: precio_servicioMinOrderByAggregateInput
    _sum?: precio_servicioSumOrderByAggregateInput
  }

  export type precio_servicioScalarWhereWithAggregatesInput = {
    AND?: precio_servicioScalarWhereWithAggregatesInput | precio_servicioScalarWhereWithAggregatesInput[]
    OR?: precio_servicioScalarWhereWithAggregatesInput[]
    NOT?: precio_servicioScalarWhereWithAggregatesInput | precio_servicioScalarWhereWithAggregatesInput[]
    idprecio?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    contado?: IntNullableWithAggregatesFilter | number | null
    contado_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento1?: IntNullableWithAggregatesFilter | number | null
    descuento1_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento2?: IntNullableWithAggregatesFilter | number | null
    descuento2_cremacion?: IntNullableWithAggregatesFilter | number | null
    fecha_vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type proveedoresWhereInput = {
    AND?: proveedoresWhereInput | proveedoresWhereInput[]
    OR?: proveedoresWhereInput[]
    NOT?: proveedoresWhereInput | proveedoresWhereInput[]
    idproveedor?: IntFilter | number
    razon?: StringNullableFilter | string | null
    cuit?: StringNullableFilter | string | null
    domicilio?: StringNullableFilter | string | null
    telefonos?: StringNullableFilter | string | null
    estado?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type proveedoresOrderByWithRelationInput = {
    idproveedor?: SortOrder
    razon?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefonos?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type proveedoresWhereUniqueInput = {
    idproveedor?: number
  }

  export type proveedoresOrderByWithAggregationInput = {
    idproveedor?: SortOrder
    razon?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefonos?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: proveedoresCountOrderByAggregateInput
    _avg?: proveedoresAvgOrderByAggregateInput
    _max?: proveedoresMaxOrderByAggregateInput
    _min?: proveedoresMinOrderByAggregateInput
    _sum?: proveedoresSumOrderByAggregateInput
  }

  export type proveedoresScalarWhereWithAggregatesInput = {
    AND?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    OR?: proveedoresScalarWhereWithAggregatesInput[]
    NOT?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    idproveedor?: IntWithAggregatesFilter | number
    razon?: StringNullableWithAggregatesFilter | string | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    domicilio?: StringNullableWithAggregatesFilter | string | null
    telefonos?: StringNullableWithAggregatesFilter | string | null
    estado?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type rodadosWhereInput = {
    AND?: rodadosWhereInput | rodadosWhereInput[]
    OR?: rodadosWhereInput[]
    NOT?: rodadosWhereInput | rodadosWhereInput[]
    patente?: StringNullableFilter | string | null
    descripcion?: StringNullableFilter | string | null
    km?: StringNullableFilter | string | null
    responsable?: StringNullableFilter | string | null
    n_poliza?: StringNullableFilter | string | null
    emp_poliza?: StringNullableFilter | string | null
    n_motor?: StringNullableFilter | string | null
    n_chasis?: StringNullableFilter | string | null
    ano_fabri?: StringNullableFilter | string | null
    desde?: DateTimeNullableFilter | Date | string | null
    hasta?: DateTimeNullableFilter | Date | string | null
    id?: IntFilter | number
  }

  export type rodadosOrderByWithRelationInput = {
    patente?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    km?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    n_poliza?: SortOrderInput | SortOrder
    emp_poliza?: SortOrderInput | SortOrder
    n_motor?: SortOrderInput | SortOrder
    n_chasis?: SortOrderInput | SortOrder
    ano_fabri?: SortOrderInput | SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type rodadosWhereUniqueInput = {
    id?: number
  }

  export type rodadosOrderByWithAggregationInput = {
    patente?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    km?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    n_poliza?: SortOrderInput | SortOrder
    emp_poliza?: SortOrderInput | SortOrder
    n_motor?: SortOrderInput | SortOrder
    n_chasis?: SortOrderInput | SortOrder
    ano_fabri?: SortOrderInput | SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: rodadosCountOrderByAggregateInput
    _avg?: rodadosAvgOrderByAggregateInput
    _max?: rodadosMaxOrderByAggregateInput
    _min?: rodadosMinOrderByAggregateInput
    _sum?: rodadosSumOrderByAggregateInput
  }

  export type rodadosScalarWhereWithAggregatesInput = {
    AND?: rodadosScalarWhereWithAggregatesInput | rodadosScalarWhereWithAggregatesInput[]
    OR?: rodadosScalarWhereWithAggregatesInput[]
    NOT?: rodadosScalarWhereWithAggregatesInput | rodadosScalarWhereWithAggregatesInput[]
    patente?: StringNullableWithAggregatesFilter | string | null
    descripcion?: StringNullableWithAggregatesFilter | string | null
    km?: StringNullableWithAggregatesFilter | string | null
    responsable?: StringNullableWithAggregatesFilter | string | null
    n_poliza?: StringNullableWithAggregatesFilter | string | null
    emp_poliza?: StringNullableWithAggregatesFilter | string | null
    n_motor?: StringNullableWithAggregatesFilter | string | null
    n_chasis?: StringNullableWithAggregatesFilter | string | null
    ano_fabri?: StringNullableWithAggregatesFilter | string | null
    desde?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hasta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    id?: IntWithAggregatesFilter | number
  }

  export type servicio_informesWhereInput = {
    AND?: servicio_informesWhereInput | servicio_informesWhereInput[]
    OR?: servicio_informesWhereInput[]
    NOT?: servicio_informesWhereInput | servicio_informesWhereInput[]
    idinforme?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    aprobado?: BoolNullableFilter | boolean | null
    fecha_aprobado?: DateTimeNullableFilter | Date | string | null
    operador_aprobado?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidado?: DateTimeNullableFilter | Date | string | null
    operador_liquidado?: StringNullableFilter | string | null
  }

  export type servicio_informesOrderByWithRelationInput = {
    idinforme?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobado?: SortOrderInput | SortOrder
    operador_aprobado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidado?: SortOrderInput | SortOrder
    operador_liquidado?: SortOrderInput | SortOrder
  }

  export type servicio_informesWhereUniqueInput = {
    idinforme?: number
  }

  export type servicio_informesOrderByWithAggregationInput = {
    idinforme?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobado?: SortOrderInput | SortOrder
    operador_aprobado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidado?: SortOrderInput | SortOrder
    operador_liquidado?: SortOrderInput | SortOrder
    _count?: servicio_informesCountOrderByAggregateInput
    _avg?: servicio_informesAvgOrderByAggregateInput
    _max?: servicio_informesMaxOrderByAggregateInput
    _min?: servicio_informesMinOrderByAggregateInput
    _sum?: servicio_informesSumOrderByAggregateInput
  }

  export type servicio_informesScalarWhereWithAggregatesInput = {
    AND?: servicio_informesScalarWhereWithAggregatesInput | servicio_informesScalarWhereWithAggregatesInput[]
    OR?: servicio_informesScalarWhereWithAggregatesInput[]
    NOT?: servicio_informesScalarWhereWithAggregatesInput | servicio_informesScalarWhereWithAggregatesInput[]
    idinforme?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_aprobado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador_aprobado?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador_liquidado?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_ventaWhereInput = {
    AND?: servicio_ventaWhereInput | servicio_ventaWhereInput[]
    OR?: servicio_ventaWhereInput[]
    NOT?: servicio_ventaWhereInput | servicio_ventaWhereInput[]
    idventa?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha_venta?: DateTimeNullableFilter | Date | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    parentesco?: StringNullableFilter | string | null
    operador_venta?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    operadorliq?: StringNullableFilter | string | null
    fecha_liquidacion?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    operadorap?: StringNullableFilter | string | null
    fecha_aprobacion?: StringNullableFilter | string | null
    comision?: FloatNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    valor_cuota?: FloatNullableFilter | number | null
    plan_cuota?: IntNullableFilter | number | null
    monto_financiacion?: FloatNullableFilter | number | null
    financiacion?: BoolNullableFilter | boolean | null
    efectivo?: FloatNullableFilter | number | null
  }

  export type servicio_ventaOrderByWithRelationInput = {
    idventa?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_venta?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    operador_venta?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    valor_cuota?: SortOrderInput | SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    monto_financiacion?: SortOrderInput | SortOrder
    financiacion?: SortOrderInput | SortOrder
    efectivo?: SortOrderInput | SortOrder
  }

  export type servicio_ventaWhereUniqueInput = {
    idventa?: number
  }

  export type servicio_ventaOrderByWithAggregationInput = {
    idventa?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_venta?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    operador_venta?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    valor_cuota?: SortOrderInput | SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    monto_financiacion?: SortOrderInput | SortOrder
    financiacion?: SortOrderInput | SortOrder
    efectivo?: SortOrderInput | SortOrder
    _count?: servicio_ventaCountOrderByAggregateInput
    _avg?: servicio_ventaAvgOrderByAggregateInput
    _max?: servicio_ventaMaxOrderByAggregateInput
    _min?: servicio_ventaMinOrderByAggregateInput
    _sum?: servicio_ventaSumOrderByAggregateInput
  }

  export type servicio_ventaScalarWhereWithAggregatesInput = {
    AND?: servicio_ventaScalarWhereWithAggregatesInput | servicio_ventaScalarWhereWithAggregatesInput[]
    OR?: servicio_ventaScalarWhereWithAggregatesInput[]
    NOT?: servicio_ventaScalarWhereWithAggregatesInput | servicio_ventaScalarWhereWithAggregatesInput[]
    idventa?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_venta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    operador_venta?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    comision?: FloatNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    valor_cuota?: FloatNullableWithAggregatesFilter | number | null
    plan_cuota?: IntNullableWithAggregatesFilter | number | null
    monto_financiacion?: FloatNullableWithAggregatesFilter | number | null
    financiacion?: BoolNullableWithAggregatesFilter | boolean | null
    efectivo?: FloatNullableWithAggregatesFilter | number | null
  }

  export type serviciosWhereInput = {
    AND?: serviciosWhereInput | serviciosWhereInput[]
    OR?: serviciosWhereInput[]
    NOT?: serviciosWhereInput | serviciosWhereInput[]
    idservicio?: IntFilter | number
    empresa?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    edad?: IntNullableFilter | number | null
    fecha_fallecimiento?: DateTimeNullableFilter | Date | string | null
    lugar_fallecimiento?: StringNullableFilter | string | null
    tipo_servicio?: StringNullableFilter | string | null
    casa_mortuaria?: StringNullableFilter | string | null
    fecha_inhumacion?: DateTimeNullableFilter | Date | string | null
    hora_inhumacion?: StringNullableFilter | string | null
    cementerio?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    contrato?: IntNullableFilter | number | null
    fecha_recepcion?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
    motivo?: StringNullableFilter | string | null
    retiro?: StringNullableFilter | string | null
    solicitado?: StringNullableFilter | string | null
    parentesco?: StringNullableFilter | string | null
    altura?: FloatNullableFilter | number | null
    peso?: FloatNullableFilter | number | null
    dni_nuevotitular?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    idataud?: IntNullableFilter | number | null
    dni_solicitante?: IntNullableFilter | number | null
    impactado?: BoolNullableFilter | boolean | null
    cremacion?: BoolNullableFilter | boolean | null
    idparcela?: IntNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    gastos_cargados?: IntNullableFilter | number | null
    obra_soc?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
    donacion?: BoolNullableFilter | boolean | null
    domicilio_solicitante?: StringNullableFilter | string | null
    detalle_corona?: StringNullableFilter | string | null
    religion?: StringNullableFilter | string | null
    estado_civil?: StringNullableFilter | string | null
    importe_servicio?: FloatNullableFilter | number | null
    telefono?: StringNullableFilter | string | null
    movil?: StringNullableFilter | string | null
    gasto_luto?: StringNullableFilter | string | null
    conyugue?: StringNullableFilter | string | null
  }

  export type serviciosOrderByWithRelationInput = {
    idservicio?: SortOrder
    empresa?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_fallecimiento?: SortOrderInput | SortOrder
    lugar_fallecimiento?: SortOrderInput | SortOrder
    tipo_servicio?: SortOrderInput | SortOrder
    casa_mortuaria?: SortOrderInput | SortOrder
    fecha_inhumacion?: SortOrderInput | SortOrder
    hora_inhumacion?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    retiro?: SortOrderInput | SortOrder
    solicitado?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    dni_nuevotitular?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    dni_solicitante?: SortOrderInput | SortOrder
    impactado?: SortOrderInput | SortOrder
    cremacion?: SortOrderInput | SortOrder
    idparcela?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    gastos_cargados?: SortOrderInput | SortOrder
    obra_soc?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    donacion?: SortOrderInput | SortOrder
    domicilio_solicitante?: SortOrderInput | SortOrder
    detalle_corona?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    estado_civil?: SortOrderInput | SortOrder
    importe_servicio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    conyugue?: SortOrderInput | SortOrder
  }

  export type serviciosWhereUniqueInput = {
    idservicio?: number
  }

  export type serviciosOrderByWithAggregationInput = {
    idservicio?: SortOrder
    empresa?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_fallecimiento?: SortOrderInput | SortOrder
    lugar_fallecimiento?: SortOrderInput | SortOrder
    tipo_servicio?: SortOrderInput | SortOrder
    casa_mortuaria?: SortOrderInput | SortOrder
    fecha_inhumacion?: SortOrderInput | SortOrder
    hora_inhumacion?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    retiro?: SortOrderInput | SortOrder
    solicitado?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    dni_nuevotitular?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    dni_solicitante?: SortOrderInput | SortOrder
    impactado?: SortOrderInput | SortOrder
    cremacion?: SortOrderInput | SortOrder
    idparcela?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    gastos_cargados?: SortOrderInput | SortOrder
    obra_soc?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    donacion?: SortOrderInput | SortOrder
    domicilio_solicitante?: SortOrderInput | SortOrder
    detalle_corona?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    estado_civil?: SortOrderInput | SortOrder
    importe_servicio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    movil?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    conyugue?: SortOrderInput | SortOrder
    _count?: serviciosCountOrderByAggregateInput
    _avg?: serviciosAvgOrderByAggregateInput
    _max?: serviciosMaxOrderByAggregateInput
    _min?: serviciosMinOrderByAggregateInput
    _sum?: serviciosSumOrderByAggregateInput
  }

  export type serviciosScalarWhereWithAggregatesInput = {
    AND?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    OR?: serviciosScalarWhereWithAggregatesInput[]
    NOT?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    idservicio?: IntWithAggregatesFilter | number
    empresa?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    edad?: IntNullableWithAggregatesFilter | number | null
    fecha_fallecimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    lugar_fallecimiento?: StringNullableWithAggregatesFilter | string | null
    tipo_servicio?: StringNullableWithAggregatesFilter | string | null
    casa_mortuaria?: StringNullableWithAggregatesFilter | string | null
    fecha_inhumacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hora_inhumacion?: StringNullableWithAggregatesFilter | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    fecha_recepcion?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    retiro?: StringNullableWithAggregatesFilter | string | null
    solicitado?: StringNullableWithAggregatesFilter | string | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    altura?: FloatNullableWithAggregatesFilter | number | null
    peso?: FloatNullableWithAggregatesFilter | number | null
    dni_nuevotitular?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    dni_solicitante?: IntNullableWithAggregatesFilter | number | null
    impactado?: BoolNullableWithAggregatesFilter | boolean | null
    cremacion?: BoolNullableWithAggregatesFilter | boolean | null
    idparcela?: IntNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    gastos_cargados?: IntNullableWithAggregatesFilter | number | null
    obra_soc?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    donacion?: BoolNullableWithAggregatesFilter | boolean | null
    domicilio_solicitante?: StringNullableWithAggregatesFilter | string | null
    detalle_corona?: StringNullableWithAggregatesFilter | string | null
    religion?: StringNullableWithAggregatesFilter | string | null
    estado_civil?: StringNullableWithAggregatesFilter | string | null
    importe_servicio?: FloatNullableWithAggregatesFilter | number | null
    telefono?: StringNullableWithAggregatesFilter | string | null
    movil?: StringNullableWithAggregatesFilter | string | null
    gasto_luto?: StringNullableWithAggregatesFilter | string | null
    conyugue?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicios_historicoWhereInput = {
    AND?: servicios_historicoWhereInput | servicios_historicoWhereInput[]
    OR?: servicios_historicoWhereInput[]
    NOT?: servicios_historicoWhereInput | servicios_historicoWhereInput[]
    NRO_NOTACR?: IntNullableFilter | number | null
    FEC_CREDIT?: DateTimeNullableFilter | Date | string | null
    EXINTO?: StringNullableFilter | string | null
    DNI_EXIN?: IntNullableFilter | number | null
    EDAD_EXIN?: IntNullableFilter | number | null
    FEC_FALLEC?: DateTimeNullableFilter | Date | string | null
    LUGAR?: StringNullableFilter | string | null
    TIPO_SERV?: StringNullableFilter | string | null
    PLAN?: StringNullableFilter | string | null
    SUB_PLAN?: StringNullableFilter | string | null
    CONTRATO?: IntNullableFilter | number | null
    CASA_MORT?: StringNullableFilter | string | null
    FEC_INHU?: DateTimeNullableFilter | Date | string | null
    HORA?: StringNullableFilter | string | null
    CEMENTERIO?: StringNullableFilter | string | null
    DONDE_ENTI?: StringNullableFilter | string | null
    ATAUD_TIPO?: StringNullableFilter | string | null
    COD_ATAUD?: IntNullableFilter | number | null
    DETALLE?: StringNullableFilter | string | null
    RETI_CUER?: StringNullableFilter | string | null
    TRASLADO_A?: StringNullableFilter | string | null
    DIFE_KM?: FloatNullableFilter | number | null
    CAPI_DOMI?: StringNullableFilter | string | null
    GRAB_PLACA?: StringNullableFilter | string | null
    TRAMITES?: StringNullableFilter | string | null
    AVISO_TELR?: StringNullableFilter | string | null
    CARROZA?: IntNullableFilter | number | null
    PORTACORO?: StringNullableFilter | string | null
    AUTO_DUELO?: IntNullableFilter | number | null
    SALA_VELAT?: StringNullableFilter | string | null
    ADICIONAL?: StringNullableFilter | string | null
    ADICIO_PAG?: FloatNullableFilter | number | null
    OBSERVA0?: StringNullableFilter | string | null
    PARCELA?: StringNullableFilter | string | null
    SEC?: StringNullableFilter | string | null
    PARC?: StringNullableFilter | string | null
    SECC?: StringNullableFilter | string | null
    GASTO_ASOC?: FloatNullableFilter | number | null
    GASTO_PAMI?: StringNullableFilter | string | null
    OBSERVA1?: StringNullableFilter | string | null
    OPE_ANUL?: IntNullableFilter | number | null
    ANULAR?: IntNullableFilter | number | null
    FEC_ANULA?: DateTimeNullableFilter | Date | string | null
    CREDITO?: IntNullableFilter | number | null
    TOTA_LETRA?: StringNullableFilter | string | null
    TOTA_NUM?: FloatNullableFilter | number | null
    FORMA_PAGO?: StringNullableFilter | string | null
    DOCUMENTO?: StringNullableFilter | string | null
    SOLI_CRED?: StringNullableFilter | string | null
    GARANT_CRE?: StringNullableFilter | string | null
    DNI_SOLI?: IntNullableFilter | number | null
    TEL_SOLI?: StringNullableFilter | string | null
    DOMI_SOLI?: StringNullableFilter | string | null
    DNI_GARANT?: IntNullableFilter | number | null
    TEL_GARANT?: StringNullableFilter | string | null
    DOMI_GARAN?: StringNullableFilter | string | null
    OPE_ANUCRE?: IntNullableFilter | number | null
    ANULA_CRE?: IntNullableFilter | number | null
    FECANU_CRE?: DateTimeNullableFilter | Date | string | null
    INFO_CRE?: IntNullableFilter | number | null
    SUCURSAL?: StringNullableFilter | string | null
    OPERADOR?: IntNullableFilter | number | null
    TRASPASO?: DateTimeNullableFilter | Date | string | null
    EMPRESA?: StringNullableFilter | string | null
    id?: IntFilter | number
  }

  export type servicios_historicoOrderByWithRelationInput = {
    NRO_NOTACR?: SortOrderInput | SortOrder
    FEC_CREDIT?: SortOrderInput | SortOrder
    EXINTO?: SortOrderInput | SortOrder
    DNI_EXIN?: SortOrderInput | SortOrder
    EDAD_EXIN?: SortOrderInput | SortOrder
    FEC_FALLEC?: SortOrderInput | SortOrder
    LUGAR?: SortOrderInput | SortOrder
    TIPO_SERV?: SortOrderInput | SortOrder
    PLAN?: SortOrderInput | SortOrder
    SUB_PLAN?: SortOrderInput | SortOrder
    CONTRATO?: SortOrderInput | SortOrder
    CASA_MORT?: SortOrderInput | SortOrder
    FEC_INHU?: SortOrderInput | SortOrder
    HORA?: SortOrderInput | SortOrder
    CEMENTERIO?: SortOrderInput | SortOrder
    DONDE_ENTI?: SortOrderInput | SortOrder
    ATAUD_TIPO?: SortOrderInput | SortOrder
    COD_ATAUD?: SortOrderInput | SortOrder
    DETALLE?: SortOrderInput | SortOrder
    RETI_CUER?: SortOrderInput | SortOrder
    TRASLADO_A?: SortOrderInput | SortOrder
    DIFE_KM?: SortOrderInput | SortOrder
    CAPI_DOMI?: SortOrderInput | SortOrder
    GRAB_PLACA?: SortOrderInput | SortOrder
    TRAMITES?: SortOrderInput | SortOrder
    AVISO_TELR?: SortOrderInput | SortOrder
    CARROZA?: SortOrderInput | SortOrder
    PORTACORO?: SortOrderInput | SortOrder
    AUTO_DUELO?: SortOrderInput | SortOrder
    SALA_VELAT?: SortOrderInput | SortOrder
    ADICIONAL?: SortOrderInput | SortOrder
    ADICIO_PAG?: SortOrderInput | SortOrder
    OBSERVA0?: SortOrderInput | SortOrder
    PARCELA?: SortOrderInput | SortOrder
    SEC?: SortOrderInput | SortOrder
    PARC?: SortOrderInput | SortOrder
    SECC?: SortOrderInput | SortOrder
    GASTO_ASOC?: SortOrderInput | SortOrder
    GASTO_PAMI?: SortOrderInput | SortOrder
    OBSERVA1?: SortOrderInput | SortOrder
    OPE_ANUL?: SortOrderInput | SortOrder
    ANULAR?: SortOrderInput | SortOrder
    FEC_ANULA?: SortOrderInput | SortOrder
    CREDITO?: SortOrderInput | SortOrder
    TOTA_LETRA?: SortOrderInput | SortOrder
    TOTA_NUM?: SortOrderInput | SortOrder
    FORMA_PAGO?: SortOrderInput | SortOrder
    DOCUMENTO?: SortOrderInput | SortOrder
    SOLI_CRED?: SortOrderInput | SortOrder
    GARANT_CRE?: SortOrderInput | SortOrder
    DNI_SOLI?: SortOrderInput | SortOrder
    TEL_SOLI?: SortOrderInput | SortOrder
    DOMI_SOLI?: SortOrderInput | SortOrder
    DNI_GARANT?: SortOrderInput | SortOrder
    TEL_GARANT?: SortOrderInput | SortOrder
    DOMI_GARAN?: SortOrderInput | SortOrder
    OPE_ANUCRE?: SortOrderInput | SortOrder
    ANULA_CRE?: SortOrderInput | SortOrder
    FECANU_CRE?: SortOrderInput | SortOrder
    INFO_CRE?: SortOrderInput | SortOrder
    SUCURSAL?: SortOrderInput | SortOrder
    OPERADOR?: SortOrderInput | SortOrder
    TRASPASO?: SortOrderInput | SortOrder
    EMPRESA?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type servicios_historicoWhereUniqueInput = {
    id?: number
  }

  export type servicios_historicoOrderByWithAggregationInput = {
    NRO_NOTACR?: SortOrderInput | SortOrder
    FEC_CREDIT?: SortOrderInput | SortOrder
    EXINTO?: SortOrderInput | SortOrder
    DNI_EXIN?: SortOrderInput | SortOrder
    EDAD_EXIN?: SortOrderInput | SortOrder
    FEC_FALLEC?: SortOrderInput | SortOrder
    LUGAR?: SortOrderInput | SortOrder
    TIPO_SERV?: SortOrderInput | SortOrder
    PLAN?: SortOrderInput | SortOrder
    SUB_PLAN?: SortOrderInput | SortOrder
    CONTRATO?: SortOrderInput | SortOrder
    CASA_MORT?: SortOrderInput | SortOrder
    FEC_INHU?: SortOrderInput | SortOrder
    HORA?: SortOrderInput | SortOrder
    CEMENTERIO?: SortOrderInput | SortOrder
    DONDE_ENTI?: SortOrderInput | SortOrder
    ATAUD_TIPO?: SortOrderInput | SortOrder
    COD_ATAUD?: SortOrderInput | SortOrder
    DETALLE?: SortOrderInput | SortOrder
    RETI_CUER?: SortOrderInput | SortOrder
    TRASLADO_A?: SortOrderInput | SortOrder
    DIFE_KM?: SortOrderInput | SortOrder
    CAPI_DOMI?: SortOrderInput | SortOrder
    GRAB_PLACA?: SortOrderInput | SortOrder
    TRAMITES?: SortOrderInput | SortOrder
    AVISO_TELR?: SortOrderInput | SortOrder
    CARROZA?: SortOrderInput | SortOrder
    PORTACORO?: SortOrderInput | SortOrder
    AUTO_DUELO?: SortOrderInput | SortOrder
    SALA_VELAT?: SortOrderInput | SortOrder
    ADICIONAL?: SortOrderInput | SortOrder
    ADICIO_PAG?: SortOrderInput | SortOrder
    OBSERVA0?: SortOrderInput | SortOrder
    PARCELA?: SortOrderInput | SortOrder
    SEC?: SortOrderInput | SortOrder
    PARC?: SortOrderInput | SortOrder
    SECC?: SortOrderInput | SortOrder
    GASTO_ASOC?: SortOrderInput | SortOrder
    GASTO_PAMI?: SortOrderInput | SortOrder
    OBSERVA1?: SortOrderInput | SortOrder
    OPE_ANUL?: SortOrderInput | SortOrder
    ANULAR?: SortOrderInput | SortOrder
    FEC_ANULA?: SortOrderInput | SortOrder
    CREDITO?: SortOrderInput | SortOrder
    TOTA_LETRA?: SortOrderInput | SortOrder
    TOTA_NUM?: SortOrderInput | SortOrder
    FORMA_PAGO?: SortOrderInput | SortOrder
    DOCUMENTO?: SortOrderInput | SortOrder
    SOLI_CRED?: SortOrderInput | SortOrder
    GARANT_CRE?: SortOrderInput | SortOrder
    DNI_SOLI?: SortOrderInput | SortOrder
    TEL_SOLI?: SortOrderInput | SortOrder
    DOMI_SOLI?: SortOrderInput | SortOrder
    DNI_GARANT?: SortOrderInput | SortOrder
    TEL_GARANT?: SortOrderInput | SortOrder
    DOMI_GARAN?: SortOrderInput | SortOrder
    OPE_ANUCRE?: SortOrderInput | SortOrder
    ANULA_CRE?: SortOrderInput | SortOrder
    FECANU_CRE?: SortOrderInput | SortOrder
    INFO_CRE?: SortOrderInput | SortOrder
    SUCURSAL?: SortOrderInput | SortOrder
    OPERADOR?: SortOrderInput | SortOrder
    TRASPASO?: SortOrderInput | SortOrder
    EMPRESA?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: servicios_historicoCountOrderByAggregateInput
    _avg?: servicios_historicoAvgOrderByAggregateInput
    _max?: servicios_historicoMaxOrderByAggregateInput
    _min?: servicios_historicoMinOrderByAggregateInput
    _sum?: servicios_historicoSumOrderByAggregateInput
  }

  export type servicios_historicoScalarWhereWithAggregatesInput = {
    AND?: servicios_historicoScalarWhereWithAggregatesInput | servicios_historicoScalarWhereWithAggregatesInput[]
    OR?: servicios_historicoScalarWhereWithAggregatesInput[]
    NOT?: servicios_historicoScalarWhereWithAggregatesInput | servicios_historicoScalarWhereWithAggregatesInput[]
    NRO_NOTACR?: IntNullableWithAggregatesFilter | number | null
    FEC_CREDIT?: DateTimeNullableWithAggregatesFilter | Date | string | null
    EXINTO?: StringNullableWithAggregatesFilter | string | null
    DNI_EXIN?: IntNullableWithAggregatesFilter | number | null
    EDAD_EXIN?: IntNullableWithAggregatesFilter | number | null
    FEC_FALLEC?: DateTimeNullableWithAggregatesFilter | Date | string | null
    LUGAR?: StringNullableWithAggregatesFilter | string | null
    TIPO_SERV?: StringNullableWithAggregatesFilter | string | null
    PLAN?: StringNullableWithAggregatesFilter | string | null
    SUB_PLAN?: StringNullableWithAggregatesFilter | string | null
    CONTRATO?: IntNullableWithAggregatesFilter | number | null
    CASA_MORT?: StringNullableWithAggregatesFilter | string | null
    FEC_INHU?: DateTimeNullableWithAggregatesFilter | Date | string | null
    HORA?: StringNullableWithAggregatesFilter | string | null
    CEMENTERIO?: StringNullableWithAggregatesFilter | string | null
    DONDE_ENTI?: StringNullableWithAggregatesFilter | string | null
    ATAUD_TIPO?: StringNullableWithAggregatesFilter | string | null
    COD_ATAUD?: IntNullableWithAggregatesFilter | number | null
    DETALLE?: StringNullableWithAggregatesFilter | string | null
    RETI_CUER?: StringNullableWithAggregatesFilter | string | null
    TRASLADO_A?: StringNullableWithAggregatesFilter | string | null
    DIFE_KM?: FloatNullableWithAggregatesFilter | number | null
    CAPI_DOMI?: StringNullableWithAggregatesFilter | string | null
    GRAB_PLACA?: StringNullableWithAggregatesFilter | string | null
    TRAMITES?: StringNullableWithAggregatesFilter | string | null
    AVISO_TELR?: StringNullableWithAggregatesFilter | string | null
    CARROZA?: IntNullableWithAggregatesFilter | number | null
    PORTACORO?: StringNullableWithAggregatesFilter | string | null
    AUTO_DUELO?: IntNullableWithAggregatesFilter | number | null
    SALA_VELAT?: StringNullableWithAggregatesFilter | string | null
    ADICIONAL?: StringNullableWithAggregatesFilter | string | null
    ADICIO_PAG?: FloatNullableWithAggregatesFilter | number | null
    OBSERVA0?: StringNullableWithAggregatesFilter | string | null
    PARCELA?: StringNullableWithAggregatesFilter | string | null
    SEC?: StringNullableWithAggregatesFilter | string | null
    PARC?: StringNullableWithAggregatesFilter | string | null
    SECC?: StringNullableWithAggregatesFilter | string | null
    GASTO_ASOC?: FloatNullableWithAggregatesFilter | number | null
    GASTO_PAMI?: StringNullableWithAggregatesFilter | string | null
    OBSERVA1?: StringNullableWithAggregatesFilter | string | null
    OPE_ANUL?: IntNullableWithAggregatesFilter | number | null
    ANULAR?: IntNullableWithAggregatesFilter | number | null
    FEC_ANULA?: DateTimeNullableWithAggregatesFilter | Date | string | null
    CREDITO?: IntNullableWithAggregatesFilter | number | null
    TOTA_LETRA?: StringNullableWithAggregatesFilter | string | null
    TOTA_NUM?: FloatNullableWithAggregatesFilter | number | null
    FORMA_PAGO?: StringNullableWithAggregatesFilter | string | null
    DOCUMENTO?: StringNullableWithAggregatesFilter | string | null
    SOLI_CRED?: StringNullableWithAggregatesFilter | string | null
    GARANT_CRE?: StringNullableWithAggregatesFilter | string | null
    DNI_SOLI?: IntNullableWithAggregatesFilter | number | null
    TEL_SOLI?: StringNullableWithAggregatesFilter | string | null
    DOMI_SOLI?: StringNullableWithAggregatesFilter | string | null
    DNI_GARANT?: IntNullableWithAggregatesFilter | number | null
    TEL_GARANT?: StringNullableWithAggregatesFilter | string | null
    DOMI_GARAN?: StringNullableWithAggregatesFilter | string | null
    OPE_ANUCRE?: IntNullableWithAggregatesFilter | number | null
    ANULA_CRE?: IntNullableWithAggregatesFilter | number | null
    FECANU_CRE?: DateTimeNullableWithAggregatesFilter | Date | string | null
    INFO_CRE?: IntNullableWithAggregatesFilter | number | null
    SUCURSAL?: StringNullableWithAggregatesFilter | string | null
    OPERADOR?: IntNullableWithAggregatesFilter | number | null
    TRASPASO?: DateTimeNullableWithAggregatesFilter | Date | string | null
    EMPRESA?: StringNullableWithAggregatesFilter | string | null
    id?: IntWithAggregatesFilter | number
  }

  export type tareasWhereInput = {
    AND?: tareasWhereInput | tareasWhereInput[]
    OR?: tareasWhereInput[]
    NOT?: tareasWhereInput | tareasWhereInput[]
    idevents?: IntFilter | number
    title?: StringNullableFilter | string | null
    allDay?: IntNullableFilter | number | null
    start?: StringNullableFilter | string | null
    end?: StringNullableFilter | string | null
    priority?: IntNullableFilter | number | null
  }

  export type tareasOrderByWithRelationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
  }

  export type tareasWhereUniqueInput = {
    idevents?: number
  }

  export type tareasOrderByWithAggregationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    _count?: tareasCountOrderByAggregateInput
    _avg?: tareasAvgOrderByAggregateInput
    _max?: tareasMaxOrderByAggregateInput
    _min?: tareasMinOrderByAggregateInput
    _sum?: tareasSumOrderByAggregateInput
  }

  export type tareasScalarWhereWithAggregatesInput = {
    AND?: tareasScalarWhereWithAggregatesInput | tareasScalarWhereWithAggregatesInput[]
    OR?: tareasScalarWhereWithAggregatesInput[]
    NOT?: tareasScalarWhereWithAggregatesInput | tareasScalarWhereWithAggregatesInput[]
    idevents?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    start?: StringNullableWithAggregatesFilter | string | null
    end?: StringNullableWithAggregatesFilter | string | null
    priority?: IntNullableWithAggregatesFilter | number | null
  }

  export type visitantesWhereInput = {
    AND?: visitantesWhereInput | visitantesWhereInput[]
    OR?: visitantesWhereInput[]
    NOT?: visitantesWhereInput | visitantesWhereInput[]
    idvisitante?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    telefono?: IntNullableFilter | number | null
    parentezco?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    temperatura?: StringNullableFilter | string | null
  }

  export type visitantesOrderByWithRelationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
  }

  export type visitantesWhereUniqueInput = {
    idvisitante?: number
  }

  export type visitantesOrderByWithAggregationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
    _count?: visitantesCountOrderByAggregateInput
    _avg?: visitantesAvgOrderByAggregateInput
    _max?: visitantesMaxOrderByAggregateInput
    _min?: visitantesMinOrderByAggregateInput
    _sum?: visitantesSumOrderByAggregateInput
  }

  export type visitantesScalarWhereWithAggregatesInput = {
    AND?: visitantesScalarWhereWithAggregatesInput | visitantesScalarWhereWithAggregatesInput[]
    OR?: visitantesScalarWhereWithAggregatesInput[]
    NOT?: visitantesScalarWhereWithAggregatesInput | visitantesScalarWhereWithAggregatesInput[]
    idvisitante?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    temperatura?: StringNullableWithAggregatesFilter | string | null
  }

  export type informe_gastosWhereInput = {
    AND?: informe_gastosWhereInput | informe_gastosWhereInput[]
    OR?: informe_gastosWhereInput[]
    NOT?: informe_gastosWhereInput | informe_gastosWhereInput[]
    idgastos?: IntFilter | number
    idinforme?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    gasto?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidado?: DateTimeNullableFilter | Date | string | null
    operadorliq?: StringNullableFilter | string | null
  }

  export type informe_gastosOrderByWithRelationInput = {
    idgastos?: SortOrder
    idinforme?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    gasto?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
  }

  export type informe_gastosWhereUniqueInput = {
    idgastos?: number
  }

  export type informe_gastosOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idinforme?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    gasto?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    _count?: informe_gastosCountOrderByAggregateInput
    _avg?: informe_gastosAvgOrderByAggregateInput
    _max?: informe_gastosMaxOrderByAggregateInput
    _min?: informe_gastosMinOrderByAggregateInput
    _sum?: informe_gastosSumOrderByAggregateInput
  }

  export type informe_gastosScalarWhereWithAggregatesInput = {
    AND?: informe_gastosScalarWhereWithAggregatesInput | informe_gastosScalarWhereWithAggregatesInput[]
    OR?: informe_gastosScalarWhereWithAggregatesInput[]
    NOT?: informe_gastosScalarWhereWithAggregatesInput | informe_gastosScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    idinforme?: IntNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    gasto?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidado?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicios_gastosWhereInput = {
    AND?: servicios_gastosWhereInput | servicios_gastosWhereInput[]
    OR?: servicios_gastosWhereInput[]
    NOT?: servicios_gastosWhereInput | servicios_gastosWhereInput[]
    idgastos?: IntFilter | number
    gastos?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type servicios_gastosOrderByWithRelationInput = {
    idgastos?: SortOrder
    gastos?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
  }

  export type servicios_gastosWhereUniqueInput = {
    idgastos?: number
  }

  export type servicios_gastosOrderByWithAggregationInput = {
    idgastos?: SortOrder
    gastos?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    _count?: servicios_gastosCountOrderByAggregateInput
    _avg?: servicios_gastosAvgOrderByAggregateInput
    _max?: servicios_gastosMaxOrderByAggregateInput
    _min?: servicios_gastosMinOrderByAggregateInput
    _sum?: servicios_gastosSumOrderByAggregateInput
  }

  export type servicios_gastosScalarWhereWithAggregatesInput = {
    AND?: servicios_gastosScalarWhereWithAggregatesInput | servicios_gastosScalarWhereWithAggregatesInput[]
    OR?: servicios_gastosScalarWhereWithAggregatesInput[]
    NOT?: servicios_gastosScalarWhereWithAggregatesInput | servicios_gastosScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    gastos?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type liquidacion_guardiasWhereInput = {
    AND?: liquidacion_guardiasWhereInput | liquidacion_guardiasWhereInput[]
    OR?: liquidacion_guardiasWhereInput[]
    NOT?: liquidacion_guardiasWhereInput | liquidacion_guardiasWhereInput[]
    idturno?: IntFilter | number
    lugar?: StringNullableFilter | string | null
    inicio?: StringNullableFilter | string | null
    fin?: StringNullableFilter | string | null
    horas?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    feriado?: BoolNullableFilter | boolean | null
    liquidado?: IntNullableFilter | number | null
    fecha_liquidacion?: DateTimeNullableFilter | Date | string | null
    operadorliq?: StringNullableFilter | string | null
    aprobado?: IntNullableFilter | number | null
    fecha_aprobacion?: DateTimeNullableFilter | Date | string | null
    operadorap?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
  }

  export type liquidacion_guardiasOrderByWithRelationInput = {
    idturno?: SortOrder
    lugar?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
  }

  export type liquidacion_guardiasWhereUniqueInput = {
    idturno?: number
  }

  export type liquidacion_guardiasOrderByWithAggregationInput = {
    idturno?: SortOrder
    lugar?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    _count?: liquidacion_guardiasCountOrderByAggregateInput
    _avg?: liquidacion_guardiasAvgOrderByAggregateInput
    _max?: liquidacion_guardiasMaxOrderByAggregateInput
    _min?: liquidacion_guardiasMinOrderByAggregateInput
    _sum?: liquidacion_guardiasSumOrderByAggregateInput
  }

  export type liquidacion_guardiasScalarWhereWithAggregatesInput = {
    AND?: liquidacion_guardiasScalarWhereWithAggregatesInput | liquidacion_guardiasScalarWhereWithAggregatesInput[]
    OR?: liquidacion_guardiasScalarWhereWithAggregatesInput[]
    NOT?: liquidacion_guardiasScalarWhereWithAggregatesInput | liquidacion_guardiasScalarWhereWithAggregatesInput[]
    idturno?: IntWithAggregatesFilter | number
    lugar?: StringNullableWithAggregatesFilter | string | null
    inicio?: StringNullableWithAggregatesFilter | string | null
    fin?: StringNullableWithAggregatesFilter | string | null
    horas?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
    liquidado?: IntNullableWithAggregatesFilter | number | null
    fecha_liquidacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    aprobado?: IntNullableWithAggregatesFilter | number | null
    fecha_aprobacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
  }

  export type liquidacion_registroWhereInput = {
    AND?: liquidacion_registroWhereInput | liquidacion_registroWhereInput[]
    OR?: liquidacion_registroWhereInput[]
    NOT?: liquidacion_registroWhereInput | liquidacion_registroWhereInput[]
    idliquidacion?: IntFilter | number
    fecha?: DateTimeNullableFilter | Date | string | null
    empleado?: StringNullableFilter | string | null
    concepto?: StringNullableFilter | string | null
    fecha_concepto?: DateTimeNullableFilter | Date | string | null
    importe?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type liquidacion_registroOrderByWithRelationInput = {
    idliquidacion?: SortOrder
    fecha?: SortOrderInput | SortOrder
    empleado?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    fecha_concepto?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type liquidacion_registroWhereUniqueInput = {
    idliquidacion?: number
  }

  export type liquidacion_registroOrderByWithAggregationInput = {
    idliquidacion?: SortOrder
    fecha?: SortOrderInput | SortOrder
    empleado?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    fecha_concepto?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: liquidacion_registroCountOrderByAggregateInput
    _avg?: liquidacion_registroAvgOrderByAggregateInput
    _max?: liquidacion_registroMaxOrderByAggregateInput
    _min?: liquidacion_registroMinOrderByAggregateInput
    _sum?: liquidacion_registroSumOrderByAggregateInput
  }

  export type liquidacion_registroScalarWhereWithAggregatesInput = {
    AND?: liquidacion_registroScalarWhereWithAggregatesInput | liquidacion_registroScalarWhereWithAggregatesInput[]
    OR?: liquidacion_registroScalarWhereWithAggregatesInput[]
    NOT?: liquidacion_registroScalarWhereWithAggregatesInput | liquidacion_registroScalarWhereWithAggregatesInput[]
    idliquidacion?: IntWithAggregatesFilter | number
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empleado?: StringNullableWithAggregatesFilter | string | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    fecha_concepto?: DateTimeNullableWithAggregatesFilter | Date | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type gastos_caja_copyWhereInput = {
    AND?: gastos_caja_copyWhereInput | gastos_caja_copyWhereInput[]
    OR?: gastos_caja_copyWhereInput[]
    NOT?: gastos_caja_copyWhereInput | gastos_caja_copyWhereInput[]
    idgastos?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operadorgestion?: StringNullableFilter | string | null
    operadortramite?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
    porciva?: StringNullableFilter | string | null
    montoiva?: IntNullableFilter | number | null
    retiibb?: FloatNullableFilter | number | null
    retggcias?: FloatNullableFilter | number | null
    perciva?: FloatNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    mediopago?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
  }

  export type gastos_caja_copyOrderByWithRelationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
  }

  export type gastos_caja_copyWhereUniqueInput = {
    idgastos?: number
  }

  export type gastos_caja_copyOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    _count?: gastos_caja_copyCountOrderByAggregateInput
    _avg?: gastos_caja_copyAvgOrderByAggregateInput
    _max?: gastos_caja_copyMaxOrderByAggregateInput
    _min?: gastos_caja_copyMinOrderByAggregateInput
    _sum?: gastos_caja_copySumOrderByAggregateInput
  }

  export type gastos_caja_copyScalarWhereWithAggregatesInput = {
    AND?: gastos_caja_copyScalarWhereWithAggregatesInput | gastos_caja_copyScalarWhereWithAggregatesInput[]
    OR?: gastos_caja_copyScalarWhereWithAggregatesInput[]
    NOT?: gastos_caja_copyScalarWhereWithAggregatesInput | gastos_caja_copyScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorgestion?: StringNullableWithAggregatesFilter | string | null
    operadortramite?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    porciva?: StringNullableWithAggregatesFilter | string | null
    montoiva?: IntNullableWithAggregatesFilter | number | null
    retiibb?: FloatNullableWithAggregatesFilter | number | null
    retggcias?: FloatNullableWithAggregatesFilter | number | null
    perciva?: FloatNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    mediopago?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
  }

  export type servicio_presupuestoWhereInput = {
    AND?: servicio_presupuestoWhereInput | servicio_presupuestoWhereInput[]
    OR?: servicio_presupuestoWhereInput[]
    NOT?: servicio_presupuestoWhereInput | servicio_presupuestoWhereInput[]
    idpresupuesto?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    apoderado?: StringNullableFilter | string | null
    domicilio?: StringNullableFilter | string | null
    telefono?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    anticipo?: FloatNullableFilter | number | null
    cuotas?: IntNullableFilter | number | null
    saldo?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type servicio_presupuestoOrderByWithRelationInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    apoderado?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    anticipo?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type servicio_presupuestoWhereUniqueInput = {
    idpresupuesto?: number
  }

  export type servicio_presupuestoOrderByWithAggregationInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    apoderado?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    anticipo?: SortOrderInput | SortOrder
    cuotas?: SortOrderInput | SortOrder
    saldo?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: servicio_presupuestoCountOrderByAggregateInput
    _avg?: servicio_presupuestoAvgOrderByAggregateInput
    _max?: servicio_presupuestoMaxOrderByAggregateInput
    _min?: servicio_presupuestoMinOrderByAggregateInput
    _sum?: servicio_presupuestoSumOrderByAggregateInput
  }

  export type servicio_presupuestoScalarWhereWithAggregatesInput = {
    AND?: servicio_presupuestoScalarWhereWithAggregatesInput | servicio_presupuestoScalarWhereWithAggregatesInput[]
    OR?: servicio_presupuestoScalarWhereWithAggregatesInput[]
    NOT?: servicio_presupuestoScalarWhereWithAggregatesInput | servicio_presupuestoScalarWhereWithAggregatesInput[]
    idpresupuesto?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    apoderado?: StringNullableWithAggregatesFilter | string | null
    domicilio?: StringNullableWithAggregatesFilter | string | null
    telefono?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    anticipo?: FloatNullableWithAggregatesFilter | number | null
    cuotas?: IntNullableWithAggregatesFilter | number | null
    saldo?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type ataud_precioCreateInput = {
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUncheckedCreateInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioCreateManyInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_ventaCreateInput = {
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUncheckedCreateInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaCreateManyInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateManyInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateInput = {
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUncheckedCreateInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateManyInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateManyInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auto_usosCreateInput = {
    FECHA?: Date | string | null
    PATENTE?: string | null
    DESCRIP?: string | null
    NOMB_OPE?: string | null
    CHOFER?: string | null
    HORA1?: string | null
    HORA2?: string | null
    TAREA?: string | null
    OBSERVA_1?: string | null
    OBSERVA_2?: string | null
    OPE_LLEGA?: string | null
    KILO_SAL?: number | null
    KILO_LLE?: number | null
  }

  export type auto_usosUncheckedCreateInput = {
    FECHA?: Date | string | null
    PATENTE?: string | null
    DESCRIP?: string | null
    NOMB_OPE?: string | null
    CHOFER?: string | null
    HORA1?: string | null
    HORA2?: string | null
    TAREA?: string | null
    OBSERVA_1?: string | null
    OBSERVA_2?: string | null
    OPE_LLEGA?: string | null
    KILO_SAL?: number | null
    KILO_LLE?: number | null
    idusos?: number
  }

  export type auto_usosUpdateInput = {
    FECHA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PATENTE?: NullableStringFieldUpdateOperationsInput | string | null
    DESCRIP?: NullableStringFieldUpdateOperationsInput | string | null
    NOMB_OPE?: NullableStringFieldUpdateOperationsInput | string | null
    CHOFER?: NullableStringFieldUpdateOperationsInput | string | null
    HORA1?: NullableStringFieldUpdateOperationsInput | string | null
    HORA2?: NullableStringFieldUpdateOperationsInput | string | null
    TAREA?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_1?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_2?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_LLEGA?: NullableStringFieldUpdateOperationsInput | string | null
    KILO_SAL?: NullableFloatFieldUpdateOperationsInput | number | null
    KILO_LLE?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type auto_usosUncheckedUpdateInput = {
    FECHA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PATENTE?: NullableStringFieldUpdateOperationsInput | string | null
    DESCRIP?: NullableStringFieldUpdateOperationsInput | string | null
    NOMB_OPE?: NullableStringFieldUpdateOperationsInput | string | null
    CHOFER?: NullableStringFieldUpdateOperationsInput | string | null
    HORA1?: NullableStringFieldUpdateOperationsInput | string | null
    HORA2?: NullableStringFieldUpdateOperationsInput | string | null
    TAREA?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_1?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_2?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_LLEGA?: NullableStringFieldUpdateOperationsInput | string | null
    KILO_SAL?: NullableFloatFieldUpdateOperationsInput | number | null
    KILO_LLE?: NullableFloatFieldUpdateOperationsInput | number | null
    idusos?: IntFieldUpdateOperationsInput | number
  }

  export type auto_usosCreateManyInput = {
    FECHA?: Date | string | null
    PATENTE?: string | null
    DESCRIP?: string | null
    NOMB_OPE?: string | null
    CHOFER?: string | null
    HORA1?: string | null
    HORA2?: string | null
    TAREA?: string | null
    OBSERVA_1?: string | null
    OBSERVA_2?: string | null
    OPE_LLEGA?: string | null
    KILO_SAL?: number | null
    KILO_LLE?: number | null
    idusos?: number
  }

  export type auto_usosUpdateManyMutationInput = {
    FECHA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PATENTE?: NullableStringFieldUpdateOperationsInput | string | null
    DESCRIP?: NullableStringFieldUpdateOperationsInput | string | null
    NOMB_OPE?: NullableStringFieldUpdateOperationsInput | string | null
    CHOFER?: NullableStringFieldUpdateOperationsInput | string | null
    HORA1?: NullableStringFieldUpdateOperationsInput | string | null
    HORA2?: NullableStringFieldUpdateOperationsInput | string | null
    TAREA?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_1?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_2?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_LLEGA?: NullableStringFieldUpdateOperationsInput | string | null
    KILO_SAL?: NullableFloatFieldUpdateOperationsInput | number | null
    KILO_LLE?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type auto_usosUncheckedUpdateManyInput = {
    FECHA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PATENTE?: NullableStringFieldUpdateOperationsInput | string | null
    DESCRIP?: NullableStringFieldUpdateOperationsInput | string | null
    NOMB_OPE?: NullableStringFieldUpdateOperationsInput | string | null
    CHOFER?: NullableStringFieldUpdateOperationsInput | string | null
    HORA1?: NullableStringFieldUpdateOperationsInput | string | null
    HORA2?: NullableStringFieldUpdateOperationsInput | string | null
    TAREA?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_1?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA_2?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_LLEGA?: NullableStringFieldUpdateOperationsInput | string | null
    KILO_SAL?: NullableFloatFieldUpdateOperationsInput | number | null
    KILO_LLE?: NullableFloatFieldUpdateOperationsInput | number | null
    idusos?: IntFieldUpdateOperationsInput | number
  }

  export type autosCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUncheckedCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosCreateManyInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateManyInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateInput = {
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUncheckedCreateInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateManyInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateManyInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateInput = {
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUncheckedCreateInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateManyInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateInput = {
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUncheckedCreateInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateManyInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateManyInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saCreateInput = {
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUncheckedCreateInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saCreateManyInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sepelioCreateInput = {
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUncheckedCreateInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioCreateManyInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_srlCreateInput = {
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUncheckedCreateInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlCreateManyInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosCreateInput = {
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUncheckedCreateInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosCreateManyInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateManyMutationInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateManyInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptos_sepelio_cuentasCreateInput = {
    idconcepto?: number | null
    idempresa?: number | null
    sc_descripcion?: string | null
    sc_cuenta?: number | null
  }

  export type conceptos_sepelio_cuentasUncheckedCreateInput = {
    idconcepto?: number | null
    idempresa?: number | null
    sc_descripcion?: string | null
    sc_cuenta?: number | null
    id?: number
  }

  export type conceptos_sepelio_cuentasUpdateInput = {
    idconcepto?: NullableIntFieldUpdateOperationsInput | number | null
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    sc_descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    sc_cuenta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type conceptos_sepelio_cuentasUncheckedUpdateInput = {
    idconcepto?: NullableIntFieldUpdateOperationsInput | number | null
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    sc_descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    sc_cuenta?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type conceptos_sepelio_cuentasCreateManyInput = {
    idconcepto?: number | null
    idempresa?: number | null
    sc_descripcion?: string | null
    sc_cuenta?: number | null
    id?: number
  }

  export type conceptos_sepelio_cuentasUpdateManyMutationInput = {
    idconcepto?: NullableIntFieldUpdateOperationsInput | number | null
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    sc_descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    sc_cuenta?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type conceptos_sepelio_cuentasUncheckedUpdateManyInput = {
    idconcepto?: NullableIntFieldUpdateOperationsInput | number | null
    idempresa?: NullableIntFieldUpdateOperationsInput | number | null
    sc_descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    sc_cuenta?: NullableIntFieldUpdateOperationsInput | number | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type fabricante_ataudCreateInput = {
    fabricante?: string | null
  }

  export type fabricante_ataudUncheckedCreateInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateManyInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateManyMutationInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateManyInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateInput = {
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUncheckedCreateInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateManyInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateManyInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gastos_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUncheckedCreateInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaCreateManyInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type generacion_cajasCreateInput = {
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUncheckedCreateInput = {
    idgeneracion?: number
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUpdateInput = {
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasUncheckedUpdateInput = {
    idgeneracion?: IntFieldUpdateOperationsInput | number
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasCreateManyInput = {
    idgeneracion?: number
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUpdateManyMutationInput = {
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasUncheckedUpdateManyInput = {
    idgeneracion?: IntFieldUpdateOperationsInput | number
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_autosCreateInput = {
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUncheckedCreateInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosCreateManyInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_stock_ataudCreateInput = {
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUncheckedCreateInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudCreateManyInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type honorariosCreateInput = {
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUncheckedCreateInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosCreateManyInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateManyMutationInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateManyInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type informe_tareasCreateInput = {
    idinforme?: number | null
    idservicio?: number | null
    operador?: string | null
    tarea?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    monto?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_tareasUncheckedCreateInput = {
    idtareas?: number
    idinforme?: number | null
    idservicio?: number | null
    operador?: string | null
    tarea?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    monto?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_tareasUpdateInput = {
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_tareasUncheckedUpdateInput = {
    idtareas?: IntFieldUpdateOperationsInput | number
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_tareasCreateManyInput = {
    idtareas?: number
    idinforme?: number | null
    idservicio?: number | null
    operador?: string | null
    tarea?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    monto?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_tareasUpdateManyMutationInput = {
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_tareasUncheckedUpdateManyInput = {
    idtareas?: IntFieldUpdateOperationsInput | number
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ingreso_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUncheckedCreateInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaCreateManyInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateManyInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type legajo_virtual_autosCreateInput = {
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUncheckedCreateInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosCreateManyInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_serviciosCreateInput = {
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUncheckedCreateInput = {
    idlegajo?: number
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateInput = {
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosCreateManyInput = {
    idlegajo?: number
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateManyMutationInput = {
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lic_conducirCreateInput = {
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    FEC_NAC?: Date | string | null
    NRO_CARNET?: string | null
    FEC_VENCI?: Date | string | null
    CLASE?: string | null
    GRUPO?: string | null
    FACTOR_RH?: string | null
  }

  export type lic_conducirUncheckedCreateInput = {
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    FEC_NAC?: Date | string | null
    NRO_CARNET?: string | null
    FEC_VENCI?: Date | string | null
    CLASE?: string | null
    GRUPO?: string | null
    FACTOR_RH?: string | null
    id?: number
  }

  export type lic_conducirUpdateInput = {
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_NAC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NRO_CARNET?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_VENCI?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLASE?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableStringFieldUpdateOperationsInput | string | null
    FACTOR_RH?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lic_conducirUncheckedUpdateInput = {
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_NAC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NRO_CARNET?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_VENCI?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLASE?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableStringFieldUpdateOperationsInput | string | null
    FACTOR_RH?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type lic_conducirCreateManyInput = {
    NRO_DOC?: number | null
    APELLIDOS?: string | null
    NOMBRES?: string | null
    FEC_NAC?: Date | string | null
    NRO_CARNET?: string | null
    FEC_VENCI?: Date | string | null
    CLASE?: string | null
    GRUPO?: string | null
    FACTOR_RH?: string | null
    id?: number
  }

  export type lic_conducirUpdateManyMutationInput = {
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_NAC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NRO_CARNET?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_VENCI?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLASE?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableStringFieldUpdateOperationsInput | string | null
    FACTOR_RH?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lic_conducirUncheckedUpdateManyInput = {
    NRO_DOC?: NullableIntFieldUpdateOperationsInput | number | null
    APELLIDOS?: NullableStringFieldUpdateOperationsInput | string | null
    NOMBRES?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_NAC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    NRO_CARNET?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_VENCI?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLASE?: NullableStringFieldUpdateOperationsInput | string | null
    GRUPO?: NullableStringFieldUpdateOperationsInput | string | null
    FACTOR_RH?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type novedadesCreateInput = {
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUncheckedCreateInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesCreateManyInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateManyMutationInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateInput = {
    operador?: string | null
  }

  export type operadorsepUncheckedCreateInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateManyInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateManyInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelasCreateInput = {
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUncheckedCreateInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasCreateManyInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateManyInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelas_lugaresCreateInput = {
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUncheckedCreateInput = {
    idlugar?: number
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUpdateInput = {
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresUncheckedUpdateInput = {
    idlugar?: IntFieldUpdateOperationsInput | number
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresCreateManyInput = {
    idlugar?: number
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUpdateManyMutationInput = {
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresUncheckedUpdateManyInput = {
    idlugar?: IntFieldUpdateOperationsInput | number
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type precio_servicioCreateInput = {
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUncheckedCreateInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioCreateManyInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proveedoresCreateInput = {
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUncheckedCreateInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresCreateManyInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateManyMutationInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateManyInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rodadosCreateInput = {
    patente?: string | null
    descripcion?: string | null
    km?: string | null
    responsable?: string | null
    n_poliza?: string | null
    emp_poliza?: string | null
    n_motor?: string | null
    n_chasis?: string | null
    ano_fabri?: string | null
    desde?: Date | string | null
    hasta?: Date | string | null
  }

  export type rodadosUncheckedCreateInput = {
    patente?: string | null
    descripcion?: string | null
    km?: string | null
    responsable?: string | null
    n_poliza?: string | null
    emp_poliza?: string | null
    n_motor?: string | null
    n_chasis?: string | null
    ano_fabri?: string | null
    desde?: Date | string | null
    hasta?: Date | string | null
    id?: number
  }

  export type rodadosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    km?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    n_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    emp_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    n_motor?: NullableStringFieldUpdateOperationsInput | string | null
    n_chasis?: NullableStringFieldUpdateOperationsInput | string | null
    ano_fabri?: NullableStringFieldUpdateOperationsInput | string | null
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rodadosUncheckedUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    km?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    n_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    emp_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    n_motor?: NullableStringFieldUpdateOperationsInput | string | null
    n_chasis?: NullableStringFieldUpdateOperationsInput | string | null
    ano_fabri?: NullableStringFieldUpdateOperationsInput | string | null
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type rodadosCreateManyInput = {
    patente?: string | null
    descripcion?: string | null
    km?: string | null
    responsable?: string | null
    n_poliza?: string | null
    emp_poliza?: string | null
    n_motor?: string | null
    n_chasis?: string | null
    ano_fabri?: string | null
    desde?: Date | string | null
    hasta?: Date | string | null
    id?: number
  }

  export type rodadosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    km?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    n_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    emp_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    n_motor?: NullableStringFieldUpdateOperationsInput | string | null
    n_chasis?: NullableStringFieldUpdateOperationsInput | string | null
    ano_fabri?: NullableStringFieldUpdateOperationsInput | string | null
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rodadosUncheckedUpdateManyInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    km?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    n_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    emp_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    n_motor?: NullableStringFieldUpdateOperationsInput | string | null
    n_chasis?: NullableStringFieldUpdateOperationsInput | string | null
    ano_fabri?: NullableStringFieldUpdateOperationsInput | string | null
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type servicio_informesCreateInput = {
    idservicio?: number | null
    fecha?: Date | string | null
    aprobado?: boolean | null
    fecha_aprobado?: Date | string | null
    operador_aprobado?: string | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operador_liquidado?: string | null
  }

  export type servicio_informesUncheckedCreateInput = {
    idinforme?: number
    idservicio?: number | null
    fecha?: Date | string | null
    aprobado?: boolean | null
    fecha_aprobado?: Date | string | null
    operador_aprobado?: string | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operador_liquidado?: string | null
  }

  export type servicio_informesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_aprobado?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_liquidado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_informesUncheckedUpdateInput = {
    idinforme?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_aprobado?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_liquidado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_informesCreateManyInput = {
    idinforme?: number
    idservicio?: number | null
    fecha?: Date | string | null
    aprobado?: boolean | null
    fecha_aprobado?: Date | string | null
    operador_aprobado?: string | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operador_liquidado?: string | null
  }

  export type servicio_informesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_aprobado?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_liquidado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_informesUncheckedUpdateManyInput = {
    idinforme?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_aprobado?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador_liquidado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_ventaCreateInput = {
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUncheckedCreateInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaCreateManyInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateManyInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type serviciosCreateInput = {
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
    detalle_corona?: string | null
    religion?: string | null
    estado_civil?: string | null
    importe_servicio?: number | null
    telefono?: string | null
    movil?: string | null
    gasto_luto?: string | null
    conyugue?: string | null
  }

  export type serviciosUncheckedCreateInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
    detalle_corona?: string | null
    religion?: string | null
    estado_civil?: string | null
    importe_servicio?: number | null
    telefono?: string | null
    movil?: string | null
    gasto_luto?: string | null
    conyugue?: string | null
  }

  export type serviciosUpdateInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_corona?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    estado_civil?: NullableStringFieldUpdateOperationsInput | string | null
    importe_servicio?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableStringFieldUpdateOperationsInput | string | null
    conyugue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_corona?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    estado_civil?: NullableStringFieldUpdateOperationsInput | string | null
    importe_servicio?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableStringFieldUpdateOperationsInput | string | null
    conyugue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosCreateManyInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
    detalle_corona?: string | null
    religion?: string | null
    estado_civil?: string | null
    importe_servicio?: number | null
    telefono?: string | null
    movil?: string | null
    gasto_luto?: string | null
    conyugue?: string | null
  }

  export type serviciosUpdateManyMutationInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_corona?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    estado_civil?: NullableStringFieldUpdateOperationsInput | string | null
    importe_servicio?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableStringFieldUpdateOperationsInput | string | null
    conyugue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateManyInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
    detalle_corona?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    estado_civil?: NullableStringFieldUpdateOperationsInput | string | null
    importe_servicio?: NullableFloatFieldUpdateOperationsInput | number | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    movil?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableStringFieldUpdateOperationsInput | string | null
    conyugue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_historicoCreateInput = {
    NRO_NOTACR?: number | null
    FEC_CREDIT?: Date | string | null
    EXINTO?: string | null
    DNI_EXIN?: number | null
    EDAD_EXIN?: number | null
    FEC_FALLEC?: Date | string | null
    LUGAR?: string | null
    TIPO_SERV?: string | null
    PLAN?: string | null
    SUB_PLAN?: string | null
    CONTRATO?: number | null
    CASA_MORT?: string | null
    FEC_INHU?: Date | string | null
    HORA?: string | null
    CEMENTERIO?: string | null
    DONDE_ENTI?: string | null
    ATAUD_TIPO?: string | null
    COD_ATAUD?: number | null
    DETALLE?: string | null
    RETI_CUER?: string | null
    TRASLADO_A?: string | null
    DIFE_KM?: number | null
    CAPI_DOMI?: string | null
    GRAB_PLACA?: string | null
    TRAMITES?: string | null
    AVISO_TELR?: string | null
    CARROZA?: number | null
    PORTACORO?: string | null
    AUTO_DUELO?: number | null
    SALA_VELAT?: string | null
    ADICIONAL?: string | null
    ADICIO_PAG?: number | null
    OBSERVA0?: string | null
    PARCELA?: string | null
    SEC?: string | null
    PARC?: string | null
    SECC?: string | null
    GASTO_ASOC?: number | null
    GASTO_PAMI?: string | null
    OBSERVA1?: string | null
    OPE_ANUL?: number | null
    ANULAR?: number | null
    FEC_ANULA?: Date | string | null
    CREDITO?: number | null
    TOTA_LETRA?: string | null
    TOTA_NUM?: number | null
    FORMA_PAGO?: string | null
    DOCUMENTO?: string | null
    SOLI_CRED?: string | null
    GARANT_CRE?: string | null
    DNI_SOLI?: number | null
    TEL_SOLI?: string | null
    DOMI_SOLI?: string | null
    DNI_GARANT?: number | null
    TEL_GARANT?: string | null
    DOMI_GARAN?: string | null
    OPE_ANUCRE?: number | null
    ANULA_CRE?: number | null
    FECANU_CRE?: Date | string | null
    INFO_CRE?: number | null
    SUCURSAL?: string | null
    OPERADOR?: number | null
    TRASPASO?: Date | string | null
    EMPRESA?: string | null
  }

  export type servicios_historicoUncheckedCreateInput = {
    NRO_NOTACR?: number | null
    FEC_CREDIT?: Date | string | null
    EXINTO?: string | null
    DNI_EXIN?: number | null
    EDAD_EXIN?: number | null
    FEC_FALLEC?: Date | string | null
    LUGAR?: string | null
    TIPO_SERV?: string | null
    PLAN?: string | null
    SUB_PLAN?: string | null
    CONTRATO?: number | null
    CASA_MORT?: string | null
    FEC_INHU?: Date | string | null
    HORA?: string | null
    CEMENTERIO?: string | null
    DONDE_ENTI?: string | null
    ATAUD_TIPO?: string | null
    COD_ATAUD?: number | null
    DETALLE?: string | null
    RETI_CUER?: string | null
    TRASLADO_A?: string | null
    DIFE_KM?: number | null
    CAPI_DOMI?: string | null
    GRAB_PLACA?: string | null
    TRAMITES?: string | null
    AVISO_TELR?: string | null
    CARROZA?: number | null
    PORTACORO?: string | null
    AUTO_DUELO?: number | null
    SALA_VELAT?: string | null
    ADICIONAL?: string | null
    ADICIO_PAG?: number | null
    OBSERVA0?: string | null
    PARCELA?: string | null
    SEC?: string | null
    PARC?: string | null
    SECC?: string | null
    GASTO_ASOC?: number | null
    GASTO_PAMI?: string | null
    OBSERVA1?: string | null
    OPE_ANUL?: number | null
    ANULAR?: number | null
    FEC_ANULA?: Date | string | null
    CREDITO?: number | null
    TOTA_LETRA?: string | null
    TOTA_NUM?: number | null
    FORMA_PAGO?: string | null
    DOCUMENTO?: string | null
    SOLI_CRED?: string | null
    GARANT_CRE?: string | null
    DNI_SOLI?: number | null
    TEL_SOLI?: string | null
    DOMI_SOLI?: string | null
    DNI_GARANT?: number | null
    TEL_GARANT?: string | null
    DOMI_GARAN?: string | null
    OPE_ANUCRE?: number | null
    ANULA_CRE?: number | null
    FECANU_CRE?: Date | string | null
    INFO_CRE?: number | null
    SUCURSAL?: string | null
    OPERADOR?: number | null
    TRASPASO?: Date | string | null
    EMPRESA?: string | null
    id?: number
  }

  export type servicios_historicoUpdateInput = {
    NRO_NOTACR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_CREDIT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EXINTO?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    EDAD_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_FALLEC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LUGAR?: NullableStringFieldUpdateOperationsInput | string | null
    TIPO_SERV?: NullableStringFieldUpdateOperationsInput | string | null
    PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    SUB_PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: NullableIntFieldUpdateOperationsInput | number | null
    CASA_MORT?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_INHU?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HORA?: NullableStringFieldUpdateOperationsInput | string | null
    CEMENTERIO?: NullableStringFieldUpdateOperationsInput | string | null
    DONDE_ENTI?: NullableStringFieldUpdateOperationsInput | string | null
    ATAUD_TIPO?: NullableStringFieldUpdateOperationsInput | string | null
    COD_ATAUD?: NullableIntFieldUpdateOperationsInput | number | null
    DETALLE?: NullableStringFieldUpdateOperationsInput | string | null
    RETI_CUER?: NullableStringFieldUpdateOperationsInput | string | null
    TRASLADO_A?: NullableStringFieldUpdateOperationsInput | string | null
    DIFE_KM?: NullableFloatFieldUpdateOperationsInput | number | null
    CAPI_DOMI?: NullableStringFieldUpdateOperationsInput | string | null
    GRAB_PLACA?: NullableStringFieldUpdateOperationsInput | string | null
    TRAMITES?: NullableStringFieldUpdateOperationsInput | string | null
    AVISO_TELR?: NullableStringFieldUpdateOperationsInput | string | null
    CARROZA?: NullableIntFieldUpdateOperationsInput | number | null
    PORTACORO?: NullableStringFieldUpdateOperationsInput | string | null
    AUTO_DUELO?: NullableIntFieldUpdateOperationsInput | number | null
    SALA_VELAT?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIONAL?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIO_PAG?: NullableFloatFieldUpdateOperationsInput | number | null
    OBSERVA0?: NullableStringFieldUpdateOperationsInput | string | null
    PARCELA?: NullableStringFieldUpdateOperationsInput | string | null
    SEC?: NullableStringFieldUpdateOperationsInput | string | null
    PARC?: NullableStringFieldUpdateOperationsInput | string | null
    SECC?: NullableStringFieldUpdateOperationsInput | string | null
    GASTO_ASOC?: NullableFloatFieldUpdateOperationsInput | number | null
    GASTO_PAMI?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA1?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUL?: NullableIntFieldUpdateOperationsInput | number | null
    ANULAR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_ANULA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CREDITO?: NullableIntFieldUpdateOperationsInput | number | null
    TOTA_LETRA?: NullableStringFieldUpdateOperationsInput | string | null
    TOTA_NUM?: NullableFloatFieldUpdateOperationsInput | number | null
    FORMA_PAGO?: NullableStringFieldUpdateOperationsInput | string | null
    DOCUMENTO?: NullableStringFieldUpdateOperationsInput | string | null
    SOLI_CRED?: NullableStringFieldUpdateOperationsInput | string | null
    GARANT_CRE?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_SOLI?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_GARANT?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_GARANT?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_GARAN?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUCRE?: NullableIntFieldUpdateOperationsInput | number | null
    ANULA_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    FECANU_CRE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    INFO_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    OPERADOR?: NullableIntFieldUpdateOperationsInput | number | null
    TRASPASO?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EMPRESA?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_historicoUncheckedUpdateInput = {
    NRO_NOTACR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_CREDIT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EXINTO?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    EDAD_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_FALLEC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LUGAR?: NullableStringFieldUpdateOperationsInput | string | null
    TIPO_SERV?: NullableStringFieldUpdateOperationsInput | string | null
    PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    SUB_PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: NullableIntFieldUpdateOperationsInput | number | null
    CASA_MORT?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_INHU?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HORA?: NullableStringFieldUpdateOperationsInput | string | null
    CEMENTERIO?: NullableStringFieldUpdateOperationsInput | string | null
    DONDE_ENTI?: NullableStringFieldUpdateOperationsInput | string | null
    ATAUD_TIPO?: NullableStringFieldUpdateOperationsInput | string | null
    COD_ATAUD?: NullableIntFieldUpdateOperationsInput | number | null
    DETALLE?: NullableStringFieldUpdateOperationsInput | string | null
    RETI_CUER?: NullableStringFieldUpdateOperationsInput | string | null
    TRASLADO_A?: NullableStringFieldUpdateOperationsInput | string | null
    DIFE_KM?: NullableFloatFieldUpdateOperationsInput | number | null
    CAPI_DOMI?: NullableStringFieldUpdateOperationsInput | string | null
    GRAB_PLACA?: NullableStringFieldUpdateOperationsInput | string | null
    TRAMITES?: NullableStringFieldUpdateOperationsInput | string | null
    AVISO_TELR?: NullableStringFieldUpdateOperationsInput | string | null
    CARROZA?: NullableIntFieldUpdateOperationsInput | number | null
    PORTACORO?: NullableStringFieldUpdateOperationsInput | string | null
    AUTO_DUELO?: NullableIntFieldUpdateOperationsInput | number | null
    SALA_VELAT?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIONAL?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIO_PAG?: NullableFloatFieldUpdateOperationsInput | number | null
    OBSERVA0?: NullableStringFieldUpdateOperationsInput | string | null
    PARCELA?: NullableStringFieldUpdateOperationsInput | string | null
    SEC?: NullableStringFieldUpdateOperationsInput | string | null
    PARC?: NullableStringFieldUpdateOperationsInput | string | null
    SECC?: NullableStringFieldUpdateOperationsInput | string | null
    GASTO_ASOC?: NullableFloatFieldUpdateOperationsInput | number | null
    GASTO_PAMI?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA1?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUL?: NullableIntFieldUpdateOperationsInput | number | null
    ANULAR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_ANULA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CREDITO?: NullableIntFieldUpdateOperationsInput | number | null
    TOTA_LETRA?: NullableStringFieldUpdateOperationsInput | string | null
    TOTA_NUM?: NullableFloatFieldUpdateOperationsInput | number | null
    FORMA_PAGO?: NullableStringFieldUpdateOperationsInput | string | null
    DOCUMENTO?: NullableStringFieldUpdateOperationsInput | string | null
    SOLI_CRED?: NullableStringFieldUpdateOperationsInput | string | null
    GARANT_CRE?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_SOLI?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_GARANT?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_GARANT?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_GARAN?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUCRE?: NullableIntFieldUpdateOperationsInput | number | null
    ANULA_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    FECANU_CRE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    INFO_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    OPERADOR?: NullableIntFieldUpdateOperationsInput | number | null
    TRASPASO?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EMPRESA?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type servicios_historicoCreateManyInput = {
    NRO_NOTACR?: number | null
    FEC_CREDIT?: Date | string | null
    EXINTO?: string | null
    DNI_EXIN?: number | null
    EDAD_EXIN?: number | null
    FEC_FALLEC?: Date | string | null
    LUGAR?: string | null
    TIPO_SERV?: string | null
    PLAN?: string | null
    SUB_PLAN?: string | null
    CONTRATO?: number | null
    CASA_MORT?: string | null
    FEC_INHU?: Date | string | null
    HORA?: string | null
    CEMENTERIO?: string | null
    DONDE_ENTI?: string | null
    ATAUD_TIPO?: string | null
    COD_ATAUD?: number | null
    DETALLE?: string | null
    RETI_CUER?: string | null
    TRASLADO_A?: string | null
    DIFE_KM?: number | null
    CAPI_DOMI?: string | null
    GRAB_PLACA?: string | null
    TRAMITES?: string | null
    AVISO_TELR?: string | null
    CARROZA?: number | null
    PORTACORO?: string | null
    AUTO_DUELO?: number | null
    SALA_VELAT?: string | null
    ADICIONAL?: string | null
    ADICIO_PAG?: number | null
    OBSERVA0?: string | null
    PARCELA?: string | null
    SEC?: string | null
    PARC?: string | null
    SECC?: string | null
    GASTO_ASOC?: number | null
    GASTO_PAMI?: string | null
    OBSERVA1?: string | null
    OPE_ANUL?: number | null
    ANULAR?: number | null
    FEC_ANULA?: Date | string | null
    CREDITO?: number | null
    TOTA_LETRA?: string | null
    TOTA_NUM?: number | null
    FORMA_PAGO?: string | null
    DOCUMENTO?: string | null
    SOLI_CRED?: string | null
    GARANT_CRE?: string | null
    DNI_SOLI?: number | null
    TEL_SOLI?: string | null
    DOMI_SOLI?: string | null
    DNI_GARANT?: number | null
    TEL_GARANT?: string | null
    DOMI_GARAN?: string | null
    OPE_ANUCRE?: number | null
    ANULA_CRE?: number | null
    FECANU_CRE?: Date | string | null
    INFO_CRE?: number | null
    SUCURSAL?: string | null
    OPERADOR?: number | null
    TRASPASO?: Date | string | null
    EMPRESA?: string | null
    id?: number
  }

  export type servicios_historicoUpdateManyMutationInput = {
    NRO_NOTACR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_CREDIT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EXINTO?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    EDAD_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_FALLEC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LUGAR?: NullableStringFieldUpdateOperationsInput | string | null
    TIPO_SERV?: NullableStringFieldUpdateOperationsInput | string | null
    PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    SUB_PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: NullableIntFieldUpdateOperationsInput | number | null
    CASA_MORT?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_INHU?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HORA?: NullableStringFieldUpdateOperationsInput | string | null
    CEMENTERIO?: NullableStringFieldUpdateOperationsInput | string | null
    DONDE_ENTI?: NullableStringFieldUpdateOperationsInput | string | null
    ATAUD_TIPO?: NullableStringFieldUpdateOperationsInput | string | null
    COD_ATAUD?: NullableIntFieldUpdateOperationsInput | number | null
    DETALLE?: NullableStringFieldUpdateOperationsInput | string | null
    RETI_CUER?: NullableStringFieldUpdateOperationsInput | string | null
    TRASLADO_A?: NullableStringFieldUpdateOperationsInput | string | null
    DIFE_KM?: NullableFloatFieldUpdateOperationsInput | number | null
    CAPI_DOMI?: NullableStringFieldUpdateOperationsInput | string | null
    GRAB_PLACA?: NullableStringFieldUpdateOperationsInput | string | null
    TRAMITES?: NullableStringFieldUpdateOperationsInput | string | null
    AVISO_TELR?: NullableStringFieldUpdateOperationsInput | string | null
    CARROZA?: NullableIntFieldUpdateOperationsInput | number | null
    PORTACORO?: NullableStringFieldUpdateOperationsInput | string | null
    AUTO_DUELO?: NullableIntFieldUpdateOperationsInput | number | null
    SALA_VELAT?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIONAL?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIO_PAG?: NullableFloatFieldUpdateOperationsInput | number | null
    OBSERVA0?: NullableStringFieldUpdateOperationsInput | string | null
    PARCELA?: NullableStringFieldUpdateOperationsInput | string | null
    SEC?: NullableStringFieldUpdateOperationsInput | string | null
    PARC?: NullableStringFieldUpdateOperationsInput | string | null
    SECC?: NullableStringFieldUpdateOperationsInput | string | null
    GASTO_ASOC?: NullableFloatFieldUpdateOperationsInput | number | null
    GASTO_PAMI?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA1?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUL?: NullableIntFieldUpdateOperationsInput | number | null
    ANULAR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_ANULA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CREDITO?: NullableIntFieldUpdateOperationsInput | number | null
    TOTA_LETRA?: NullableStringFieldUpdateOperationsInput | string | null
    TOTA_NUM?: NullableFloatFieldUpdateOperationsInput | number | null
    FORMA_PAGO?: NullableStringFieldUpdateOperationsInput | string | null
    DOCUMENTO?: NullableStringFieldUpdateOperationsInput | string | null
    SOLI_CRED?: NullableStringFieldUpdateOperationsInput | string | null
    GARANT_CRE?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_SOLI?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_GARANT?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_GARANT?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_GARAN?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUCRE?: NullableIntFieldUpdateOperationsInput | number | null
    ANULA_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    FECANU_CRE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    INFO_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    OPERADOR?: NullableIntFieldUpdateOperationsInput | number | null
    TRASPASO?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EMPRESA?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_historicoUncheckedUpdateManyInput = {
    NRO_NOTACR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_CREDIT?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EXINTO?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    EDAD_EXIN?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_FALLEC?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LUGAR?: NullableStringFieldUpdateOperationsInput | string | null
    TIPO_SERV?: NullableStringFieldUpdateOperationsInput | string | null
    PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    SUB_PLAN?: NullableStringFieldUpdateOperationsInput | string | null
    CONTRATO?: NullableIntFieldUpdateOperationsInput | number | null
    CASA_MORT?: NullableStringFieldUpdateOperationsInput | string | null
    FEC_INHU?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    HORA?: NullableStringFieldUpdateOperationsInput | string | null
    CEMENTERIO?: NullableStringFieldUpdateOperationsInput | string | null
    DONDE_ENTI?: NullableStringFieldUpdateOperationsInput | string | null
    ATAUD_TIPO?: NullableStringFieldUpdateOperationsInput | string | null
    COD_ATAUD?: NullableIntFieldUpdateOperationsInput | number | null
    DETALLE?: NullableStringFieldUpdateOperationsInput | string | null
    RETI_CUER?: NullableStringFieldUpdateOperationsInput | string | null
    TRASLADO_A?: NullableStringFieldUpdateOperationsInput | string | null
    DIFE_KM?: NullableFloatFieldUpdateOperationsInput | number | null
    CAPI_DOMI?: NullableStringFieldUpdateOperationsInput | string | null
    GRAB_PLACA?: NullableStringFieldUpdateOperationsInput | string | null
    TRAMITES?: NullableStringFieldUpdateOperationsInput | string | null
    AVISO_TELR?: NullableStringFieldUpdateOperationsInput | string | null
    CARROZA?: NullableIntFieldUpdateOperationsInput | number | null
    PORTACORO?: NullableStringFieldUpdateOperationsInput | string | null
    AUTO_DUELO?: NullableIntFieldUpdateOperationsInput | number | null
    SALA_VELAT?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIONAL?: NullableStringFieldUpdateOperationsInput | string | null
    ADICIO_PAG?: NullableFloatFieldUpdateOperationsInput | number | null
    OBSERVA0?: NullableStringFieldUpdateOperationsInput | string | null
    PARCELA?: NullableStringFieldUpdateOperationsInput | string | null
    SEC?: NullableStringFieldUpdateOperationsInput | string | null
    PARC?: NullableStringFieldUpdateOperationsInput | string | null
    SECC?: NullableStringFieldUpdateOperationsInput | string | null
    GASTO_ASOC?: NullableFloatFieldUpdateOperationsInput | number | null
    GASTO_PAMI?: NullableStringFieldUpdateOperationsInput | string | null
    OBSERVA1?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUL?: NullableIntFieldUpdateOperationsInput | number | null
    ANULAR?: NullableIntFieldUpdateOperationsInput | number | null
    FEC_ANULA?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CREDITO?: NullableIntFieldUpdateOperationsInput | number | null
    TOTA_LETRA?: NullableStringFieldUpdateOperationsInput | string | null
    TOTA_NUM?: NullableFloatFieldUpdateOperationsInput | number | null
    FORMA_PAGO?: NullableStringFieldUpdateOperationsInput | string | null
    DOCUMENTO?: NullableStringFieldUpdateOperationsInput | string | null
    SOLI_CRED?: NullableStringFieldUpdateOperationsInput | string | null
    GARANT_CRE?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_SOLI?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_SOLI?: NullableStringFieldUpdateOperationsInput | string | null
    DNI_GARANT?: NullableIntFieldUpdateOperationsInput | number | null
    TEL_GARANT?: NullableStringFieldUpdateOperationsInput | string | null
    DOMI_GARAN?: NullableStringFieldUpdateOperationsInput | string | null
    OPE_ANUCRE?: NullableIntFieldUpdateOperationsInput | number | null
    ANULA_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    FECANU_CRE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    INFO_CRE?: NullableIntFieldUpdateOperationsInput | number | null
    SUCURSAL?: NullableStringFieldUpdateOperationsInput | string | null
    OPERADOR?: NullableIntFieldUpdateOperationsInput | number | null
    TRASPASO?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EMPRESA?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type tareasCreateInput = {
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUncheckedCreateInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasUncheckedUpdateInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasCreateManyInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasUncheckedUpdateManyInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type visitantesCreateInput = {
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUncheckedCreateInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesCreateManyInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateManyInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_gastosCreateInput = {
    idinforme?: number | null
    idservicio?: number | null
    gasto?: string | null
    observacion?: string | null
    importe?: number | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_gastosUncheckedCreateInput = {
    idgastos?: number
    idinforme?: number | null
    idservicio?: number | null
    gasto?: string | null
    observacion?: string | null
    importe?: number | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_gastosUpdateInput = {
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    gasto?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_gastosUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    gasto?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_gastosCreateManyInput = {
    idgastos?: number
    idinforme?: number | null
    idservicio?: number | null
    gasto?: string | null
    observacion?: string | null
    importe?: number | null
    liquidado?: boolean | null
    fecha_liquidado?: Date | string | null
    operadorliq?: string | null
  }

  export type informe_gastosUpdateManyMutationInput = {
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    gasto?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type informe_gastosUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idinforme?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    gasto?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidado?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_gastosCreateInput = {
    gastos?: string | null
    observacion?: string | null
  }

  export type servicios_gastosUncheckedCreateInput = {
    idgastos?: number
    gastos?: string | null
    observacion?: string | null
  }

  export type servicios_gastosUpdateInput = {
    gastos?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_gastosUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    gastos?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_gastosCreateManyInput = {
    idgastos?: number
    gastos?: string | null
    observacion?: string | null
  }

  export type servicios_gastosUpdateManyMutationInput = {
    gastos?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_gastosUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    gastos?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type liquidacion_guardiasCreateInput = {
    lugar?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    operador?: string | null
    mes?: number | null
    ano?: number | null
    feriado?: boolean | null
    liquidado?: number | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
    aprobado?: number | null
    fecha_aprobacion?: Date | string | null
    operadorap?: string | null
    importe?: number | null
  }

  export type liquidacion_guardiasUncheckedCreateInput = {
    idturno?: number
    lugar?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    operador?: string | null
    mes?: number | null
    ano?: number | null
    feriado?: boolean | null
    liquidado?: number | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
    aprobado?: number | null
    fecha_aprobacion?: Date | string | null
    operadorap?: string | null
    importe?: number | null
  }

  export type liquidacion_guardiasUpdateInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type liquidacion_guardiasUncheckedUpdateInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type liquidacion_guardiasCreateManyInput = {
    idturno?: number
    lugar?: string | null
    inicio?: string | null
    fin?: string | null
    horas?: number | null
    operador?: string | null
    mes?: number | null
    ano?: number | null
    feriado?: boolean | null
    liquidado?: number | null
    fecha_liquidacion?: Date | string | null
    operadorliq?: string | null
    aprobado?: number | null
    fecha_aprobacion?: Date | string | null
    operadorap?: string | null
    importe?: number | null
  }

  export type liquidacion_guardiasUpdateManyMutationInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type liquidacion_guardiasUncheckedUpdateManyInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_aprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type liquidacion_registroCreateInput = {
    fecha?: Date | string | null
    empleado?: string | null
    concepto?: string | null
    fecha_concepto?: Date | string | null
    importe?: number | null
    operador?: string | null
  }

  export type liquidacion_registroUncheckedCreateInput = {
    idliquidacion?: number
    fecha?: Date | string | null
    empleado?: string | null
    concepto?: string | null
    fecha_concepto?: Date | string | null
    importe?: number | null
    operador?: string | null
  }

  export type liquidacion_registroUpdateInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_concepto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type liquidacion_registroUncheckedUpdateInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_concepto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type liquidacion_registroCreateManyInput = {
    idliquidacion?: number
    fecha?: Date | string | null
    empleado?: string | null
    concepto?: string | null
    fecha_concepto?: Date | string | null
    importe?: number | null
    operador?: string | null
  }

  export type liquidacion_registroUpdateManyMutationInput = {
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_concepto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type liquidacion_registroUncheckedUpdateManyInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empleado?: NullableStringFieldUpdateOperationsInput | string | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_concepto?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gastos_caja_copyCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_caja_copyUncheckedCreateInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_caja_copyUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_caja_copyUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_caja_copyCreateManyInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_caja_copyUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_caja_copyUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicio_presupuestoCreateInput = {
    idservicio?: number | null
    fecha?: Date | string | null
    apoderado?: string | null
    domicilio?: string | null
    telefono?: string | null
    detalle?: string | null
    total?: number | null
    anticipo?: number | null
    cuotas?: number | null
    saldo?: number | null
    operador?: string | null
  }

  export type servicio_presupuestoUncheckedCreateInput = {
    idpresupuesto?: number
    idservicio?: number | null
    fecha?: Date | string | null
    apoderado?: string | null
    domicilio?: string | null
    telefono?: string | null
    detalle?: string | null
    total?: number | null
    anticipo?: number | null
    cuotas?: number | null
    saldo?: number | null
    operador?: string | null
  }

  export type servicio_presupuestoUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apoderado?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    anticipo?: NullableFloatFieldUpdateOperationsInput | number | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_presupuestoUncheckedUpdateInput = {
    idpresupuesto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apoderado?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    anticipo?: NullableFloatFieldUpdateOperationsInput | number | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_presupuestoCreateManyInput = {
    idpresupuesto?: number
    idservicio?: number | null
    fecha?: Date | string | null
    apoderado?: string | null
    domicilio?: string | null
    telefono?: string | null
    detalle?: string | null
    total?: number | null
    anticipo?: number | null
    cuotas?: number | null
    saldo?: number | null
    operador?: string | null
  }

  export type servicio_presupuestoUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apoderado?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    anticipo?: NullableFloatFieldUpdateOperationsInput | number | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_presupuestoUncheckedUpdateManyInput = {
    idpresupuesto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apoderado?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    anticipo?: NullableFloatFieldUpdateOperationsInput | number | null
    cuotas?: NullableIntFieldUpdateOperationsInput | number | null
    saldo?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ataud_precioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type ataud_precioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type ataud_ventaCountOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaAvgOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataud_ventaMaxOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaMinOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaSumOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataudesCountOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesAvgOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type ataudesMaxOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesMinOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesSumOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type auto_usosCountOrderByAggregateInput = {
    FECHA?: SortOrder
    PATENTE?: SortOrder
    DESCRIP?: SortOrder
    NOMB_OPE?: SortOrder
    CHOFER?: SortOrder
    HORA1?: SortOrder
    HORA2?: SortOrder
    TAREA?: SortOrder
    OBSERVA_1?: SortOrder
    OBSERVA_2?: SortOrder
    OPE_LLEGA?: SortOrder
    KILO_SAL?: SortOrder
    KILO_LLE?: SortOrder
    idusos?: SortOrder
  }

  export type auto_usosAvgOrderByAggregateInput = {
    KILO_SAL?: SortOrder
    KILO_LLE?: SortOrder
    idusos?: SortOrder
  }

  export type auto_usosMaxOrderByAggregateInput = {
    FECHA?: SortOrder
    PATENTE?: SortOrder
    DESCRIP?: SortOrder
    NOMB_OPE?: SortOrder
    CHOFER?: SortOrder
    HORA1?: SortOrder
    HORA2?: SortOrder
    TAREA?: SortOrder
    OBSERVA_1?: SortOrder
    OBSERVA_2?: SortOrder
    OPE_LLEGA?: SortOrder
    KILO_SAL?: SortOrder
    KILO_LLE?: SortOrder
    idusos?: SortOrder
  }

  export type auto_usosMinOrderByAggregateInput = {
    FECHA?: SortOrder
    PATENTE?: SortOrder
    DESCRIP?: SortOrder
    NOMB_OPE?: SortOrder
    CHOFER?: SortOrder
    HORA1?: SortOrder
    HORA2?: SortOrder
    TAREA?: SortOrder
    OBSERVA_1?: SortOrder
    OBSERVA_2?: SortOrder
    OPE_LLEGA?: SortOrder
    KILO_SAL?: SortOrder
    KILO_LLE?: SortOrder
    idusos?: SortOrder
  }

  export type auto_usosSumOrderByAggregateInput = {
    KILO_SAL?: SortOrder
    KILO_LLE?: SortOrder
    idusos?: SortOrder
  }

  export type autosCountOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosAvgOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autosMaxOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosMinOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosSumOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autos_hoja_rutaCountOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaAvgOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_hoja_rutaMaxOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaMinOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaSumOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_pago_patenteCountOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteAvgOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type autos_pago_patenteMaxOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteMinOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteSumOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type caja_saCountOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_saMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saMinOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saSumOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_sepelioCountOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type caja_sepelioMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioMinOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioSumOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type caja_srlCountOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_srlMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlMinOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlSumOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type conceptosCountOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosAvgOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type conceptosMaxOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosMinOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosSumOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type conceptos_sepelio_cuentasCountOrderByAggregateInput = {
    idconcepto?: SortOrder
    idempresa?: SortOrder
    sc_descripcion?: SortOrder
    sc_cuenta?: SortOrder
    id?: SortOrder
  }

  export type conceptos_sepelio_cuentasAvgOrderByAggregateInput = {
    idconcepto?: SortOrder
    idempresa?: SortOrder
    sc_cuenta?: SortOrder
    id?: SortOrder
  }

  export type conceptos_sepelio_cuentasMaxOrderByAggregateInput = {
    idconcepto?: SortOrder
    idempresa?: SortOrder
    sc_descripcion?: SortOrder
    sc_cuenta?: SortOrder
    id?: SortOrder
  }

  export type conceptos_sepelio_cuentasMinOrderByAggregateInput = {
    idconcepto?: SortOrder
    idempresa?: SortOrder
    sc_descripcion?: SortOrder
    sc_cuenta?: SortOrder
    id?: SortOrder
  }

  export type conceptos_sepelio_cuentasSumOrderByAggregateInput = {
    idconcepto?: SortOrder
    idempresa?: SortOrder
    sc_cuenta?: SortOrder
    id?: SortOrder
  }

  export type fabricante_ataudCountOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudAvgOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type fabricante_ataudMaxOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudMinOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudSumOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type gasto_lutoCountOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoAvgOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gasto_lutoMaxOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoMinOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoSumOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gastos_cajaCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type generacion_cajasCountOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasAvgOrderByAggregateInput = {
    idgeneracion?: SortOrder
  }

  export type generacion_cajasMaxOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasMinOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasSumOrderByAggregateInput = {
    idgeneracion?: SortOrder
  }

  export type historial_autosCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_autosMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_stock_ataudCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type historial_stock_ataudMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type honorariosCountOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosAvgOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMaxOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMinOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosSumOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type informe_tareasCountOrderByAggregateInput = {
    idtareas?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    operador?: SortOrder
    tarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    monto?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_tareasAvgOrderByAggregateInput = {
    idtareas?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    horas?: SortOrder
    monto?: SortOrder
  }

  export type informe_tareasMaxOrderByAggregateInput = {
    idtareas?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    operador?: SortOrder
    tarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    monto?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_tareasMinOrderByAggregateInput = {
    idtareas?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    operador?: SortOrder
    tarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    monto?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_tareasSumOrderByAggregateInput = {
    idtareas?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    horas?: SortOrder
    monto?: SortOrder
  }

  export type ingreso_cajaCountOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaAvgOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMaxOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMinOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaSumOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    ptoventa?: SortOrder
  }

  export type legajo_virtual_autosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_autosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_serviciosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
  }

  export type legajo_virtual_serviciosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
  }

  export type lic_conducirCountOrderByAggregateInput = {
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    FEC_NAC?: SortOrder
    NRO_CARNET?: SortOrder
    FEC_VENCI?: SortOrder
    CLASE?: SortOrder
    GRUPO?: SortOrder
    FACTOR_RH?: SortOrder
    id?: SortOrder
  }

  export type lic_conducirAvgOrderByAggregateInput = {
    NRO_DOC?: SortOrder
    id?: SortOrder
  }

  export type lic_conducirMaxOrderByAggregateInput = {
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    FEC_NAC?: SortOrder
    NRO_CARNET?: SortOrder
    FEC_VENCI?: SortOrder
    CLASE?: SortOrder
    GRUPO?: SortOrder
    FACTOR_RH?: SortOrder
    id?: SortOrder
  }

  export type lic_conducirMinOrderByAggregateInput = {
    NRO_DOC?: SortOrder
    APELLIDOS?: SortOrder
    NOMBRES?: SortOrder
    FEC_NAC?: SortOrder
    NRO_CARNET?: SortOrder
    FEC_VENCI?: SortOrder
    CLASE?: SortOrder
    GRUPO?: SortOrder
    FACTOR_RH?: SortOrder
    id?: SortOrder
  }

  export type lic_conducirSumOrderByAggregateInput = {
    NRO_DOC?: SortOrder
    id?: SortOrder
  }

  export type novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type operadorsepCountOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepAvgOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type operadorsepMaxOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepMinOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepSumOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type parcelasCountOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasAvgOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMaxOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMinOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasSumOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type parcelas_lugaresCountOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresAvgOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
  }

  export type parcelas_lugaresMaxOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresMinOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresSumOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
  }

  export type precio_servicioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type precio_servicioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type proveedoresCountOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresAvgOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedoresMaxOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresMinOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresSumOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type rodadosCountOrderByAggregateInput = {
    patente?: SortOrder
    descripcion?: SortOrder
    km?: SortOrder
    responsable?: SortOrder
    n_poliza?: SortOrder
    emp_poliza?: SortOrder
    n_motor?: SortOrder
    n_chasis?: SortOrder
    ano_fabri?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    id?: SortOrder
  }

  export type rodadosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rodadosMaxOrderByAggregateInput = {
    patente?: SortOrder
    descripcion?: SortOrder
    km?: SortOrder
    responsable?: SortOrder
    n_poliza?: SortOrder
    emp_poliza?: SortOrder
    n_motor?: SortOrder
    n_chasis?: SortOrder
    ano_fabri?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    id?: SortOrder
  }

  export type rodadosMinOrderByAggregateInput = {
    patente?: SortOrder
    descripcion?: SortOrder
    km?: SortOrder
    responsable?: SortOrder
    n_poliza?: SortOrder
    emp_poliza?: SortOrder
    n_motor?: SortOrder
    n_chasis?: SortOrder
    ano_fabri?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    id?: SortOrder
  }

  export type rodadosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type servicio_informesCountOrderByAggregateInput = {
    idinforme?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    aprobado?: SortOrder
    fecha_aprobado?: SortOrder
    operador_aprobado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operador_liquidado?: SortOrder
  }

  export type servicio_informesAvgOrderByAggregateInput = {
    idinforme?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_informesMaxOrderByAggregateInput = {
    idinforme?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    aprobado?: SortOrder
    fecha_aprobado?: SortOrder
    operador_aprobado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operador_liquidado?: SortOrder
  }

  export type servicio_informesMinOrderByAggregateInput = {
    idinforme?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    aprobado?: SortOrder
    fecha_aprobado?: SortOrder
    operador_aprobado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operador_liquidado?: SortOrder
  }

  export type servicio_informesSumOrderByAggregateInput = {
    idinforme?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_ventaCountOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaAvgOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMaxOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMinOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaSumOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type serviciosCountOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
    detalle_corona?: SortOrder
    religion?: SortOrder
    estado_civil?: SortOrder
    importe_servicio?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    gasto_luto?: SortOrder
    conyugue?: SortOrder
  }

  export type serviciosAvgOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
    importe_servicio?: SortOrder
  }

  export type serviciosMaxOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
    detalle_corona?: SortOrder
    religion?: SortOrder
    estado_civil?: SortOrder
    importe_servicio?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    gasto_luto?: SortOrder
    conyugue?: SortOrder
  }

  export type serviciosMinOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
    detalle_corona?: SortOrder
    religion?: SortOrder
    estado_civil?: SortOrder
    importe_servicio?: SortOrder
    telefono?: SortOrder
    movil?: SortOrder
    gasto_luto?: SortOrder
    conyugue?: SortOrder
  }

  export type serviciosSumOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
    importe_servicio?: SortOrder
  }

  export type servicios_historicoCountOrderByAggregateInput = {
    NRO_NOTACR?: SortOrder
    FEC_CREDIT?: SortOrder
    EXINTO?: SortOrder
    DNI_EXIN?: SortOrder
    EDAD_EXIN?: SortOrder
    FEC_FALLEC?: SortOrder
    LUGAR?: SortOrder
    TIPO_SERV?: SortOrder
    PLAN?: SortOrder
    SUB_PLAN?: SortOrder
    CONTRATO?: SortOrder
    CASA_MORT?: SortOrder
    FEC_INHU?: SortOrder
    HORA?: SortOrder
    CEMENTERIO?: SortOrder
    DONDE_ENTI?: SortOrder
    ATAUD_TIPO?: SortOrder
    COD_ATAUD?: SortOrder
    DETALLE?: SortOrder
    RETI_CUER?: SortOrder
    TRASLADO_A?: SortOrder
    DIFE_KM?: SortOrder
    CAPI_DOMI?: SortOrder
    GRAB_PLACA?: SortOrder
    TRAMITES?: SortOrder
    AVISO_TELR?: SortOrder
    CARROZA?: SortOrder
    PORTACORO?: SortOrder
    AUTO_DUELO?: SortOrder
    SALA_VELAT?: SortOrder
    ADICIONAL?: SortOrder
    ADICIO_PAG?: SortOrder
    OBSERVA0?: SortOrder
    PARCELA?: SortOrder
    SEC?: SortOrder
    PARC?: SortOrder
    SECC?: SortOrder
    GASTO_ASOC?: SortOrder
    GASTO_PAMI?: SortOrder
    OBSERVA1?: SortOrder
    OPE_ANUL?: SortOrder
    ANULAR?: SortOrder
    FEC_ANULA?: SortOrder
    CREDITO?: SortOrder
    TOTA_LETRA?: SortOrder
    TOTA_NUM?: SortOrder
    FORMA_PAGO?: SortOrder
    DOCUMENTO?: SortOrder
    SOLI_CRED?: SortOrder
    GARANT_CRE?: SortOrder
    DNI_SOLI?: SortOrder
    TEL_SOLI?: SortOrder
    DOMI_SOLI?: SortOrder
    DNI_GARANT?: SortOrder
    TEL_GARANT?: SortOrder
    DOMI_GARAN?: SortOrder
    OPE_ANUCRE?: SortOrder
    ANULA_CRE?: SortOrder
    FECANU_CRE?: SortOrder
    INFO_CRE?: SortOrder
    SUCURSAL?: SortOrder
    OPERADOR?: SortOrder
    TRASPASO?: SortOrder
    EMPRESA?: SortOrder
    id?: SortOrder
  }

  export type servicios_historicoAvgOrderByAggregateInput = {
    NRO_NOTACR?: SortOrder
    DNI_EXIN?: SortOrder
    EDAD_EXIN?: SortOrder
    CONTRATO?: SortOrder
    COD_ATAUD?: SortOrder
    DIFE_KM?: SortOrder
    CARROZA?: SortOrder
    AUTO_DUELO?: SortOrder
    ADICIO_PAG?: SortOrder
    GASTO_ASOC?: SortOrder
    OPE_ANUL?: SortOrder
    ANULAR?: SortOrder
    CREDITO?: SortOrder
    TOTA_NUM?: SortOrder
    DNI_SOLI?: SortOrder
    DNI_GARANT?: SortOrder
    OPE_ANUCRE?: SortOrder
    ANULA_CRE?: SortOrder
    INFO_CRE?: SortOrder
    OPERADOR?: SortOrder
    id?: SortOrder
  }

  export type servicios_historicoMaxOrderByAggregateInput = {
    NRO_NOTACR?: SortOrder
    FEC_CREDIT?: SortOrder
    EXINTO?: SortOrder
    DNI_EXIN?: SortOrder
    EDAD_EXIN?: SortOrder
    FEC_FALLEC?: SortOrder
    LUGAR?: SortOrder
    TIPO_SERV?: SortOrder
    PLAN?: SortOrder
    SUB_PLAN?: SortOrder
    CONTRATO?: SortOrder
    CASA_MORT?: SortOrder
    FEC_INHU?: SortOrder
    HORA?: SortOrder
    CEMENTERIO?: SortOrder
    DONDE_ENTI?: SortOrder
    ATAUD_TIPO?: SortOrder
    COD_ATAUD?: SortOrder
    DETALLE?: SortOrder
    RETI_CUER?: SortOrder
    TRASLADO_A?: SortOrder
    DIFE_KM?: SortOrder
    CAPI_DOMI?: SortOrder
    GRAB_PLACA?: SortOrder
    TRAMITES?: SortOrder
    AVISO_TELR?: SortOrder
    CARROZA?: SortOrder
    PORTACORO?: SortOrder
    AUTO_DUELO?: SortOrder
    SALA_VELAT?: SortOrder
    ADICIONAL?: SortOrder
    ADICIO_PAG?: SortOrder
    OBSERVA0?: SortOrder
    PARCELA?: SortOrder
    SEC?: SortOrder
    PARC?: SortOrder
    SECC?: SortOrder
    GASTO_ASOC?: SortOrder
    GASTO_PAMI?: SortOrder
    OBSERVA1?: SortOrder
    OPE_ANUL?: SortOrder
    ANULAR?: SortOrder
    FEC_ANULA?: SortOrder
    CREDITO?: SortOrder
    TOTA_LETRA?: SortOrder
    TOTA_NUM?: SortOrder
    FORMA_PAGO?: SortOrder
    DOCUMENTO?: SortOrder
    SOLI_CRED?: SortOrder
    GARANT_CRE?: SortOrder
    DNI_SOLI?: SortOrder
    TEL_SOLI?: SortOrder
    DOMI_SOLI?: SortOrder
    DNI_GARANT?: SortOrder
    TEL_GARANT?: SortOrder
    DOMI_GARAN?: SortOrder
    OPE_ANUCRE?: SortOrder
    ANULA_CRE?: SortOrder
    FECANU_CRE?: SortOrder
    INFO_CRE?: SortOrder
    SUCURSAL?: SortOrder
    OPERADOR?: SortOrder
    TRASPASO?: SortOrder
    EMPRESA?: SortOrder
    id?: SortOrder
  }

  export type servicios_historicoMinOrderByAggregateInput = {
    NRO_NOTACR?: SortOrder
    FEC_CREDIT?: SortOrder
    EXINTO?: SortOrder
    DNI_EXIN?: SortOrder
    EDAD_EXIN?: SortOrder
    FEC_FALLEC?: SortOrder
    LUGAR?: SortOrder
    TIPO_SERV?: SortOrder
    PLAN?: SortOrder
    SUB_PLAN?: SortOrder
    CONTRATO?: SortOrder
    CASA_MORT?: SortOrder
    FEC_INHU?: SortOrder
    HORA?: SortOrder
    CEMENTERIO?: SortOrder
    DONDE_ENTI?: SortOrder
    ATAUD_TIPO?: SortOrder
    COD_ATAUD?: SortOrder
    DETALLE?: SortOrder
    RETI_CUER?: SortOrder
    TRASLADO_A?: SortOrder
    DIFE_KM?: SortOrder
    CAPI_DOMI?: SortOrder
    GRAB_PLACA?: SortOrder
    TRAMITES?: SortOrder
    AVISO_TELR?: SortOrder
    CARROZA?: SortOrder
    PORTACORO?: SortOrder
    AUTO_DUELO?: SortOrder
    SALA_VELAT?: SortOrder
    ADICIONAL?: SortOrder
    ADICIO_PAG?: SortOrder
    OBSERVA0?: SortOrder
    PARCELA?: SortOrder
    SEC?: SortOrder
    PARC?: SortOrder
    SECC?: SortOrder
    GASTO_ASOC?: SortOrder
    GASTO_PAMI?: SortOrder
    OBSERVA1?: SortOrder
    OPE_ANUL?: SortOrder
    ANULAR?: SortOrder
    FEC_ANULA?: SortOrder
    CREDITO?: SortOrder
    TOTA_LETRA?: SortOrder
    TOTA_NUM?: SortOrder
    FORMA_PAGO?: SortOrder
    DOCUMENTO?: SortOrder
    SOLI_CRED?: SortOrder
    GARANT_CRE?: SortOrder
    DNI_SOLI?: SortOrder
    TEL_SOLI?: SortOrder
    DOMI_SOLI?: SortOrder
    DNI_GARANT?: SortOrder
    TEL_GARANT?: SortOrder
    DOMI_GARAN?: SortOrder
    OPE_ANUCRE?: SortOrder
    ANULA_CRE?: SortOrder
    FECANU_CRE?: SortOrder
    INFO_CRE?: SortOrder
    SUCURSAL?: SortOrder
    OPERADOR?: SortOrder
    TRASPASO?: SortOrder
    EMPRESA?: SortOrder
    id?: SortOrder
  }

  export type servicios_historicoSumOrderByAggregateInput = {
    NRO_NOTACR?: SortOrder
    DNI_EXIN?: SortOrder
    EDAD_EXIN?: SortOrder
    CONTRATO?: SortOrder
    COD_ATAUD?: SortOrder
    DIFE_KM?: SortOrder
    CARROZA?: SortOrder
    AUTO_DUELO?: SortOrder
    ADICIO_PAG?: SortOrder
    GASTO_ASOC?: SortOrder
    OPE_ANUL?: SortOrder
    ANULAR?: SortOrder
    CREDITO?: SortOrder
    TOTA_NUM?: SortOrder
    DNI_SOLI?: SortOrder
    DNI_GARANT?: SortOrder
    OPE_ANUCRE?: SortOrder
    ANULA_CRE?: SortOrder
    INFO_CRE?: SortOrder
    OPERADOR?: SortOrder
    id?: SortOrder
  }

  export type tareasCountOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasAvgOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type tareasMaxOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasMinOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasSumOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type visitantesCountOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesAvgOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type visitantesMaxOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesMinOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesSumOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type informe_gastosCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    gasto?: SortOrder
    observacion?: SortOrder
    importe?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_gastosAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    importe?: SortOrder
  }

  export type informe_gastosMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    gasto?: SortOrder
    observacion?: SortOrder
    importe?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_gastosMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    gasto?: SortOrder
    observacion?: SortOrder
    importe?: SortOrder
    liquidado?: SortOrder
    fecha_liquidado?: SortOrder
    operadorliq?: SortOrder
  }

  export type informe_gastosSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idinforme?: SortOrder
    idservicio?: SortOrder
    importe?: SortOrder
  }

  export type servicios_gastosCountOrderByAggregateInput = {
    idgastos?: SortOrder
    gastos?: SortOrder
    observacion?: SortOrder
  }

  export type servicios_gastosAvgOrderByAggregateInput = {
    idgastos?: SortOrder
  }

  export type servicios_gastosMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    gastos?: SortOrder
    observacion?: SortOrder
  }

  export type servicios_gastosMinOrderByAggregateInput = {
    idgastos?: SortOrder
    gastos?: SortOrder
    observacion?: SortOrder
  }

  export type servicios_gastosSumOrderByAggregateInput = {
    idgastos?: SortOrder
  }

  export type liquidacion_guardiasCountOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_guardiasAvgOrderByAggregateInput = {
    idturno?: SortOrder
    horas?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    liquidado?: SortOrder
    aprobado?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_guardiasMaxOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_guardiasMinOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_guardiasSumOrderByAggregateInput = {
    idturno?: SortOrder
    horas?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    liquidado?: SortOrder
    aprobado?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_registroCountOrderByAggregateInput = {
    idliquidacion?: SortOrder
    fecha?: SortOrder
    empleado?: SortOrder
    concepto?: SortOrder
    fecha_concepto?: SortOrder
    importe?: SortOrder
    operador?: SortOrder
  }

  export type liquidacion_registroAvgOrderByAggregateInput = {
    idliquidacion?: SortOrder
    importe?: SortOrder
  }

  export type liquidacion_registroMaxOrderByAggregateInput = {
    idliquidacion?: SortOrder
    fecha?: SortOrder
    empleado?: SortOrder
    concepto?: SortOrder
    fecha_concepto?: SortOrder
    importe?: SortOrder
    operador?: SortOrder
  }

  export type liquidacion_registroMinOrderByAggregateInput = {
    idliquidacion?: SortOrder
    fecha?: SortOrder
    empleado?: SortOrder
    concepto?: SortOrder
    fecha_concepto?: SortOrder
    importe?: SortOrder
    operador?: SortOrder
  }

  export type liquidacion_registroSumOrderByAggregateInput = {
    idliquidacion?: SortOrder
    importe?: SortOrder
  }

  export type gastos_caja_copyCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_caja_copyAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_caja_copyMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_caja_copyMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_caja_copySumOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_presupuestoCountOrderByAggregateInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    apoderado?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    detalle?: SortOrder
    total?: SortOrder
    anticipo?: SortOrder
    cuotas?: SortOrder
    saldo?: SortOrder
    operador?: SortOrder
  }

  export type servicio_presupuestoAvgOrderByAggregateInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrder
    total?: SortOrder
    anticipo?: SortOrder
    cuotas?: SortOrder
    saldo?: SortOrder
  }

  export type servicio_presupuestoMaxOrderByAggregateInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    apoderado?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    detalle?: SortOrder
    total?: SortOrder
    anticipo?: SortOrder
    cuotas?: SortOrder
    saldo?: SortOrder
    operador?: SortOrder
  }

  export type servicio_presupuestoMinOrderByAggregateInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrder
    fecha?: SortOrder
    apoderado?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    detalle?: SortOrder
    total?: SortOrder
    anticipo?: SortOrder
    cuotas?: SortOrder
    saldo?: SortOrder
    operador?: SortOrder
  }

  export type servicio_presupuestoSumOrderByAggregateInput = {
    idpresupuesto?: SortOrder
    idservicio?: SortOrder
    total?: SortOrder
    anticipo?: SortOrder
    cuotas?: SortOrder
    saldo?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}