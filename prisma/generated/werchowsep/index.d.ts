
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model ataud_precio
 * 
 */
export type ataud_precio = {
  idprecio: number
  idataud: number | null
  codigo: number | null
  ataud: string | null
  precio: number | null
  pri_desc: number | null
  sec_desc: number | null
  fecha: Date | null
  operador: string | null
  estado: boolean | null
}

/**
 * Model ataud_venta
 * 
 */
export type ataud_venta = {
  idataudventa: number
  idataud: number | null
  contrato: number | null
  apellido_fall: string | null
  nombre_fall: string | null
  dni_fall: number | null
  dom_fall: string | null
  ndom_fall: number | null
  barrio_fall: string | null
  telefono_fall: string | null
  apellido_sol: string | null
  nombre_sol: string | null
  dni_sol: number | null
  telefono_sol: string | null
  fecha: Date | null
  operador: string | null
  ataud: string | null
}

/**
 * Model ataudes
 * 
 */
export type ataudes = {
  idataud: number
  nombre: string | null
  tipo: string | null
  medidas: string | null
  uso: string | null
  fabricante: string | null
  codigo: number | null
  fecha_alta: Date | null
  stock: number | null
  fecha_reposicion: Date | null
  fecha_baja: Date | null
  observaciones: string | null
  estado: boolean | null
  operador: string | null
}

/**
 * Model autos
 * 
 */
export type autos = {
  patente: string | null
  auto: string | null
  kilometros: number | null
  responsable: string | null
  nro_poliza: string | null
  empresa: string | null
  vencimiento: Date | null
  motor: string | null
  chasis: string | null
  modelo: number | null
  cobertura: string | null
  idauto: number
  estado: boolean | null
  operador: string | null
}

/**
 * Model autos_hoja_ruta
 * 
 */
export type autos_hoja_ruta = {
  idhojaruta: number
  patente: string | null
  auto: string | null
  conductor: string | null
  idservicio: number | null
  fecha_salida: Date | null
  km_salida: number | null
  fecha_llegada: Date | null
  km_llegada: number | null
  fecha_registro: Date | null
  operador: string | null
}

/**
 * Model autos_novedades
 * 
 */
export type autos_novedades = {
  idnovedad: number
  patente: string | null
  fecha: Date | null
  novedad: string | null
  operador: string | null
  auto: string | null
}

/**
 * Model autos_pago_patente
 * 
 */
export type autos_pago_patente = {
  idpago: number
  patente: string | null
  mes: number | null
  ano: number | null
  importe: number | null
  cod_pago: number | null
  idauto: number | null
  operador: string | null
}

/**
 * Model caja_sepelio
 * 
 */
export type caja_sepelio = {
  idcaja: number
  operador: string | null
  detalle: string | null
  monto: number | null
  estado: boolean | null
  fecha: Date | null
  gastos: number | null
  totalcaja: number | null
  empresa: string | null
  tipofactura: string | null
  nfactura: number | null
  ptoventa: number | null
  concepto: string | null
  cierre: Date | null
  ultimacarga: Date | null
}

/**
 * Model conceptos
 * 
 */
export type conceptos = {
  idconcepto: number
  concepto: string | null
  tipo: string | null
}

/**
 * Model fabricante_ataud
 * 
 */
export type fabricante_ataud = {
  idfabricante: number
  fabricante: string | null
}

/**
 * Model gasto_luto
 * 
 */
export type gasto_luto = {
  idgastoluto: number
  idservicio: number | null
  contrato: number | null
  dni_extinto: number | null
  extinto: string | null
  gasto_luto: number | null
  idataud: number | null
  apellido_ben: string | null
  nombre_ben: string | null
  telefono_ben: string | null
  fecha: string | null
  operador: string | null
  parentezco: string | null
}

/**
 * Model gastos_caja
 * 
 */
export type gastos_caja = {
  idgastos: number
  idcaja: number | null
  concepto: string | null
  tipofactura: string | null
  nfactura: string | null
  fecha: Date | null
  operadorgestion: string | null
  operadortramite: string | null
  ptoventa: number | null
  porciva: string | null
  montoiva: number | null
  retiibb: number | null
  retggcias: number | null
  perciva: number | null
  detalle: string | null
  mediopago: string | null
  proveedor: string | null
  empresa: string | null
  total: number | null
  idservicio: number | null
}

/**
 * Model historial_autos
 * 
 */
export type historial_autos = {
  idhistorial: number
  patente: string | null
  idauto: number | null
  operador: string | null
  fecha: Date | null
  accion: string | null
}

/**
 * Model historial_stock_ataud
 * 
 */
export type historial_stock_ataud = {
  idhistorial: number
  idataud: number | null
  fecha_carga: Date | null
  stock_anterior: number | null
  stock_nuevo: number | null
  remito: string | null
  operador: string | null
  fecha_recepcion: Date | null
}

/**
 * Model honorarios
 * 
 */
export type honorarios = {
  idtrabajo: number
  trabajo: string | null
  dias_habiles: number | null
  finde: number | null
  feriado: number | null
}

/**
 * Model ingreso_caja
 * 
 */
export type ingreso_caja = {
  idingreso: number
  idcaja: number | null
  concepto: string | null
  monto: number | null
  operador: string | null
  fecha: Date | null
  tipofactura: string | null
  nfactura: number | null
  empresa: string | null
  detalle: string | null
  ptoventa: number | null
}

/**
 * Model legajo_virtual_autos
 * 
 */
export type legajo_virtual_autos = {
  idlegajo: number
  patente: string | null
  archivo: string | null
  fecha_subida: Date | null
}

/**
 * Model legajo_virtual_servicios
 * 
 */
export type legajo_virtual_servicios = {
  idlegajo: number
  servicio: string | null
  archivo: string | null
  fecha_subida: Date | null
  empresa: string | null
}

/**
 * Model novedades
 * 
 */
export type novedades = {
  idnovedad: number
  novedad: string | null
  fecha: Date | null
  operador: string | null
}

/**
 * Model operadorsep
 * 
 */
export type operadorsep = {
  idoperador: number
  operador: string | null
}

/**
 * Model parcelas
 * 
 */
export type parcelas = {
  idparcela: number
  idservicio: number | null
  dni_extinto: number | null
  ficha: number | null
  parcela: string | null
  mza: number | null
  lote: number | null
  asignada: boolean | null
  fecha: string | null
  cementerio: string | null
  operador: string | null
  fecha_alta: string | null
  operador_asignacion: string | null
  fecha_asignacion: string | null
  lugares: number | null
}

/**
 * Model planificacion_guardias
 * 
 */
export type planificacion_guardias = {
  idturno: number
  lugar: string | null
  inicio: Date | null
  fin: Date | null
  horas: Date | null
  operador: string | null
  mes_planificacion: string | null
  feriado: boolean | null
  tarea: string | null
  liquidado: boolean | null
  fecha_liquidacion: string | null
  operadorliq: string | null
  aprobado: boolean | null
  fecha_aprobacion: string | null
  operadorap: string | null
  ano_planificacion: number | null
}

/**
 * Model precio_servicio
 * 
 */
export type precio_servicio = {
  idprecio: number
  codigo: number | null
  contado: number | null
  contado_cremacion: number | null
  descuento1: number | null
  descuento1_cremacion: number | null
  descuento2: number | null
  descuento2_cremacion: number | null
  fecha_vigencia: Date | null
}

/**
 * Model proveedores
 * 
 */
export type proveedores = {
  idproveedor: number
  razon: string | null
  cuit: string | null
  domicilio: string | null
  telefonos: string | null
  estado: number | null
  operador: string | null
}

/**
 * Model servicio_detalles
 * 
 */
export type servicio_detalles = {
  iddetalles: number
  idservicio: number | null
  detalle: string | null
  lugar: string | null
  monto: string | null
  patente: string | null
  operador: string | null
  fecha: string | null
  observacion: string | null
}

/**
 * Model servicio_gastos
 * 
 */
export type servicio_gastos = {
  idgastos: number
  idservicio: number | null
  tipo_gasto: string | null
  horas: Date | null
  operador: string | null
  observaciones: string | null
  inicio: string | null
  fin: string | null
  feriado: boolean | null
  liquidado: boolean | null
  operadorliq: string | null
  fecha_liquidacion: string | null
  aprobado: boolean | null
  operadorap: string | null
  fecha_aprobacion: string | null
}

/**
 * Model servicio_venta
 * 
 */
export type servicio_venta = {
  idventa: number
  idservicio: number | null
  monto: number | null
  operador: string | null
  fecha_venta: Date | null
  apellido_sol: string | null
  nombre_sol: string | null
  dni_sol: number | null
  parentesco: string | null
  operador_venta: string | null
  liquidado: boolean | null
  operadorliq: string | null
  fecha_liquidacion: string | null
  aprobado: boolean | null
  operadorap: string | null
  fecha_aprobacion: string | null
  comision: number | null
  fecha_carga: Date | null
  valor_cuota: number | null
  plan_cuota: number | null
  monto_financiacion: number | null
  financiacion: boolean | null
  efectivo: number | null
}

/**
 * Model servicios
 * 
 */
export type servicios = {
  idservicio: number
  empresa: string | null
  dni: number | null
  apellido: string | null
  nombre: string | null
  edad: number | null
  fecha_fallecimiento: Date | null
  lugar_fallecimiento: string | null
  tipo_servicio: string | null
  casa_mortuaria: string | null
  fecha_inhumacion: Date | null
  hora_inhumacion: Date | null
  cementerio: string | null
  estado: boolean | null
  contrato: number | null
  fecha_recepcion: string | null
  sucursal: string | null
  motivo: string | null
  retiro: string | null
  solicitado: string | null
  parentesco: string | null
  altura: number | null
  peso: number | null
  dni_nuevotitular: number | null
  operador: string | null
  idataud: number | null
  dni_solicitante: number | null
  impactado: boolean | null
  cremacion: boolean | null
  idparcela: number | null
  liquidado: boolean | null
  fecha_liquidacion: string | null
  gastos_cargados: number | null
  obra_soc: string | null
  importe: number | null
  donacion: boolean | null
  domicilio_solicitante: string | null
}

/**
 * Model servicios_liquidacion
 * 
 */
export type servicios_liquidacion = {
  idliquidacion: number
  idservicio: number | null
  total_liquidacion: number | null
  fecha_liquidacion: Date | null
  operador: string | null
}

/**
 * Model tareas
 * 
 */
export type tareas = {
  idevents: number
  title: string | null
  allDay: number | null
  start: string | null
  end: string | null
  priority: boolean | null
}

/**
 * Model tareas_adicionales
 * 
 */
export type tareas_adicionales = {
  idtarea: number
  inicio: Date | null
  fin: Date | null
  tarea: string | null
  operador: string | null
  observaciones: string | null
  horas: Date | null
  feriado: number | null
  liquidado: boolean | null
  fecha_liquidacion: string | null
  operadorliq: string | null
  aprobado: boolean | null
  fecha_aprobacion: string | null
  operadorap: string | null
  mes_planificacion: string | null
}

/**
 * Model tipo_detalle
 * 
 */
export type tipo_detalle = {
  idtipodetalle: number
  tipo_detalle: string | null
  observacion: string | null
}

/**
 * Model visitantes
 * 
 */
export type visitantes = {
  idvisitante: number
  idservicio: number | null
  nombre: string | null
  apellido: string | null
  dni: number | null
  telefono: number | null
  parentezco: string | null
  operador: string | null
  fecha: Date | null
  temperatura: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ataud_precios
 * const ataud_precios = await prisma.ataud_precio.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ataud_precios
   * const ataud_precios = await prisma.ataud_precio.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.ataud_precio`: Exposes CRUD operations for the **ataud_precio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_precios
    * const ataud_precios = await prisma.ataud_precio.findMany()
    * ```
    */
  get ataud_precio(): Prisma.ataud_precioDelegate<GlobalReject>;

  /**
   * `prisma.ataud_venta`: Exposes CRUD operations for the **ataud_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_ventas
    * const ataud_ventas = await prisma.ataud_venta.findMany()
    * ```
    */
  get ataud_venta(): Prisma.ataud_ventaDelegate<GlobalReject>;

  /**
   * `prisma.ataudes`: Exposes CRUD operations for the **ataudes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataudes
    * const ataudes = await prisma.ataudes.findMany()
    * ```
    */
  get ataudes(): Prisma.ataudesDelegate<GlobalReject>;

  /**
   * `prisma.autos`: Exposes CRUD operations for the **autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos
    * const autos = await prisma.autos.findMany()
    * ```
    */
  get autos(): Prisma.autosDelegate<GlobalReject>;

  /**
   * `prisma.autos_hoja_ruta`: Exposes CRUD operations for the **autos_hoja_ruta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_hoja_rutas
    * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
    * ```
    */
  get autos_hoja_ruta(): Prisma.autos_hoja_rutaDelegate<GlobalReject>;

  /**
   * `prisma.autos_novedades`: Exposes CRUD operations for the **autos_novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_novedades
    * const autos_novedades = await prisma.autos_novedades.findMany()
    * ```
    */
  get autos_novedades(): Prisma.autos_novedadesDelegate<GlobalReject>;

  /**
   * `prisma.autos_pago_patente`: Exposes CRUD operations for the **autos_pago_patente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_pago_patentes
    * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
    * ```
    */
  get autos_pago_patente(): Prisma.autos_pago_patenteDelegate<GlobalReject>;

  /**
   * `prisma.caja_sepelio`: Exposes CRUD operations for the **caja_sepelio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sepelios
    * const caja_sepelios = await prisma.caja_sepelio.findMany()
    * ```
    */
  get caja_sepelio(): Prisma.caja_sepelioDelegate<GlobalReject>;

  /**
   * `prisma.conceptos`: Exposes CRUD operations for the **conceptos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conceptos
    * const conceptos = await prisma.conceptos.findMany()
    * ```
    */
  get conceptos(): Prisma.conceptosDelegate<GlobalReject>;

  /**
   * `prisma.fabricante_ataud`: Exposes CRUD operations for the **fabricante_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fabricante_atauds
    * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
    * ```
    */
  get fabricante_ataud(): Prisma.fabricante_ataudDelegate<GlobalReject>;

  /**
   * `prisma.gasto_luto`: Exposes CRUD operations for the **gasto_luto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gasto_lutos
    * const gasto_lutos = await prisma.gasto_luto.findMany()
    * ```
    */
  get gasto_luto(): Prisma.gasto_lutoDelegate<GlobalReject>;

  /**
   * `prisma.gastos_caja`: Exposes CRUD operations for the **gastos_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastos_cajas
    * const gastos_cajas = await prisma.gastos_caja.findMany()
    * ```
    */
  get gastos_caja(): Prisma.gastos_cajaDelegate<GlobalReject>;

  /**
   * `prisma.historial_autos`: Exposes CRUD operations for the **historial_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_autos
    * const historial_autos = await prisma.historial_autos.findMany()
    * ```
    */
  get historial_autos(): Prisma.historial_autosDelegate<GlobalReject>;

  /**
   * `prisma.historial_stock_ataud`: Exposes CRUD operations for the **historial_stock_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_stock_atauds
    * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
    * ```
    */
  get historial_stock_ataud(): Prisma.historial_stock_ataudDelegate<GlobalReject>;

  /**
   * `prisma.honorarios`: Exposes CRUD operations for the **honorarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Honorarios
    * const honorarios = await prisma.honorarios.findMany()
    * ```
    */
  get honorarios(): Prisma.honorariosDelegate<GlobalReject>;

  /**
   * `prisma.ingreso_caja`: Exposes CRUD operations for the **ingreso_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingreso_cajas
    * const ingreso_cajas = await prisma.ingreso_caja.findMany()
    * ```
    */
  get ingreso_caja(): Prisma.ingreso_cajaDelegate<GlobalReject>;

  /**
   * `prisma.legajo_virtual_autos`: Exposes CRUD operations for the **legajo_virtual_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_autos
    * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
    * ```
    */
  get legajo_virtual_autos(): Prisma.legajo_virtual_autosDelegate<GlobalReject>;

  /**
   * `prisma.legajo_virtual_servicios`: Exposes CRUD operations for the **legajo_virtual_servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_servicios
    * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
    * ```
    */
  get legajo_virtual_servicios(): Prisma.legajo_virtual_serviciosDelegate<GlobalReject>;

  /**
   * `prisma.novedades`: Exposes CRUD operations for the **novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Novedades
    * const novedades = await prisma.novedades.findMany()
    * ```
    */
  get novedades(): Prisma.novedadesDelegate<GlobalReject>;

  /**
   * `prisma.operadorsep`: Exposes CRUD operations for the **operadorsep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operadorseps
    * const operadorseps = await prisma.operadorsep.findMany()
    * ```
    */
  get operadorsep(): Prisma.operadorsepDelegate<GlobalReject>;

  /**
   * `prisma.parcelas`: Exposes CRUD operations for the **parcelas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcelas
    * const parcelas = await prisma.parcelas.findMany()
    * ```
    */
  get parcelas(): Prisma.parcelasDelegate<GlobalReject>;

  /**
   * `prisma.planificacion_guardias`: Exposes CRUD operations for the **planificacion_guardias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planificacion_guardias
    * const planificacion_guardias = await prisma.planificacion_guardias.findMany()
    * ```
    */
  get planificacion_guardias(): Prisma.planificacion_guardiasDelegate<GlobalReject>;

  /**
   * `prisma.precio_servicio`: Exposes CRUD operations for the **precio_servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Precio_servicios
    * const precio_servicios = await prisma.precio_servicio.findMany()
    * ```
    */
  get precio_servicio(): Prisma.precio_servicioDelegate<GlobalReject>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.proveedoresDelegate<GlobalReject>;

  /**
   * `prisma.servicio_detalles`: Exposes CRUD operations for the **servicio_detalles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_detalles
    * const servicio_detalles = await prisma.servicio_detalles.findMany()
    * ```
    */
  get servicio_detalles(): Prisma.servicio_detallesDelegate<GlobalReject>;

  /**
   * `prisma.servicio_gastos`: Exposes CRUD operations for the **servicio_gastos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_gastos
    * const servicio_gastos = await prisma.servicio_gastos.findMany()
    * ```
    */
  get servicio_gastos(): Prisma.servicio_gastosDelegate<GlobalReject>;

  /**
   * `prisma.servicio_venta`: Exposes CRUD operations for the **servicio_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_ventas
    * const servicio_ventas = await prisma.servicio_venta.findMany()
    * ```
    */
  get servicio_venta(): Prisma.servicio_ventaDelegate<GlobalReject>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.serviciosDelegate<GlobalReject>;

  /**
   * `prisma.servicios_liquidacion`: Exposes CRUD operations for the **servicios_liquidacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios_liquidacions
    * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany()
    * ```
    */
  get servicios_liquidacion(): Prisma.servicios_liquidacionDelegate<GlobalReject>;

  /**
   * `prisma.tareas`: Exposes CRUD operations for the **tareas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas
    * const tareas = await prisma.tareas.findMany()
    * ```
    */
  get tareas(): Prisma.tareasDelegate<GlobalReject>;

  /**
   * `prisma.tareas_adicionales`: Exposes CRUD operations for the **tareas_adicionales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas_adicionales
    * const tareas_adicionales = await prisma.tareas_adicionales.findMany()
    * ```
    */
  get tareas_adicionales(): Prisma.tareas_adicionalesDelegate<GlobalReject>;

  /**
   * `prisma.tipo_detalle`: Exposes CRUD operations for the **tipo_detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_detalles
    * const tipo_detalles = await prisma.tipo_detalle.findMany()
    * ```
    */
  get tipo_detalle(): Prisma.tipo_detalleDelegate<GlobalReject>;

  /**
   * `prisma.visitantes`: Exposes CRUD operations for the **visitantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitantes
    * const visitantes = await prisma.visitantes.findMany()
    * ```
    */
  get visitantes(): Prisma.visitantesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: 1e7af066ee9cb95cf3a403c78d9aab3e6b04f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ataud_precio: 'ataud_precio',
    ataud_venta: 'ataud_venta',
    ataudes: 'ataudes',
    autos: 'autos',
    autos_hoja_ruta: 'autos_hoja_ruta',
    autos_novedades: 'autos_novedades',
    autos_pago_patente: 'autos_pago_patente',
    caja_sepelio: 'caja_sepelio',
    conceptos: 'conceptos',
    fabricante_ataud: 'fabricante_ataud',
    gasto_luto: 'gasto_luto',
    gastos_caja: 'gastos_caja',
    historial_autos: 'historial_autos',
    historial_stock_ataud: 'historial_stock_ataud',
    honorarios: 'honorarios',
    ingreso_caja: 'ingreso_caja',
    legajo_virtual_autos: 'legajo_virtual_autos',
    legajo_virtual_servicios: 'legajo_virtual_servicios',
    novedades: 'novedades',
    operadorsep: 'operadorsep',
    parcelas: 'parcelas',
    planificacion_guardias: 'planificacion_guardias',
    precio_servicio: 'precio_servicio',
    proveedores: 'proveedores',
    servicio_detalles: 'servicio_detalles',
    servicio_gastos: 'servicio_gastos',
    servicio_venta: 'servicio_venta',
    servicios: 'servicios',
    servicios_liquidacion: 'servicios_liquidacion',
    tareas: 'tareas',
    tareas_adicionales: 'tareas_adicionales',
    tipo_detalle: 'tipo_detalle',
    visitantes: 'visitantes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model ataud_precio
   */


  export type AggregateAtaud_precio = {
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  export type Ataud_precioAvgAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioSumAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioMinAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioMaxAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioCountAggregateOutputType = {
    idprecio: number
    idataud: number
    codigo: number
    ataud: number
    precio: number
    pri_desc: number
    sec_desc: number
    fecha: number
    operador: number
    estado: number
    _all: number
  }


  export type Ataud_precioAvgAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioSumAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioMinAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioMaxAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioCountAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
    _all?: true
  }

  export type Ataud_precioAggregateArgs = {
    /**
     * Filter which ataud_precio to aggregate.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: Enumerable<ataud_precioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_precios
    **/
    _count?: true | Ataud_precioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_precioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_precioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_precioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_precioMaxAggregateInputType
  }

  export type GetAtaud_precioAggregateType<T extends Ataud_precioAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_precio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_precio[P]>
      : GetScalarType<T[P], AggregateAtaud_precio[P]>
  }




  export type Ataud_precioGroupByArgs = {
    where?: ataud_precioWhereInput
    orderBy?: Enumerable<ataud_precioOrderByWithAggregationInput>
    by: Ataud_precioScalarFieldEnum[]
    having?: ataud_precioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_precioCountAggregateInputType | true
    _avg?: Ataud_precioAvgAggregateInputType
    _sum?: Ataud_precioSumAggregateInputType
    _min?: Ataud_precioMinAggregateInputType
    _max?: Ataud_precioMaxAggregateInputType
  }


  export type Ataud_precioGroupByOutputType = {
    idprecio: number
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  type GetAtaud_precioGroupByPayload<T extends Ataud_precioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Ataud_precioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_precioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
        }
      >
    >


  export type ataud_precioSelect = {
    idprecio?: boolean
    idataud?: boolean
    codigo?: boolean
    ataud?: boolean
    precio?: boolean
    pri_desc?: boolean
    sec_desc?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }


  export type ataud_precioGetPayload<S extends boolean | null | undefined | ataud_precioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ataud_precio :
    S extends undefined ? never :
    S extends { include: any } & (ataud_precioArgs | ataud_precioFindManyArgs)
    ? ataud_precio 
    : S extends { select: any } & (ataud_precioArgs | ataud_precioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ataud_precio ? ataud_precio[P] : never
  } 
      : ataud_precio


  type ataud_precioCountArgs = 
    Omit<ataud_precioFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_precioCountAggregateInputType | true
    }

  export interface ataud_precioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ataud_precio that matches the filter.
     * @param {ataud_precioFindUniqueArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_precioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_precioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<ataud_precioGetPayload<T>> : Prisma__ataud_precioClient<ataud_precioGetPayload<T> | null, null>

    /**
     * Find one Ataud_precio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_precioFindUniqueOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_precioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ataud_precioFindUniqueOrThrowArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Find the first Ataud_precio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_precioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_precioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<ataud_precioGetPayload<T>> : Prisma__ataud_precioClient<ataud_precioGetPayload<T> | null, null>

    /**
     * Find the first Ataud_precio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_precioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ataud_precioFindFirstOrThrowArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Find zero or more Ataud_precios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany()
     * 
     * // Get first 10 Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const ataud_precioWithIdprecioOnly = await prisma.ataud_precio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends ataud_precioFindManyArgs>(
      args?: SelectSubset<T, ataud_precioFindManyArgs>
    ): Prisma.PrismaPromise<Array<ataud_precioGetPayload<T>>>

    /**
     * Create a Ataud_precio.
     * @param {ataud_precioCreateArgs} args - Arguments to create a Ataud_precio.
     * @example
     * // Create one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.create({
     *   data: {
     *     // ... data to create a Ataud_precio
     *   }
     * })
     * 
    **/
    create<T extends ataud_precioCreateArgs>(
      args: SelectSubset<T, ataud_precioCreateArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Create many Ataud_precios.
     *     @param {ataud_precioCreateManyArgs} args - Arguments to create many Ataud_precios.
     *     @example
     *     // Create many Ataud_precios
     *     const ataud_precio = await prisma.ataud_precio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_precioCreateManyArgs>(
      args?: SelectSubset<T, ataud_precioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_precio.
     * @param {ataud_precioDeleteArgs} args - Arguments to delete one Ataud_precio.
     * @example
     * // Delete one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.delete({
     *   where: {
     *     // ... filter to delete one Ataud_precio
     *   }
     * })
     * 
    **/
    delete<T extends ataud_precioDeleteArgs>(
      args: SelectSubset<T, ataud_precioDeleteArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Update one Ataud_precio.
     * @param {ataud_precioUpdateArgs} args - Arguments to update one Ataud_precio.
     * @example
     * // Update one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_precioUpdateArgs>(
      args: SelectSubset<T, ataud_precioUpdateArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Delete zero or more Ataud_precios.
     * @param {ataud_precioDeleteManyArgs} args - Arguments to filter Ataud_precios to delete.
     * @example
     * // Delete a few Ataud_precios
     * const { count } = await prisma.ataud_precio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_precioDeleteManyArgs>(
      args?: SelectSubset<T, ataud_precioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_precios
     * const ataud_precio = await prisma.ataud_precio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_precioUpdateManyArgs>(
      args: SelectSubset<T, ataud_precioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_precio.
     * @param {ataud_precioUpsertArgs} args - Arguments to update or create a Ataud_precio.
     * @example
     * // Update or create a Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.upsert({
     *   create: {
     *     // ... data to create a Ataud_precio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_precio we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_precioUpsertArgs>(
      args: SelectSubset<T, ataud_precioUpsertArgs>
    ): Prisma__ataud_precioClient<ataud_precioGetPayload<T>>

    /**
     * Count the number of Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioCountArgs} args - Arguments to filter Ataud_precios to count.
     * @example
     * // Count the number of Ataud_precios
     * const count = await prisma.ataud_precio.count({
     *   where: {
     *     // ... the filter for the Ataud_precios we want to count
     *   }
     * })
    **/
    count<T extends ataud_precioCountArgs>(
      args?: Subset<T, ataud_precioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_precioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_precioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_precioAggregateArgs>(args: Subset<T, Ataud_precioAggregateArgs>): Prisma.PrismaPromise<GetAtaud_precioAggregateType<T>>

    /**
     * Group by Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_precioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ataud_precioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ataud_precioGroupByArgs['orderBy'] }
        : { orderBy?: Ataud_precioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ataud_precioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_precioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_precio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_precioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_precio base type for findUnique actions
   */
  export type ataud_precioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }

  /**
   * ataud_precio findUnique
   */
  export interface ataud_precioFindUniqueArgs extends ataud_precioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findUniqueOrThrow
   */
  export type ataud_precioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio base type for findFirst actions
   */
  export type ataud_precioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: Enumerable<ataud_precioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Enumerable<Ataud_precioScalarFieldEnum>
  }

  /**
   * ataud_precio findFirst
   */
  export interface ataud_precioFindFirstArgs extends ataud_precioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findFirstOrThrow
   */
  export type ataud_precioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: Enumerable<ataud_precioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Enumerable<Ataud_precioScalarFieldEnum>
  }


  /**
   * ataud_precio findMany
   */
  export type ataud_precioFindManyArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter, which ataud_precios to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: Enumerable<ataud_precioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    distinct?: Enumerable<Ataud_precioScalarFieldEnum>
  }


  /**
   * ataud_precio create
   */
  export type ataud_precioCreateArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * The data needed to create a ataud_precio.
     */
    data: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
  }


  /**
   * ataud_precio createMany
   */
  export type ataud_precioCreateManyArgs = {
    /**
     * The data used to create many ataud_precios.
     */
    data: Enumerable<ataud_precioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ataud_precio update
   */
  export type ataud_precioUpdateArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * The data needed to update a ataud_precio.
     */
    data: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
    /**
     * Choose, which ataud_precio to update.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio updateMany
   */
  export type ataud_precioUpdateManyArgs = {
    /**
     * The data used to update ataud_precios.
     */
    data: XOR<ataud_precioUpdateManyMutationInput, ataud_precioUncheckedUpdateManyInput>
    /**
     * Filter which ataud_precios to update
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio upsert
   */
  export type ataud_precioUpsertArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * The filter to search for the ataud_precio to update in case it exists.
     */
    where: ataud_precioWhereUniqueInput
    /**
     * In case the ataud_precio found by the `where` argument doesn't exist, create a new ataud_precio with this data.
     */
    create: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
    /**
     * In case the ataud_precio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
  }


  /**
   * ataud_precio delete
   */
  export type ataud_precioDeleteArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
    /**
     * Filter which ataud_precio to delete.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio deleteMany
   */
  export type ataud_precioDeleteManyArgs = {
    /**
     * Filter which ataud_precios to delete
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio without action
   */
  export type ataud_precioArgs = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect | null
  }



  /**
   * Model ataud_venta
   */


  export type AggregateAtaud_venta = {
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  export type Ataud_ventaAvgAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaSumAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaMinAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaMaxAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaCountAggregateOutputType = {
    idataudventa: number
    idataud: number
    contrato: number
    apellido_fall: number
    nombre_fall: number
    dni_fall: number
    dom_fall: number
    ndom_fall: number
    barrio_fall: number
    telefono_fall: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    telefono_sol: number
    fecha: number
    operador: number
    ataud: number
    _all: number
  }


  export type Ataud_ventaAvgAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaSumAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaMinAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaMaxAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaCountAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
    _all?: true
  }

  export type Ataud_ventaAggregateArgs = {
    /**
     * Filter which ataud_venta to aggregate.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: Enumerable<ataud_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_ventas
    **/
    _count?: true | Ataud_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_ventaMaxAggregateInputType
  }

  export type GetAtaud_ventaAggregateType<T extends Ataud_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_venta[P]>
      : GetScalarType<T[P], AggregateAtaud_venta[P]>
  }




  export type Ataud_ventaGroupByArgs = {
    where?: ataud_ventaWhereInput
    orderBy?: Enumerable<ataud_ventaOrderByWithAggregationInput>
    by: Ataud_ventaScalarFieldEnum[]
    having?: ataud_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_ventaCountAggregateInputType | true
    _avg?: Ataud_ventaAvgAggregateInputType
    _sum?: Ataud_ventaSumAggregateInputType
    _min?: Ataud_ventaMinAggregateInputType
    _max?: Ataud_ventaMaxAggregateInputType
  }


  export type Ataud_ventaGroupByOutputType = {
    idataudventa: number
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  type GetAtaud_ventaGroupByPayload<T extends Ataud_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Ataud_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
        }
      >
    >


  export type ataud_ventaSelect = {
    idataudventa?: boolean
    idataud?: boolean
    contrato?: boolean
    apellido_fall?: boolean
    nombre_fall?: boolean
    dni_fall?: boolean
    dom_fall?: boolean
    ndom_fall?: boolean
    barrio_fall?: boolean
    telefono_fall?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    telefono_sol?: boolean
    fecha?: boolean
    operador?: boolean
    ataud?: boolean
  }


  export type ataud_ventaGetPayload<S extends boolean | null | undefined | ataud_ventaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ataud_venta :
    S extends undefined ? never :
    S extends { include: any } & (ataud_ventaArgs | ataud_ventaFindManyArgs)
    ? ataud_venta 
    : S extends { select: any } & (ataud_ventaArgs | ataud_ventaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ataud_venta ? ataud_venta[P] : never
  } 
      : ataud_venta


  type ataud_ventaCountArgs = 
    Omit<ataud_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_ventaCountAggregateInputType | true
    }

  export interface ataud_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ataud_venta that matches the filter.
     * @param {ataud_ventaFindUniqueArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_ventaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_ventaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>> : Prisma__ataud_ventaClient<ataud_ventaGetPayload<T> | null, null>

    /**
     * Find one Ataud_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_ventaFindUniqueOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_ventaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ataud_ventaFindUniqueOrThrowArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Find the first Ataud_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_ventaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_ventaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>> : Prisma__ataud_ventaClient<ataud_ventaGetPayload<T> | null, null>

    /**
     * Find the first Ataud_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_ventaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ataud_ventaFindFirstOrThrowArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Find zero or more Ataud_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany()
     * 
     * // Get first 10 Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany({ take: 10 })
     * 
     * // Only select the `idataudventa`
     * const ataud_ventaWithIdataudventaOnly = await prisma.ataud_venta.findMany({ select: { idataudventa: true } })
     * 
    **/
    findMany<T extends ataud_ventaFindManyArgs>(
      args?: SelectSubset<T, ataud_ventaFindManyArgs>
    ): Prisma.PrismaPromise<Array<ataud_ventaGetPayload<T>>>

    /**
     * Create a Ataud_venta.
     * @param {ataud_ventaCreateArgs} args - Arguments to create a Ataud_venta.
     * @example
     * // Create one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.create({
     *   data: {
     *     // ... data to create a Ataud_venta
     *   }
     * })
     * 
    **/
    create<T extends ataud_ventaCreateArgs>(
      args: SelectSubset<T, ataud_ventaCreateArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Create many Ataud_ventas.
     *     @param {ataud_ventaCreateManyArgs} args - Arguments to create many Ataud_ventas.
     *     @example
     *     // Create many Ataud_ventas
     *     const ataud_venta = await prisma.ataud_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_ventaCreateManyArgs>(
      args?: SelectSubset<T, ataud_ventaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_venta.
     * @param {ataud_ventaDeleteArgs} args - Arguments to delete one Ataud_venta.
     * @example
     * // Delete one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.delete({
     *   where: {
     *     // ... filter to delete one Ataud_venta
     *   }
     * })
     * 
    **/
    delete<T extends ataud_ventaDeleteArgs>(
      args: SelectSubset<T, ataud_ventaDeleteArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Update one Ataud_venta.
     * @param {ataud_ventaUpdateArgs} args - Arguments to update one Ataud_venta.
     * @example
     * // Update one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_ventaUpdateArgs>(
      args: SelectSubset<T, ataud_ventaUpdateArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Delete zero or more Ataud_ventas.
     * @param {ataud_ventaDeleteManyArgs} args - Arguments to filter Ataud_ventas to delete.
     * @example
     * // Delete a few Ataud_ventas
     * const { count } = await prisma.ataud_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_ventaDeleteManyArgs>(
      args?: SelectSubset<T, ataud_ventaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_ventas
     * const ataud_venta = await prisma.ataud_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_ventaUpdateManyArgs>(
      args: SelectSubset<T, ataud_ventaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_venta.
     * @param {ataud_ventaUpsertArgs} args - Arguments to update or create a Ataud_venta.
     * @example
     * // Update or create a Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.upsert({
     *   create: {
     *     // ... data to create a Ataud_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_venta we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_ventaUpsertArgs>(
      args: SelectSubset<T, ataud_ventaUpsertArgs>
    ): Prisma__ataud_ventaClient<ataud_ventaGetPayload<T>>

    /**
     * Count the number of Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaCountArgs} args - Arguments to filter Ataud_ventas to count.
     * @example
     * // Count the number of Ataud_ventas
     * const count = await prisma.ataud_venta.count({
     *   where: {
     *     // ... the filter for the Ataud_ventas we want to count
     *   }
     * })
    **/
    count<T extends ataud_ventaCountArgs>(
      args?: Subset<T, ataud_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_ventaAggregateArgs>(args: Subset<T, Ataud_ventaAggregateArgs>): Prisma.PrismaPromise<GetAtaud_ventaAggregateType<T>>

    /**
     * Group by Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ataud_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ataud_ventaGroupByArgs['orderBy'] }
        : { orderBy?: Ataud_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ataud_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_ventaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_venta base type for findUnique actions
   */
  export type ataud_ventaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }

  /**
   * ataud_venta findUnique
   */
  export interface ataud_ventaFindUniqueArgs extends ataud_ventaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findUniqueOrThrow
   */
  export type ataud_ventaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta base type for findFirst actions
   */
  export type ataud_ventaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: Enumerable<ataud_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Enumerable<Ataud_ventaScalarFieldEnum>
  }

  /**
   * ataud_venta findFirst
   */
  export interface ataud_ventaFindFirstArgs extends ataud_ventaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findFirstOrThrow
   */
  export type ataud_ventaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: Enumerable<ataud_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Enumerable<Ataud_ventaScalarFieldEnum>
  }


  /**
   * ataud_venta findMany
   */
  export type ataud_ventaFindManyArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter, which ataud_ventas to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: Enumerable<ataud_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    distinct?: Enumerable<Ataud_ventaScalarFieldEnum>
  }


  /**
   * ataud_venta create
   */
  export type ataud_ventaCreateArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * The data needed to create a ataud_venta.
     */
    data: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
  }


  /**
   * ataud_venta createMany
   */
  export type ataud_ventaCreateManyArgs = {
    /**
     * The data used to create many ataud_ventas.
     */
    data: Enumerable<ataud_ventaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ataud_venta update
   */
  export type ataud_ventaUpdateArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * The data needed to update a ataud_venta.
     */
    data: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
    /**
     * Choose, which ataud_venta to update.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta updateMany
   */
  export type ataud_ventaUpdateManyArgs = {
    /**
     * The data used to update ataud_ventas.
     */
    data: XOR<ataud_ventaUpdateManyMutationInput, ataud_ventaUncheckedUpdateManyInput>
    /**
     * Filter which ataud_ventas to update
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta upsert
   */
  export type ataud_ventaUpsertArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * The filter to search for the ataud_venta to update in case it exists.
     */
    where: ataud_ventaWhereUniqueInput
    /**
     * In case the ataud_venta found by the `where` argument doesn't exist, create a new ataud_venta with this data.
     */
    create: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
    /**
     * In case the ataud_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
  }


  /**
   * ataud_venta delete
   */
  export type ataud_ventaDeleteArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
    /**
     * Filter which ataud_venta to delete.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta deleteMany
   */
  export type ataud_ventaDeleteManyArgs = {
    /**
     * Filter which ataud_ventas to delete
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta without action
   */
  export type ataud_ventaArgs = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect | null
  }



  /**
   * Model ataudes
   */


  export type AggregateAtaudes = {
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  export type AtaudesAvgAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesSumAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesMinAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesMaxAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesCountAggregateOutputType = {
    idataud: number
    nombre: number
    tipo: number
    medidas: number
    uso: number
    fabricante: number
    codigo: number
    fecha_alta: number
    stock: number
    fecha_reposicion: number
    fecha_baja: number
    observaciones: number
    estado: number
    operador: number
    _all: number
  }


  export type AtaudesAvgAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesSumAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesMinAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesMaxAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesCountAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AtaudesAggregateArgs = {
    /**
     * Filter which ataudes to aggregate.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: Enumerable<ataudesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataudes
    **/
    _count?: true | AtaudesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtaudesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtaudesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtaudesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtaudesMaxAggregateInputType
  }

  export type GetAtaudesAggregateType<T extends AtaudesAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaudes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaudes[P]>
      : GetScalarType<T[P], AggregateAtaudes[P]>
  }




  export type AtaudesGroupByArgs = {
    where?: ataudesWhereInput
    orderBy?: Enumerable<ataudesOrderByWithAggregationInput>
    by: AtaudesScalarFieldEnum[]
    having?: ataudesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtaudesCountAggregateInputType | true
    _avg?: AtaudesAvgAggregateInputType
    _sum?: AtaudesSumAggregateInputType
    _min?: AtaudesMinAggregateInputType
    _max?: AtaudesMaxAggregateInputType
  }


  export type AtaudesGroupByOutputType = {
    idataud: number
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  type GetAtaudesGroupByPayload<T extends AtaudesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AtaudesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtaudesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
            : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
        }
      >
    >


  export type ataudesSelect = {
    idataud?: boolean
    nombre?: boolean
    tipo?: boolean
    medidas?: boolean
    uso?: boolean
    fabricante?: boolean
    codigo?: boolean
    fecha_alta?: boolean
    stock?: boolean
    fecha_reposicion?: boolean
    fecha_baja?: boolean
    observaciones?: boolean
    estado?: boolean
    operador?: boolean
  }


  export type ataudesGetPayload<S extends boolean | null | undefined | ataudesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ataudes :
    S extends undefined ? never :
    S extends { include: any } & (ataudesArgs | ataudesFindManyArgs)
    ? ataudes 
    : S extends { select: any } & (ataudesArgs | ataudesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ataudes ? ataudes[P] : never
  } 
      : ataudes


  type ataudesCountArgs = 
    Omit<ataudesFindManyArgs, 'select' | 'include'> & {
      select?: AtaudesCountAggregateInputType | true
    }

  export interface ataudesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ataudes that matches the filter.
     * @param {ataudesFindUniqueArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataudesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataudesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataudes'> extends True ? Prisma__ataudesClient<ataudesGetPayload<T>> : Prisma__ataudesClient<ataudesGetPayload<T> | null, null>

    /**
     * Find one Ataudes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataudesFindUniqueOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataudesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ataudesFindUniqueOrThrowArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Find the first Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataudesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataudesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataudes'> extends True ? Prisma__ataudesClient<ataudesGetPayload<T>> : Prisma__ataudesClient<ataudesGetPayload<T> | null, null>

    /**
     * Find the first Ataudes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataudesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ataudesFindFirstOrThrowArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Find zero or more Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataudes
     * const ataudes = await prisma.ataudes.findMany()
     * 
     * // Get first 10 Ataudes
     * const ataudes = await prisma.ataudes.findMany({ take: 10 })
     * 
     * // Only select the `idataud`
     * const ataudesWithIdataudOnly = await prisma.ataudes.findMany({ select: { idataud: true } })
     * 
    **/
    findMany<T extends ataudesFindManyArgs>(
      args?: SelectSubset<T, ataudesFindManyArgs>
    ): Prisma.PrismaPromise<Array<ataudesGetPayload<T>>>

    /**
     * Create a Ataudes.
     * @param {ataudesCreateArgs} args - Arguments to create a Ataudes.
     * @example
     * // Create one Ataudes
     * const Ataudes = await prisma.ataudes.create({
     *   data: {
     *     // ... data to create a Ataudes
     *   }
     * })
     * 
    **/
    create<T extends ataudesCreateArgs>(
      args: SelectSubset<T, ataudesCreateArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Create many Ataudes.
     *     @param {ataudesCreateManyArgs} args - Arguments to create many Ataudes.
     *     @example
     *     // Create many Ataudes
     *     const ataudes = await prisma.ataudes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataudesCreateManyArgs>(
      args?: SelectSubset<T, ataudesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataudes.
     * @param {ataudesDeleteArgs} args - Arguments to delete one Ataudes.
     * @example
     * // Delete one Ataudes
     * const Ataudes = await prisma.ataudes.delete({
     *   where: {
     *     // ... filter to delete one Ataudes
     *   }
     * })
     * 
    **/
    delete<T extends ataudesDeleteArgs>(
      args: SelectSubset<T, ataudesDeleteArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Update one Ataudes.
     * @param {ataudesUpdateArgs} args - Arguments to update one Ataudes.
     * @example
     * // Update one Ataudes
     * const ataudes = await prisma.ataudes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataudesUpdateArgs>(
      args: SelectSubset<T, ataudesUpdateArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Delete zero or more Ataudes.
     * @param {ataudesDeleteManyArgs} args - Arguments to filter Ataudes to delete.
     * @example
     * // Delete a few Ataudes
     * const { count } = await prisma.ataudes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataudesDeleteManyArgs>(
      args?: SelectSubset<T, ataudesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataudes
     * const ataudes = await prisma.ataudes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataudesUpdateManyArgs>(
      args: SelectSubset<T, ataudesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataudes.
     * @param {ataudesUpsertArgs} args - Arguments to update or create a Ataudes.
     * @example
     * // Update or create a Ataudes
     * const ataudes = await prisma.ataudes.upsert({
     *   create: {
     *     // ... data to create a Ataudes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataudes we want to update
     *   }
     * })
    **/
    upsert<T extends ataudesUpsertArgs>(
      args: SelectSubset<T, ataudesUpsertArgs>
    ): Prisma__ataudesClient<ataudesGetPayload<T>>

    /**
     * Count the number of Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesCountArgs} args - Arguments to filter Ataudes to count.
     * @example
     * // Count the number of Ataudes
     * const count = await prisma.ataudes.count({
     *   where: {
     *     // ... the filter for the Ataudes we want to count
     *   }
     * })
    **/
    count<T extends ataudesCountArgs>(
      args?: Subset<T, ataudesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtaudesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtaudesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtaudesAggregateArgs>(args: Subset<T, AtaudesAggregateArgs>): Prisma.PrismaPromise<GetAtaudesAggregateType<T>>

    /**
     * Group by Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtaudesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtaudesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtaudesGroupByArgs['orderBy'] }
        : { orderBy?: AtaudesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtaudesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaudesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataudes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataudesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataudes base type for findUnique actions
   */
  export type ataudesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }

  /**
   * ataudes findUnique
   */
  export interface ataudesFindUniqueArgs extends ataudesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findUniqueOrThrow
   */
  export type ataudesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes base type for findFirst actions
   */
  export type ataudesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: Enumerable<ataudesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: Enumerable<AtaudesScalarFieldEnum>
  }

  /**
   * ataudes findFirst
   */
  export interface ataudesFindFirstArgs extends ataudesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findFirstOrThrow
   */
  export type ataudesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: Enumerable<ataudesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: Enumerable<AtaudesScalarFieldEnum>
  }


  /**
   * ataudes findMany
   */
  export type ataudesFindManyArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: Enumerable<ataudesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    distinct?: Enumerable<AtaudesScalarFieldEnum>
  }


  /**
   * ataudes create
   */
  export type ataudesCreateArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * The data needed to create a ataudes.
     */
    data: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
  }


  /**
   * ataudes createMany
   */
  export type ataudesCreateManyArgs = {
    /**
     * The data used to create many ataudes.
     */
    data: Enumerable<ataudesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ataudes update
   */
  export type ataudesUpdateArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * The data needed to update a ataudes.
     */
    data: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
    /**
     * Choose, which ataudes to update.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes updateMany
   */
  export type ataudesUpdateManyArgs = {
    /**
     * The data used to update ataudes.
     */
    data: XOR<ataudesUpdateManyMutationInput, ataudesUncheckedUpdateManyInput>
    /**
     * Filter which ataudes to update
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes upsert
   */
  export type ataudesUpsertArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * The filter to search for the ataudes to update in case it exists.
     */
    where: ataudesWhereUniqueInput
    /**
     * In case the ataudes found by the `where` argument doesn't exist, create a new ataudes with this data.
     */
    create: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
    /**
     * In case the ataudes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
  }


  /**
   * ataudes delete
   */
  export type ataudesDeleteArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
    /**
     * Filter which ataudes to delete.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes deleteMany
   */
  export type ataudesDeleteManyArgs = {
    /**
     * Filter which ataudes to delete
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes without action
   */
  export type ataudesArgs = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect | null
  }



  /**
   * Model autos
   */


  export type AggregateAutos = {
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  export type AutosAvgAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosSumAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosMinAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosMaxAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosCountAggregateOutputType = {
    patente: number
    auto: number
    kilometros: number
    responsable: number
    nro_poliza: number
    empresa: number
    vencimiento: number
    motor: number
    chasis: number
    modelo: number
    cobertura: number
    idauto: number
    estado: number
    operador: number
    _all: number
  }


  export type AutosAvgAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosSumAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosMinAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosMaxAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosCountAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AutosAggregateArgs = {
    /**
     * Filter which autos to aggregate.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: Enumerable<autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos
    **/
    _count?: true | AutosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutosMaxAggregateInputType
  }

  export type GetAutosAggregateType<T extends AutosAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos[P]>
      : GetScalarType<T[P], AggregateAutos[P]>
  }




  export type AutosGroupByArgs = {
    where?: autosWhereInput
    orderBy?: Enumerable<autosOrderByWithAggregationInput>
    by: AutosScalarFieldEnum[]
    having?: autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutosCountAggregateInputType | true
    _avg?: AutosAvgAggregateInputType
    _sum?: AutosSumAggregateInputType
    _min?: AutosMinAggregateInputType
    _max?: AutosMaxAggregateInputType
  }


  export type AutosGroupByOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number
    estado: boolean | null
    operador: string | null
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  type GetAutosGroupByPayload<T extends AutosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AutosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutosGroupByOutputType[P]>
            : GetScalarType<T[P], AutosGroupByOutputType[P]>
        }
      >
    >


  export type autosSelect = {
    patente?: boolean
    auto?: boolean
    kilometros?: boolean
    responsable?: boolean
    nro_poliza?: boolean
    empresa?: boolean
    vencimiento?: boolean
    motor?: boolean
    chasis?: boolean
    modelo?: boolean
    cobertura?: boolean
    idauto?: boolean
    estado?: boolean
    operador?: boolean
  }


  export type autosGetPayload<S extends boolean | null | undefined | autosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? autos :
    S extends undefined ? never :
    S extends { include: any } & (autosArgs | autosFindManyArgs)
    ? autos 
    : S extends { select: any } & (autosArgs | autosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof autos ? autos[P] : never
  } 
      : autos


  type autosCountArgs = 
    Omit<autosFindManyArgs, 'select' | 'include'> & {
      select?: AutosCountAggregateInputType | true
    }

  export interface autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Autos that matches the filter.
     * @param {autosFindUniqueArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos'> extends True ? Prisma__autosClient<autosGetPayload<T>> : Prisma__autosClient<autosGetPayload<T> | null, null>

    /**
     * Find one Autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autosFindUniqueOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, autosFindUniqueOrThrowArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Find the first Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos'> extends True ? Prisma__autosClient<autosGetPayload<T>> : Prisma__autosClient<autosGetPayload<T> | null, null>

    /**
     * Find the first Autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, autosFindFirstOrThrowArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Find zero or more Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos
     * const autos = await prisma.autos.findMany()
     * 
     * // Get first 10 Autos
     * const autos = await prisma.autos.findMany({ take: 10 })
     * 
     * // Only select the `patente`
     * const autosWithPatenteOnly = await prisma.autos.findMany({ select: { patente: true } })
     * 
    **/
    findMany<T extends autosFindManyArgs>(
      args?: SelectSubset<T, autosFindManyArgs>
    ): Prisma.PrismaPromise<Array<autosGetPayload<T>>>

    /**
     * Create a Autos.
     * @param {autosCreateArgs} args - Arguments to create a Autos.
     * @example
     * // Create one Autos
     * const Autos = await prisma.autos.create({
     *   data: {
     *     // ... data to create a Autos
     *   }
     * })
     * 
    **/
    create<T extends autosCreateArgs>(
      args: SelectSubset<T, autosCreateArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Create many Autos.
     *     @param {autosCreateManyArgs} args - Arguments to create many Autos.
     *     @example
     *     // Create many Autos
     *     const autos = await prisma.autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autosCreateManyArgs>(
      args?: SelectSubset<T, autosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos.
     * @param {autosDeleteArgs} args - Arguments to delete one Autos.
     * @example
     * // Delete one Autos
     * const Autos = await prisma.autos.delete({
     *   where: {
     *     // ... filter to delete one Autos
     *   }
     * })
     * 
    **/
    delete<T extends autosDeleteArgs>(
      args: SelectSubset<T, autosDeleteArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Update one Autos.
     * @param {autosUpdateArgs} args - Arguments to update one Autos.
     * @example
     * // Update one Autos
     * const autos = await prisma.autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autosUpdateArgs>(
      args: SelectSubset<T, autosUpdateArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Delete zero or more Autos.
     * @param {autosDeleteManyArgs} args - Arguments to filter Autos to delete.
     * @example
     * // Delete a few Autos
     * const { count } = await prisma.autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autosDeleteManyArgs>(
      args?: SelectSubset<T, autosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos
     * const autos = await prisma.autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autosUpdateManyArgs>(
      args: SelectSubset<T, autosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos.
     * @param {autosUpsertArgs} args - Arguments to update or create a Autos.
     * @example
     * // Update or create a Autos
     * const autos = await prisma.autos.upsert({
     *   create: {
     *     // ... data to create a Autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos we want to update
     *   }
     * })
    **/
    upsert<T extends autosUpsertArgs>(
      args: SelectSubset<T, autosUpsertArgs>
    ): Prisma__autosClient<autosGetPayload<T>>

    /**
     * Count the number of Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosCountArgs} args - Arguments to filter Autos to count.
     * @example
     * // Count the number of Autos
     * const count = await prisma.autos.count({
     *   where: {
     *     // ... the filter for the Autos we want to count
     *   }
     * })
    **/
    count<T extends autosCountArgs>(
      args?: Subset<T, autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutosAggregateArgs>(args: Subset<T, AutosAggregateArgs>): Prisma.PrismaPromise<GetAutosAggregateType<T>>

    /**
     * Group by Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutosGroupByArgs['orderBy'] }
        : { orderBy?: AutosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos base type for findUnique actions
   */
  export type autosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }

  /**
   * autos findUnique
   */
  export interface autosFindUniqueArgs extends autosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findUniqueOrThrow
   */
  export type autosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos base type for findFirst actions
   */
  export type autosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: Enumerable<autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: Enumerable<AutosScalarFieldEnum>
  }

  /**
   * autos findFirst
   */
  export interface autosFindFirstArgs extends autosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findFirstOrThrow
   */
  export type autosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: Enumerable<autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: Enumerable<AutosScalarFieldEnum>
  }


  /**
   * autos findMany
   */
  export type autosFindManyArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: Enumerable<autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    distinct?: Enumerable<AutosScalarFieldEnum>
  }


  /**
   * autos create
   */
  export type autosCreateArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * The data needed to create a autos.
     */
    data: XOR<autosCreateInput, autosUncheckedCreateInput>
  }


  /**
   * autos createMany
   */
  export type autosCreateManyArgs = {
    /**
     * The data used to create many autos.
     */
    data: Enumerable<autosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * autos update
   */
  export type autosUpdateArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * The data needed to update a autos.
     */
    data: XOR<autosUpdateInput, autosUncheckedUpdateInput>
    /**
     * Choose, which autos to update.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos updateMany
   */
  export type autosUpdateManyArgs = {
    /**
     * The data used to update autos.
     */
    data: XOR<autosUpdateManyMutationInput, autosUncheckedUpdateManyInput>
    /**
     * Filter which autos to update
     */
    where?: autosWhereInput
  }


  /**
   * autos upsert
   */
  export type autosUpsertArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * The filter to search for the autos to update in case it exists.
     */
    where: autosWhereUniqueInput
    /**
     * In case the autos found by the `where` argument doesn't exist, create a new autos with this data.
     */
    create: XOR<autosCreateInput, autosUncheckedCreateInput>
    /**
     * In case the autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autosUpdateInput, autosUncheckedUpdateInput>
  }


  /**
   * autos delete
   */
  export type autosDeleteArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
    /**
     * Filter which autos to delete.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos deleteMany
   */
  export type autosDeleteManyArgs = {
    /**
     * Filter which autos to delete
     */
    where?: autosWhereInput
  }


  /**
   * autos without action
   */
  export type autosArgs = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect | null
  }



  /**
   * Model autos_hoja_ruta
   */


  export type AggregateAutos_hoja_ruta = {
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  export type Autos_hoja_rutaAvgAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaSumAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaMinAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaMaxAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaCountAggregateOutputType = {
    idhojaruta: number
    patente: number
    auto: number
    conductor: number
    idservicio: number
    fecha_salida: number
    km_salida: number
    fecha_llegada: number
    km_llegada: number
    fecha_registro: number
    operador: number
    _all: number
  }


  export type Autos_hoja_rutaAvgAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaSumAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaMinAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaMaxAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaCountAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
    _all?: true
  }

  export type Autos_hoja_rutaAggregateArgs = {
    /**
     * Filter which autos_hoja_ruta to aggregate.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: Enumerable<autos_hoja_rutaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_hoja_rutas
    **/
    _count?: true | Autos_hoja_rutaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_hoja_rutaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_hoja_rutaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }

  export type GetAutos_hoja_rutaAggregateType<T extends Autos_hoja_rutaAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_hoja_ruta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
      : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
  }




  export type Autos_hoja_rutaGroupByArgs = {
    where?: autos_hoja_rutaWhereInput
    orderBy?: Enumerable<autos_hoja_rutaOrderByWithAggregationInput>
    by: Autos_hoja_rutaScalarFieldEnum[]
    having?: autos_hoja_rutaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_hoja_rutaCountAggregateInputType | true
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    _sum?: Autos_hoja_rutaSumAggregateInputType
    _min?: Autos_hoja_rutaMinAggregateInputType
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }


  export type Autos_hoja_rutaGroupByOutputType = {
    idhojaruta: number
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  type GetAutos_hoja_rutaGroupByPayload<T extends Autos_hoja_rutaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Autos_hoja_rutaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_hoja_rutaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
        }
      >
    >


  export type autos_hoja_rutaSelect = {
    idhojaruta?: boolean
    patente?: boolean
    auto?: boolean
    conductor?: boolean
    idservicio?: boolean
    fecha_salida?: boolean
    km_salida?: boolean
    fecha_llegada?: boolean
    km_llegada?: boolean
    fecha_registro?: boolean
    operador?: boolean
  }


  export type autos_hoja_rutaGetPayload<S extends boolean | null | undefined | autos_hoja_rutaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? autos_hoja_ruta :
    S extends undefined ? never :
    S extends { include: any } & (autos_hoja_rutaArgs | autos_hoja_rutaFindManyArgs)
    ? autos_hoja_ruta 
    : S extends { select: any } & (autos_hoja_rutaArgs | autos_hoja_rutaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof autos_hoja_ruta ? autos_hoja_ruta[P] : never
  } 
      : autos_hoja_ruta


  type autos_hoja_rutaCountArgs = 
    Omit<autos_hoja_rutaFindManyArgs, 'select' | 'include'> & {
      select?: Autos_hoja_rutaCountAggregateInputType | true
    }

  export interface autos_hoja_rutaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Autos_hoja_ruta that matches the filter.
     * @param {autos_hoja_rutaFindUniqueArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_hoja_rutaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_hoja_rutaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>> : Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T> | null, null>

    /**
     * Find one Autos_hoja_ruta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_hoja_rutaFindUniqueOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_hoja_rutaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, autos_hoja_rutaFindUniqueOrThrowArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Find the first Autos_hoja_ruta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_hoja_rutaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>> : Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T> | null, null>

    /**
     * Find the first Autos_hoja_ruta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_hoja_rutaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstOrThrowArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Find zero or more Autos_hoja_rutas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
     * 
     * // Get first 10 Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany({ take: 10 })
     * 
     * // Only select the `idhojaruta`
     * const autos_hoja_rutaWithIdhojarutaOnly = await prisma.autos_hoja_ruta.findMany({ select: { idhojaruta: true } })
     * 
    **/
    findMany<T extends autos_hoja_rutaFindManyArgs>(
      args?: SelectSubset<T, autos_hoja_rutaFindManyArgs>
    ): Prisma.PrismaPromise<Array<autos_hoja_rutaGetPayload<T>>>

    /**
     * Create a Autos_hoja_ruta.
     * @param {autos_hoja_rutaCreateArgs} args - Arguments to create a Autos_hoja_ruta.
     * @example
     * // Create one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.create({
     *   data: {
     *     // ... data to create a Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    create<T extends autos_hoja_rutaCreateArgs>(
      args: SelectSubset<T, autos_hoja_rutaCreateArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Create many Autos_hoja_rutas.
     *     @param {autos_hoja_rutaCreateManyArgs} args - Arguments to create many Autos_hoja_rutas.
     *     @example
     *     // Create many Autos_hoja_rutas
     *     const autos_hoja_ruta = await prisma.autos_hoja_ruta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_hoja_rutaCreateManyArgs>(
      args?: SelectSubset<T, autos_hoja_rutaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_hoja_ruta.
     * @param {autos_hoja_rutaDeleteArgs} args - Arguments to delete one Autos_hoja_ruta.
     * @example
     * // Delete one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.delete({
     *   where: {
     *     // ... filter to delete one Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    delete<T extends autos_hoja_rutaDeleteArgs>(
      args: SelectSubset<T, autos_hoja_rutaDeleteArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpdateArgs} args - Arguments to update one Autos_hoja_ruta.
     * @example
     * // Update one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_hoja_rutaUpdateArgs>(
      args: SelectSubset<T, autos_hoja_rutaUpdateArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Delete zero or more Autos_hoja_rutas.
     * @param {autos_hoja_rutaDeleteManyArgs} args - Arguments to filter Autos_hoja_rutas to delete.
     * @example
     * // Delete a few Autos_hoja_rutas
     * const { count } = await prisma.autos_hoja_ruta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_hoja_rutaDeleteManyArgs>(
      args?: SelectSubset<T, autos_hoja_rutaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_hoja_rutas
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_hoja_rutaUpdateManyArgs>(
      args: SelectSubset<T, autos_hoja_rutaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpsertArgs} args - Arguments to update or create a Autos_hoja_ruta.
     * @example
     * // Update or create a Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.upsert({
     *   create: {
     *     // ... data to create a Autos_hoja_ruta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_hoja_ruta we want to update
     *   }
     * })
    **/
    upsert<T extends autos_hoja_rutaUpsertArgs>(
      args: SelectSubset<T, autos_hoja_rutaUpsertArgs>
    ): Prisma__autos_hoja_rutaClient<autos_hoja_rutaGetPayload<T>>

    /**
     * Count the number of Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaCountArgs} args - Arguments to filter Autos_hoja_rutas to count.
     * @example
     * // Count the number of Autos_hoja_rutas
     * const count = await prisma.autos_hoja_ruta.count({
     *   where: {
     *     // ... the filter for the Autos_hoja_rutas we want to count
     *   }
     * })
    **/
    count<T extends autos_hoja_rutaCountArgs>(
      args?: Subset<T, autos_hoja_rutaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_hoja_rutaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_hoja_rutaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_hoja_rutaAggregateArgs>(args: Subset<T, Autos_hoja_rutaAggregateArgs>): Prisma.PrismaPromise<GetAutos_hoja_rutaAggregateType<T>>

    /**
     * Group by Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_hoja_rutaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Autos_hoja_rutaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Autos_hoja_rutaGroupByArgs['orderBy'] }
        : { orderBy?: Autos_hoja_rutaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Autos_hoja_rutaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_hoja_rutaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_hoja_ruta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_hoja_rutaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_hoja_ruta base type for findUnique actions
   */
  export type autos_hoja_rutaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }

  /**
   * autos_hoja_ruta findUnique
   */
  export interface autos_hoja_rutaFindUniqueArgs extends autos_hoja_rutaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findUniqueOrThrow
   */
  export type autos_hoja_rutaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta base type for findFirst actions
   */
  export type autos_hoja_rutaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: Enumerable<autos_hoja_rutaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Enumerable<Autos_hoja_rutaScalarFieldEnum>
  }

  /**
   * autos_hoja_ruta findFirst
   */
  export interface autos_hoja_rutaFindFirstArgs extends autos_hoja_rutaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findFirstOrThrow
   */
  export type autos_hoja_rutaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: Enumerable<autos_hoja_rutaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Enumerable<Autos_hoja_rutaScalarFieldEnum>
  }


  /**
   * autos_hoja_ruta findMany
   */
  export type autos_hoja_rutaFindManyArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter, which autos_hoja_rutas to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: Enumerable<autos_hoja_rutaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    distinct?: Enumerable<Autos_hoja_rutaScalarFieldEnum>
  }


  /**
   * autos_hoja_ruta create
   */
  export type autos_hoja_rutaCreateArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * The data needed to create a autos_hoja_ruta.
     */
    data: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
  }


  /**
   * autos_hoja_ruta createMany
   */
  export type autos_hoja_rutaCreateManyArgs = {
    /**
     * The data used to create many autos_hoja_rutas.
     */
    data: Enumerable<autos_hoja_rutaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * autos_hoja_ruta update
   */
  export type autos_hoja_rutaUpdateArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * The data needed to update a autos_hoja_ruta.
     */
    data: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
    /**
     * Choose, which autos_hoja_ruta to update.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta updateMany
   */
  export type autos_hoja_rutaUpdateManyArgs = {
    /**
     * The data used to update autos_hoja_rutas.
     */
    data: XOR<autos_hoja_rutaUpdateManyMutationInput, autos_hoja_rutaUncheckedUpdateManyInput>
    /**
     * Filter which autos_hoja_rutas to update
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta upsert
   */
  export type autos_hoja_rutaUpsertArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * The filter to search for the autos_hoja_ruta to update in case it exists.
     */
    where: autos_hoja_rutaWhereUniqueInput
    /**
     * In case the autos_hoja_ruta found by the `where` argument doesn't exist, create a new autos_hoja_ruta with this data.
     */
    create: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
    /**
     * In case the autos_hoja_ruta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
  }


  /**
   * autos_hoja_ruta delete
   */
  export type autos_hoja_rutaDeleteArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
    /**
     * Filter which autos_hoja_ruta to delete.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta deleteMany
   */
  export type autos_hoja_rutaDeleteManyArgs = {
    /**
     * Filter which autos_hoja_rutas to delete
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta without action
   */
  export type autos_hoja_rutaArgs = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect | null
  }



  /**
   * Model autos_novedades
   */


  export type AggregateAutos_novedades = {
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  export type Autos_novedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesMinAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesMaxAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesCountAggregateOutputType = {
    idnovedad: number
    patente: number
    fecha: number
    novedad: number
    operador: number
    auto: number
    _all: number
  }


  export type Autos_novedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesMinAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesMaxAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesCountAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
    _all?: true
  }

  export type Autos_novedadesAggregateArgs = {
    /**
     * Filter which autos_novedades to aggregate.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: Enumerable<autos_novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_novedades
    **/
    _count?: true | Autos_novedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_novedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_novedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_novedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_novedadesMaxAggregateInputType
  }

  export type GetAutos_novedadesAggregateType<T extends Autos_novedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_novedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_novedades[P]>
      : GetScalarType<T[P], AggregateAutos_novedades[P]>
  }




  export type Autos_novedadesGroupByArgs = {
    where?: autos_novedadesWhereInput
    orderBy?: Enumerable<autos_novedadesOrderByWithAggregationInput>
    by: Autos_novedadesScalarFieldEnum[]
    having?: autos_novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_novedadesCountAggregateInputType | true
    _avg?: Autos_novedadesAvgAggregateInputType
    _sum?: Autos_novedadesSumAggregateInputType
    _min?: Autos_novedadesMinAggregateInputType
    _max?: Autos_novedadesMaxAggregateInputType
  }


  export type Autos_novedadesGroupByOutputType = {
    idnovedad: number
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  type GetAutos_novedadesGroupByPayload<T extends Autos_novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Autos_novedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_novedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
        }
      >
    >


  export type autos_novedadesSelect = {
    idnovedad?: boolean
    patente?: boolean
    fecha?: boolean
    novedad?: boolean
    operador?: boolean
    auto?: boolean
  }


  export type autos_novedadesGetPayload<S extends boolean | null | undefined | autos_novedadesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? autos_novedades :
    S extends undefined ? never :
    S extends { include: any } & (autos_novedadesArgs | autos_novedadesFindManyArgs)
    ? autos_novedades 
    : S extends { select: any } & (autos_novedadesArgs | autos_novedadesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof autos_novedades ? autos_novedades[P] : never
  } 
      : autos_novedades


  type autos_novedadesCountArgs = 
    Omit<autos_novedadesFindManyArgs, 'select' | 'include'> & {
      select?: Autos_novedadesCountAggregateInputType | true
    }

  export interface autos_novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Autos_novedades that matches the filter.
     * @param {autos_novedadesFindUniqueArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_novedadesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_novedadesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>> : Prisma__autos_novedadesClient<autos_novedadesGetPayload<T> | null, null>

    /**
     * Find one Autos_novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_novedadesFindUniqueOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_novedadesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, autos_novedadesFindUniqueOrThrowArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Find the first Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_novedadesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_novedadesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>> : Prisma__autos_novedadesClient<autos_novedadesGetPayload<T> | null, null>

    /**
     * Find the first Autos_novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_novedadesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, autos_novedadesFindFirstOrThrowArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Find zero or more Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany()
     * 
     * // Get first 10 Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const autos_novedadesWithIdnovedadOnly = await prisma.autos_novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends autos_novedadesFindManyArgs>(
      args?: SelectSubset<T, autos_novedadesFindManyArgs>
    ): Prisma.PrismaPromise<Array<autos_novedadesGetPayload<T>>>

    /**
     * Create a Autos_novedades.
     * @param {autos_novedadesCreateArgs} args - Arguments to create a Autos_novedades.
     * @example
     * // Create one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.create({
     *   data: {
     *     // ... data to create a Autos_novedades
     *   }
     * })
     * 
    **/
    create<T extends autos_novedadesCreateArgs>(
      args: SelectSubset<T, autos_novedadesCreateArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Create many Autos_novedades.
     *     @param {autos_novedadesCreateManyArgs} args - Arguments to create many Autos_novedades.
     *     @example
     *     // Create many Autos_novedades
     *     const autos_novedades = await prisma.autos_novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_novedadesCreateManyArgs>(
      args?: SelectSubset<T, autos_novedadesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_novedades.
     * @param {autos_novedadesDeleteArgs} args - Arguments to delete one Autos_novedades.
     * @example
     * // Delete one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.delete({
     *   where: {
     *     // ... filter to delete one Autos_novedades
     *   }
     * })
     * 
    **/
    delete<T extends autos_novedadesDeleteArgs>(
      args: SelectSubset<T, autos_novedadesDeleteArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Update one Autos_novedades.
     * @param {autos_novedadesUpdateArgs} args - Arguments to update one Autos_novedades.
     * @example
     * // Update one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_novedadesUpdateArgs>(
      args: SelectSubset<T, autos_novedadesUpdateArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Delete zero or more Autos_novedades.
     * @param {autos_novedadesDeleteManyArgs} args - Arguments to filter Autos_novedades to delete.
     * @example
     * // Delete a few Autos_novedades
     * const { count } = await prisma.autos_novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_novedadesDeleteManyArgs>(
      args?: SelectSubset<T, autos_novedadesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_novedadesUpdateManyArgs>(
      args: SelectSubset<T, autos_novedadesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_novedades.
     * @param {autos_novedadesUpsertArgs} args - Arguments to update or create a Autos_novedades.
     * @example
     * // Update or create a Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.upsert({
     *   create: {
     *     // ... data to create a Autos_novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_novedades we want to update
     *   }
     * })
    **/
    upsert<T extends autos_novedadesUpsertArgs>(
      args: SelectSubset<T, autos_novedadesUpsertArgs>
    ): Prisma__autos_novedadesClient<autos_novedadesGetPayload<T>>

    /**
     * Count the number of Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesCountArgs} args - Arguments to filter Autos_novedades to count.
     * @example
     * // Count the number of Autos_novedades
     * const count = await prisma.autos_novedades.count({
     *   where: {
     *     // ... the filter for the Autos_novedades we want to count
     *   }
     * })
    **/
    count<T extends autos_novedadesCountArgs>(
      args?: Subset<T, autos_novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_novedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_novedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_novedadesAggregateArgs>(args: Subset<T, Autos_novedadesAggregateArgs>): Prisma.PrismaPromise<GetAutos_novedadesAggregateType<T>>

    /**
     * Group by Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Autos_novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Autos_novedadesGroupByArgs['orderBy'] }
        : { orderBy?: Autos_novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Autos_novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_novedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_novedadesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_novedades base type for findUnique actions
   */
  export type autos_novedadesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }

  /**
   * autos_novedades findUnique
   */
  export interface autos_novedadesFindUniqueArgs extends autos_novedadesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findUniqueOrThrow
   */
  export type autos_novedadesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades base type for findFirst actions
   */
  export type autos_novedadesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: Enumerable<autos_novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Enumerable<Autos_novedadesScalarFieldEnum>
  }

  /**
   * autos_novedades findFirst
   */
  export interface autos_novedadesFindFirstArgs extends autos_novedadesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findFirstOrThrow
   */
  export type autos_novedadesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: Enumerable<autos_novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Enumerable<Autos_novedadesScalarFieldEnum>
  }


  /**
   * autos_novedades findMany
   */
  export type autos_novedadesFindManyArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: Enumerable<autos_novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    distinct?: Enumerable<Autos_novedadesScalarFieldEnum>
  }


  /**
   * autos_novedades create
   */
  export type autos_novedadesCreateArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * The data needed to create a autos_novedades.
     */
    data: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
  }


  /**
   * autos_novedades createMany
   */
  export type autos_novedadesCreateManyArgs = {
    /**
     * The data used to create many autos_novedades.
     */
    data: Enumerable<autos_novedadesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * autos_novedades update
   */
  export type autos_novedadesUpdateArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * The data needed to update a autos_novedades.
     */
    data: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
    /**
     * Choose, which autos_novedades to update.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades updateMany
   */
  export type autos_novedadesUpdateManyArgs = {
    /**
     * The data used to update autos_novedades.
     */
    data: XOR<autos_novedadesUpdateManyMutationInput, autos_novedadesUncheckedUpdateManyInput>
    /**
     * Filter which autos_novedades to update
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades upsert
   */
  export type autos_novedadesUpsertArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * The filter to search for the autos_novedades to update in case it exists.
     */
    where: autos_novedadesWhereUniqueInput
    /**
     * In case the autos_novedades found by the `where` argument doesn't exist, create a new autos_novedades with this data.
     */
    create: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
    /**
     * In case the autos_novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
  }


  /**
   * autos_novedades delete
   */
  export type autos_novedadesDeleteArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
    /**
     * Filter which autos_novedades to delete.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades deleteMany
   */
  export type autos_novedadesDeleteManyArgs = {
    /**
     * Filter which autos_novedades to delete
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades without action
   */
  export type autos_novedadesArgs = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect | null
  }



  /**
   * Model autos_pago_patente
   */


  export type AggregateAutos_pago_patente = {
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  export type Autos_pago_patenteAvgAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteSumAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteMinAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteMaxAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteCountAggregateOutputType = {
    idpago: number
    patente: number
    mes: number
    ano: number
    importe: number
    cod_pago: number
    idauto: number
    operador: number
    _all: number
  }


  export type Autos_pago_patenteAvgAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteSumAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteMinAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteMaxAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteCountAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
    _all?: true
  }

  export type Autos_pago_patenteAggregateArgs = {
    /**
     * Filter which autos_pago_patente to aggregate.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: Enumerable<autos_pago_patenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_pago_patentes
    **/
    _count?: true | Autos_pago_patenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_pago_patenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_pago_patenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_pago_patenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_pago_patenteMaxAggregateInputType
  }

  export type GetAutos_pago_patenteAggregateType<T extends Autos_pago_patenteAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_pago_patente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
      : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
  }




  export type Autos_pago_patenteGroupByArgs = {
    where?: autos_pago_patenteWhereInput
    orderBy?: Enumerable<autos_pago_patenteOrderByWithAggregationInput>
    by: Autos_pago_patenteScalarFieldEnum[]
    having?: autos_pago_patenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_pago_patenteCountAggregateInputType | true
    _avg?: Autos_pago_patenteAvgAggregateInputType
    _sum?: Autos_pago_patenteSumAggregateInputType
    _min?: Autos_pago_patenteMinAggregateInputType
    _max?: Autos_pago_patenteMaxAggregateInputType
  }


  export type Autos_pago_patenteGroupByOutputType = {
    idpago: number
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  type GetAutos_pago_patenteGroupByPayload<T extends Autos_pago_patenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Autos_pago_patenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_pago_patenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
        }
      >
    >


  export type autos_pago_patenteSelect = {
    idpago?: boolean
    patente?: boolean
    mes?: boolean
    ano?: boolean
    importe?: boolean
    cod_pago?: boolean
    idauto?: boolean
    operador?: boolean
  }


  export type autos_pago_patenteGetPayload<S extends boolean | null | undefined | autos_pago_patenteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? autos_pago_patente :
    S extends undefined ? never :
    S extends { include: any } & (autos_pago_patenteArgs | autos_pago_patenteFindManyArgs)
    ? autos_pago_patente 
    : S extends { select: any } & (autos_pago_patenteArgs | autos_pago_patenteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof autos_pago_patente ? autos_pago_patente[P] : never
  } 
      : autos_pago_patente


  type autos_pago_patenteCountArgs = 
    Omit<autos_pago_patenteFindManyArgs, 'select' | 'include'> & {
      select?: Autos_pago_patenteCountAggregateInputType | true
    }

  export interface autos_pago_patenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Autos_pago_patente that matches the filter.
     * @param {autos_pago_patenteFindUniqueArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_pago_patenteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_pago_patenteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>> : Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T> | null, null>

    /**
     * Find one Autos_pago_patente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_pago_patenteFindUniqueOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_pago_patenteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, autos_pago_patenteFindUniqueOrThrowArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Find the first Autos_pago_patente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_pago_patenteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>> : Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T> | null, null>

    /**
     * Find the first Autos_pago_patente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_pago_patenteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstOrThrowArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Find zero or more Autos_pago_patentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
     * 
     * // Get first 10 Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany({ take: 10 })
     * 
     * // Only select the `idpago`
     * const autos_pago_patenteWithIdpagoOnly = await prisma.autos_pago_patente.findMany({ select: { idpago: true } })
     * 
    **/
    findMany<T extends autos_pago_patenteFindManyArgs>(
      args?: SelectSubset<T, autos_pago_patenteFindManyArgs>
    ): Prisma.PrismaPromise<Array<autos_pago_patenteGetPayload<T>>>

    /**
     * Create a Autos_pago_patente.
     * @param {autos_pago_patenteCreateArgs} args - Arguments to create a Autos_pago_patente.
     * @example
     * // Create one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.create({
     *   data: {
     *     // ... data to create a Autos_pago_patente
     *   }
     * })
     * 
    **/
    create<T extends autos_pago_patenteCreateArgs>(
      args: SelectSubset<T, autos_pago_patenteCreateArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Create many Autos_pago_patentes.
     *     @param {autos_pago_patenteCreateManyArgs} args - Arguments to create many Autos_pago_patentes.
     *     @example
     *     // Create many Autos_pago_patentes
     *     const autos_pago_patente = await prisma.autos_pago_patente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_pago_patenteCreateManyArgs>(
      args?: SelectSubset<T, autos_pago_patenteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_pago_patente.
     * @param {autos_pago_patenteDeleteArgs} args - Arguments to delete one Autos_pago_patente.
     * @example
     * // Delete one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.delete({
     *   where: {
     *     // ... filter to delete one Autos_pago_patente
     *   }
     * })
     * 
    **/
    delete<T extends autos_pago_patenteDeleteArgs>(
      args: SelectSubset<T, autos_pago_patenteDeleteArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Update one Autos_pago_patente.
     * @param {autos_pago_patenteUpdateArgs} args - Arguments to update one Autos_pago_patente.
     * @example
     * // Update one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_pago_patenteUpdateArgs>(
      args: SelectSubset<T, autos_pago_patenteUpdateArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Delete zero or more Autos_pago_patentes.
     * @param {autos_pago_patenteDeleteManyArgs} args - Arguments to filter Autos_pago_patentes to delete.
     * @example
     * // Delete a few Autos_pago_patentes
     * const { count } = await prisma.autos_pago_patente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_pago_patenteDeleteManyArgs>(
      args?: SelectSubset<T, autos_pago_patenteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_pago_patentes
     * const autos_pago_patente = await prisma.autos_pago_patente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_pago_patenteUpdateManyArgs>(
      args: SelectSubset<T, autos_pago_patenteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_pago_patente.
     * @param {autos_pago_patenteUpsertArgs} args - Arguments to update or create a Autos_pago_patente.
     * @example
     * // Update or create a Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.upsert({
     *   create: {
     *     // ... data to create a Autos_pago_patente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_pago_patente we want to update
     *   }
     * })
    **/
    upsert<T extends autos_pago_patenteUpsertArgs>(
      args: SelectSubset<T, autos_pago_patenteUpsertArgs>
    ): Prisma__autos_pago_patenteClient<autos_pago_patenteGetPayload<T>>

    /**
     * Count the number of Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteCountArgs} args - Arguments to filter Autos_pago_patentes to count.
     * @example
     * // Count the number of Autos_pago_patentes
     * const count = await prisma.autos_pago_patente.count({
     *   where: {
     *     // ... the filter for the Autos_pago_patentes we want to count
     *   }
     * })
    **/
    count<T extends autos_pago_patenteCountArgs>(
      args?: Subset<T, autos_pago_patenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_pago_patenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_pago_patenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_pago_patenteAggregateArgs>(args: Subset<T, Autos_pago_patenteAggregateArgs>): Prisma.PrismaPromise<GetAutos_pago_patenteAggregateType<T>>

    /**
     * Group by Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_pago_patenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Autos_pago_patenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Autos_pago_patenteGroupByArgs['orderBy'] }
        : { orderBy?: Autos_pago_patenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Autos_pago_patenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_pago_patenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_pago_patente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_pago_patenteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_pago_patente base type for findUnique actions
   */
  export type autos_pago_patenteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }

  /**
   * autos_pago_patente findUnique
   */
  export interface autos_pago_patenteFindUniqueArgs extends autos_pago_patenteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findUniqueOrThrow
   */
  export type autos_pago_patenteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente base type for findFirst actions
   */
  export type autos_pago_patenteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: Enumerable<autos_pago_patenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Enumerable<Autos_pago_patenteScalarFieldEnum>
  }

  /**
   * autos_pago_patente findFirst
   */
  export interface autos_pago_patenteFindFirstArgs extends autos_pago_patenteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findFirstOrThrow
   */
  export type autos_pago_patenteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: Enumerable<autos_pago_patenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Enumerable<Autos_pago_patenteScalarFieldEnum>
  }


  /**
   * autos_pago_patente findMany
   */
  export type autos_pago_patenteFindManyArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter, which autos_pago_patentes to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: Enumerable<autos_pago_patenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    distinct?: Enumerable<Autos_pago_patenteScalarFieldEnum>
  }


  /**
   * autos_pago_patente create
   */
  export type autos_pago_patenteCreateArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * The data needed to create a autos_pago_patente.
     */
    data: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
  }


  /**
   * autos_pago_patente createMany
   */
  export type autos_pago_patenteCreateManyArgs = {
    /**
     * The data used to create many autos_pago_patentes.
     */
    data: Enumerable<autos_pago_patenteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * autos_pago_patente update
   */
  export type autos_pago_patenteUpdateArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * The data needed to update a autos_pago_patente.
     */
    data: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
    /**
     * Choose, which autos_pago_patente to update.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente updateMany
   */
  export type autos_pago_patenteUpdateManyArgs = {
    /**
     * The data used to update autos_pago_patentes.
     */
    data: XOR<autos_pago_patenteUpdateManyMutationInput, autos_pago_patenteUncheckedUpdateManyInput>
    /**
     * Filter which autos_pago_patentes to update
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente upsert
   */
  export type autos_pago_patenteUpsertArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * The filter to search for the autos_pago_patente to update in case it exists.
     */
    where: autos_pago_patenteWhereUniqueInput
    /**
     * In case the autos_pago_patente found by the `where` argument doesn't exist, create a new autos_pago_patente with this data.
     */
    create: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
    /**
     * In case the autos_pago_patente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
  }


  /**
   * autos_pago_patente delete
   */
  export type autos_pago_patenteDeleteArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
    /**
     * Filter which autos_pago_patente to delete.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente deleteMany
   */
  export type autos_pago_patenteDeleteManyArgs = {
    /**
     * Filter which autos_pago_patentes to delete
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente without action
   */
  export type autos_pago_patenteArgs = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect | null
  }



  /**
   * Model caja_sepelio
   */


  export type AggregateCaja_sepelio = {
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  export type Caja_sepelioAvgAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioSumAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioMinAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioMaxAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioCountAggregateOutputType = {
    idcaja: number
    operador: number
    detalle: number
    monto: number
    estado: number
    fecha: number
    gastos: number
    totalcaja: number
    empresa: number
    tipofactura: number
    nfactura: number
    ptoventa: number
    concepto: number
    cierre: number
    ultimacarga: number
    _all: number
  }


  export type Caja_sepelioAvgAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioSumAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioMinAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioMaxAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioCountAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
    _all?: true
  }

  export type Caja_sepelioAggregateArgs = {
    /**
     * Filter which caja_sepelio to aggregate.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: Enumerable<caja_sepelioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sepelios
    **/
    _count?: true | Caja_sepelioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_sepelioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_sepelioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_sepelioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_sepelioMaxAggregateInputType
  }

  export type GetCaja_sepelioAggregateType<T extends Caja_sepelioAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sepelio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sepelio[P]>
      : GetScalarType<T[P], AggregateCaja_sepelio[P]>
  }




  export type Caja_sepelioGroupByArgs = {
    where?: caja_sepelioWhereInput
    orderBy?: Enumerable<caja_sepelioOrderByWithAggregationInput>
    by: Caja_sepelioScalarFieldEnum[]
    having?: caja_sepelioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_sepelioCountAggregateInputType | true
    _avg?: Caja_sepelioAvgAggregateInputType
    _sum?: Caja_sepelioSumAggregateInputType
    _min?: Caja_sepelioMinAggregateInputType
    _max?: Caja_sepelioMaxAggregateInputType
  }


  export type Caja_sepelioGroupByOutputType = {
    idcaja: number
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  type GetCaja_sepelioGroupByPayload<T extends Caja_sepelioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Caja_sepelioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_sepelioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
        }
      >
    >


  export type caja_sepelioSelect = {
    idcaja?: boolean
    operador?: boolean
    detalle?: boolean
    monto?: boolean
    estado?: boolean
    fecha?: boolean
    gastos?: boolean
    totalcaja?: boolean
    empresa?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    ptoventa?: boolean
    concepto?: boolean
    cierre?: boolean
    ultimacarga?: boolean
  }


  export type caja_sepelioGetPayload<S extends boolean | null | undefined | caja_sepelioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? caja_sepelio :
    S extends undefined ? never :
    S extends { include: any } & (caja_sepelioArgs | caja_sepelioFindManyArgs)
    ? caja_sepelio 
    : S extends { select: any } & (caja_sepelioArgs | caja_sepelioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof caja_sepelio ? caja_sepelio[P] : never
  } 
      : caja_sepelio


  type caja_sepelioCountArgs = 
    Omit<caja_sepelioFindManyArgs, 'select' | 'include'> & {
      select?: Caja_sepelioCountAggregateInputType | true
    }

  export interface caja_sepelioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Caja_sepelio that matches the filter.
     * @param {caja_sepelioFindUniqueArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_sepelioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_sepelioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>> : Prisma__caja_sepelioClient<caja_sepelioGetPayload<T> | null, null>

    /**
     * Find one Caja_sepelio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_sepelioFindUniqueOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_sepelioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, caja_sepelioFindUniqueOrThrowArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Find the first Caja_sepelio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_sepelioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_sepelioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>> : Prisma__caja_sepelioClient<caja_sepelioGetPayload<T> | null, null>

    /**
     * Find the first Caja_sepelio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_sepelioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, caja_sepelioFindFirstOrThrowArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Find zero or more Caja_sepelios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany()
     * 
     * // Get first 10 Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_sepelioWithIdcajaOnly = await prisma.caja_sepelio.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_sepelioFindManyArgs>(
      args?: SelectSubset<T, caja_sepelioFindManyArgs>
    ): Prisma.PrismaPromise<Array<caja_sepelioGetPayload<T>>>

    /**
     * Create a Caja_sepelio.
     * @param {caja_sepelioCreateArgs} args - Arguments to create a Caja_sepelio.
     * @example
     * // Create one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.create({
     *   data: {
     *     // ... data to create a Caja_sepelio
     *   }
     * })
     * 
    **/
    create<T extends caja_sepelioCreateArgs>(
      args: SelectSubset<T, caja_sepelioCreateArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Create many Caja_sepelios.
     *     @param {caja_sepelioCreateManyArgs} args - Arguments to create many Caja_sepelios.
     *     @example
     *     // Create many Caja_sepelios
     *     const caja_sepelio = await prisma.caja_sepelio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_sepelioCreateManyArgs>(
      args?: SelectSubset<T, caja_sepelioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sepelio.
     * @param {caja_sepelioDeleteArgs} args - Arguments to delete one Caja_sepelio.
     * @example
     * // Delete one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.delete({
     *   where: {
     *     // ... filter to delete one Caja_sepelio
     *   }
     * })
     * 
    **/
    delete<T extends caja_sepelioDeleteArgs>(
      args: SelectSubset<T, caja_sepelioDeleteArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Update one Caja_sepelio.
     * @param {caja_sepelioUpdateArgs} args - Arguments to update one Caja_sepelio.
     * @example
     * // Update one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_sepelioUpdateArgs>(
      args: SelectSubset<T, caja_sepelioUpdateArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Delete zero or more Caja_sepelios.
     * @param {caja_sepelioDeleteManyArgs} args - Arguments to filter Caja_sepelios to delete.
     * @example
     * // Delete a few Caja_sepelios
     * const { count } = await prisma.caja_sepelio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_sepelioDeleteManyArgs>(
      args?: SelectSubset<T, caja_sepelioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sepelios
     * const caja_sepelio = await prisma.caja_sepelio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_sepelioUpdateManyArgs>(
      args: SelectSubset<T, caja_sepelioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sepelio.
     * @param {caja_sepelioUpsertArgs} args - Arguments to update or create a Caja_sepelio.
     * @example
     * // Update or create a Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.upsert({
     *   create: {
     *     // ... data to create a Caja_sepelio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sepelio we want to update
     *   }
     * })
    **/
    upsert<T extends caja_sepelioUpsertArgs>(
      args: SelectSubset<T, caja_sepelioUpsertArgs>
    ): Prisma__caja_sepelioClient<caja_sepelioGetPayload<T>>

    /**
     * Count the number of Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioCountArgs} args - Arguments to filter Caja_sepelios to count.
     * @example
     * // Count the number of Caja_sepelios
     * const count = await prisma.caja_sepelio.count({
     *   where: {
     *     // ... the filter for the Caja_sepelios we want to count
     *   }
     * })
    **/
    count<T extends caja_sepelioCountArgs>(
      args?: Subset<T, caja_sepelioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_sepelioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_sepelioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_sepelioAggregateArgs>(args: Subset<T, Caja_sepelioAggregateArgs>): Prisma.PrismaPromise<GetCaja_sepelioAggregateType<T>>

    /**
     * Group by Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_sepelioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Caja_sepelioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Caja_sepelioGroupByArgs['orderBy'] }
        : { orderBy?: Caja_sepelioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Caja_sepelioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_sepelioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sepelio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_sepelioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sepelio base type for findUnique actions
   */
  export type caja_sepelioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }

  /**
   * caja_sepelio findUnique
   */
  export interface caja_sepelioFindUniqueArgs extends caja_sepelioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findUniqueOrThrow
   */
  export type caja_sepelioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio base type for findFirst actions
   */
  export type caja_sepelioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: Enumerable<caja_sepelioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Enumerable<Caja_sepelioScalarFieldEnum>
  }

  /**
   * caja_sepelio findFirst
   */
  export interface caja_sepelioFindFirstArgs extends caja_sepelioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findFirstOrThrow
   */
  export type caja_sepelioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: Enumerable<caja_sepelioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Enumerable<Caja_sepelioScalarFieldEnum>
  }


  /**
   * caja_sepelio findMany
   */
  export type caja_sepelioFindManyArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter, which caja_sepelios to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: Enumerable<caja_sepelioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    distinct?: Enumerable<Caja_sepelioScalarFieldEnum>
  }


  /**
   * caja_sepelio create
   */
  export type caja_sepelioCreateArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * The data needed to create a caja_sepelio.
     */
    data: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
  }


  /**
   * caja_sepelio createMany
   */
  export type caja_sepelioCreateManyArgs = {
    /**
     * The data used to create many caja_sepelios.
     */
    data: Enumerable<caja_sepelioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * caja_sepelio update
   */
  export type caja_sepelioUpdateArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * The data needed to update a caja_sepelio.
     */
    data: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
    /**
     * Choose, which caja_sepelio to update.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio updateMany
   */
  export type caja_sepelioUpdateManyArgs = {
    /**
     * The data used to update caja_sepelios.
     */
    data: XOR<caja_sepelioUpdateManyMutationInput, caja_sepelioUncheckedUpdateManyInput>
    /**
     * Filter which caja_sepelios to update
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio upsert
   */
  export type caja_sepelioUpsertArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * The filter to search for the caja_sepelio to update in case it exists.
     */
    where: caja_sepelioWhereUniqueInput
    /**
     * In case the caja_sepelio found by the `where` argument doesn't exist, create a new caja_sepelio with this data.
     */
    create: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
    /**
     * In case the caja_sepelio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
  }


  /**
   * caja_sepelio delete
   */
  export type caja_sepelioDeleteArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
    /**
     * Filter which caja_sepelio to delete.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio deleteMany
   */
  export type caja_sepelioDeleteManyArgs = {
    /**
     * Filter which caja_sepelios to delete
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio without action
   */
  export type caja_sepelioArgs = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect | null
  }



  /**
   * Model conceptos
   */


  export type AggregateConceptos = {
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  export type ConceptosAvgAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosSumAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosMinAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosMaxAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosCountAggregateOutputType = {
    idconcepto: number
    concepto: number
    tipo: number
    _all: number
  }


  export type ConceptosAvgAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosSumAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosMinAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosMaxAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosCountAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
    _all?: true
  }

  export type ConceptosAggregateArgs = {
    /**
     * Filter which conceptos to aggregate.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: Enumerable<conceptosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conceptos
    **/
    _count?: true | ConceptosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptosMaxAggregateInputType
  }

  export type GetConceptosAggregateType<T extends ConceptosAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptos[P]>
      : GetScalarType<T[P], AggregateConceptos[P]>
  }




  export type ConceptosGroupByArgs = {
    where?: conceptosWhereInput
    orderBy?: Enumerable<conceptosOrderByWithAggregationInput>
    by: ConceptosScalarFieldEnum[]
    having?: conceptosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptosCountAggregateInputType | true
    _avg?: ConceptosAvgAggregateInputType
    _sum?: ConceptosSumAggregateInputType
    _min?: ConceptosMinAggregateInputType
    _max?: ConceptosMaxAggregateInputType
  }


  export type ConceptosGroupByOutputType = {
    idconcepto: number
    concepto: string | null
    tipo: string | null
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  type GetConceptosGroupByPayload<T extends ConceptosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ConceptosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
        }
      >
    >


  export type conceptosSelect = {
    idconcepto?: boolean
    concepto?: boolean
    tipo?: boolean
  }


  export type conceptosGetPayload<S extends boolean | null | undefined | conceptosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? conceptos :
    S extends undefined ? never :
    S extends { include: any } & (conceptosArgs | conceptosFindManyArgs)
    ? conceptos 
    : S extends { select: any } & (conceptosArgs | conceptosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof conceptos ? conceptos[P] : never
  } 
      : conceptos


  type conceptosCountArgs = 
    Omit<conceptosFindManyArgs, 'select' | 'include'> & {
      select?: ConceptosCountAggregateInputType | true
    }

  export interface conceptosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Conceptos that matches the filter.
     * @param {conceptosFindUniqueArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conceptosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, conceptosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'conceptos'> extends True ? Prisma__conceptosClient<conceptosGetPayload<T>> : Prisma__conceptosClient<conceptosGetPayload<T> | null, null>

    /**
     * Find one Conceptos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conceptosFindUniqueOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conceptosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, conceptosFindUniqueOrThrowArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Find the first Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conceptosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, conceptosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'conceptos'> extends True ? Prisma__conceptosClient<conceptosGetPayload<T>> : Prisma__conceptosClient<conceptosGetPayload<T> | null, null>

    /**
     * Find the first Conceptos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conceptosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, conceptosFindFirstOrThrowArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Find zero or more Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conceptos
     * const conceptos = await prisma.conceptos.findMany()
     * 
     * // Get first 10 Conceptos
     * const conceptos = await prisma.conceptos.findMany({ take: 10 })
     * 
     * // Only select the `idconcepto`
     * const conceptosWithIdconceptoOnly = await prisma.conceptos.findMany({ select: { idconcepto: true } })
     * 
    **/
    findMany<T extends conceptosFindManyArgs>(
      args?: SelectSubset<T, conceptosFindManyArgs>
    ): Prisma.PrismaPromise<Array<conceptosGetPayload<T>>>

    /**
     * Create a Conceptos.
     * @param {conceptosCreateArgs} args - Arguments to create a Conceptos.
     * @example
     * // Create one Conceptos
     * const Conceptos = await prisma.conceptos.create({
     *   data: {
     *     // ... data to create a Conceptos
     *   }
     * })
     * 
    **/
    create<T extends conceptosCreateArgs>(
      args: SelectSubset<T, conceptosCreateArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Create many Conceptos.
     *     @param {conceptosCreateManyArgs} args - Arguments to create many Conceptos.
     *     @example
     *     // Create many Conceptos
     *     const conceptos = await prisma.conceptos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conceptosCreateManyArgs>(
      args?: SelectSubset<T, conceptosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conceptos.
     * @param {conceptosDeleteArgs} args - Arguments to delete one Conceptos.
     * @example
     * // Delete one Conceptos
     * const Conceptos = await prisma.conceptos.delete({
     *   where: {
     *     // ... filter to delete one Conceptos
     *   }
     * })
     * 
    **/
    delete<T extends conceptosDeleteArgs>(
      args: SelectSubset<T, conceptosDeleteArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Update one Conceptos.
     * @param {conceptosUpdateArgs} args - Arguments to update one Conceptos.
     * @example
     * // Update one Conceptos
     * const conceptos = await prisma.conceptos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conceptosUpdateArgs>(
      args: SelectSubset<T, conceptosUpdateArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Delete zero or more Conceptos.
     * @param {conceptosDeleteManyArgs} args - Arguments to filter Conceptos to delete.
     * @example
     * // Delete a few Conceptos
     * const { count } = await prisma.conceptos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conceptosDeleteManyArgs>(
      args?: SelectSubset<T, conceptosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conceptos
     * const conceptos = await prisma.conceptos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conceptosUpdateManyArgs>(
      args: SelectSubset<T, conceptosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conceptos.
     * @param {conceptosUpsertArgs} args - Arguments to update or create a Conceptos.
     * @example
     * // Update or create a Conceptos
     * const conceptos = await prisma.conceptos.upsert({
     *   create: {
     *     // ... data to create a Conceptos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conceptos we want to update
     *   }
     * })
    **/
    upsert<T extends conceptosUpsertArgs>(
      args: SelectSubset<T, conceptosUpsertArgs>
    ): Prisma__conceptosClient<conceptosGetPayload<T>>

    /**
     * Count the number of Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosCountArgs} args - Arguments to filter Conceptos to count.
     * @example
     * // Count the number of Conceptos
     * const count = await prisma.conceptos.count({
     *   where: {
     *     // ... the filter for the Conceptos we want to count
     *   }
     * })
    **/
    count<T extends conceptosCountArgs>(
      args?: Subset<T, conceptosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptosAggregateArgs>(args: Subset<T, ConceptosAggregateArgs>): Prisma.PrismaPromise<GetConceptosAggregateType<T>>

    /**
     * Group by Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptosGroupByArgs['orderBy'] }
        : { orderBy?: ConceptosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for conceptos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__conceptosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * conceptos base type for findUnique actions
   */
  export type conceptosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }

  /**
   * conceptos findUnique
   */
  export interface conceptosFindUniqueArgs extends conceptosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findUniqueOrThrow
   */
  export type conceptosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos base type for findFirst actions
   */
  export type conceptosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: Enumerable<conceptosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: Enumerable<ConceptosScalarFieldEnum>
  }

  /**
   * conceptos findFirst
   */
  export interface conceptosFindFirstArgs extends conceptosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findFirstOrThrow
   */
  export type conceptosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: Enumerable<conceptosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: Enumerable<ConceptosScalarFieldEnum>
  }


  /**
   * conceptos findMany
   */
  export type conceptosFindManyArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: Enumerable<conceptosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    distinct?: Enumerable<ConceptosScalarFieldEnum>
  }


  /**
   * conceptos create
   */
  export type conceptosCreateArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * The data needed to create a conceptos.
     */
    data: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
  }


  /**
   * conceptos createMany
   */
  export type conceptosCreateManyArgs = {
    /**
     * The data used to create many conceptos.
     */
    data: Enumerable<conceptosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * conceptos update
   */
  export type conceptosUpdateArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * The data needed to update a conceptos.
     */
    data: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
    /**
     * Choose, which conceptos to update.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos updateMany
   */
  export type conceptosUpdateManyArgs = {
    /**
     * The data used to update conceptos.
     */
    data: XOR<conceptosUpdateManyMutationInput, conceptosUncheckedUpdateManyInput>
    /**
     * Filter which conceptos to update
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos upsert
   */
  export type conceptosUpsertArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * The filter to search for the conceptos to update in case it exists.
     */
    where: conceptosWhereUniqueInput
    /**
     * In case the conceptos found by the `where` argument doesn't exist, create a new conceptos with this data.
     */
    create: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
    /**
     * In case the conceptos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
  }


  /**
   * conceptos delete
   */
  export type conceptosDeleteArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
    /**
     * Filter which conceptos to delete.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos deleteMany
   */
  export type conceptosDeleteManyArgs = {
    /**
     * Filter which conceptos to delete
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos without action
   */
  export type conceptosArgs = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect | null
  }



  /**
   * Model fabricante_ataud
   */


  export type AggregateFabricante_ataud = {
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  export type Fabricante_ataudAvgAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudSumAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudMinAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudMaxAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudCountAggregateOutputType = {
    idfabricante: number
    fabricante: number
    _all: number
  }


  export type Fabricante_ataudAvgAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudSumAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudMinAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudMaxAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudCountAggregateInputType = {
    idfabricante?: true
    fabricante?: true
    _all?: true
  }

  export type Fabricante_ataudAggregateArgs = {
    /**
     * Filter which fabricante_ataud to aggregate.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: Enumerable<fabricante_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fabricante_atauds
    **/
    _count?: true | Fabricante_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fabricante_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fabricante_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fabricante_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fabricante_ataudMaxAggregateInputType
  }

  export type GetFabricante_ataudAggregateType<T extends Fabricante_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateFabricante_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabricante_ataud[P]>
      : GetScalarType<T[P], AggregateFabricante_ataud[P]>
  }




  export type Fabricante_ataudGroupByArgs = {
    where?: fabricante_ataudWhereInput
    orderBy?: Enumerable<fabricante_ataudOrderByWithAggregationInput>
    by: Fabricante_ataudScalarFieldEnum[]
    having?: fabricante_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fabricante_ataudCountAggregateInputType | true
    _avg?: Fabricante_ataudAvgAggregateInputType
    _sum?: Fabricante_ataudSumAggregateInputType
    _min?: Fabricante_ataudMinAggregateInputType
    _max?: Fabricante_ataudMaxAggregateInputType
  }


  export type Fabricante_ataudGroupByOutputType = {
    idfabricante: number
    fabricante: string | null
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  type GetFabricante_ataudGroupByPayload<T extends Fabricante_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Fabricante_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fabricante_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
        }
      >
    >


  export type fabricante_ataudSelect = {
    idfabricante?: boolean
    fabricante?: boolean
  }


  export type fabricante_ataudGetPayload<S extends boolean | null | undefined | fabricante_ataudArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fabricante_ataud :
    S extends undefined ? never :
    S extends { include: any } & (fabricante_ataudArgs | fabricante_ataudFindManyArgs)
    ? fabricante_ataud 
    : S extends { select: any } & (fabricante_ataudArgs | fabricante_ataudFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof fabricante_ataud ? fabricante_ataud[P] : never
  } 
      : fabricante_ataud


  type fabricante_ataudCountArgs = 
    Omit<fabricante_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Fabricante_ataudCountAggregateInputType | true
    }

  export interface fabricante_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fabricante_ataud that matches the filter.
     * @param {fabricante_ataudFindUniqueArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fabricante_ataudFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fabricante_ataudFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>> : Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T> | null, null>

    /**
     * Find one Fabricante_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fabricante_ataudFindUniqueOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fabricante_ataudFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fabricante_ataudFindUniqueOrThrowArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Find the first Fabricante_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fabricante_ataudFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fabricante_ataudFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>> : Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T> | null, null>

    /**
     * Find the first Fabricante_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fabricante_ataudFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fabricante_ataudFindFirstOrThrowArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Find zero or more Fabricante_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
     * 
     * // Get first 10 Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idfabricante`
     * const fabricante_ataudWithIdfabricanteOnly = await prisma.fabricante_ataud.findMany({ select: { idfabricante: true } })
     * 
    **/
    findMany<T extends fabricante_ataudFindManyArgs>(
      args?: SelectSubset<T, fabricante_ataudFindManyArgs>
    ): Prisma.PrismaPromise<Array<fabricante_ataudGetPayload<T>>>

    /**
     * Create a Fabricante_ataud.
     * @param {fabricante_ataudCreateArgs} args - Arguments to create a Fabricante_ataud.
     * @example
     * // Create one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.create({
     *   data: {
     *     // ... data to create a Fabricante_ataud
     *   }
     * })
     * 
    **/
    create<T extends fabricante_ataudCreateArgs>(
      args: SelectSubset<T, fabricante_ataudCreateArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Create many Fabricante_atauds.
     *     @param {fabricante_ataudCreateManyArgs} args - Arguments to create many Fabricante_atauds.
     *     @example
     *     // Create many Fabricante_atauds
     *     const fabricante_ataud = await prisma.fabricante_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fabricante_ataudCreateManyArgs>(
      args?: SelectSubset<T, fabricante_ataudCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fabricante_ataud.
     * @param {fabricante_ataudDeleteArgs} args - Arguments to delete one Fabricante_ataud.
     * @example
     * // Delete one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.delete({
     *   where: {
     *     // ... filter to delete one Fabricante_ataud
     *   }
     * })
     * 
    **/
    delete<T extends fabricante_ataudDeleteArgs>(
      args: SelectSubset<T, fabricante_ataudDeleteArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Update one Fabricante_ataud.
     * @param {fabricante_ataudUpdateArgs} args - Arguments to update one Fabricante_ataud.
     * @example
     * // Update one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fabricante_ataudUpdateArgs>(
      args: SelectSubset<T, fabricante_ataudUpdateArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Delete zero or more Fabricante_atauds.
     * @param {fabricante_ataudDeleteManyArgs} args - Arguments to filter Fabricante_atauds to delete.
     * @example
     * // Delete a few Fabricante_atauds
     * const { count } = await prisma.fabricante_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fabricante_ataudDeleteManyArgs>(
      args?: SelectSubset<T, fabricante_ataudDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fabricante_atauds
     * const fabricante_ataud = await prisma.fabricante_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fabricante_ataudUpdateManyArgs>(
      args: SelectSubset<T, fabricante_ataudUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fabricante_ataud.
     * @param {fabricante_ataudUpsertArgs} args - Arguments to update or create a Fabricante_ataud.
     * @example
     * // Update or create a Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.upsert({
     *   create: {
     *     // ... data to create a Fabricante_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fabricante_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends fabricante_ataudUpsertArgs>(
      args: SelectSubset<T, fabricante_ataudUpsertArgs>
    ): Prisma__fabricante_ataudClient<fabricante_ataudGetPayload<T>>

    /**
     * Count the number of Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudCountArgs} args - Arguments to filter Fabricante_atauds to count.
     * @example
     * // Count the number of Fabricante_atauds
     * const count = await prisma.fabricante_ataud.count({
     *   where: {
     *     // ... the filter for the Fabricante_atauds we want to count
     *   }
     * })
    **/
    count<T extends fabricante_ataudCountArgs>(
      args?: Subset<T, fabricante_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fabricante_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fabricante_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fabricante_ataudAggregateArgs>(args: Subset<T, Fabricante_ataudAggregateArgs>): Prisma.PrismaPromise<GetFabricante_ataudAggregateType<T>>

    /**
     * Group by Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fabricante_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fabricante_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fabricante_ataudGroupByArgs['orderBy'] }
        : { orderBy?: Fabricante_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fabricante_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricante_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fabricante_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fabricante_ataudClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fabricante_ataud base type for findUnique actions
   */
  export type fabricante_ataudFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }

  /**
   * fabricante_ataud findUnique
   */
  export interface fabricante_ataudFindUniqueArgs extends fabricante_ataudFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findUniqueOrThrow
   */
  export type fabricante_ataudFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud base type for findFirst actions
   */
  export type fabricante_ataudFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: Enumerable<fabricante_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Enumerable<Fabricante_ataudScalarFieldEnum>
  }

  /**
   * fabricante_ataud findFirst
   */
  export interface fabricante_ataudFindFirstArgs extends fabricante_ataudFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findFirstOrThrow
   */
  export type fabricante_ataudFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: Enumerable<fabricante_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Enumerable<Fabricante_ataudScalarFieldEnum>
  }


  /**
   * fabricante_ataud findMany
   */
  export type fabricante_ataudFindManyArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter, which fabricante_atauds to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: Enumerable<fabricante_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    distinct?: Enumerable<Fabricante_ataudScalarFieldEnum>
  }


  /**
   * fabricante_ataud create
   */
  export type fabricante_ataudCreateArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * The data needed to create a fabricante_ataud.
     */
    data: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
  }


  /**
   * fabricante_ataud createMany
   */
  export type fabricante_ataudCreateManyArgs = {
    /**
     * The data used to create many fabricante_atauds.
     */
    data: Enumerable<fabricante_ataudCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fabricante_ataud update
   */
  export type fabricante_ataudUpdateArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * The data needed to update a fabricante_ataud.
     */
    data: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
    /**
     * Choose, which fabricante_ataud to update.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud updateMany
   */
  export type fabricante_ataudUpdateManyArgs = {
    /**
     * The data used to update fabricante_atauds.
     */
    data: XOR<fabricante_ataudUpdateManyMutationInput, fabricante_ataudUncheckedUpdateManyInput>
    /**
     * Filter which fabricante_atauds to update
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud upsert
   */
  export type fabricante_ataudUpsertArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * The filter to search for the fabricante_ataud to update in case it exists.
     */
    where: fabricante_ataudWhereUniqueInput
    /**
     * In case the fabricante_ataud found by the `where` argument doesn't exist, create a new fabricante_ataud with this data.
     */
    create: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
    /**
     * In case the fabricante_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
  }


  /**
   * fabricante_ataud delete
   */
  export type fabricante_ataudDeleteArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
    /**
     * Filter which fabricante_ataud to delete.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud deleteMany
   */
  export type fabricante_ataudDeleteManyArgs = {
    /**
     * Filter which fabricante_atauds to delete
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud without action
   */
  export type fabricante_ataudArgs = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect | null
  }



  /**
   * Model gasto_luto
   */


  export type AggregateGasto_luto = {
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  export type Gasto_lutoAvgAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoSumAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoMinAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoMaxAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoCountAggregateOutputType = {
    idgastoluto: number
    idservicio: number
    contrato: number
    dni_extinto: number
    extinto: number
    gasto_luto: number
    idataud: number
    apellido_ben: number
    nombre_ben: number
    telefono_ben: number
    fecha: number
    operador: number
    parentezco: number
    _all: number
  }


  export type Gasto_lutoAvgAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoSumAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoMinAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoMaxAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoCountAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
    _all?: true
  }

  export type Gasto_lutoAggregateArgs = {
    /**
     * Filter which gasto_luto to aggregate.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: Enumerable<gasto_lutoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gasto_lutos
    **/
    _count?: true | Gasto_lutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gasto_lutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gasto_lutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gasto_lutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gasto_lutoMaxAggregateInputType
  }

  export type GetGasto_lutoAggregateType<T extends Gasto_lutoAggregateArgs> = {
        [P in keyof T & keyof AggregateGasto_luto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGasto_luto[P]>
      : GetScalarType<T[P], AggregateGasto_luto[P]>
  }




  export type Gasto_lutoGroupByArgs = {
    where?: gasto_lutoWhereInput
    orderBy?: Enumerable<gasto_lutoOrderByWithAggregationInput>
    by: Gasto_lutoScalarFieldEnum[]
    having?: gasto_lutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gasto_lutoCountAggregateInputType | true
    _avg?: Gasto_lutoAvgAggregateInputType
    _sum?: Gasto_lutoSumAggregateInputType
    _min?: Gasto_lutoMinAggregateInputType
    _max?: Gasto_lutoMaxAggregateInputType
  }


  export type Gasto_lutoGroupByOutputType = {
    idgastoluto: number
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  type GetGasto_lutoGroupByPayload<T extends Gasto_lutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Gasto_lutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gasto_lutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
            : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
        }
      >
    >


  export type gasto_lutoSelect = {
    idgastoluto?: boolean
    idservicio?: boolean
    contrato?: boolean
    dni_extinto?: boolean
    extinto?: boolean
    gasto_luto?: boolean
    idataud?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    telefono_ben?: boolean
    fecha?: boolean
    operador?: boolean
    parentezco?: boolean
  }


  export type gasto_lutoGetPayload<S extends boolean | null | undefined | gasto_lutoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gasto_luto :
    S extends undefined ? never :
    S extends { include: any } & (gasto_lutoArgs | gasto_lutoFindManyArgs)
    ? gasto_luto 
    : S extends { select: any } & (gasto_lutoArgs | gasto_lutoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof gasto_luto ? gasto_luto[P] : never
  } 
      : gasto_luto


  type gasto_lutoCountArgs = 
    Omit<gasto_lutoFindManyArgs, 'select' | 'include'> & {
      select?: Gasto_lutoCountAggregateInputType | true
    }

  export interface gasto_lutoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gasto_luto that matches the filter.
     * @param {gasto_lutoFindUniqueArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gasto_lutoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gasto_lutoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>> : Prisma__gasto_lutoClient<gasto_lutoGetPayload<T> | null, null>

    /**
     * Find one Gasto_luto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gasto_lutoFindUniqueOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gasto_lutoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, gasto_lutoFindUniqueOrThrowArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Find the first Gasto_luto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gasto_lutoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gasto_lutoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>> : Prisma__gasto_lutoClient<gasto_lutoGetPayload<T> | null, null>

    /**
     * Find the first Gasto_luto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gasto_lutoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, gasto_lutoFindFirstOrThrowArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Find zero or more Gasto_lutos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany()
     * 
     * // Get first 10 Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany({ take: 10 })
     * 
     * // Only select the `idgastoluto`
     * const gasto_lutoWithIdgastolutoOnly = await prisma.gasto_luto.findMany({ select: { idgastoluto: true } })
     * 
    **/
    findMany<T extends gasto_lutoFindManyArgs>(
      args?: SelectSubset<T, gasto_lutoFindManyArgs>
    ): Prisma.PrismaPromise<Array<gasto_lutoGetPayload<T>>>

    /**
     * Create a Gasto_luto.
     * @param {gasto_lutoCreateArgs} args - Arguments to create a Gasto_luto.
     * @example
     * // Create one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.create({
     *   data: {
     *     // ... data to create a Gasto_luto
     *   }
     * })
     * 
    **/
    create<T extends gasto_lutoCreateArgs>(
      args: SelectSubset<T, gasto_lutoCreateArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Create many Gasto_lutos.
     *     @param {gasto_lutoCreateManyArgs} args - Arguments to create many Gasto_lutos.
     *     @example
     *     // Create many Gasto_lutos
     *     const gasto_luto = await prisma.gasto_luto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gasto_lutoCreateManyArgs>(
      args?: SelectSubset<T, gasto_lutoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gasto_luto.
     * @param {gasto_lutoDeleteArgs} args - Arguments to delete one Gasto_luto.
     * @example
     * // Delete one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.delete({
     *   where: {
     *     // ... filter to delete one Gasto_luto
     *   }
     * })
     * 
    **/
    delete<T extends gasto_lutoDeleteArgs>(
      args: SelectSubset<T, gasto_lutoDeleteArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Update one Gasto_luto.
     * @param {gasto_lutoUpdateArgs} args - Arguments to update one Gasto_luto.
     * @example
     * // Update one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gasto_lutoUpdateArgs>(
      args: SelectSubset<T, gasto_lutoUpdateArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Delete zero or more Gasto_lutos.
     * @param {gasto_lutoDeleteManyArgs} args - Arguments to filter Gasto_lutos to delete.
     * @example
     * // Delete a few Gasto_lutos
     * const { count } = await prisma.gasto_luto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gasto_lutoDeleteManyArgs>(
      args?: SelectSubset<T, gasto_lutoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gasto_lutos
     * const gasto_luto = await prisma.gasto_luto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gasto_lutoUpdateManyArgs>(
      args: SelectSubset<T, gasto_lutoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gasto_luto.
     * @param {gasto_lutoUpsertArgs} args - Arguments to update or create a Gasto_luto.
     * @example
     * // Update or create a Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.upsert({
     *   create: {
     *     // ... data to create a Gasto_luto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gasto_luto we want to update
     *   }
     * })
    **/
    upsert<T extends gasto_lutoUpsertArgs>(
      args: SelectSubset<T, gasto_lutoUpsertArgs>
    ): Prisma__gasto_lutoClient<gasto_lutoGetPayload<T>>

    /**
     * Count the number of Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoCountArgs} args - Arguments to filter Gasto_lutos to count.
     * @example
     * // Count the number of Gasto_lutos
     * const count = await prisma.gasto_luto.count({
     *   where: {
     *     // ... the filter for the Gasto_lutos we want to count
     *   }
     * })
    **/
    count<T extends gasto_lutoCountArgs>(
      args?: Subset<T, gasto_lutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gasto_lutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gasto_lutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gasto_lutoAggregateArgs>(args: Subset<T, Gasto_lutoAggregateArgs>): Prisma.PrismaPromise<GetGasto_lutoAggregateType<T>>

    /**
     * Group by Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gasto_lutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gasto_lutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gasto_lutoGroupByArgs['orderBy'] }
        : { orderBy?: Gasto_lutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gasto_lutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGasto_lutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gasto_luto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gasto_lutoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gasto_luto base type for findUnique actions
   */
  export type gasto_lutoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }

  /**
   * gasto_luto findUnique
   */
  export interface gasto_lutoFindUniqueArgs extends gasto_lutoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findUniqueOrThrow
   */
  export type gasto_lutoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto base type for findFirst actions
   */
  export type gasto_lutoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: Enumerable<gasto_lutoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Enumerable<Gasto_lutoScalarFieldEnum>
  }

  /**
   * gasto_luto findFirst
   */
  export interface gasto_lutoFindFirstArgs extends gasto_lutoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findFirstOrThrow
   */
  export type gasto_lutoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: Enumerable<gasto_lutoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Enumerable<Gasto_lutoScalarFieldEnum>
  }


  /**
   * gasto_luto findMany
   */
  export type gasto_lutoFindManyArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter, which gasto_lutos to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: Enumerable<gasto_lutoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    distinct?: Enumerable<Gasto_lutoScalarFieldEnum>
  }


  /**
   * gasto_luto create
   */
  export type gasto_lutoCreateArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * The data needed to create a gasto_luto.
     */
    data: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
  }


  /**
   * gasto_luto createMany
   */
  export type gasto_lutoCreateManyArgs = {
    /**
     * The data used to create many gasto_lutos.
     */
    data: Enumerable<gasto_lutoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gasto_luto update
   */
  export type gasto_lutoUpdateArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * The data needed to update a gasto_luto.
     */
    data: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
    /**
     * Choose, which gasto_luto to update.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto updateMany
   */
  export type gasto_lutoUpdateManyArgs = {
    /**
     * The data used to update gasto_lutos.
     */
    data: XOR<gasto_lutoUpdateManyMutationInput, gasto_lutoUncheckedUpdateManyInput>
    /**
     * Filter which gasto_lutos to update
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto upsert
   */
  export type gasto_lutoUpsertArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * The filter to search for the gasto_luto to update in case it exists.
     */
    where: gasto_lutoWhereUniqueInput
    /**
     * In case the gasto_luto found by the `where` argument doesn't exist, create a new gasto_luto with this data.
     */
    create: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
    /**
     * In case the gasto_luto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
  }


  /**
   * gasto_luto delete
   */
  export type gasto_lutoDeleteArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
    /**
     * Filter which gasto_luto to delete.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto deleteMany
   */
  export type gasto_lutoDeleteManyArgs = {
    /**
     * Filter which gasto_lutos to delete
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto without action
   */
  export type gasto_lutoArgs = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect | null
  }



  /**
   * Model gastos_caja
   */


  export type AggregateGastos_caja = {
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  export type Gastos_cajaAvgAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaSumAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMinAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMaxAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaCountAggregateOutputType = {
    idgastos: number
    idcaja: number
    concepto: number
    tipofactura: number
    nfactura: number
    fecha: number
    operadorgestion: number
    operadortramite: number
    ptoventa: number
    porciva: number
    montoiva: number
    retiibb: number
    retggcias: number
    perciva: number
    detalle: number
    mediopago: number
    proveedor: number
    empresa: number
    total: number
    idservicio: number
    _all: number
  }


  export type Gastos_cajaAvgAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaSumAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMinAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMaxAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaCountAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
    _all?: true
  }

  export type Gastos_cajaAggregateArgs = {
    /**
     * Filter which gastos_caja to aggregate.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: Enumerable<gastos_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastos_cajas
    **/
    _count?: true | Gastos_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gastos_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gastos_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gastos_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gastos_cajaMaxAggregateInputType
  }

  export type GetGastos_cajaAggregateType<T extends Gastos_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateGastos_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastos_caja[P]>
      : GetScalarType<T[P], AggregateGastos_caja[P]>
  }




  export type Gastos_cajaGroupByArgs = {
    where?: gastos_cajaWhereInput
    orderBy?: Enumerable<gastos_cajaOrderByWithAggregationInput>
    by: Gastos_cajaScalarFieldEnum[]
    having?: gastos_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gastos_cajaCountAggregateInputType | true
    _avg?: Gastos_cajaAvgAggregateInputType
    _sum?: Gastos_cajaSumAggregateInputType
    _min?: Gastos_cajaMinAggregateInputType
    _max?: Gastos_cajaMaxAggregateInputType
  }


  export type Gastos_cajaGroupByOutputType = {
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  type GetGastos_cajaGroupByPayload<T extends Gastos_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Gastos_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gastos_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
        }
      >
    >


  export type gastos_cajaSelect = {
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }


  export type gastos_cajaGetPayload<S extends boolean | null | undefined | gastos_cajaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gastos_caja :
    S extends undefined ? never :
    S extends { include: any } & (gastos_cajaArgs | gastos_cajaFindManyArgs)
    ? gastos_caja 
    : S extends { select: any } & (gastos_cajaArgs | gastos_cajaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof gastos_caja ? gastos_caja[P] : never
  } 
      : gastos_caja


  type gastos_cajaCountArgs = 
    Omit<gastos_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Gastos_cajaCountAggregateInputType | true
    }

  export interface gastos_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gastos_caja that matches the filter.
     * @param {gastos_cajaFindUniqueArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastos_cajaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastos_cajaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>> : Prisma__gastos_cajaClient<gastos_cajaGetPayload<T> | null, null>

    /**
     * Find one Gastos_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gastos_cajaFindUniqueOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gastos_cajaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, gastos_cajaFindUniqueOrThrowArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Find the first Gastos_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastos_cajaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastos_cajaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>> : Prisma__gastos_cajaClient<gastos_cajaGetPayload<T> | null, null>

    /**
     * Find the first Gastos_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gastos_cajaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, gastos_cajaFindFirstOrThrowArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Find zero or more Gastos_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany()
     * 
     * // Get first 10 Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const gastos_cajaWithIdgastosOnly = await prisma.gastos_caja.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends gastos_cajaFindManyArgs>(
      args?: SelectSubset<T, gastos_cajaFindManyArgs>
    ): Prisma.PrismaPromise<Array<gastos_cajaGetPayload<T>>>

    /**
     * Create a Gastos_caja.
     * @param {gastos_cajaCreateArgs} args - Arguments to create a Gastos_caja.
     * @example
     * // Create one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.create({
     *   data: {
     *     // ... data to create a Gastos_caja
     *   }
     * })
     * 
    **/
    create<T extends gastos_cajaCreateArgs>(
      args: SelectSubset<T, gastos_cajaCreateArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Create many Gastos_cajas.
     *     @param {gastos_cajaCreateManyArgs} args - Arguments to create many Gastos_cajas.
     *     @example
     *     // Create many Gastos_cajas
     *     const gastos_caja = await prisma.gastos_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastos_cajaCreateManyArgs>(
      args?: SelectSubset<T, gastos_cajaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gastos_caja.
     * @param {gastos_cajaDeleteArgs} args - Arguments to delete one Gastos_caja.
     * @example
     * // Delete one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.delete({
     *   where: {
     *     // ... filter to delete one Gastos_caja
     *   }
     * })
     * 
    **/
    delete<T extends gastos_cajaDeleteArgs>(
      args: SelectSubset<T, gastos_cajaDeleteArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Update one Gastos_caja.
     * @param {gastos_cajaUpdateArgs} args - Arguments to update one Gastos_caja.
     * @example
     * // Update one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastos_cajaUpdateArgs>(
      args: SelectSubset<T, gastos_cajaUpdateArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Delete zero or more Gastos_cajas.
     * @param {gastos_cajaDeleteManyArgs} args - Arguments to filter Gastos_cajas to delete.
     * @example
     * // Delete a few Gastos_cajas
     * const { count } = await prisma.gastos_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastos_cajaDeleteManyArgs>(
      args?: SelectSubset<T, gastos_cajaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastos_cajas
     * const gastos_caja = await prisma.gastos_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastos_cajaUpdateManyArgs>(
      args: SelectSubset<T, gastos_cajaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastos_caja.
     * @param {gastos_cajaUpsertArgs} args - Arguments to update or create a Gastos_caja.
     * @example
     * // Update or create a Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.upsert({
     *   create: {
     *     // ... data to create a Gastos_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastos_caja we want to update
     *   }
     * })
    **/
    upsert<T extends gastos_cajaUpsertArgs>(
      args: SelectSubset<T, gastos_cajaUpsertArgs>
    ): Prisma__gastos_cajaClient<gastos_cajaGetPayload<T>>

    /**
     * Count the number of Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaCountArgs} args - Arguments to filter Gastos_cajas to count.
     * @example
     * // Count the number of Gastos_cajas
     * const count = await prisma.gastos_caja.count({
     *   where: {
     *     // ... the filter for the Gastos_cajas we want to count
     *   }
     * })
    **/
    count<T extends gastos_cajaCountArgs>(
      args?: Subset<T, gastos_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gastos_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gastos_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gastos_cajaAggregateArgs>(args: Subset<T, Gastos_cajaAggregateArgs>): Prisma.PrismaPromise<GetGastos_cajaAggregateType<T>>

    /**
     * Group by Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gastos_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gastos_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gastos_cajaGroupByArgs['orderBy'] }
        : { orderBy?: Gastos_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gastos_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastos_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gastos_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastos_cajaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gastos_caja base type for findUnique actions
   */
  export type gastos_cajaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }

  /**
   * gastos_caja findUnique
   */
  export interface gastos_cajaFindUniqueArgs extends gastos_cajaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findUniqueOrThrow
   */
  export type gastos_cajaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja base type for findFirst actions
   */
  export type gastos_cajaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: Enumerable<gastos_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Enumerable<Gastos_cajaScalarFieldEnum>
  }

  /**
   * gastos_caja findFirst
   */
  export interface gastos_cajaFindFirstArgs extends gastos_cajaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findFirstOrThrow
   */
  export type gastos_cajaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: Enumerable<gastos_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Enumerable<Gastos_cajaScalarFieldEnum>
  }


  /**
   * gastos_caja findMany
   */
  export type gastos_cajaFindManyArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter, which gastos_cajas to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: Enumerable<gastos_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    distinct?: Enumerable<Gastos_cajaScalarFieldEnum>
  }


  /**
   * gastos_caja create
   */
  export type gastos_cajaCreateArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * The data needed to create a gastos_caja.
     */
    data: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
  }


  /**
   * gastos_caja createMany
   */
  export type gastos_cajaCreateManyArgs = {
    /**
     * The data used to create many gastos_cajas.
     */
    data: Enumerable<gastos_cajaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gastos_caja update
   */
  export type gastos_cajaUpdateArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * The data needed to update a gastos_caja.
     */
    data: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
    /**
     * Choose, which gastos_caja to update.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja updateMany
   */
  export type gastos_cajaUpdateManyArgs = {
    /**
     * The data used to update gastos_cajas.
     */
    data: XOR<gastos_cajaUpdateManyMutationInput, gastos_cajaUncheckedUpdateManyInput>
    /**
     * Filter which gastos_cajas to update
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja upsert
   */
  export type gastos_cajaUpsertArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * The filter to search for the gastos_caja to update in case it exists.
     */
    where: gastos_cajaWhereUniqueInput
    /**
     * In case the gastos_caja found by the `where` argument doesn't exist, create a new gastos_caja with this data.
     */
    create: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
    /**
     * In case the gastos_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
  }


  /**
   * gastos_caja delete
   */
  export type gastos_cajaDeleteArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
    /**
     * Filter which gastos_caja to delete.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja deleteMany
   */
  export type gastos_cajaDeleteManyArgs = {
    /**
     * Filter which gastos_cajas to delete
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja without action
   */
  export type gastos_cajaArgs = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect | null
  }



  /**
   * Model historial_autos
   */


  export type AggregateHistorial_autos = {
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  export type Historial_autosAvgAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosSumAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosMinAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosMaxAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosCountAggregateOutputType = {
    idhistorial: number
    patente: number
    idauto: number
    operador: number
    fecha: number
    accion: number
    _all: number
  }


  export type Historial_autosAvgAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosSumAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosMinAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosMaxAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosCountAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
    _all?: true
  }

  export type Historial_autosAggregateArgs = {
    /**
     * Filter which historial_autos to aggregate.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: Enumerable<historial_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_autos
    **/
    _count?: true | Historial_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_autosMaxAggregateInputType
  }

  export type GetHistorial_autosAggregateType<T extends Historial_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_autos[P]>
      : GetScalarType<T[P], AggregateHistorial_autos[P]>
  }




  export type Historial_autosGroupByArgs = {
    where?: historial_autosWhereInput
    orderBy?: Enumerable<historial_autosOrderByWithAggregationInput>
    by: Historial_autosScalarFieldEnum[]
    having?: historial_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_autosCountAggregateInputType | true
    _avg?: Historial_autosAvgAggregateInputType
    _sum?: Historial_autosSumAggregateInputType
    _min?: Historial_autosMinAggregateInputType
    _max?: Historial_autosMaxAggregateInputType
  }


  export type Historial_autosGroupByOutputType = {
    idhistorial: number
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  type GetHistorial_autosGroupByPayload<T extends Historial_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Historial_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
        }
      >
    >


  export type historial_autosSelect = {
    idhistorial?: boolean
    patente?: boolean
    idauto?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }


  export type historial_autosGetPayload<S extends boolean | null | undefined | historial_autosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? historial_autos :
    S extends undefined ? never :
    S extends { include: any } & (historial_autosArgs | historial_autosFindManyArgs)
    ? historial_autos 
    : S extends { select: any } & (historial_autosArgs | historial_autosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof historial_autos ? historial_autos[P] : never
  } 
      : historial_autos


  type historial_autosCountArgs = 
    Omit<historial_autosFindManyArgs, 'select' | 'include'> & {
      select?: Historial_autosCountAggregateInputType | true
    }

  export interface historial_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Historial_autos that matches the filter.
     * @param {historial_autosFindUniqueArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_autosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_autosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_autos'> extends True ? Prisma__historial_autosClient<historial_autosGetPayload<T>> : Prisma__historial_autosClient<historial_autosGetPayload<T> | null, null>

    /**
     * Find one Historial_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_autosFindUniqueOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_autosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, historial_autosFindUniqueOrThrowArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Find the first Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_autosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_autosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_autos'> extends True ? Prisma__historial_autosClient<historial_autosGetPayload<T>> : Prisma__historial_autosClient<historial_autosGetPayload<T> | null, null>

    /**
     * Find the first Historial_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_autosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, historial_autosFindFirstOrThrowArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Find zero or more Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany()
     * 
     * // Get first 10 Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_autosWithIdhistorialOnly = await prisma.historial_autos.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_autosFindManyArgs>(
      args?: SelectSubset<T, historial_autosFindManyArgs>
    ): Prisma.PrismaPromise<Array<historial_autosGetPayload<T>>>

    /**
     * Create a Historial_autos.
     * @param {historial_autosCreateArgs} args - Arguments to create a Historial_autos.
     * @example
     * // Create one Historial_autos
     * const Historial_autos = await prisma.historial_autos.create({
     *   data: {
     *     // ... data to create a Historial_autos
     *   }
     * })
     * 
    **/
    create<T extends historial_autosCreateArgs>(
      args: SelectSubset<T, historial_autosCreateArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Create many Historial_autos.
     *     @param {historial_autosCreateManyArgs} args - Arguments to create many Historial_autos.
     *     @example
     *     // Create many Historial_autos
     *     const historial_autos = await prisma.historial_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_autosCreateManyArgs>(
      args?: SelectSubset<T, historial_autosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_autos.
     * @param {historial_autosDeleteArgs} args - Arguments to delete one Historial_autos.
     * @example
     * // Delete one Historial_autos
     * const Historial_autos = await prisma.historial_autos.delete({
     *   where: {
     *     // ... filter to delete one Historial_autos
     *   }
     * })
     * 
    **/
    delete<T extends historial_autosDeleteArgs>(
      args: SelectSubset<T, historial_autosDeleteArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Update one Historial_autos.
     * @param {historial_autosUpdateArgs} args - Arguments to update one Historial_autos.
     * @example
     * // Update one Historial_autos
     * const historial_autos = await prisma.historial_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_autosUpdateArgs>(
      args: SelectSubset<T, historial_autosUpdateArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Delete zero or more Historial_autos.
     * @param {historial_autosDeleteManyArgs} args - Arguments to filter Historial_autos to delete.
     * @example
     * // Delete a few Historial_autos
     * const { count } = await prisma.historial_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_autosDeleteManyArgs>(
      args?: SelectSubset<T, historial_autosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_autos
     * const historial_autos = await prisma.historial_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_autosUpdateManyArgs>(
      args: SelectSubset<T, historial_autosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_autos.
     * @param {historial_autosUpsertArgs} args - Arguments to update or create a Historial_autos.
     * @example
     * // Update or create a Historial_autos
     * const historial_autos = await prisma.historial_autos.upsert({
     *   create: {
     *     // ... data to create a Historial_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_autos we want to update
     *   }
     * })
    **/
    upsert<T extends historial_autosUpsertArgs>(
      args: SelectSubset<T, historial_autosUpsertArgs>
    ): Prisma__historial_autosClient<historial_autosGetPayload<T>>

    /**
     * Count the number of Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosCountArgs} args - Arguments to filter Historial_autos to count.
     * @example
     * // Count the number of Historial_autos
     * const count = await prisma.historial_autos.count({
     *   where: {
     *     // ... the filter for the Historial_autos we want to count
     *   }
     * })
    **/
    count<T extends historial_autosCountArgs>(
      args?: Subset<T, historial_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_autosAggregateArgs>(args: Subset<T, Historial_autosAggregateArgs>): Prisma.PrismaPromise<GetHistorial_autosAggregateType<T>>

    /**
     * Group by Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Historial_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Historial_autosGroupByArgs['orderBy'] }
        : { orderBy?: Historial_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Historial_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_autosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_autos base type for findUnique actions
   */
  export type historial_autosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }

  /**
   * historial_autos findUnique
   */
  export interface historial_autosFindUniqueArgs extends historial_autosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findUniqueOrThrow
   */
  export type historial_autosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos base type for findFirst actions
   */
  export type historial_autosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: Enumerable<historial_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Enumerable<Historial_autosScalarFieldEnum>
  }

  /**
   * historial_autos findFirst
   */
  export interface historial_autosFindFirstArgs extends historial_autosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findFirstOrThrow
   */
  export type historial_autosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: Enumerable<historial_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Enumerable<Historial_autosScalarFieldEnum>
  }


  /**
   * historial_autos findMany
   */
  export type historial_autosFindManyArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: Enumerable<historial_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    distinct?: Enumerable<Historial_autosScalarFieldEnum>
  }


  /**
   * historial_autos create
   */
  export type historial_autosCreateArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * The data needed to create a historial_autos.
     */
    data: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
  }


  /**
   * historial_autos createMany
   */
  export type historial_autosCreateManyArgs = {
    /**
     * The data used to create many historial_autos.
     */
    data: Enumerable<historial_autosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * historial_autos update
   */
  export type historial_autosUpdateArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * The data needed to update a historial_autos.
     */
    data: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
    /**
     * Choose, which historial_autos to update.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos updateMany
   */
  export type historial_autosUpdateManyArgs = {
    /**
     * The data used to update historial_autos.
     */
    data: XOR<historial_autosUpdateManyMutationInput, historial_autosUncheckedUpdateManyInput>
    /**
     * Filter which historial_autos to update
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos upsert
   */
  export type historial_autosUpsertArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * The filter to search for the historial_autos to update in case it exists.
     */
    where: historial_autosWhereUniqueInput
    /**
     * In case the historial_autos found by the `where` argument doesn't exist, create a new historial_autos with this data.
     */
    create: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
    /**
     * In case the historial_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
  }


  /**
   * historial_autos delete
   */
  export type historial_autosDeleteArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
    /**
     * Filter which historial_autos to delete.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos deleteMany
   */
  export type historial_autosDeleteManyArgs = {
    /**
     * Filter which historial_autos to delete
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos without action
   */
  export type historial_autosArgs = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect | null
  }



  /**
   * Model historial_stock_ataud
   */


  export type AggregateHistorial_stock_ataud = {
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  export type Historial_stock_ataudAvgAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudSumAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudMinAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudMaxAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudCountAggregateOutputType = {
    idhistorial: number
    idataud: number
    fecha_carga: number
    stock_anterior: number
    stock_nuevo: number
    remito: number
    operador: number
    fecha_recepcion: number
    _all: number
  }


  export type Historial_stock_ataudAvgAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudSumAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudMinAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudMaxAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudCountAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
    _all?: true
  }

  export type Historial_stock_ataudAggregateArgs = {
    /**
     * Filter which historial_stock_ataud to aggregate.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: Enumerable<historial_stock_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_stock_atauds
    **/
    _count?: true | Historial_stock_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_stock_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_stock_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_stock_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_stock_ataudMaxAggregateInputType
  }

  export type GetHistorial_stock_ataudAggregateType<T extends Historial_stock_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_stock_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
      : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
  }




  export type Historial_stock_ataudGroupByArgs = {
    where?: historial_stock_ataudWhereInput
    orderBy?: Enumerable<historial_stock_ataudOrderByWithAggregationInput>
    by: Historial_stock_ataudScalarFieldEnum[]
    having?: historial_stock_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_stock_ataudCountAggregateInputType | true
    _avg?: Historial_stock_ataudAvgAggregateInputType
    _sum?: Historial_stock_ataudSumAggregateInputType
    _min?: Historial_stock_ataudMinAggregateInputType
    _max?: Historial_stock_ataudMaxAggregateInputType
  }


  export type Historial_stock_ataudGroupByOutputType = {
    idhistorial: number
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  type GetHistorial_stock_ataudGroupByPayload<T extends Historial_stock_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Historial_stock_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_stock_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
        }
      >
    >


  export type historial_stock_ataudSelect = {
    idhistorial?: boolean
    idataud?: boolean
    fecha_carga?: boolean
    stock_anterior?: boolean
    stock_nuevo?: boolean
    remito?: boolean
    operador?: boolean
    fecha_recepcion?: boolean
  }


  export type historial_stock_ataudGetPayload<S extends boolean | null | undefined | historial_stock_ataudArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? historial_stock_ataud :
    S extends undefined ? never :
    S extends { include: any } & (historial_stock_ataudArgs | historial_stock_ataudFindManyArgs)
    ? historial_stock_ataud 
    : S extends { select: any } & (historial_stock_ataudArgs | historial_stock_ataudFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof historial_stock_ataud ? historial_stock_ataud[P] : never
  } 
      : historial_stock_ataud


  type historial_stock_ataudCountArgs = 
    Omit<historial_stock_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Historial_stock_ataudCountAggregateInputType | true
    }

  export interface historial_stock_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Historial_stock_ataud that matches the filter.
     * @param {historial_stock_ataudFindUniqueArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_stock_ataudFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_stock_ataudFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>> : Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T> | null, null>

    /**
     * Find one Historial_stock_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_stock_ataudFindUniqueOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_stock_ataudFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, historial_stock_ataudFindUniqueOrThrowArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Find the first Historial_stock_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_stock_ataudFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>> : Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T> | null, null>

    /**
     * Find the first Historial_stock_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_stock_ataudFindFirstOrThrowArgs>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstOrThrowArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Find zero or more Historial_stock_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
     * 
     * // Get first 10 Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_stock_ataudWithIdhistorialOnly = await prisma.historial_stock_ataud.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_stock_ataudFindManyArgs>(
      args?: SelectSubset<T, historial_stock_ataudFindManyArgs>
    ): Prisma.PrismaPromise<Array<historial_stock_ataudGetPayload<T>>>

    /**
     * Create a Historial_stock_ataud.
     * @param {historial_stock_ataudCreateArgs} args - Arguments to create a Historial_stock_ataud.
     * @example
     * // Create one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.create({
     *   data: {
     *     // ... data to create a Historial_stock_ataud
     *   }
     * })
     * 
    **/
    create<T extends historial_stock_ataudCreateArgs>(
      args: SelectSubset<T, historial_stock_ataudCreateArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Create many Historial_stock_atauds.
     *     @param {historial_stock_ataudCreateManyArgs} args - Arguments to create many Historial_stock_atauds.
     *     @example
     *     // Create many Historial_stock_atauds
     *     const historial_stock_ataud = await prisma.historial_stock_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_stock_ataudCreateManyArgs>(
      args?: SelectSubset<T, historial_stock_ataudCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_stock_ataud.
     * @param {historial_stock_ataudDeleteArgs} args - Arguments to delete one Historial_stock_ataud.
     * @example
     * // Delete one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.delete({
     *   where: {
     *     // ... filter to delete one Historial_stock_ataud
     *   }
     * })
     * 
    **/
    delete<T extends historial_stock_ataudDeleteArgs>(
      args: SelectSubset<T, historial_stock_ataudDeleteArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpdateArgs} args - Arguments to update one Historial_stock_ataud.
     * @example
     * // Update one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_stock_ataudUpdateArgs>(
      args: SelectSubset<T, historial_stock_ataudUpdateArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Delete zero or more Historial_stock_atauds.
     * @param {historial_stock_ataudDeleteManyArgs} args - Arguments to filter Historial_stock_atauds to delete.
     * @example
     * // Delete a few Historial_stock_atauds
     * const { count } = await prisma.historial_stock_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_stock_ataudDeleteManyArgs>(
      args?: SelectSubset<T, historial_stock_ataudDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_stock_atauds
     * const historial_stock_ataud = await prisma.historial_stock_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_stock_ataudUpdateManyArgs>(
      args: SelectSubset<T, historial_stock_ataudUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpsertArgs} args - Arguments to update or create a Historial_stock_ataud.
     * @example
     * // Update or create a Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.upsert({
     *   create: {
     *     // ... data to create a Historial_stock_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_stock_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends historial_stock_ataudUpsertArgs>(
      args: SelectSubset<T, historial_stock_ataudUpsertArgs>
    ): Prisma__historial_stock_ataudClient<historial_stock_ataudGetPayload<T>>

    /**
     * Count the number of Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudCountArgs} args - Arguments to filter Historial_stock_atauds to count.
     * @example
     * // Count the number of Historial_stock_atauds
     * const count = await prisma.historial_stock_ataud.count({
     *   where: {
     *     // ... the filter for the Historial_stock_atauds we want to count
     *   }
     * })
    **/
    count<T extends historial_stock_ataudCountArgs>(
      args?: Subset<T, historial_stock_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_stock_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_stock_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_stock_ataudAggregateArgs>(args: Subset<T, Historial_stock_ataudAggregateArgs>): Prisma.PrismaPromise<GetHistorial_stock_ataudAggregateType<T>>

    /**
     * Group by Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_stock_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Historial_stock_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Historial_stock_ataudGroupByArgs['orderBy'] }
        : { orderBy?: Historial_stock_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Historial_stock_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_stock_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_stock_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_stock_ataudClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_stock_ataud base type for findUnique actions
   */
  export type historial_stock_ataudFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }

  /**
   * historial_stock_ataud findUnique
   */
  export interface historial_stock_ataudFindUniqueArgs extends historial_stock_ataudFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findUniqueOrThrow
   */
  export type historial_stock_ataudFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud base type for findFirst actions
   */
  export type historial_stock_ataudFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: Enumerable<historial_stock_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Enumerable<Historial_stock_ataudScalarFieldEnum>
  }

  /**
   * historial_stock_ataud findFirst
   */
  export interface historial_stock_ataudFindFirstArgs extends historial_stock_ataudFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findFirstOrThrow
   */
  export type historial_stock_ataudFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: Enumerable<historial_stock_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Enumerable<Historial_stock_ataudScalarFieldEnum>
  }


  /**
   * historial_stock_ataud findMany
   */
  export type historial_stock_ataudFindManyArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter, which historial_stock_atauds to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: Enumerable<historial_stock_ataudOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    distinct?: Enumerable<Historial_stock_ataudScalarFieldEnum>
  }


  /**
   * historial_stock_ataud create
   */
  export type historial_stock_ataudCreateArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * The data needed to create a historial_stock_ataud.
     */
    data: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
  }


  /**
   * historial_stock_ataud createMany
   */
  export type historial_stock_ataudCreateManyArgs = {
    /**
     * The data used to create many historial_stock_atauds.
     */
    data: Enumerable<historial_stock_ataudCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * historial_stock_ataud update
   */
  export type historial_stock_ataudUpdateArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * The data needed to update a historial_stock_ataud.
     */
    data: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
    /**
     * Choose, which historial_stock_ataud to update.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud updateMany
   */
  export type historial_stock_ataudUpdateManyArgs = {
    /**
     * The data used to update historial_stock_atauds.
     */
    data: XOR<historial_stock_ataudUpdateManyMutationInput, historial_stock_ataudUncheckedUpdateManyInput>
    /**
     * Filter which historial_stock_atauds to update
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud upsert
   */
  export type historial_stock_ataudUpsertArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * The filter to search for the historial_stock_ataud to update in case it exists.
     */
    where: historial_stock_ataudWhereUniqueInput
    /**
     * In case the historial_stock_ataud found by the `where` argument doesn't exist, create a new historial_stock_ataud with this data.
     */
    create: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
    /**
     * In case the historial_stock_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
  }


  /**
   * historial_stock_ataud delete
   */
  export type historial_stock_ataudDeleteArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
    /**
     * Filter which historial_stock_ataud to delete.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud deleteMany
   */
  export type historial_stock_ataudDeleteManyArgs = {
    /**
     * Filter which historial_stock_atauds to delete
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud without action
   */
  export type historial_stock_ataudArgs = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect | null
  }



  /**
   * Model honorarios
   */


  export type AggregateHonorarios = {
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  export type HonorariosAvgAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosSumAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMinAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMaxAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosCountAggregateOutputType = {
    idtrabajo: number
    trabajo: number
    dias_habiles: number
    finde: number
    feriado: number
    _all: number
  }


  export type HonorariosAvgAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosSumAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMinAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMaxAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosCountAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
    _all?: true
  }

  export type HonorariosAggregateArgs = {
    /**
     * Filter which honorarios to aggregate.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: Enumerable<honorariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned honorarios
    **/
    _count?: true | HonorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HonorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HonorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HonorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HonorariosMaxAggregateInputType
  }

  export type GetHonorariosAggregateType<T extends HonorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateHonorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHonorarios[P]>
      : GetScalarType<T[P], AggregateHonorarios[P]>
  }




  export type HonorariosGroupByArgs = {
    where?: honorariosWhereInput
    orderBy?: Enumerable<honorariosOrderByWithAggregationInput>
    by: HonorariosScalarFieldEnum[]
    having?: honorariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HonorariosCountAggregateInputType | true
    _avg?: HonorariosAvgAggregateInputType
    _sum?: HonorariosSumAggregateInputType
    _min?: HonorariosMinAggregateInputType
    _max?: HonorariosMaxAggregateInputType
  }


  export type HonorariosGroupByOutputType = {
    idtrabajo: number
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  type GetHonorariosGroupByPayload<T extends HonorariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HonorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HonorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
            : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
        }
      >
    >


  export type honorariosSelect = {
    idtrabajo?: boolean
    trabajo?: boolean
    dias_habiles?: boolean
    finde?: boolean
    feriado?: boolean
  }


  export type honorariosGetPayload<S extends boolean | null | undefined | honorariosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? honorarios :
    S extends undefined ? never :
    S extends { include: any } & (honorariosArgs | honorariosFindManyArgs)
    ? honorarios 
    : S extends { select: any } & (honorariosArgs | honorariosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof honorarios ? honorarios[P] : never
  } 
      : honorarios


  type honorariosCountArgs = 
    Omit<honorariosFindManyArgs, 'select' | 'include'> & {
      select?: HonorariosCountAggregateInputType | true
    }

  export interface honorariosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Honorarios that matches the filter.
     * @param {honorariosFindUniqueArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends honorariosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, honorariosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'honorarios'> extends True ? Prisma__honorariosClient<honorariosGetPayload<T>> : Prisma__honorariosClient<honorariosGetPayload<T> | null, null>

    /**
     * Find one Honorarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {honorariosFindUniqueOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends honorariosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, honorariosFindUniqueOrThrowArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Find the first Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends honorariosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, honorariosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'honorarios'> extends True ? Prisma__honorariosClient<honorariosGetPayload<T>> : Prisma__honorariosClient<honorariosGetPayload<T> | null, null>

    /**
     * Find the first Honorarios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends honorariosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, honorariosFindFirstOrThrowArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Find zero or more Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Honorarios
     * const honorarios = await prisma.honorarios.findMany()
     * 
     * // Get first 10 Honorarios
     * const honorarios = await prisma.honorarios.findMany({ take: 10 })
     * 
     * // Only select the `idtrabajo`
     * const honorariosWithIdtrabajoOnly = await prisma.honorarios.findMany({ select: { idtrabajo: true } })
     * 
    **/
    findMany<T extends honorariosFindManyArgs>(
      args?: SelectSubset<T, honorariosFindManyArgs>
    ): Prisma.PrismaPromise<Array<honorariosGetPayload<T>>>

    /**
     * Create a Honorarios.
     * @param {honorariosCreateArgs} args - Arguments to create a Honorarios.
     * @example
     * // Create one Honorarios
     * const Honorarios = await prisma.honorarios.create({
     *   data: {
     *     // ... data to create a Honorarios
     *   }
     * })
     * 
    **/
    create<T extends honorariosCreateArgs>(
      args: SelectSubset<T, honorariosCreateArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Create many Honorarios.
     *     @param {honorariosCreateManyArgs} args - Arguments to create many Honorarios.
     *     @example
     *     // Create many Honorarios
     *     const honorarios = await prisma.honorarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends honorariosCreateManyArgs>(
      args?: SelectSubset<T, honorariosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Honorarios.
     * @param {honorariosDeleteArgs} args - Arguments to delete one Honorarios.
     * @example
     * // Delete one Honorarios
     * const Honorarios = await prisma.honorarios.delete({
     *   where: {
     *     // ... filter to delete one Honorarios
     *   }
     * })
     * 
    **/
    delete<T extends honorariosDeleteArgs>(
      args: SelectSubset<T, honorariosDeleteArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Update one Honorarios.
     * @param {honorariosUpdateArgs} args - Arguments to update one Honorarios.
     * @example
     * // Update one Honorarios
     * const honorarios = await prisma.honorarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends honorariosUpdateArgs>(
      args: SelectSubset<T, honorariosUpdateArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Delete zero or more Honorarios.
     * @param {honorariosDeleteManyArgs} args - Arguments to filter Honorarios to delete.
     * @example
     * // Delete a few Honorarios
     * const { count } = await prisma.honorarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends honorariosDeleteManyArgs>(
      args?: SelectSubset<T, honorariosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Honorarios
     * const honorarios = await prisma.honorarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends honorariosUpdateManyArgs>(
      args: SelectSubset<T, honorariosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Honorarios.
     * @param {honorariosUpsertArgs} args - Arguments to update or create a Honorarios.
     * @example
     * // Update or create a Honorarios
     * const honorarios = await prisma.honorarios.upsert({
     *   create: {
     *     // ... data to create a Honorarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Honorarios we want to update
     *   }
     * })
    **/
    upsert<T extends honorariosUpsertArgs>(
      args: SelectSubset<T, honorariosUpsertArgs>
    ): Prisma__honorariosClient<honorariosGetPayload<T>>

    /**
     * Count the number of Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosCountArgs} args - Arguments to filter Honorarios to count.
     * @example
     * // Count the number of Honorarios
     * const count = await prisma.honorarios.count({
     *   where: {
     *     // ... the filter for the Honorarios we want to count
     *   }
     * })
    **/
    count<T extends honorariosCountArgs>(
      args?: Subset<T, honorariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HonorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HonorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HonorariosAggregateArgs>(args: Subset<T, HonorariosAggregateArgs>): Prisma.PrismaPromise<GetHonorariosAggregateType<T>>

    /**
     * Group by Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HonorariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HonorariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HonorariosGroupByArgs['orderBy'] }
        : { orderBy?: HonorariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HonorariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHonorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for honorarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__honorariosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * honorarios base type for findUnique actions
   */
  export type honorariosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }

  /**
   * honorarios findUnique
   */
  export interface honorariosFindUniqueArgs extends honorariosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findUniqueOrThrow
   */
  export type honorariosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios base type for findFirst actions
   */
  export type honorariosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: Enumerable<honorariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: Enumerable<HonorariosScalarFieldEnum>
  }

  /**
   * honorarios findFirst
   */
  export interface honorariosFindFirstArgs extends honorariosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findFirstOrThrow
   */
  export type honorariosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: Enumerable<honorariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: Enumerable<HonorariosScalarFieldEnum>
  }


  /**
   * honorarios findMany
   */
  export type honorariosFindManyArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: Enumerable<honorariosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    distinct?: Enumerable<HonorariosScalarFieldEnum>
  }


  /**
   * honorarios create
   */
  export type honorariosCreateArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * The data needed to create a honorarios.
     */
    data: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
  }


  /**
   * honorarios createMany
   */
  export type honorariosCreateManyArgs = {
    /**
     * The data used to create many honorarios.
     */
    data: Enumerable<honorariosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * honorarios update
   */
  export type honorariosUpdateArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * The data needed to update a honorarios.
     */
    data: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
    /**
     * Choose, which honorarios to update.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios updateMany
   */
  export type honorariosUpdateManyArgs = {
    /**
     * The data used to update honorarios.
     */
    data: XOR<honorariosUpdateManyMutationInput, honorariosUncheckedUpdateManyInput>
    /**
     * Filter which honorarios to update
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios upsert
   */
  export type honorariosUpsertArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * The filter to search for the honorarios to update in case it exists.
     */
    where: honorariosWhereUniqueInput
    /**
     * In case the honorarios found by the `where` argument doesn't exist, create a new honorarios with this data.
     */
    create: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
    /**
     * In case the honorarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
  }


  /**
   * honorarios delete
   */
  export type honorariosDeleteArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
    /**
     * Filter which honorarios to delete.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios deleteMany
   */
  export type honorariosDeleteManyArgs = {
    /**
     * Filter which honorarios to delete
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios without action
   */
  export type honorariosArgs = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect | null
  }



  /**
   * Model ingreso_caja
   */


  export type AggregateIngreso_caja = {
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  export type Ingreso_cajaAvgAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaSumAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMinAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: number | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMaxAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: number | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaCountAggregateOutputType = {
    idingreso: number
    idcaja: number
    concepto: number
    monto: number
    operador: number
    fecha: number
    tipofactura: number
    nfactura: number
    empresa: number
    detalle: number
    ptoventa: number
    _all: number
  }


  export type Ingreso_cajaAvgAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Ingreso_cajaSumAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMinAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMaxAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaCountAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
    _all?: true
  }

  export type Ingreso_cajaAggregateArgs = {
    /**
     * Filter which ingreso_caja to aggregate.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: Enumerable<ingreso_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ingreso_cajas
    **/
    _count?: true | Ingreso_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ingreso_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ingreso_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ingreso_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ingreso_cajaMaxAggregateInputType
  }

  export type GetIngreso_cajaAggregateType<T extends Ingreso_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateIngreso_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngreso_caja[P]>
      : GetScalarType<T[P], AggregateIngreso_caja[P]>
  }




  export type Ingreso_cajaGroupByArgs = {
    where?: ingreso_cajaWhereInput
    orderBy?: Enumerable<ingreso_cajaOrderByWithAggregationInput>
    by: Ingreso_cajaScalarFieldEnum[]
    having?: ingreso_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ingreso_cajaCountAggregateInputType | true
    _avg?: Ingreso_cajaAvgAggregateInputType
    _sum?: Ingreso_cajaSumAggregateInputType
    _min?: Ingreso_cajaMinAggregateInputType
    _max?: Ingreso_cajaMaxAggregateInputType
  }


  export type Ingreso_cajaGroupByOutputType = {
    idingreso: number
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: number | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  type GetIngreso_cajaGroupByPayload<T extends Ingreso_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Ingreso_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ingreso_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
        }
      >
    >


  export type ingreso_cajaSelect = {
    idingreso?: boolean
    idcaja?: boolean
    concepto?: boolean
    monto?: boolean
    operador?: boolean
    fecha?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    empresa?: boolean
    detalle?: boolean
    ptoventa?: boolean
  }


  export type ingreso_cajaGetPayload<S extends boolean | null | undefined | ingreso_cajaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ingreso_caja :
    S extends undefined ? never :
    S extends { include: any } & (ingreso_cajaArgs | ingreso_cajaFindManyArgs)
    ? ingreso_caja 
    : S extends { select: any } & (ingreso_cajaArgs | ingreso_cajaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ingreso_caja ? ingreso_caja[P] : never
  } 
      : ingreso_caja


  type ingreso_cajaCountArgs = 
    Omit<ingreso_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Ingreso_cajaCountAggregateInputType | true
    }

  export interface ingreso_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ingreso_caja that matches the filter.
     * @param {ingreso_cajaFindUniqueArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ingreso_cajaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ingreso_cajaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>> : Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T> | null, null>

    /**
     * Find one Ingreso_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ingreso_cajaFindUniqueOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ingreso_cajaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ingreso_cajaFindUniqueOrThrowArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Find the first Ingreso_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ingreso_cajaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ingreso_cajaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>> : Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T> | null, null>

    /**
     * Find the first Ingreso_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ingreso_cajaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ingreso_cajaFindFirstOrThrowArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Find zero or more Ingreso_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany()
     * 
     * // Get first 10 Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany({ take: 10 })
     * 
     * // Only select the `idingreso`
     * const ingreso_cajaWithIdingresoOnly = await prisma.ingreso_caja.findMany({ select: { idingreso: true } })
     * 
    **/
    findMany<T extends ingreso_cajaFindManyArgs>(
      args?: SelectSubset<T, ingreso_cajaFindManyArgs>
    ): Prisma.PrismaPromise<Array<ingreso_cajaGetPayload<T>>>

    /**
     * Create a Ingreso_caja.
     * @param {ingreso_cajaCreateArgs} args - Arguments to create a Ingreso_caja.
     * @example
     * // Create one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.create({
     *   data: {
     *     // ... data to create a Ingreso_caja
     *   }
     * })
     * 
    **/
    create<T extends ingreso_cajaCreateArgs>(
      args: SelectSubset<T, ingreso_cajaCreateArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Create many Ingreso_cajas.
     *     @param {ingreso_cajaCreateManyArgs} args - Arguments to create many Ingreso_cajas.
     *     @example
     *     // Create many Ingreso_cajas
     *     const ingreso_caja = await prisma.ingreso_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ingreso_cajaCreateManyArgs>(
      args?: SelectSubset<T, ingreso_cajaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingreso_caja.
     * @param {ingreso_cajaDeleteArgs} args - Arguments to delete one Ingreso_caja.
     * @example
     * // Delete one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.delete({
     *   where: {
     *     // ... filter to delete one Ingreso_caja
     *   }
     * })
     * 
    **/
    delete<T extends ingreso_cajaDeleteArgs>(
      args: SelectSubset<T, ingreso_cajaDeleteArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Update one Ingreso_caja.
     * @param {ingreso_cajaUpdateArgs} args - Arguments to update one Ingreso_caja.
     * @example
     * // Update one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ingreso_cajaUpdateArgs>(
      args: SelectSubset<T, ingreso_cajaUpdateArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Delete zero or more Ingreso_cajas.
     * @param {ingreso_cajaDeleteManyArgs} args - Arguments to filter Ingreso_cajas to delete.
     * @example
     * // Delete a few Ingreso_cajas
     * const { count } = await prisma.ingreso_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ingreso_cajaDeleteManyArgs>(
      args?: SelectSubset<T, ingreso_cajaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingreso_cajas
     * const ingreso_caja = await prisma.ingreso_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ingreso_cajaUpdateManyArgs>(
      args: SelectSubset<T, ingreso_cajaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingreso_caja.
     * @param {ingreso_cajaUpsertArgs} args - Arguments to update or create a Ingreso_caja.
     * @example
     * // Update or create a Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.upsert({
     *   create: {
     *     // ... data to create a Ingreso_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingreso_caja we want to update
     *   }
     * })
    **/
    upsert<T extends ingreso_cajaUpsertArgs>(
      args: SelectSubset<T, ingreso_cajaUpsertArgs>
    ): Prisma__ingreso_cajaClient<ingreso_cajaGetPayload<T>>

    /**
     * Count the number of Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaCountArgs} args - Arguments to filter Ingreso_cajas to count.
     * @example
     * // Count the number of Ingreso_cajas
     * const count = await prisma.ingreso_caja.count({
     *   where: {
     *     // ... the filter for the Ingreso_cajas we want to count
     *   }
     * })
    **/
    count<T extends ingreso_cajaCountArgs>(
      args?: Subset<T, ingreso_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ingreso_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ingreso_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ingreso_cajaAggregateArgs>(args: Subset<T, Ingreso_cajaAggregateArgs>): Prisma.PrismaPromise<GetIngreso_cajaAggregateType<T>>

    /**
     * Group by Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ingreso_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ingreso_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ingreso_cajaGroupByArgs['orderBy'] }
        : { orderBy?: Ingreso_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ingreso_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngreso_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ingreso_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ingreso_cajaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ingreso_caja base type for findUnique actions
   */
  export type ingreso_cajaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }

  /**
   * ingreso_caja findUnique
   */
  export interface ingreso_cajaFindUniqueArgs extends ingreso_cajaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findUniqueOrThrow
   */
  export type ingreso_cajaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja base type for findFirst actions
   */
  export type ingreso_cajaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: Enumerable<ingreso_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Enumerable<Ingreso_cajaScalarFieldEnum>
  }

  /**
   * ingreso_caja findFirst
   */
  export interface ingreso_cajaFindFirstArgs extends ingreso_cajaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findFirstOrThrow
   */
  export type ingreso_cajaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: Enumerable<ingreso_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Enumerable<Ingreso_cajaScalarFieldEnum>
  }


  /**
   * ingreso_caja findMany
   */
  export type ingreso_cajaFindManyArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter, which ingreso_cajas to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: Enumerable<ingreso_cajaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    distinct?: Enumerable<Ingreso_cajaScalarFieldEnum>
  }


  /**
   * ingreso_caja create
   */
  export type ingreso_cajaCreateArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * The data needed to create a ingreso_caja.
     */
    data: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
  }


  /**
   * ingreso_caja createMany
   */
  export type ingreso_cajaCreateManyArgs = {
    /**
     * The data used to create many ingreso_cajas.
     */
    data: Enumerable<ingreso_cajaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ingreso_caja update
   */
  export type ingreso_cajaUpdateArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * The data needed to update a ingreso_caja.
     */
    data: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
    /**
     * Choose, which ingreso_caja to update.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja updateMany
   */
  export type ingreso_cajaUpdateManyArgs = {
    /**
     * The data used to update ingreso_cajas.
     */
    data: XOR<ingreso_cajaUpdateManyMutationInput, ingreso_cajaUncheckedUpdateManyInput>
    /**
     * Filter which ingreso_cajas to update
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja upsert
   */
  export type ingreso_cajaUpsertArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * The filter to search for the ingreso_caja to update in case it exists.
     */
    where: ingreso_cajaWhereUniqueInput
    /**
     * In case the ingreso_caja found by the `where` argument doesn't exist, create a new ingreso_caja with this data.
     */
    create: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
    /**
     * In case the ingreso_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
  }


  /**
   * ingreso_caja delete
   */
  export type ingreso_cajaDeleteArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
    /**
     * Filter which ingreso_caja to delete.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja deleteMany
   */
  export type ingreso_cajaDeleteManyArgs = {
    /**
     * Filter which ingreso_cajas to delete
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja without action
   */
  export type ingreso_cajaArgs = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect | null
  }



  /**
   * Model legajo_virtual_autos
   */


  export type AggregateLegajo_virtual_autos = {
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_autosAvgAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosSumAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosMinAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosMaxAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosCountAggregateOutputType = {
    idlegajo: number
    patente: number
    archivo: number
    fecha_subida: number
    _all: number
  }


  export type Legajo_virtual_autosAvgAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosSumAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosMinAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosMaxAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosCountAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
    _all?: true
  }

  export type Legajo_virtual_autosAggregateArgs = {
    /**
     * Filter which legajo_virtual_autos to aggregate.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_autos
    **/
    _count?: true | Legajo_virtual_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }

  export type GetLegajo_virtual_autosAggregateType<T extends Legajo_virtual_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
  }




  export type Legajo_virtual_autosGroupByArgs = {
    where?: legajo_virtual_autosWhereInput
    orderBy?: Enumerable<legajo_virtual_autosOrderByWithAggregationInput>
    by: Legajo_virtual_autosScalarFieldEnum[]
    having?: legajo_virtual_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_autosCountAggregateInputType | true
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    _sum?: Legajo_virtual_autosSumAggregateInputType
    _min?: Legajo_virtual_autosMinAggregateInputType
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }


  export type Legajo_virtual_autosGroupByOutputType = {
    idlegajo: number
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_autosGroupByPayload<T extends Legajo_virtual_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Legajo_virtual_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_autosSelect = {
    idlegajo?: boolean
    patente?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }


  export type legajo_virtual_autosGetPayload<S extends boolean | null | undefined | legajo_virtual_autosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? legajo_virtual_autos :
    S extends undefined ? never :
    S extends { include: any } & (legajo_virtual_autosArgs | legajo_virtual_autosFindManyArgs)
    ? legajo_virtual_autos 
    : S extends { select: any } & (legajo_virtual_autosArgs | legajo_virtual_autosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof legajo_virtual_autos ? legajo_virtual_autos[P] : never
  } 
      : legajo_virtual_autos


  type legajo_virtual_autosCountArgs = 
    Omit<legajo_virtual_autosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_autosCountAggregateInputType | true
    }

  export interface legajo_virtual_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Legajo_virtual_autos that matches the filter.
     * @param {legajo_virtual_autosFindUniqueArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_autosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_autosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>> : Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T> | null, null>

    /**
     * Find one Legajo_virtual_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_autosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_autosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, legajo_virtual_autosFindUniqueOrThrowArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Find the first Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_autosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>> : Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T> | null, null>

    /**
     * Find the first Legajo_virtual_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_autosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstOrThrowArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Find zero or more Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
     * 
     * // Get first 10 Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_autosWithIdlegajoOnly = await prisma.legajo_virtual_autos.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_autosFindManyArgs>(
      args?: SelectSubset<T, legajo_virtual_autosFindManyArgs>
    ): Prisma.PrismaPromise<Array<legajo_virtual_autosGetPayload<T>>>

    /**
     * Create a Legajo_virtual_autos.
     * @param {legajo_virtual_autosCreateArgs} args - Arguments to create a Legajo_virtual_autos.
     * @example
     * // Create one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_autosCreateArgs>(
      args: SelectSubset<T, legajo_virtual_autosCreateArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Create many Legajo_virtual_autos.
     *     @param {legajo_virtual_autosCreateManyArgs} args - Arguments to create many Legajo_virtual_autos.
     *     @example
     *     // Create many Legajo_virtual_autos
     *     const legajo_virtual_autos = await prisma.legajo_virtual_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_autosCreateManyArgs>(
      args?: SelectSubset<T, legajo_virtual_autosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteArgs} args - Arguments to delete one Legajo_virtual_autos.
     * @example
     * // Delete one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_autosDeleteArgs>(
      args: SelectSubset<T, legajo_virtual_autosDeleteArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpdateArgs} args - Arguments to update one Legajo_virtual_autos.
     * @example
     * // Update one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_autosUpdateArgs>(
      args: SelectSubset<T, legajo_virtual_autosUpdateArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Delete zero or more Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteManyArgs} args - Arguments to filter Legajo_virtual_autos to delete.
     * @example
     * // Delete a few Legajo_virtual_autos
     * const { count } = await prisma.legajo_virtual_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_autosDeleteManyArgs>(
      args?: SelectSubset<T, legajo_virtual_autosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_autosUpdateManyArgs>(
      args: SelectSubset<T, legajo_virtual_autosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpsertArgs} args - Arguments to update or create a Legajo_virtual_autos.
     * @example
     * // Update or create a Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_autosUpsertArgs>(
      args: SelectSubset<T, legajo_virtual_autosUpsertArgs>
    ): Prisma__legajo_virtual_autosClient<legajo_virtual_autosGetPayload<T>>

    /**
     * Count the number of Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosCountArgs} args - Arguments to filter Legajo_virtual_autos to count.
     * @example
     * // Count the number of Legajo_virtual_autos
     * const count = await prisma.legajo_virtual_autos.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_autosCountArgs>(
      args?: Subset<T, legajo_virtual_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_autosAggregateArgs>(args: Subset<T, Legajo_virtual_autosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_autosAggregateType<T>>

    /**
     * Group by Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Legajo_virtual_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Legajo_virtual_autosGroupByArgs['orderBy'] }
        : { orderBy?: Legajo_virtual_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Legajo_virtual_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_autosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_autos base type for findUnique actions
   */
  export type legajo_virtual_autosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }

  /**
   * legajo_virtual_autos findUnique
   */
  export interface legajo_virtual_autosFindUniqueArgs extends legajo_virtual_autosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findUniqueOrThrow
   */
  export type legajo_virtual_autosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos base type for findFirst actions
   */
  export type legajo_virtual_autosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Enumerable<Legajo_virtual_autosScalarFieldEnum>
  }

  /**
   * legajo_virtual_autos findFirst
   */
  export interface legajo_virtual_autosFindFirstArgs extends legajo_virtual_autosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findFirstOrThrow
   */
  export type legajo_virtual_autosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Enumerable<Legajo_virtual_autosScalarFieldEnum>
  }


  /**
   * legajo_virtual_autos findMany
   */
  export type legajo_virtual_autosFindManyArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_autosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    distinct?: Enumerable<Legajo_virtual_autosScalarFieldEnum>
  }


  /**
   * legajo_virtual_autos create
   */
  export type legajo_virtual_autosCreateArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * The data needed to create a legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_autos createMany
   */
  export type legajo_virtual_autosCreateManyArgs = {
    /**
     * The data used to create many legajo_virtual_autos.
     */
    data: Enumerable<legajo_virtual_autosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_autos update
   */
  export type legajo_virtual_autosUpdateArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * The data needed to update a legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_autos to update.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos updateMany
   */
  export type legajo_virtual_autosUpdateManyArgs = {
    /**
     * The data used to update legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateManyMutationInput, legajo_virtual_autosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_autos to update
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos upsert
   */
  export type legajo_virtual_autosUpsertArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * The filter to search for the legajo_virtual_autos to update in case it exists.
     */
    where: legajo_virtual_autosWhereUniqueInput
    /**
     * In case the legajo_virtual_autos found by the `where` argument doesn't exist, create a new legajo_virtual_autos with this data.
     */
    create: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_autos delete
   */
  export type legajo_virtual_autosDeleteArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
    /**
     * Filter which legajo_virtual_autos to delete.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos deleteMany
   */
  export type legajo_virtual_autosDeleteManyArgs = {
    /**
     * Filter which legajo_virtual_autos to delete
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos without action
   */
  export type legajo_virtual_autosArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect | null
  }



  /**
   * Model legajo_virtual_servicios
   */


  export type AggregateLegajo_virtual_servicios = {
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_serviciosAvgAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_serviciosSumAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_serviciosMinAggregateOutputType = {
    idlegajo: number | null
    servicio: string | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosMaxAggregateOutputType = {
    idlegajo: number | null
    servicio: string | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosCountAggregateOutputType = {
    idlegajo: number
    servicio: number
    archivo: number
    fecha_subida: number
    empresa: number
    _all: number
  }


  export type Legajo_virtual_serviciosAvgAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_serviciosSumAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_serviciosMinAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosMaxAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosCountAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    _all?: true
  }

  export type Legajo_virtual_serviciosAggregateArgs = {
    /**
     * Filter which legajo_virtual_servicios to aggregate.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_servicios
    **/
    _count?: true | Legajo_virtual_serviciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }

  export type GetLegajo_virtual_serviciosAggregateType<T extends Legajo_virtual_serviciosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_servicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
  }




  export type Legajo_virtual_serviciosGroupByArgs = {
    where?: legajo_virtual_serviciosWhereInput
    orderBy?: Enumerable<legajo_virtual_serviciosOrderByWithAggregationInput>
    by: Legajo_virtual_serviciosScalarFieldEnum[]
    having?: legajo_virtual_serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_serviciosCountAggregateInputType | true
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }


  export type Legajo_virtual_serviciosGroupByOutputType = {
    idlegajo: number
    servicio: string | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_serviciosGroupByPayload<T extends Legajo_virtual_serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Legajo_virtual_serviciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_serviciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_serviciosSelect = {
    idlegajo?: boolean
    servicio?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }


  export type legajo_virtual_serviciosGetPayload<S extends boolean | null | undefined | legajo_virtual_serviciosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? legajo_virtual_servicios :
    S extends undefined ? never :
    S extends { include: any } & (legajo_virtual_serviciosArgs | legajo_virtual_serviciosFindManyArgs)
    ? legajo_virtual_servicios 
    : S extends { select: any } & (legajo_virtual_serviciosArgs | legajo_virtual_serviciosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof legajo_virtual_servicios ? legajo_virtual_servicios[P] : never
  } 
      : legajo_virtual_servicios


  type legajo_virtual_serviciosCountArgs = 
    Omit<legajo_virtual_serviciosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_serviciosCountAggregateInputType | true
    }

  export interface legajo_virtual_serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Legajo_virtual_servicios that matches the filter.
     * @param {legajo_virtual_serviciosFindUniqueArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_serviciosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_serviciosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>> : Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T> | null, null>

    /**
     * Find one Legajo_virtual_servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_serviciosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_serviciosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindUniqueOrThrowArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_serviciosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>> : Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T> | null, null>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_serviciosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstOrThrowArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Find zero or more Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
     * 
     * // Get first 10 Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_serviciosWithIdlegajoOnly = await prisma.legajo_virtual_servicios.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_serviciosFindManyArgs>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindManyArgs>
    ): Prisma.PrismaPromise<Array<legajo_virtual_serviciosGetPayload<T>>>

    /**
     * Create a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosCreateArgs} args - Arguments to create a Legajo_virtual_servicios.
     * @example
     * // Create one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_serviciosCreateArgs>(
      args: SelectSubset<T, legajo_virtual_serviciosCreateArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Create many Legajo_virtual_servicios.
     *     @param {legajo_virtual_serviciosCreateManyArgs} args - Arguments to create many Legajo_virtual_servicios.
     *     @example
     *     // Create many Legajo_virtual_servicios
     *     const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_serviciosCreateManyArgs>(
      args?: SelectSubset<T, legajo_virtual_serviciosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteArgs} args - Arguments to delete one Legajo_virtual_servicios.
     * @example
     * // Delete one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_serviciosDeleteArgs>(
      args: SelectSubset<T, legajo_virtual_serviciosDeleteArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpdateArgs} args - Arguments to update one Legajo_virtual_servicios.
     * @example
     * // Update one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_serviciosUpdateArgs>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Delete zero or more Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteManyArgs} args - Arguments to filter Legajo_virtual_servicios to delete.
     * @example
     * // Delete a few Legajo_virtual_servicios
     * const { count } = await prisma.legajo_virtual_servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_serviciosDeleteManyArgs>(
      args?: SelectSubset<T, legajo_virtual_serviciosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_serviciosUpdateManyArgs>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpsertArgs} args - Arguments to update or create a Legajo_virtual_servicios.
     * @example
     * // Update or create a Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_serviciosUpsertArgs>(
      args: SelectSubset<T, legajo_virtual_serviciosUpsertArgs>
    ): Prisma__legajo_virtual_serviciosClient<legajo_virtual_serviciosGetPayload<T>>

    /**
     * Count the number of Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosCountArgs} args - Arguments to filter Legajo_virtual_servicios to count.
     * @example
     * // Count the number of Legajo_virtual_servicios
     * const count = await prisma.legajo_virtual_servicios.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_serviciosCountArgs>(
      args?: Subset<T, legajo_virtual_serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_serviciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_serviciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_serviciosAggregateArgs>(args: Subset<T, Legajo_virtual_serviciosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_serviciosAggregateType<T>>

    /**
     * Group by Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Legajo_virtual_serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Legajo_virtual_serviciosGroupByArgs['orderBy'] }
        : { orderBy?: Legajo_virtual_serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Legajo_virtual_serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_serviciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_serviciosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_servicios base type for findUnique actions
   */
  export type legajo_virtual_serviciosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }

  /**
   * legajo_virtual_servicios findUnique
   */
  export interface legajo_virtual_serviciosFindUniqueArgs extends legajo_virtual_serviciosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findUniqueOrThrow
   */
  export type legajo_virtual_serviciosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios base type for findFirst actions
   */
  export type legajo_virtual_serviciosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Enumerable<Legajo_virtual_serviciosScalarFieldEnum>
  }

  /**
   * legajo_virtual_servicios findFirst
   */
  export interface legajo_virtual_serviciosFindFirstArgs extends legajo_virtual_serviciosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findFirstOrThrow
   */
  export type legajo_virtual_serviciosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Enumerable<Legajo_virtual_serviciosScalarFieldEnum>
  }


  /**
   * legajo_virtual_servicios findMany
   */
  export type legajo_virtual_serviciosFindManyArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: Enumerable<legajo_virtual_serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    distinct?: Enumerable<Legajo_virtual_serviciosScalarFieldEnum>
  }


  /**
   * legajo_virtual_servicios create
   */
  export type legajo_virtual_serviciosCreateArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * The data needed to create a legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_servicios createMany
   */
  export type legajo_virtual_serviciosCreateManyArgs = {
    /**
     * The data used to create many legajo_virtual_servicios.
     */
    data: Enumerable<legajo_virtual_serviciosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_servicios update
   */
  export type legajo_virtual_serviciosUpdateArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * The data needed to update a legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_servicios to update.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios updateMany
   */
  export type legajo_virtual_serviciosUpdateManyArgs = {
    /**
     * The data used to update legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateManyMutationInput, legajo_virtual_serviciosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_servicios to update
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios upsert
   */
  export type legajo_virtual_serviciosUpsertArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * The filter to search for the legajo_virtual_servicios to update in case it exists.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
    /**
     * In case the legajo_virtual_servicios found by the `where` argument doesn't exist, create a new legajo_virtual_servicios with this data.
     */
    create: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_servicios delete
   */
  export type legajo_virtual_serviciosDeleteArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
    /**
     * Filter which legajo_virtual_servicios to delete.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios deleteMany
   */
  export type legajo_virtual_serviciosDeleteManyArgs = {
    /**
     * Filter which legajo_virtual_servicios to delete
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios without action
   */
  export type legajo_virtual_serviciosArgs = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect | null
  }



  /**
   * Model novedades
   */


  export type AggregateNovedades = {
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  export type NovedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesMinAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesMaxAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesCountAggregateOutputType = {
    idnovedad: number
    novedad: number
    fecha: number
    operador: number
    _all: number
  }


  export type NovedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesMinAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesMaxAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesCountAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
    _all?: true
  }

  export type NovedadesAggregateArgs = {
    /**
     * Filter which novedades to aggregate.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: Enumerable<novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned novedades
    **/
    _count?: true | NovedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovedadesMaxAggregateInputType
  }

  export type GetNovedadesAggregateType<T extends NovedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateNovedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovedades[P]>
      : GetScalarType<T[P], AggregateNovedades[P]>
  }




  export type NovedadesGroupByArgs = {
    where?: novedadesWhereInput
    orderBy?: Enumerable<novedadesOrderByWithAggregationInput>
    by: NovedadesScalarFieldEnum[]
    having?: novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovedadesCountAggregateInputType | true
    _avg?: NovedadesAvgAggregateInputType
    _sum?: NovedadesSumAggregateInputType
    _min?: NovedadesMinAggregateInputType
    _max?: NovedadesMaxAggregateInputType
  }


  export type NovedadesGroupByOutputType = {
    idnovedad: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  type GetNovedadesGroupByPayload<T extends NovedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NovedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
            : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
        }
      >
    >


  export type novedadesSelect = {
    idnovedad?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
  }


  export type novedadesGetPayload<S extends boolean | null | undefined | novedadesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? novedades :
    S extends undefined ? never :
    S extends { include: any } & (novedadesArgs | novedadesFindManyArgs)
    ? novedades 
    : S extends { select: any } & (novedadesArgs | novedadesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof novedades ? novedades[P] : never
  } 
      : novedades


  type novedadesCountArgs = 
    Omit<novedadesFindManyArgs, 'select' | 'include'> & {
      select?: NovedadesCountAggregateInputType | true
    }

  export interface novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Novedades that matches the filter.
     * @param {novedadesFindUniqueArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends novedadesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, novedadesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'novedades'> extends True ? Prisma__novedadesClient<novedadesGetPayload<T>> : Prisma__novedadesClient<novedadesGetPayload<T> | null, null>

    /**
     * Find one Novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {novedadesFindUniqueOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends novedadesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, novedadesFindUniqueOrThrowArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Find the first Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends novedadesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, novedadesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'novedades'> extends True ? Prisma__novedadesClient<novedadesGetPayload<T>> : Prisma__novedadesClient<novedadesGetPayload<T> | null, null>

    /**
     * Find the first Novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends novedadesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, novedadesFindFirstOrThrowArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Find zero or more Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Novedades
     * const novedades = await prisma.novedades.findMany()
     * 
     * // Get first 10 Novedades
     * const novedades = await prisma.novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const novedadesWithIdnovedadOnly = await prisma.novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends novedadesFindManyArgs>(
      args?: SelectSubset<T, novedadesFindManyArgs>
    ): Prisma.PrismaPromise<Array<novedadesGetPayload<T>>>

    /**
     * Create a Novedades.
     * @param {novedadesCreateArgs} args - Arguments to create a Novedades.
     * @example
     * // Create one Novedades
     * const Novedades = await prisma.novedades.create({
     *   data: {
     *     // ... data to create a Novedades
     *   }
     * })
     * 
    **/
    create<T extends novedadesCreateArgs>(
      args: SelectSubset<T, novedadesCreateArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Create many Novedades.
     *     @param {novedadesCreateManyArgs} args - Arguments to create many Novedades.
     *     @example
     *     // Create many Novedades
     *     const novedades = await prisma.novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends novedadesCreateManyArgs>(
      args?: SelectSubset<T, novedadesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Novedades.
     * @param {novedadesDeleteArgs} args - Arguments to delete one Novedades.
     * @example
     * // Delete one Novedades
     * const Novedades = await prisma.novedades.delete({
     *   where: {
     *     // ... filter to delete one Novedades
     *   }
     * })
     * 
    **/
    delete<T extends novedadesDeleteArgs>(
      args: SelectSubset<T, novedadesDeleteArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Update one Novedades.
     * @param {novedadesUpdateArgs} args - Arguments to update one Novedades.
     * @example
     * // Update one Novedades
     * const novedades = await prisma.novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends novedadesUpdateArgs>(
      args: SelectSubset<T, novedadesUpdateArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Delete zero or more Novedades.
     * @param {novedadesDeleteManyArgs} args - Arguments to filter Novedades to delete.
     * @example
     * // Delete a few Novedades
     * const { count } = await prisma.novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends novedadesDeleteManyArgs>(
      args?: SelectSubset<T, novedadesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Novedades
     * const novedades = await prisma.novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends novedadesUpdateManyArgs>(
      args: SelectSubset<T, novedadesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Novedades.
     * @param {novedadesUpsertArgs} args - Arguments to update or create a Novedades.
     * @example
     * // Update or create a Novedades
     * const novedades = await prisma.novedades.upsert({
     *   create: {
     *     // ... data to create a Novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Novedades we want to update
     *   }
     * })
    **/
    upsert<T extends novedadesUpsertArgs>(
      args: SelectSubset<T, novedadesUpsertArgs>
    ): Prisma__novedadesClient<novedadesGetPayload<T>>

    /**
     * Count the number of Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesCountArgs} args - Arguments to filter Novedades to count.
     * @example
     * // Count the number of Novedades
     * const count = await prisma.novedades.count({
     *   where: {
     *     // ... the filter for the Novedades we want to count
     *   }
     * })
    **/
    count<T extends novedadesCountArgs>(
      args?: Subset<T, novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovedadesAggregateArgs>(args: Subset<T, NovedadesAggregateArgs>): Prisma.PrismaPromise<GetNovedadesAggregateType<T>>

    /**
     * Group by Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NovedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NovedadesGroupByArgs['orderBy'] }
        : { orderBy?: NovedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NovedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__novedadesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * novedades base type for findUnique actions
   */
  export type novedadesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }

  /**
   * novedades findUnique
   */
  export interface novedadesFindUniqueArgs extends novedadesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findUniqueOrThrow
   */
  export type novedadesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades base type for findFirst actions
   */
  export type novedadesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: Enumerable<novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: Enumerable<NovedadesScalarFieldEnum>
  }

  /**
   * novedades findFirst
   */
  export interface novedadesFindFirstArgs extends novedadesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findFirstOrThrow
   */
  export type novedadesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: Enumerable<novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: Enumerable<NovedadesScalarFieldEnum>
  }


  /**
   * novedades findMany
   */
  export type novedadesFindManyArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: Enumerable<novedadesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    distinct?: Enumerable<NovedadesScalarFieldEnum>
  }


  /**
   * novedades create
   */
  export type novedadesCreateArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * The data needed to create a novedades.
     */
    data: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
  }


  /**
   * novedades createMany
   */
  export type novedadesCreateManyArgs = {
    /**
     * The data used to create many novedades.
     */
    data: Enumerable<novedadesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * novedades update
   */
  export type novedadesUpdateArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * The data needed to update a novedades.
     */
    data: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
    /**
     * Choose, which novedades to update.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades updateMany
   */
  export type novedadesUpdateManyArgs = {
    /**
     * The data used to update novedades.
     */
    data: XOR<novedadesUpdateManyMutationInput, novedadesUncheckedUpdateManyInput>
    /**
     * Filter which novedades to update
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades upsert
   */
  export type novedadesUpsertArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * The filter to search for the novedades to update in case it exists.
     */
    where: novedadesWhereUniqueInput
    /**
     * In case the novedades found by the `where` argument doesn't exist, create a new novedades with this data.
     */
    create: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
    /**
     * In case the novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
  }


  /**
   * novedades delete
   */
  export type novedadesDeleteArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
    /**
     * Filter which novedades to delete.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades deleteMany
   */
  export type novedadesDeleteManyArgs = {
    /**
     * Filter which novedades to delete
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades without action
   */
  export type novedadesArgs = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect | null
  }



  /**
   * Model operadorsep
   */


  export type AggregateOperadorsep = {
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  export type OperadorsepAvgAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepSumAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepMinAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepMaxAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepCountAggregateOutputType = {
    idoperador: number
    operador: number
    _all: number
  }


  export type OperadorsepAvgAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepSumAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepMinAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepMaxAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepCountAggregateInputType = {
    idoperador?: true
    operador?: true
    _all?: true
  }

  export type OperadorsepAggregateArgs = {
    /**
     * Filter which operadorsep to aggregate.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: Enumerable<operadorsepOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operadorseps
    **/
    _count?: true | OperadorsepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperadorsepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperadorsepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperadorsepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperadorsepMaxAggregateInputType
  }

  export type GetOperadorsepAggregateType<T extends OperadorsepAggregateArgs> = {
        [P in keyof T & keyof AggregateOperadorsep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperadorsep[P]>
      : GetScalarType<T[P], AggregateOperadorsep[P]>
  }




  export type OperadorsepGroupByArgs = {
    where?: operadorsepWhereInput
    orderBy?: Enumerable<operadorsepOrderByWithAggregationInput>
    by: OperadorsepScalarFieldEnum[]
    having?: operadorsepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperadorsepCountAggregateInputType | true
    _avg?: OperadorsepAvgAggregateInputType
    _sum?: OperadorsepSumAggregateInputType
    _min?: OperadorsepMinAggregateInputType
    _max?: OperadorsepMaxAggregateInputType
  }


  export type OperadorsepGroupByOutputType = {
    idoperador: number
    operador: string | null
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  type GetOperadorsepGroupByPayload<T extends OperadorsepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperadorsepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperadorsepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
            : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
        }
      >
    >


  export type operadorsepSelect = {
    idoperador?: boolean
    operador?: boolean
  }


  export type operadorsepGetPayload<S extends boolean | null | undefined | operadorsepArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? operadorsep :
    S extends undefined ? never :
    S extends { include: any } & (operadorsepArgs | operadorsepFindManyArgs)
    ? operadorsep 
    : S extends { select: any } & (operadorsepArgs | operadorsepFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof operadorsep ? operadorsep[P] : never
  } 
      : operadorsep


  type operadorsepCountArgs = 
    Omit<operadorsepFindManyArgs, 'select' | 'include'> & {
      select?: OperadorsepCountAggregateInputType | true
    }

  export interface operadorsepDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Operadorsep that matches the filter.
     * @param {operadorsepFindUniqueArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operadorsepFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operadorsepFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operadorsep'> extends True ? Prisma__operadorsepClient<operadorsepGetPayload<T>> : Prisma__operadorsepClient<operadorsepGetPayload<T> | null, null>

    /**
     * Find one Operadorsep that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operadorsepFindUniqueOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operadorsepFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, operadorsepFindUniqueOrThrowArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Find the first Operadorsep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operadorsepFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operadorsepFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operadorsep'> extends True ? Prisma__operadorsepClient<operadorsepGetPayload<T>> : Prisma__operadorsepClient<operadorsepGetPayload<T> | null, null>

    /**
     * Find the first Operadorsep that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operadorsepFindFirstOrThrowArgs>(
      args?: SelectSubset<T, operadorsepFindFirstOrThrowArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Find zero or more Operadorseps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany()
     * 
     * // Get first 10 Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany({ take: 10 })
     * 
     * // Only select the `idoperador`
     * const operadorsepWithIdoperadorOnly = await prisma.operadorsep.findMany({ select: { idoperador: true } })
     * 
    **/
    findMany<T extends operadorsepFindManyArgs>(
      args?: SelectSubset<T, operadorsepFindManyArgs>
    ): Prisma.PrismaPromise<Array<operadorsepGetPayload<T>>>

    /**
     * Create a Operadorsep.
     * @param {operadorsepCreateArgs} args - Arguments to create a Operadorsep.
     * @example
     * // Create one Operadorsep
     * const Operadorsep = await prisma.operadorsep.create({
     *   data: {
     *     // ... data to create a Operadorsep
     *   }
     * })
     * 
    **/
    create<T extends operadorsepCreateArgs>(
      args: SelectSubset<T, operadorsepCreateArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Create many Operadorseps.
     *     @param {operadorsepCreateManyArgs} args - Arguments to create many Operadorseps.
     *     @example
     *     // Create many Operadorseps
     *     const operadorsep = await prisma.operadorsep.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operadorsepCreateManyArgs>(
      args?: SelectSubset<T, operadorsepCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operadorsep.
     * @param {operadorsepDeleteArgs} args - Arguments to delete one Operadorsep.
     * @example
     * // Delete one Operadorsep
     * const Operadorsep = await prisma.operadorsep.delete({
     *   where: {
     *     // ... filter to delete one Operadorsep
     *   }
     * })
     * 
    **/
    delete<T extends operadorsepDeleteArgs>(
      args: SelectSubset<T, operadorsepDeleteArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Update one Operadorsep.
     * @param {operadorsepUpdateArgs} args - Arguments to update one Operadorsep.
     * @example
     * // Update one Operadorsep
     * const operadorsep = await prisma.operadorsep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operadorsepUpdateArgs>(
      args: SelectSubset<T, operadorsepUpdateArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Delete zero or more Operadorseps.
     * @param {operadorsepDeleteManyArgs} args - Arguments to filter Operadorseps to delete.
     * @example
     * // Delete a few Operadorseps
     * const { count } = await prisma.operadorsep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operadorsepDeleteManyArgs>(
      args?: SelectSubset<T, operadorsepDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operadorseps
     * const operadorsep = await prisma.operadorsep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operadorsepUpdateManyArgs>(
      args: SelectSubset<T, operadorsepUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operadorsep.
     * @param {operadorsepUpsertArgs} args - Arguments to update or create a Operadorsep.
     * @example
     * // Update or create a Operadorsep
     * const operadorsep = await prisma.operadorsep.upsert({
     *   create: {
     *     // ... data to create a Operadorsep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operadorsep we want to update
     *   }
     * })
    **/
    upsert<T extends operadorsepUpsertArgs>(
      args: SelectSubset<T, operadorsepUpsertArgs>
    ): Prisma__operadorsepClient<operadorsepGetPayload<T>>

    /**
     * Count the number of Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepCountArgs} args - Arguments to filter Operadorseps to count.
     * @example
     * // Count the number of Operadorseps
     * const count = await prisma.operadorsep.count({
     *   where: {
     *     // ... the filter for the Operadorseps we want to count
     *   }
     * })
    **/
    count<T extends operadorsepCountArgs>(
      args?: Subset<T, operadorsepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperadorsepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperadorsepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperadorsepAggregateArgs>(args: Subset<T, OperadorsepAggregateArgs>): Prisma.PrismaPromise<GetOperadorsepAggregateType<T>>

    /**
     * Group by Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperadorsepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperadorsepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperadorsepGroupByArgs['orderBy'] }
        : { orderBy?: OperadorsepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperadorsepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperadorsepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operadorsep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operadorsepClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operadorsep base type for findUnique actions
   */
  export type operadorsepFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }

  /**
   * operadorsep findUnique
   */
  export interface operadorsepFindUniqueArgs extends operadorsepFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findUniqueOrThrow
   */
  export type operadorsepFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep base type for findFirst actions
   */
  export type operadorsepFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: Enumerable<operadorsepOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: Enumerable<OperadorsepScalarFieldEnum>
  }

  /**
   * operadorsep findFirst
   */
  export interface operadorsepFindFirstArgs extends operadorsepFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findFirstOrThrow
   */
  export type operadorsepFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: Enumerable<operadorsepOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: Enumerable<OperadorsepScalarFieldEnum>
  }


  /**
   * operadorsep findMany
   */
  export type operadorsepFindManyArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter, which operadorseps to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: Enumerable<operadorsepOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    distinct?: Enumerable<OperadorsepScalarFieldEnum>
  }


  /**
   * operadorsep create
   */
  export type operadorsepCreateArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * The data needed to create a operadorsep.
     */
    data: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
  }


  /**
   * operadorsep createMany
   */
  export type operadorsepCreateManyArgs = {
    /**
     * The data used to create many operadorseps.
     */
    data: Enumerable<operadorsepCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * operadorsep update
   */
  export type operadorsepUpdateArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * The data needed to update a operadorsep.
     */
    data: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
    /**
     * Choose, which operadorsep to update.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep updateMany
   */
  export type operadorsepUpdateManyArgs = {
    /**
     * The data used to update operadorseps.
     */
    data: XOR<operadorsepUpdateManyMutationInput, operadorsepUncheckedUpdateManyInput>
    /**
     * Filter which operadorseps to update
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep upsert
   */
  export type operadorsepUpsertArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * The filter to search for the operadorsep to update in case it exists.
     */
    where: operadorsepWhereUniqueInput
    /**
     * In case the operadorsep found by the `where` argument doesn't exist, create a new operadorsep with this data.
     */
    create: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
    /**
     * In case the operadorsep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
  }


  /**
   * operadorsep delete
   */
  export type operadorsepDeleteArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
    /**
     * Filter which operadorsep to delete.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep deleteMany
   */
  export type operadorsepDeleteManyArgs = {
    /**
     * Filter which operadorseps to delete
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep without action
   */
  export type operadorsepArgs = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect | null
  }



  /**
   * Model parcelas
   */


  export type AggregateParcelas = {
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  export type ParcelasAvgAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasSumAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasMinAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasMaxAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasCountAggregateOutputType = {
    idparcela: number
    idservicio: number
    dni_extinto: number
    ficha: number
    parcela: number
    mza: number
    lote: number
    asignada: number
    fecha: number
    cementerio: number
    operador: number
    fecha_alta: number
    operador_asignacion: number
    fecha_asignacion: number
    lugares: number
    _all: number
  }


  export type ParcelasAvgAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasSumAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasMinAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasMaxAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasCountAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
    _all?: true
  }

  export type ParcelasAggregateArgs = {
    /**
     * Filter which parcelas to aggregate.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: Enumerable<parcelasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parcelas
    **/
    _count?: true | ParcelasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParcelasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParcelasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcelasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcelasMaxAggregateInputType
  }

  export type GetParcelasAggregateType<T extends ParcelasAggregateArgs> = {
        [P in keyof T & keyof AggregateParcelas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcelas[P]>
      : GetScalarType<T[P], AggregateParcelas[P]>
  }




  export type ParcelasGroupByArgs = {
    where?: parcelasWhereInput
    orderBy?: Enumerable<parcelasOrderByWithAggregationInput>
    by: ParcelasScalarFieldEnum[]
    having?: parcelasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcelasCountAggregateInputType | true
    _avg?: ParcelasAvgAggregateInputType
    _sum?: ParcelasSumAggregateInputType
    _min?: ParcelasMinAggregateInputType
    _max?: ParcelasMaxAggregateInputType
  }


  export type ParcelasGroupByOutputType = {
    idparcela: number
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  type GetParcelasGroupByPayload<T extends ParcelasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ParcelasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcelasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
        }
      >
    >


  export type parcelasSelect = {
    idparcela?: boolean
    idservicio?: boolean
    dni_extinto?: boolean
    ficha?: boolean
    parcela?: boolean
    mza?: boolean
    lote?: boolean
    asignada?: boolean
    fecha?: boolean
    cementerio?: boolean
    operador?: boolean
    fecha_alta?: boolean
    operador_asignacion?: boolean
    fecha_asignacion?: boolean
    lugares?: boolean
  }


  export type parcelasGetPayload<S extends boolean | null | undefined | parcelasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? parcelas :
    S extends undefined ? never :
    S extends { include: any } & (parcelasArgs | parcelasFindManyArgs)
    ? parcelas 
    : S extends { select: any } & (parcelasArgs | parcelasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof parcelas ? parcelas[P] : never
  } 
      : parcelas


  type parcelasCountArgs = 
    Omit<parcelasFindManyArgs, 'select' | 'include'> & {
      select?: ParcelasCountAggregateInputType | true
    }

  export interface parcelasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Parcelas that matches the filter.
     * @param {parcelasFindUniqueArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parcelasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parcelasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parcelas'> extends True ? Prisma__parcelasClient<parcelasGetPayload<T>> : Prisma__parcelasClient<parcelasGetPayload<T> | null, null>

    /**
     * Find one Parcelas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parcelasFindUniqueOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parcelasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, parcelasFindUniqueOrThrowArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Find the first Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parcelasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parcelasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parcelas'> extends True ? Prisma__parcelasClient<parcelasGetPayload<T>> : Prisma__parcelasClient<parcelasGetPayload<T> | null, null>

    /**
     * Find the first Parcelas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parcelasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parcelasFindFirstOrThrowArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Find zero or more Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas
     * const parcelas = await prisma.parcelas.findMany()
     * 
     * // Get first 10 Parcelas
     * const parcelas = await prisma.parcelas.findMany({ take: 10 })
     * 
     * // Only select the `idparcela`
     * const parcelasWithIdparcelaOnly = await prisma.parcelas.findMany({ select: { idparcela: true } })
     * 
    **/
    findMany<T extends parcelasFindManyArgs>(
      args?: SelectSubset<T, parcelasFindManyArgs>
    ): Prisma.PrismaPromise<Array<parcelasGetPayload<T>>>

    /**
     * Create a Parcelas.
     * @param {parcelasCreateArgs} args - Arguments to create a Parcelas.
     * @example
     * // Create one Parcelas
     * const Parcelas = await prisma.parcelas.create({
     *   data: {
     *     // ... data to create a Parcelas
     *   }
     * })
     * 
    **/
    create<T extends parcelasCreateArgs>(
      args: SelectSubset<T, parcelasCreateArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Create many Parcelas.
     *     @param {parcelasCreateManyArgs} args - Arguments to create many Parcelas.
     *     @example
     *     // Create many Parcelas
     *     const parcelas = await prisma.parcelas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends parcelasCreateManyArgs>(
      args?: SelectSubset<T, parcelasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcelas.
     * @param {parcelasDeleteArgs} args - Arguments to delete one Parcelas.
     * @example
     * // Delete one Parcelas
     * const Parcelas = await prisma.parcelas.delete({
     *   where: {
     *     // ... filter to delete one Parcelas
     *   }
     * })
     * 
    **/
    delete<T extends parcelasDeleteArgs>(
      args: SelectSubset<T, parcelasDeleteArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Update one Parcelas.
     * @param {parcelasUpdateArgs} args - Arguments to update one Parcelas.
     * @example
     * // Update one Parcelas
     * const parcelas = await prisma.parcelas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parcelasUpdateArgs>(
      args: SelectSubset<T, parcelasUpdateArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Delete zero or more Parcelas.
     * @param {parcelasDeleteManyArgs} args - Arguments to filter Parcelas to delete.
     * @example
     * // Delete a few Parcelas
     * const { count } = await prisma.parcelas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parcelasDeleteManyArgs>(
      args?: SelectSubset<T, parcelasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas
     * const parcelas = await prisma.parcelas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parcelasUpdateManyArgs>(
      args: SelectSubset<T, parcelasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcelas.
     * @param {parcelasUpsertArgs} args - Arguments to update or create a Parcelas.
     * @example
     * // Update or create a Parcelas
     * const parcelas = await prisma.parcelas.upsert({
     *   create: {
     *     // ... data to create a Parcelas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcelas we want to update
     *   }
     * })
    **/
    upsert<T extends parcelasUpsertArgs>(
      args: SelectSubset<T, parcelasUpsertArgs>
    ): Prisma__parcelasClient<parcelasGetPayload<T>>

    /**
     * Count the number of Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasCountArgs} args - Arguments to filter Parcelas to count.
     * @example
     * // Count the number of Parcelas
     * const count = await prisma.parcelas.count({
     *   where: {
     *     // ... the filter for the Parcelas we want to count
     *   }
     * })
    **/
    count<T extends parcelasCountArgs>(
      args?: Subset<T, parcelasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcelasAggregateArgs>(args: Subset<T, ParcelasAggregateArgs>): Prisma.PrismaPromise<GetParcelasAggregateType<T>>

    /**
     * Group by Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParcelasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParcelasGroupByArgs['orderBy'] }
        : { orderBy?: ParcelasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParcelasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parcelas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parcelasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parcelas base type for findUnique actions
   */
  export type parcelasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }

  /**
   * parcelas findUnique
   */
  export interface parcelasFindUniqueArgs extends parcelasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findUniqueOrThrow
   */
  export type parcelasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas base type for findFirst actions
   */
  export type parcelasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: Enumerable<parcelasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: Enumerable<ParcelasScalarFieldEnum>
  }

  /**
   * parcelas findFirst
   */
  export interface parcelasFindFirstArgs extends parcelasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findFirstOrThrow
   */
  export type parcelasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: Enumerable<parcelasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: Enumerable<ParcelasScalarFieldEnum>
  }


  /**
   * parcelas findMany
   */
  export type parcelasFindManyArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: Enumerable<parcelasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    distinct?: Enumerable<ParcelasScalarFieldEnum>
  }


  /**
   * parcelas create
   */
  export type parcelasCreateArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * The data needed to create a parcelas.
     */
    data: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
  }


  /**
   * parcelas createMany
   */
  export type parcelasCreateManyArgs = {
    /**
     * The data used to create many parcelas.
     */
    data: Enumerable<parcelasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * parcelas update
   */
  export type parcelasUpdateArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * The data needed to update a parcelas.
     */
    data: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
    /**
     * Choose, which parcelas to update.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas updateMany
   */
  export type parcelasUpdateManyArgs = {
    /**
     * The data used to update parcelas.
     */
    data: XOR<parcelasUpdateManyMutationInput, parcelasUncheckedUpdateManyInput>
    /**
     * Filter which parcelas to update
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas upsert
   */
  export type parcelasUpsertArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * The filter to search for the parcelas to update in case it exists.
     */
    where: parcelasWhereUniqueInput
    /**
     * In case the parcelas found by the `where` argument doesn't exist, create a new parcelas with this data.
     */
    create: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
    /**
     * In case the parcelas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
  }


  /**
   * parcelas delete
   */
  export type parcelasDeleteArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
    /**
     * Filter which parcelas to delete.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas deleteMany
   */
  export type parcelasDeleteManyArgs = {
    /**
     * Filter which parcelas to delete
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas without action
   */
  export type parcelasArgs = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect | null
  }



  /**
   * Model planificacion_guardias
   */


  export type AggregatePlanificacion_guardias = {
    _count: Planificacion_guardiasCountAggregateOutputType | null
    _avg: Planificacion_guardiasAvgAggregateOutputType | null
    _sum: Planificacion_guardiasSumAggregateOutputType | null
    _min: Planificacion_guardiasMinAggregateOutputType | null
    _max: Planificacion_guardiasMaxAggregateOutputType | null
  }

  export type Planificacion_guardiasAvgAggregateOutputType = {
    idturno: number | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasSumAggregateOutputType = {
    idturno: number | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasMinAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: Date | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasMaxAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: Date | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasCountAggregateOutputType = {
    idturno: number
    lugar: number
    inicio: number
    fin: number
    horas: number
    operador: number
    mes_planificacion: number
    feriado: number
    tarea: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    aprobado: number
    fecha_aprobacion: number
    operadorap: number
    ano_planificacion: number
    _all: number
  }


  export type Planificacion_guardiasAvgAggregateInputType = {
    idturno?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasSumAggregateInputType = {
    idturno?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasMinAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasMaxAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasCountAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
    _all?: true
  }

  export type Planificacion_guardiasAggregateArgs = {
    /**
     * Filter which planificacion_guardias to aggregate.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: Enumerable<planificacion_guardiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planificacion_guardias
    **/
    _count?: true | Planificacion_guardiasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Planificacion_guardiasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Planificacion_guardiasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Planificacion_guardiasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Planificacion_guardiasMaxAggregateInputType
  }

  export type GetPlanificacion_guardiasAggregateType<T extends Planificacion_guardiasAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanificacion_guardias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanificacion_guardias[P]>
      : GetScalarType<T[P], AggregatePlanificacion_guardias[P]>
  }




  export type Planificacion_guardiasGroupByArgs = {
    where?: planificacion_guardiasWhereInput
    orderBy?: Enumerable<planificacion_guardiasOrderByWithAggregationInput>
    by: Planificacion_guardiasScalarFieldEnum[]
    having?: planificacion_guardiasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Planificacion_guardiasCountAggregateInputType | true
    _avg?: Planificacion_guardiasAvgAggregateInputType
    _sum?: Planificacion_guardiasSumAggregateInputType
    _min?: Planificacion_guardiasMinAggregateInputType
    _max?: Planificacion_guardiasMaxAggregateInputType
  }


  export type Planificacion_guardiasGroupByOutputType = {
    idturno: number
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: Date | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
    _count: Planificacion_guardiasCountAggregateOutputType | null
    _avg: Planificacion_guardiasAvgAggregateOutputType | null
    _sum: Planificacion_guardiasSumAggregateOutputType | null
    _min: Planificacion_guardiasMinAggregateOutputType | null
    _max: Planificacion_guardiasMaxAggregateOutputType | null
  }

  type GetPlanificacion_guardiasGroupByPayload<T extends Planificacion_guardiasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Planificacion_guardiasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Planificacion_guardiasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Planificacion_guardiasGroupByOutputType[P]>
            : GetScalarType<T[P], Planificacion_guardiasGroupByOutputType[P]>
        }
      >
    >


  export type planificacion_guardiasSelect = {
    idturno?: boolean
    lugar?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    operador?: boolean
    mes_planificacion?: boolean
    feriado?: boolean
    tarea?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    ano_planificacion?: boolean
  }


  export type planificacion_guardiasGetPayload<S extends boolean | null | undefined | planificacion_guardiasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? planificacion_guardias :
    S extends undefined ? never :
    S extends { include: any } & (planificacion_guardiasArgs | planificacion_guardiasFindManyArgs)
    ? planificacion_guardias 
    : S extends { select: any } & (planificacion_guardiasArgs | planificacion_guardiasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof planificacion_guardias ? planificacion_guardias[P] : never
  } 
      : planificacion_guardias


  type planificacion_guardiasCountArgs = 
    Omit<planificacion_guardiasFindManyArgs, 'select' | 'include'> & {
      select?: Planificacion_guardiasCountAggregateInputType | true
    }

  export interface planificacion_guardiasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Planificacion_guardias that matches the filter.
     * @param {planificacion_guardiasFindUniqueArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planificacion_guardiasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, planificacion_guardiasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'planificacion_guardias'> extends True ? Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>> : Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T> | null, null>

    /**
     * Find one Planificacion_guardias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planificacion_guardiasFindUniqueOrThrowArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planificacion_guardiasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, planificacion_guardiasFindUniqueOrThrowArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Find the first Planificacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindFirstArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planificacion_guardiasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, planificacion_guardiasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'planificacion_guardias'> extends True ? Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>> : Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T> | null, null>

    /**
     * Find the first Planificacion_guardias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindFirstOrThrowArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planificacion_guardiasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, planificacion_guardiasFindFirstOrThrowArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Find zero or more Planificacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findMany()
     * 
     * // Get first 10 Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findMany({ take: 10 })
     * 
     * // Only select the `idturno`
     * const planificacion_guardiasWithIdturnoOnly = await prisma.planificacion_guardias.findMany({ select: { idturno: true } })
     * 
    **/
    findMany<T extends planificacion_guardiasFindManyArgs>(
      args?: SelectSubset<T, planificacion_guardiasFindManyArgs>
    ): Prisma.PrismaPromise<Array<planificacion_guardiasGetPayload<T>>>

    /**
     * Create a Planificacion_guardias.
     * @param {planificacion_guardiasCreateArgs} args - Arguments to create a Planificacion_guardias.
     * @example
     * // Create one Planificacion_guardias
     * const Planificacion_guardias = await prisma.planificacion_guardias.create({
     *   data: {
     *     // ... data to create a Planificacion_guardias
     *   }
     * })
     * 
    **/
    create<T extends planificacion_guardiasCreateArgs>(
      args: SelectSubset<T, planificacion_guardiasCreateArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Create many Planificacion_guardias.
     *     @param {planificacion_guardiasCreateManyArgs} args - Arguments to create many Planificacion_guardias.
     *     @example
     *     // Create many Planificacion_guardias
     *     const planificacion_guardias = await prisma.planificacion_guardias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planificacion_guardiasCreateManyArgs>(
      args?: SelectSubset<T, planificacion_guardiasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Planificacion_guardias.
     * @param {planificacion_guardiasDeleteArgs} args - Arguments to delete one Planificacion_guardias.
     * @example
     * // Delete one Planificacion_guardias
     * const Planificacion_guardias = await prisma.planificacion_guardias.delete({
     *   where: {
     *     // ... filter to delete one Planificacion_guardias
     *   }
     * })
     * 
    **/
    delete<T extends planificacion_guardiasDeleteArgs>(
      args: SelectSubset<T, planificacion_guardiasDeleteArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Update one Planificacion_guardias.
     * @param {planificacion_guardiasUpdateArgs} args - Arguments to update one Planificacion_guardias.
     * @example
     * // Update one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planificacion_guardiasUpdateArgs>(
      args: SelectSubset<T, planificacion_guardiasUpdateArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Delete zero or more Planificacion_guardias.
     * @param {planificacion_guardiasDeleteManyArgs} args - Arguments to filter Planificacion_guardias to delete.
     * @example
     * // Delete a few Planificacion_guardias
     * const { count } = await prisma.planificacion_guardias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planificacion_guardiasDeleteManyArgs>(
      args?: SelectSubset<T, planificacion_guardiasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planificacion_guardiasUpdateManyArgs>(
      args: SelectSubset<T, planificacion_guardiasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planificacion_guardias.
     * @param {planificacion_guardiasUpsertArgs} args - Arguments to update or create a Planificacion_guardias.
     * @example
     * // Update or create a Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.upsert({
     *   create: {
     *     // ... data to create a Planificacion_guardias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planificacion_guardias we want to update
     *   }
     * })
    **/
    upsert<T extends planificacion_guardiasUpsertArgs>(
      args: SelectSubset<T, planificacion_guardiasUpsertArgs>
    ): Prisma__planificacion_guardiasClient<planificacion_guardiasGetPayload<T>>

    /**
     * Count the number of Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasCountArgs} args - Arguments to filter Planificacion_guardias to count.
     * @example
     * // Count the number of Planificacion_guardias
     * const count = await prisma.planificacion_guardias.count({
     *   where: {
     *     // ... the filter for the Planificacion_guardias we want to count
     *   }
     * })
    **/
    count<T extends planificacion_guardiasCountArgs>(
      args?: Subset<T, planificacion_guardiasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Planificacion_guardiasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Planificacion_guardiasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Planificacion_guardiasAggregateArgs>(args: Subset<T, Planificacion_guardiasAggregateArgs>): Prisma.PrismaPromise<GetPlanificacion_guardiasAggregateType<T>>

    /**
     * Group by Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Planificacion_guardiasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Planificacion_guardiasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Planificacion_guardiasGroupByArgs['orderBy'] }
        : { orderBy?: Planificacion_guardiasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Planificacion_guardiasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanificacion_guardiasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for planificacion_guardias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__planificacion_guardiasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * planificacion_guardias base type for findUnique actions
   */
  export type planificacion_guardiasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where: planificacion_guardiasWhereUniqueInput
  }

  /**
   * planificacion_guardias findUnique
   */
  export interface planificacion_guardiasFindUniqueArgs extends planificacion_guardiasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planificacion_guardias findUniqueOrThrow
   */
  export type planificacion_guardiasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias base type for findFirst actions
   */
  export type planificacion_guardiasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: Enumerable<planificacion_guardiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planificacion_guardias.
     */
    distinct?: Enumerable<Planificacion_guardiasScalarFieldEnum>
  }

  /**
   * planificacion_guardias findFirst
   */
  export interface planificacion_guardiasFindFirstArgs extends planificacion_guardiasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planificacion_guardias findFirstOrThrow
   */
  export type planificacion_guardiasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: Enumerable<planificacion_guardiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planificacion_guardias.
     */
    distinct?: Enumerable<Planificacion_guardiasScalarFieldEnum>
  }


  /**
   * planificacion_guardias findMany
   */
  export type planificacion_guardiasFindManyArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: Enumerable<planificacion_guardiasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    distinct?: Enumerable<Planificacion_guardiasScalarFieldEnum>
  }


  /**
   * planificacion_guardias create
   */
  export type planificacion_guardiasCreateArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * The data needed to create a planificacion_guardias.
     */
    data: XOR<planificacion_guardiasCreateInput, planificacion_guardiasUncheckedCreateInput>
  }


  /**
   * planificacion_guardias createMany
   */
  export type planificacion_guardiasCreateManyArgs = {
    /**
     * The data used to create many planificacion_guardias.
     */
    data: Enumerable<planificacion_guardiasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * planificacion_guardias update
   */
  export type planificacion_guardiasUpdateArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * The data needed to update a planificacion_guardias.
     */
    data: XOR<planificacion_guardiasUpdateInput, planificacion_guardiasUncheckedUpdateInput>
    /**
     * Choose, which planificacion_guardias to update.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias updateMany
   */
  export type planificacion_guardiasUpdateManyArgs = {
    /**
     * The data used to update planificacion_guardias.
     */
    data: XOR<planificacion_guardiasUpdateManyMutationInput, planificacion_guardiasUncheckedUpdateManyInput>
    /**
     * Filter which planificacion_guardias to update
     */
    where?: planificacion_guardiasWhereInput
  }


  /**
   * planificacion_guardias upsert
   */
  export type planificacion_guardiasUpsertArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * The filter to search for the planificacion_guardias to update in case it exists.
     */
    where: planificacion_guardiasWhereUniqueInput
    /**
     * In case the planificacion_guardias found by the `where` argument doesn't exist, create a new planificacion_guardias with this data.
     */
    create: XOR<planificacion_guardiasCreateInput, planificacion_guardiasUncheckedCreateInput>
    /**
     * In case the planificacion_guardias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planificacion_guardiasUpdateInput, planificacion_guardiasUncheckedUpdateInput>
  }


  /**
   * planificacion_guardias delete
   */
  export type planificacion_guardiasDeleteArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
    /**
     * Filter which planificacion_guardias to delete.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias deleteMany
   */
  export type planificacion_guardiasDeleteManyArgs = {
    /**
     * Filter which planificacion_guardias to delete
     */
    where?: planificacion_guardiasWhereInput
  }


  /**
   * planificacion_guardias without action
   */
  export type planificacion_guardiasArgs = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect | null
  }



  /**
   * Model precio_servicio
   */


  export type AggregatePrecio_servicio = {
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  export type Precio_servicioAvgAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioSumAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioMinAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioMaxAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioCountAggregateOutputType = {
    idprecio: number
    codigo: number
    contado: number
    contado_cremacion: number
    descuento1: number
    descuento1_cremacion: number
    descuento2: number
    descuento2_cremacion: number
    fecha_vigencia: number
    _all: number
  }


  export type Precio_servicioAvgAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioSumAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioMinAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioMaxAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioCountAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
    _all?: true
  }

  export type Precio_servicioAggregateArgs = {
    /**
     * Filter which precio_servicio to aggregate.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: Enumerable<precio_servicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned precio_servicios
    **/
    _count?: true | Precio_servicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Precio_servicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Precio_servicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Precio_servicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Precio_servicioMaxAggregateInputType
  }

  export type GetPrecio_servicioAggregateType<T extends Precio_servicioAggregateArgs> = {
        [P in keyof T & keyof AggregatePrecio_servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrecio_servicio[P]>
      : GetScalarType<T[P], AggregatePrecio_servicio[P]>
  }




  export type Precio_servicioGroupByArgs = {
    where?: precio_servicioWhereInput
    orderBy?: Enumerable<precio_servicioOrderByWithAggregationInput>
    by: Precio_servicioScalarFieldEnum[]
    having?: precio_servicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Precio_servicioCountAggregateInputType | true
    _avg?: Precio_servicioAvgAggregateInputType
    _sum?: Precio_servicioSumAggregateInputType
    _min?: Precio_servicioMinAggregateInputType
    _max?: Precio_servicioMaxAggregateInputType
  }


  export type Precio_servicioGroupByOutputType = {
    idprecio: number
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  type GetPrecio_servicioGroupByPayload<T extends Precio_servicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Precio_servicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Precio_servicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
            : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
        }
      >
    >


  export type precio_servicioSelect = {
    idprecio?: boolean
    codigo?: boolean
    contado?: boolean
    contado_cremacion?: boolean
    descuento1?: boolean
    descuento1_cremacion?: boolean
    descuento2?: boolean
    descuento2_cremacion?: boolean
    fecha_vigencia?: boolean
  }


  export type precio_servicioGetPayload<S extends boolean | null | undefined | precio_servicioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? precio_servicio :
    S extends undefined ? never :
    S extends { include: any } & (precio_servicioArgs | precio_servicioFindManyArgs)
    ? precio_servicio 
    : S extends { select: any } & (precio_servicioArgs | precio_servicioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof precio_servicio ? precio_servicio[P] : never
  } 
      : precio_servicio


  type precio_servicioCountArgs = 
    Omit<precio_servicioFindManyArgs, 'select' | 'include'> & {
      select?: Precio_servicioCountAggregateInputType | true
    }

  export interface precio_servicioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Precio_servicio that matches the filter.
     * @param {precio_servicioFindUniqueArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends precio_servicioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, precio_servicioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<precio_servicioGetPayload<T>> : Prisma__precio_servicioClient<precio_servicioGetPayload<T> | null, null>

    /**
     * Find one Precio_servicio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {precio_servicioFindUniqueOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends precio_servicioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, precio_servicioFindUniqueOrThrowArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Find the first Precio_servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends precio_servicioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, precio_servicioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<precio_servicioGetPayload<T>> : Prisma__precio_servicioClient<precio_servicioGetPayload<T> | null, null>

    /**
     * Find the first Precio_servicio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends precio_servicioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, precio_servicioFindFirstOrThrowArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Find zero or more Precio_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany()
     * 
     * // Get first 10 Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const precio_servicioWithIdprecioOnly = await prisma.precio_servicio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends precio_servicioFindManyArgs>(
      args?: SelectSubset<T, precio_servicioFindManyArgs>
    ): Prisma.PrismaPromise<Array<precio_servicioGetPayload<T>>>

    /**
     * Create a Precio_servicio.
     * @param {precio_servicioCreateArgs} args - Arguments to create a Precio_servicio.
     * @example
     * // Create one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.create({
     *   data: {
     *     // ... data to create a Precio_servicio
     *   }
     * })
     * 
    **/
    create<T extends precio_servicioCreateArgs>(
      args: SelectSubset<T, precio_servicioCreateArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Create many Precio_servicios.
     *     @param {precio_servicioCreateManyArgs} args - Arguments to create many Precio_servicios.
     *     @example
     *     // Create many Precio_servicios
     *     const precio_servicio = await prisma.precio_servicio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends precio_servicioCreateManyArgs>(
      args?: SelectSubset<T, precio_servicioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Precio_servicio.
     * @param {precio_servicioDeleteArgs} args - Arguments to delete one Precio_servicio.
     * @example
     * // Delete one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.delete({
     *   where: {
     *     // ... filter to delete one Precio_servicio
     *   }
     * })
     * 
    **/
    delete<T extends precio_servicioDeleteArgs>(
      args: SelectSubset<T, precio_servicioDeleteArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Update one Precio_servicio.
     * @param {precio_servicioUpdateArgs} args - Arguments to update one Precio_servicio.
     * @example
     * // Update one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends precio_servicioUpdateArgs>(
      args: SelectSubset<T, precio_servicioUpdateArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Delete zero or more Precio_servicios.
     * @param {precio_servicioDeleteManyArgs} args - Arguments to filter Precio_servicios to delete.
     * @example
     * // Delete a few Precio_servicios
     * const { count } = await prisma.precio_servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends precio_servicioDeleteManyArgs>(
      args?: SelectSubset<T, precio_servicioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Precio_servicios
     * const precio_servicio = await prisma.precio_servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends precio_servicioUpdateManyArgs>(
      args: SelectSubset<T, precio_servicioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Precio_servicio.
     * @param {precio_servicioUpsertArgs} args - Arguments to update or create a Precio_servicio.
     * @example
     * // Update or create a Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.upsert({
     *   create: {
     *     // ... data to create a Precio_servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Precio_servicio we want to update
     *   }
     * })
    **/
    upsert<T extends precio_servicioUpsertArgs>(
      args: SelectSubset<T, precio_servicioUpsertArgs>
    ): Prisma__precio_servicioClient<precio_servicioGetPayload<T>>

    /**
     * Count the number of Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioCountArgs} args - Arguments to filter Precio_servicios to count.
     * @example
     * // Count the number of Precio_servicios
     * const count = await prisma.precio_servicio.count({
     *   where: {
     *     // ... the filter for the Precio_servicios we want to count
     *   }
     * })
    **/
    count<T extends precio_servicioCountArgs>(
      args?: Subset<T, precio_servicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Precio_servicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Precio_servicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Precio_servicioAggregateArgs>(args: Subset<T, Precio_servicioAggregateArgs>): Prisma.PrismaPromise<GetPrecio_servicioAggregateType<T>>

    /**
     * Group by Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Precio_servicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Precio_servicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Precio_servicioGroupByArgs['orderBy'] }
        : { orderBy?: Precio_servicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Precio_servicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrecio_servicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for precio_servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__precio_servicioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * precio_servicio base type for findUnique actions
   */
  export type precio_servicioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }

  /**
   * precio_servicio findUnique
   */
  export interface precio_servicioFindUniqueArgs extends precio_servicioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findUniqueOrThrow
   */
  export type precio_servicioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio base type for findFirst actions
   */
  export type precio_servicioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: Enumerable<precio_servicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Enumerable<Precio_servicioScalarFieldEnum>
  }

  /**
   * precio_servicio findFirst
   */
  export interface precio_servicioFindFirstArgs extends precio_servicioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findFirstOrThrow
   */
  export type precio_servicioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: Enumerable<precio_servicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Enumerable<Precio_servicioScalarFieldEnum>
  }


  /**
   * precio_servicio findMany
   */
  export type precio_servicioFindManyArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter, which precio_servicios to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: Enumerable<precio_servicioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    distinct?: Enumerable<Precio_servicioScalarFieldEnum>
  }


  /**
   * precio_servicio create
   */
  export type precio_servicioCreateArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * The data needed to create a precio_servicio.
     */
    data: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
  }


  /**
   * precio_servicio createMany
   */
  export type precio_servicioCreateManyArgs = {
    /**
     * The data used to create many precio_servicios.
     */
    data: Enumerable<precio_servicioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * precio_servicio update
   */
  export type precio_servicioUpdateArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * The data needed to update a precio_servicio.
     */
    data: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
    /**
     * Choose, which precio_servicio to update.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio updateMany
   */
  export type precio_servicioUpdateManyArgs = {
    /**
     * The data used to update precio_servicios.
     */
    data: XOR<precio_servicioUpdateManyMutationInput, precio_servicioUncheckedUpdateManyInput>
    /**
     * Filter which precio_servicios to update
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio upsert
   */
  export type precio_servicioUpsertArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * The filter to search for the precio_servicio to update in case it exists.
     */
    where: precio_servicioWhereUniqueInput
    /**
     * In case the precio_servicio found by the `where` argument doesn't exist, create a new precio_servicio with this data.
     */
    create: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
    /**
     * In case the precio_servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
  }


  /**
   * precio_servicio delete
   */
  export type precio_servicioDeleteArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
    /**
     * Filter which precio_servicio to delete.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio deleteMany
   */
  export type precio_servicioDeleteManyArgs = {
    /**
     * Filter which precio_servicios to delete
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio without action
   */
  export type precio_servicioArgs = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect | null
  }



  /**
   * Model proveedores
   */


  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresCountAggregateOutputType = {
    idproveedor: number
    razon: number
    cuit: number
    domicilio: number
    telefonos: number
    estado: number
    operador: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresSumAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresMinAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresCountAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs = {
    /**
     * Filter which proveedores to aggregate.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: Enumerable<proveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type ProveedoresGroupByArgs = {
    where?: proveedoresWhereInput
    orderBy?: Enumerable<proveedoresOrderByWithAggregationInput>
    by: ProveedoresScalarFieldEnum[]
    having?: proveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }


  export type ProveedoresGroupByOutputType = {
    idproveedor: number
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends ProveedoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type proveedoresSelect = {
    idproveedor?: boolean
    razon?: boolean
    cuit?: boolean
    domicilio?: boolean
    telefonos?: boolean
    estado?: boolean
    operador?: boolean
  }


  export type proveedoresGetPayload<S extends boolean | null | undefined | proveedoresArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? proveedores :
    S extends undefined ? never :
    S extends { include: any } & (proveedoresArgs | proveedoresFindManyArgs)
    ? proveedores 
    : S extends { select: any } & (proveedoresArgs | proveedoresFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof proveedores ? proveedores[P] : never
  } 
      : proveedores


  type proveedoresCountArgs = 
    Omit<proveedoresFindManyArgs, 'select' | 'include'> & {
      select?: ProveedoresCountAggregateInputType | true
    }

  export interface proveedoresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {proveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proveedoresFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, proveedoresFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'proveedores'> extends True ? Prisma__proveedoresClient<proveedoresGetPayload<T>> : Prisma__proveedoresClient<proveedoresGetPayload<T> | null, null>

    /**
     * Find one Proveedores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {proveedoresFindUniqueOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends proveedoresFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, proveedoresFindUniqueOrThrowArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proveedoresFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, proveedoresFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'proveedores'> extends True ? Prisma__proveedoresClient<proveedoresGetPayload<T>> : Prisma__proveedoresClient<proveedoresGetPayload<T> | null, null>

    /**
     * Find the first Proveedores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends proveedoresFindFirstOrThrowArgs>(
      args?: SelectSubset<T, proveedoresFindFirstOrThrowArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `idproveedor`
     * const proveedoresWithIdproveedorOnly = await prisma.proveedores.findMany({ select: { idproveedor: true } })
     * 
    **/
    findMany<T extends proveedoresFindManyArgs>(
      args?: SelectSubset<T, proveedoresFindManyArgs>
    ): Prisma.PrismaPromise<Array<proveedoresGetPayload<T>>>

    /**
     * Create a Proveedores.
     * @param {proveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
    **/
    create<T extends proveedoresCreateArgs>(
      args: SelectSubset<T, proveedoresCreateArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Create many Proveedores.
     *     @param {proveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     *     @example
     *     // Create many Proveedores
     *     const proveedores = await prisma.proveedores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proveedoresCreateManyArgs>(
      args?: SelectSubset<T, proveedoresCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedores.
     * @param {proveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
    **/
    delete<T extends proveedoresDeleteArgs>(
      args: SelectSubset<T, proveedoresDeleteArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Update one Proveedores.
     * @param {proveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proveedoresUpdateArgs>(
      args: SelectSubset<T, proveedoresUpdateArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Delete zero or more Proveedores.
     * @param {proveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proveedoresDeleteManyArgs>(
      args?: SelectSubset<T, proveedoresDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proveedoresUpdateManyArgs>(
      args: SelectSubset<T, proveedoresUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {proveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
    **/
    upsert<T extends proveedoresUpsertArgs>(
      args: SelectSubset<T, proveedoresUpsertArgs>
    ): Prisma__proveedoresClient<proveedoresGetPayload<T>>

    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends proveedoresCountArgs>(
      args?: Subset<T, proveedoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): Prisma.PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProveedoresGroupByArgs['orderBy'] }
        : { orderBy?: ProveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__proveedoresClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * proveedores base type for findUnique actions
   */
  export type proveedoresFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores findUnique
   */
  export interface proveedoresFindUniqueArgs extends proveedoresFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findUniqueOrThrow
   */
  export type proveedoresFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores base type for findFirst actions
   */
  export type proveedoresFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: Enumerable<proveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: Enumerable<ProveedoresScalarFieldEnum>
  }

  /**
   * proveedores findFirst
   */
  export interface proveedoresFindFirstArgs extends proveedoresFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findFirstOrThrow
   */
  export type proveedoresFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: Enumerable<proveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: Enumerable<ProveedoresScalarFieldEnum>
  }


  /**
   * proveedores findMany
   */
  export type proveedoresFindManyArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: Enumerable<proveedoresOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    distinct?: Enumerable<ProveedoresScalarFieldEnum>
  }


  /**
   * proveedores create
   */
  export type proveedoresCreateArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * The data needed to create a proveedores.
     */
    data: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
  }


  /**
   * proveedores createMany
   */
  export type proveedoresCreateManyArgs = {
    /**
     * The data used to create many proveedores.
     */
    data: Enumerable<proveedoresCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * proveedores update
   */
  export type proveedoresUpdateArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * The data needed to update a proveedores.
     */
    data: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
    /**
     * Choose, which proveedores to update.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores updateMany
   */
  export type proveedoresUpdateManyArgs = {
    /**
     * The data used to update proveedores.
     */
    data: XOR<proveedoresUpdateManyMutationInput, proveedoresUncheckedUpdateManyInput>
    /**
     * Filter which proveedores to update
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores upsert
   */
  export type proveedoresUpsertArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * The filter to search for the proveedores to update in case it exists.
     */
    where: proveedoresWhereUniqueInput
    /**
     * In case the proveedores found by the `where` argument doesn't exist, create a new proveedores with this data.
     */
    create: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
    /**
     * In case the proveedores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
  }


  /**
   * proveedores delete
   */
  export type proveedoresDeleteArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
    /**
     * Filter which proveedores to delete.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores deleteMany
   */
  export type proveedoresDeleteManyArgs = {
    /**
     * Filter which proveedores to delete
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores without action
   */
  export type proveedoresArgs = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect | null
  }



  /**
   * Model servicio_detalles
   */


  export type AggregateServicio_detalles = {
    _count: Servicio_detallesCountAggregateOutputType | null
    _avg: Servicio_detallesAvgAggregateOutputType | null
    _sum: Servicio_detallesSumAggregateOutputType | null
    _min: Servicio_detallesMinAggregateOutputType | null
    _max: Servicio_detallesMaxAggregateOutputType | null
  }

  export type Servicio_detallesAvgAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
  }

  export type Servicio_detallesSumAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
  }

  export type Servicio_detallesMinAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
  }

  export type Servicio_detallesMaxAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
  }

  export type Servicio_detallesCountAggregateOutputType = {
    iddetalles: number
    idservicio: number
    detalle: number
    lugar: number
    monto: number
    patente: number
    operador: number
    fecha: number
    observacion: number
    _all: number
  }


  export type Servicio_detallesAvgAggregateInputType = {
    iddetalles?: true
    idservicio?: true
  }

  export type Servicio_detallesSumAggregateInputType = {
    iddetalles?: true
    idservicio?: true
  }

  export type Servicio_detallesMinAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
  }

  export type Servicio_detallesMaxAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
  }

  export type Servicio_detallesCountAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
    _all?: true
  }

  export type Servicio_detallesAggregateArgs = {
    /**
     * Filter which servicio_detalles to aggregate.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: Enumerable<servicio_detallesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_detalles
    **/
    _count?: true | Servicio_detallesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_detallesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_detallesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_detallesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_detallesMaxAggregateInputType
  }

  export type GetServicio_detallesAggregateType<T extends Servicio_detallesAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_detalles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_detalles[P]>
      : GetScalarType<T[P], AggregateServicio_detalles[P]>
  }




  export type Servicio_detallesGroupByArgs = {
    where?: servicio_detallesWhereInput
    orderBy?: Enumerable<servicio_detallesOrderByWithAggregationInput>
    by: Servicio_detallesScalarFieldEnum[]
    having?: servicio_detallesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_detallesCountAggregateInputType | true
    _avg?: Servicio_detallesAvgAggregateInputType
    _sum?: Servicio_detallesSumAggregateInputType
    _min?: Servicio_detallesMinAggregateInputType
    _max?: Servicio_detallesMaxAggregateInputType
  }


  export type Servicio_detallesGroupByOutputType = {
    iddetalles: number
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    _count: Servicio_detallesCountAggregateOutputType | null
    _avg: Servicio_detallesAvgAggregateOutputType | null
    _sum: Servicio_detallesSumAggregateOutputType | null
    _min: Servicio_detallesMinAggregateOutputType | null
    _max: Servicio_detallesMaxAggregateOutputType | null
  }

  type GetServicio_detallesGroupByPayload<T extends Servicio_detallesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Servicio_detallesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_detallesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_detallesGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_detallesGroupByOutputType[P]>
        }
      >
    >


  export type servicio_detallesSelect = {
    iddetalles?: boolean
    idservicio?: boolean
    detalle?: boolean
    lugar?: boolean
    monto?: boolean
    patente?: boolean
    operador?: boolean
    fecha?: boolean
    observacion?: boolean
  }


  export type servicio_detallesGetPayload<S extends boolean | null | undefined | servicio_detallesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? servicio_detalles :
    S extends undefined ? never :
    S extends { include: any } & (servicio_detallesArgs | servicio_detallesFindManyArgs)
    ? servicio_detalles 
    : S extends { select: any } & (servicio_detallesArgs | servicio_detallesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof servicio_detalles ? servicio_detalles[P] : never
  } 
      : servicio_detalles


  type servicio_detallesCountArgs = 
    Omit<servicio_detallesFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_detallesCountAggregateInputType | true
    }

  export interface servicio_detallesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Servicio_detalles that matches the filter.
     * @param {servicio_detallesFindUniqueArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_detallesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_detallesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_detalles'> extends True ? Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>> : Prisma__servicio_detallesClient<servicio_detallesGetPayload<T> | null, null>

    /**
     * Find one Servicio_detalles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_detallesFindUniqueOrThrowArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_detallesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicio_detallesFindUniqueOrThrowArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Find the first Servicio_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindFirstArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_detallesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_detallesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_detalles'> extends True ? Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>> : Prisma__servicio_detallesClient<servicio_detallesGetPayload<T> | null, null>

    /**
     * Find the first Servicio_detalles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindFirstOrThrowArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_detallesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicio_detallesFindFirstOrThrowArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Find zero or more Servicio_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findMany()
     * 
     * // Get first 10 Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findMany({ take: 10 })
     * 
     * // Only select the `iddetalles`
     * const servicio_detallesWithIddetallesOnly = await prisma.servicio_detalles.findMany({ select: { iddetalles: true } })
     * 
    **/
    findMany<T extends servicio_detallesFindManyArgs>(
      args?: SelectSubset<T, servicio_detallesFindManyArgs>
    ): Prisma.PrismaPromise<Array<servicio_detallesGetPayload<T>>>

    /**
     * Create a Servicio_detalles.
     * @param {servicio_detallesCreateArgs} args - Arguments to create a Servicio_detalles.
     * @example
     * // Create one Servicio_detalles
     * const Servicio_detalles = await prisma.servicio_detalles.create({
     *   data: {
     *     // ... data to create a Servicio_detalles
     *   }
     * })
     * 
    **/
    create<T extends servicio_detallesCreateArgs>(
      args: SelectSubset<T, servicio_detallesCreateArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Create many Servicio_detalles.
     *     @param {servicio_detallesCreateManyArgs} args - Arguments to create many Servicio_detalles.
     *     @example
     *     // Create many Servicio_detalles
     *     const servicio_detalles = await prisma.servicio_detalles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_detallesCreateManyArgs>(
      args?: SelectSubset<T, servicio_detallesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_detalles.
     * @param {servicio_detallesDeleteArgs} args - Arguments to delete one Servicio_detalles.
     * @example
     * // Delete one Servicio_detalles
     * const Servicio_detalles = await prisma.servicio_detalles.delete({
     *   where: {
     *     // ... filter to delete one Servicio_detalles
     *   }
     * })
     * 
    **/
    delete<T extends servicio_detallesDeleteArgs>(
      args: SelectSubset<T, servicio_detallesDeleteArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Update one Servicio_detalles.
     * @param {servicio_detallesUpdateArgs} args - Arguments to update one Servicio_detalles.
     * @example
     * // Update one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_detallesUpdateArgs>(
      args: SelectSubset<T, servicio_detallesUpdateArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Delete zero or more Servicio_detalles.
     * @param {servicio_detallesDeleteManyArgs} args - Arguments to filter Servicio_detalles to delete.
     * @example
     * // Delete a few Servicio_detalles
     * const { count } = await prisma.servicio_detalles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_detallesDeleteManyArgs>(
      args?: SelectSubset<T, servicio_detallesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_detallesUpdateManyArgs>(
      args: SelectSubset<T, servicio_detallesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_detalles.
     * @param {servicio_detallesUpsertArgs} args - Arguments to update or create a Servicio_detalles.
     * @example
     * // Update or create a Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.upsert({
     *   create: {
     *     // ... data to create a Servicio_detalles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_detalles we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_detallesUpsertArgs>(
      args: SelectSubset<T, servicio_detallesUpsertArgs>
    ): Prisma__servicio_detallesClient<servicio_detallesGetPayload<T>>

    /**
     * Count the number of Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesCountArgs} args - Arguments to filter Servicio_detalles to count.
     * @example
     * // Count the number of Servicio_detalles
     * const count = await prisma.servicio_detalles.count({
     *   where: {
     *     // ... the filter for the Servicio_detalles we want to count
     *   }
     * })
    **/
    count<T extends servicio_detallesCountArgs>(
      args?: Subset<T, servicio_detallesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_detallesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_detallesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_detallesAggregateArgs>(args: Subset<T, Servicio_detallesAggregateArgs>): Prisma.PrismaPromise<GetServicio_detallesAggregateType<T>>

    /**
     * Group by Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_detallesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Servicio_detallesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Servicio_detallesGroupByArgs['orderBy'] }
        : { orderBy?: Servicio_detallesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Servicio_detallesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_detallesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_detalles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_detallesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_detalles base type for findUnique actions
   */
  export type servicio_detallesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where: servicio_detallesWhereUniqueInput
  }

  /**
   * servicio_detalles findUnique
   */
  export interface servicio_detallesFindUniqueArgs extends servicio_detallesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_detalles findUniqueOrThrow
   */
  export type servicio_detallesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles base type for findFirst actions
   */
  export type servicio_detallesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: Enumerable<servicio_detallesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_detalles.
     */
    distinct?: Enumerable<Servicio_detallesScalarFieldEnum>
  }

  /**
   * servicio_detalles findFirst
   */
  export interface servicio_detallesFindFirstArgs extends servicio_detallesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_detalles findFirstOrThrow
   */
  export type servicio_detallesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: Enumerable<servicio_detallesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_detalles.
     */
    distinct?: Enumerable<Servicio_detallesScalarFieldEnum>
  }


  /**
   * servicio_detalles findMany
   */
  export type servicio_detallesFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: Enumerable<servicio_detallesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    distinct?: Enumerable<Servicio_detallesScalarFieldEnum>
  }


  /**
   * servicio_detalles create
   */
  export type servicio_detallesCreateArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * The data needed to create a servicio_detalles.
     */
    data: XOR<servicio_detallesCreateInput, servicio_detallesUncheckedCreateInput>
  }


  /**
   * servicio_detalles createMany
   */
  export type servicio_detallesCreateManyArgs = {
    /**
     * The data used to create many servicio_detalles.
     */
    data: Enumerable<servicio_detallesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicio_detalles update
   */
  export type servicio_detallesUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * The data needed to update a servicio_detalles.
     */
    data: XOR<servicio_detallesUpdateInput, servicio_detallesUncheckedUpdateInput>
    /**
     * Choose, which servicio_detalles to update.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles updateMany
   */
  export type servicio_detallesUpdateManyArgs = {
    /**
     * The data used to update servicio_detalles.
     */
    data: XOR<servicio_detallesUpdateManyMutationInput, servicio_detallesUncheckedUpdateManyInput>
    /**
     * Filter which servicio_detalles to update
     */
    where?: servicio_detallesWhereInput
  }


  /**
   * servicio_detalles upsert
   */
  export type servicio_detallesUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * The filter to search for the servicio_detalles to update in case it exists.
     */
    where: servicio_detallesWhereUniqueInput
    /**
     * In case the servicio_detalles found by the `where` argument doesn't exist, create a new servicio_detalles with this data.
     */
    create: XOR<servicio_detallesCreateInput, servicio_detallesUncheckedCreateInput>
    /**
     * In case the servicio_detalles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_detallesUpdateInput, servicio_detallesUncheckedUpdateInput>
  }


  /**
   * servicio_detalles delete
   */
  export type servicio_detallesDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
    /**
     * Filter which servicio_detalles to delete.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles deleteMany
   */
  export type servicio_detallesDeleteManyArgs = {
    /**
     * Filter which servicio_detalles to delete
     */
    where?: servicio_detallesWhereInput
  }


  /**
   * servicio_detalles without action
   */
  export type servicio_detallesArgs = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect | null
  }



  /**
   * Model servicio_gastos
   */


  export type AggregateServicio_gastos = {
    _count: Servicio_gastosCountAggregateOutputType | null
    _avg: Servicio_gastosAvgAggregateOutputType | null
    _sum: Servicio_gastosSumAggregateOutputType | null
    _min: Servicio_gastosMinAggregateOutputType | null
    _max: Servicio_gastosMaxAggregateOutputType | null
  }

  export type Servicio_gastosAvgAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
  }

  export type Servicio_gastosSumAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
  }

  export type Servicio_gastosMinAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
  }

  export type Servicio_gastosMaxAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
  }

  export type Servicio_gastosCountAggregateOutputType = {
    idgastos: number
    idservicio: number
    tipo_gasto: number
    horas: number
    operador: number
    observaciones: number
    inicio: number
    fin: number
    feriado: number
    liquidado: number
    operadorliq: number
    fecha_liquidacion: number
    aprobado: number
    operadorap: number
    fecha_aprobacion: number
    _all: number
  }


  export type Servicio_gastosAvgAggregateInputType = {
    idgastos?: true
    idservicio?: true
  }

  export type Servicio_gastosSumAggregateInputType = {
    idgastos?: true
    idservicio?: true
  }

  export type Servicio_gastosMinAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
  }

  export type Servicio_gastosMaxAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
  }

  export type Servicio_gastosCountAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    _all?: true
  }

  export type Servicio_gastosAggregateArgs = {
    /**
     * Filter which servicio_gastos to aggregate.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: Enumerable<servicio_gastosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_gastos
    **/
    _count?: true | Servicio_gastosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_gastosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_gastosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_gastosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_gastosMaxAggregateInputType
  }

  export type GetServicio_gastosAggregateType<T extends Servicio_gastosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_gastos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_gastos[P]>
      : GetScalarType<T[P], AggregateServicio_gastos[P]>
  }




  export type Servicio_gastosGroupByArgs = {
    where?: servicio_gastosWhereInput
    orderBy?: Enumerable<servicio_gastosOrderByWithAggregationInput>
    by: Servicio_gastosScalarFieldEnum[]
    having?: servicio_gastosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_gastosCountAggregateInputType | true
    _avg?: Servicio_gastosAvgAggregateInputType
    _sum?: Servicio_gastosSumAggregateInputType
    _min?: Servicio_gastosMinAggregateInputType
    _max?: Servicio_gastosMaxAggregateInputType
  }


  export type Servicio_gastosGroupByOutputType = {
    idgastos: number
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    _count: Servicio_gastosCountAggregateOutputType | null
    _avg: Servicio_gastosAvgAggregateOutputType | null
    _sum: Servicio_gastosSumAggregateOutputType | null
    _min: Servicio_gastosMinAggregateOutputType | null
    _max: Servicio_gastosMaxAggregateOutputType | null
  }

  type GetServicio_gastosGroupByPayload<T extends Servicio_gastosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Servicio_gastosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_gastosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_gastosGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_gastosGroupByOutputType[P]>
        }
      >
    >


  export type servicio_gastosSelect = {
    idgastos?: boolean
    idservicio?: boolean
    tipo_gasto?: boolean
    horas?: boolean
    operador?: boolean
    observaciones?: boolean
    inicio?: boolean
    fin?: boolean
    feriado?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
  }


  export type servicio_gastosGetPayload<S extends boolean | null | undefined | servicio_gastosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? servicio_gastos :
    S extends undefined ? never :
    S extends { include: any } & (servicio_gastosArgs | servicio_gastosFindManyArgs)
    ? servicio_gastos 
    : S extends { select: any } & (servicio_gastosArgs | servicio_gastosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof servicio_gastos ? servicio_gastos[P] : never
  } 
      : servicio_gastos


  type servicio_gastosCountArgs = 
    Omit<servicio_gastosFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_gastosCountAggregateInputType | true
    }

  export interface servicio_gastosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Servicio_gastos that matches the filter.
     * @param {servicio_gastosFindUniqueArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_gastosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_gastosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_gastos'> extends True ? Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>> : Prisma__servicio_gastosClient<servicio_gastosGetPayload<T> | null, null>

    /**
     * Find one Servicio_gastos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_gastosFindUniqueOrThrowArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_gastosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicio_gastosFindUniqueOrThrowArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Find the first Servicio_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindFirstArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_gastosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_gastosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_gastos'> extends True ? Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>> : Prisma__servicio_gastosClient<servicio_gastosGetPayload<T> | null, null>

    /**
     * Find the first Servicio_gastos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindFirstOrThrowArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_gastosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicio_gastosFindFirstOrThrowArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Find zero or more Servicio_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findMany()
     * 
     * // Get first 10 Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const servicio_gastosWithIdgastosOnly = await prisma.servicio_gastos.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends servicio_gastosFindManyArgs>(
      args?: SelectSubset<T, servicio_gastosFindManyArgs>
    ): Prisma.PrismaPromise<Array<servicio_gastosGetPayload<T>>>

    /**
     * Create a Servicio_gastos.
     * @param {servicio_gastosCreateArgs} args - Arguments to create a Servicio_gastos.
     * @example
     * // Create one Servicio_gastos
     * const Servicio_gastos = await prisma.servicio_gastos.create({
     *   data: {
     *     // ... data to create a Servicio_gastos
     *   }
     * })
     * 
    **/
    create<T extends servicio_gastosCreateArgs>(
      args: SelectSubset<T, servicio_gastosCreateArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Create many Servicio_gastos.
     *     @param {servicio_gastosCreateManyArgs} args - Arguments to create many Servicio_gastos.
     *     @example
     *     // Create many Servicio_gastos
     *     const servicio_gastos = await prisma.servicio_gastos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_gastosCreateManyArgs>(
      args?: SelectSubset<T, servicio_gastosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_gastos.
     * @param {servicio_gastosDeleteArgs} args - Arguments to delete one Servicio_gastos.
     * @example
     * // Delete one Servicio_gastos
     * const Servicio_gastos = await prisma.servicio_gastos.delete({
     *   where: {
     *     // ... filter to delete one Servicio_gastos
     *   }
     * })
     * 
    **/
    delete<T extends servicio_gastosDeleteArgs>(
      args: SelectSubset<T, servicio_gastosDeleteArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Update one Servicio_gastos.
     * @param {servicio_gastosUpdateArgs} args - Arguments to update one Servicio_gastos.
     * @example
     * // Update one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_gastosUpdateArgs>(
      args: SelectSubset<T, servicio_gastosUpdateArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Delete zero or more Servicio_gastos.
     * @param {servicio_gastosDeleteManyArgs} args - Arguments to filter Servicio_gastos to delete.
     * @example
     * // Delete a few Servicio_gastos
     * const { count } = await prisma.servicio_gastos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_gastosDeleteManyArgs>(
      args?: SelectSubset<T, servicio_gastosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_gastosUpdateManyArgs>(
      args: SelectSubset<T, servicio_gastosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_gastos.
     * @param {servicio_gastosUpsertArgs} args - Arguments to update or create a Servicio_gastos.
     * @example
     * // Update or create a Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.upsert({
     *   create: {
     *     // ... data to create a Servicio_gastos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_gastos we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_gastosUpsertArgs>(
      args: SelectSubset<T, servicio_gastosUpsertArgs>
    ): Prisma__servicio_gastosClient<servicio_gastosGetPayload<T>>

    /**
     * Count the number of Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosCountArgs} args - Arguments to filter Servicio_gastos to count.
     * @example
     * // Count the number of Servicio_gastos
     * const count = await prisma.servicio_gastos.count({
     *   where: {
     *     // ... the filter for the Servicio_gastos we want to count
     *   }
     * })
    **/
    count<T extends servicio_gastosCountArgs>(
      args?: Subset<T, servicio_gastosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_gastosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_gastosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_gastosAggregateArgs>(args: Subset<T, Servicio_gastosAggregateArgs>): Prisma.PrismaPromise<GetServicio_gastosAggregateType<T>>

    /**
     * Group by Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_gastosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Servicio_gastosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Servicio_gastosGroupByArgs['orderBy'] }
        : { orderBy?: Servicio_gastosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Servicio_gastosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_gastosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_gastos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_gastosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_gastos base type for findUnique actions
   */
  export type servicio_gastosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where: servicio_gastosWhereUniqueInput
  }

  /**
   * servicio_gastos findUnique
   */
  export interface servicio_gastosFindUniqueArgs extends servicio_gastosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_gastos findUniqueOrThrow
   */
  export type servicio_gastosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos base type for findFirst actions
   */
  export type servicio_gastosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: Enumerable<servicio_gastosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_gastos.
     */
    distinct?: Enumerable<Servicio_gastosScalarFieldEnum>
  }

  /**
   * servicio_gastos findFirst
   */
  export interface servicio_gastosFindFirstArgs extends servicio_gastosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_gastos findFirstOrThrow
   */
  export type servicio_gastosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: Enumerable<servicio_gastosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_gastos.
     */
    distinct?: Enumerable<Servicio_gastosScalarFieldEnum>
  }


  /**
   * servicio_gastos findMany
   */
  export type servicio_gastosFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: Enumerable<servicio_gastosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    distinct?: Enumerable<Servicio_gastosScalarFieldEnum>
  }


  /**
   * servicio_gastos create
   */
  export type servicio_gastosCreateArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * The data needed to create a servicio_gastos.
     */
    data: XOR<servicio_gastosCreateInput, servicio_gastosUncheckedCreateInput>
  }


  /**
   * servicio_gastos createMany
   */
  export type servicio_gastosCreateManyArgs = {
    /**
     * The data used to create many servicio_gastos.
     */
    data: Enumerable<servicio_gastosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicio_gastos update
   */
  export type servicio_gastosUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * The data needed to update a servicio_gastos.
     */
    data: XOR<servicio_gastosUpdateInput, servicio_gastosUncheckedUpdateInput>
    /**
     * Choose, which servicio_gastos to update.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos updateMany
   */
  export type servicio_gastosUpdateManyArgs = {
    /**
     * The data used to update servicio_gastos.
     */
    data: XOR<servicio_gastosUpdateManyMutationInput, servicio_gastosUncheckedUpdateManyInput>
    /**
     * Filter which servicio_gastos to update
     */
    where?: servicio_gastosWhereInput
  }


  /**
   * servicio_gastos upsert
   */
  export type servicio_gastosUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * The filter to search for the servicio_gastos to update in case it exists.
     */
    where: servicio_gastosWhereUniqueInput
    /**
     * In case the servicio_gastos found by the `where` argument doesn't exist, create a new servicio_gastos with this data.
     */
    create: XOR<servicio_gastosCreateInput, servicio_gastosUncheckedCreateInput>
    /**
     * In case the servicio_gastos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_gastosUpdateInput, servicio_gastosUncheckedUpdateInput>
  }


  /**
   * servicio_gastos delete
   */
  export type servicio_gastosDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
    /**
     * Filter which servicio_gastos to delete.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos deleteMany
   */
  export type servicio_gastosDeleteManyArgs = {
    /**
     * Filter which servicio_gastos to delete
     */
    where?: servicio_gastosWhereInput
  }


  /**
   * servicio_gastos without action
   */
  export type servicio_gastosArgs = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect | null
  }



  /**
   * Model servicio_venta
   */


  export type AggregateServicio_venta = {
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  export type Servicio_ventaAvgAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaSumAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaMinAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaMaxAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaCountAggregateOutputType = {
    idventa: number
    idservicio: number
    monto: number
    operador: number
    fecha_venta: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    parentesco: number
    operador_venta: number
    liquidado: number
    operadorliq: number
    fecha_liquidacion: number
    aprobado: number
    operadorap: number
    fecha_aprobacion: number
    comision: number
    fecha_carga: number
    valor_cuota: number
    plan_cuota: number
    monto_financiacion: number
    financiacion: number
    efectivo: number
    _all: number
  }


  export type Servicio_ventaAvgAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaSumAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMinAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMaxAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaCountAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
    _all?: true
  }

  export type Servicio_ventaAggregateArgs = {
    /**
     * Filter which servicio_venta to aggregate.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: Enumerable<servicio_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_ventas
    **/
    _count?: true | Servicio_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_ventaMaxAggregateInputType
  }

  export type GetServicio_ventaAggregateType<T extends Servicio_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_venta[P]>
      : GetScalarType<T[P], AggregateServicio_venta[P]>
  }




  export type Servicio_ventaGroupByArgs = {
    where?: servicio_ventaWhereInput
    orderBy?: Enumerable<servicio_ventaOrderByWithAggregationInput>
    by: Servicio_ventaScalarFieldEnum[]
    having?: servicio_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_ventaCountAggregateInputType | true
    _avg?: Servicio_ventaAvgAggregateInputType
    _sum?: Servicio_ventaSumAggregateInputType
    _min?: Servicio_ventaMinAggregateInputType
    _max?: Servicio_ventaMaxAggregateInputType
  }


  export type Servicio_ventaGroupByOutputType = {
    idventa: number
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  type GetServicio_ventaGroupByPayload<T extends Servicio_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Servicio_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
        }
      >
    >


  export type servicio_ventaSelect = {
    idventa?: boolean
    idservicio?: boolean
    monto?: boolean
    operador?: boolean
    fecha_venta?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    parentesco?: boolean
    operador_venta?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
    comision?: boolean
    fecha_carga?: boolean
    valor_cuota?: boolean
    plan_cuota?: boolean
    monto_financiacion?: boolean
    financiacion?: boolean
    efectivo?: boolean
  }


  export type servicio_ventaGetPayload<S extends boolean | null | undefined | servicio_ventaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? servicio_venta :
    S extends undefined ? never :
    S extends { include: any } & (servicio_ventaArgs | servicio_ventaFindManyArgs)
    ? servicio_venta 
    : S extends { select: any } & (servicio_ventaArgs | servicio_ventaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof servicio_venta ? servicio_venta[P] : never
  } 
      : servicio_venta


  type servicio_ventaCountArgs = 
    Omit<servicio_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_ventaCountAggregateInputType | true
    }

  export interface servicio_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Servicio_venta that matches the filter.
     * @param {servicio_ventaFindUniqueArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_ventaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_ventaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>> : Prisma__servicio_ventaClient<servicio_ventaGetPayload<T> | null, null>

    /**
     * Find one Servicio_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_ventaFindUniqueOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_ventaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicio_ventaFindUniqueOrThrowArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Find the first Servicio_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_ventaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_ventaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>> : Prisma__servicio_ventaClient<servicio_ventaGetPayload<T> | null, null>

    /**
     * Find the first Servicio_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_ventaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicio_ventaFindFirstOrThrowArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Find zero or more Servicio_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany()
     * 
     * // Get first 10 Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany({ take: 10 })
     * 
     * // Only select the `idventa`
     * const servicio_ventaWithIdventaOnly = await prisma.servicio_venta.findMany({ select: { idventa: true } })
     * 
    **/
    findMany<T extends servicio_ventaFindManyArgs>(
      args?: SelectSubset<T, servicio_ventaFindManyArgs>
    ): Prisma.PrismaPromise<Array<servicio_ventaGetPayload<T>>>

    /**
     * Create a Servicio_venta.
     * @param {servicio_ventaCreateArgs} args - Arguments to create a Servicio_venta.
     * @example
     * // Create one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.create({
     *   data: {
     *     // ... data to create a Servicio_venta
     *   }
     * })
     * 
    **/
    create<T extends servicio_ventaCreateArgs>(
      args: SelectSubset<T, servicio_ventaCreateArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Create many Servicio_ventas.
     *     @param {servicio_ventaCreateManyArgs} args - Arguments to create many Servicio_ventas.
     *     @example
     *     // Create many Servicio_ventas
     *     const servicio_venta = await prisma.servicio_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_ventaCreateManyArgs>(
      args?: SelectSubset<T, servicio_ventaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_venta.
     * @param {servicio_ventaDeleteArgs} args - Arguments to delete one Servicio_venta.
     * @example
     * // Delete one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.delete({
     *   where: {
     *     // ... filter to delete one Servicio_venta
     *   }
     * })
     * 
    **/
    delete<T extends servicio_ventaDeleteArgs>(
      args: SelectSubset<T, servicio_ventaDeleteArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Update one Servicio_venta.
     * @param {servicio_ventaUpdateArgs} args - Arguments to update one Servicio_venta.
     * @example
     * // Update one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_ventaUpdateArgs>(
      args: SelectSubset<T, servicio_ventaUpdateArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Delete zero or more Servicio_ventas.
     * @param {servicio_ventaDeleteManyArgs} args - Arguments to filter Servicio_ventas to delete.
     * @example
     * // Delete a few Servicio_ventas
     * const { count } = await prisma.servicio_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_ventaDeleteManyArgs>(
      args?: SelectSubset<T, servicio_ventaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_ventas
     * const servicio_venta = await prisma.servicio_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_ventaUpdateManyArgs>(
      args: SelectSubset<T, servicio_ventaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_venta.
     * @param {servicio_ventaUpsertArgs} args - Arguments to update or create a Servicio_venta.
     * @example
     * // Update or create a Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.upsert({
     *   create: {
     *     // ... data to create a Servicio_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_venta we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_ventaUpsertArgs>(
      args: SelectSubset<T, servicio_ventaUpsertArgs>
    ): Prisma__servicio_ventaClient<servicio_ventaGetPayload<T>>

    /**
     * Count the number of Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaCountArgs} args - Arguments to filter Servicio_ventas to count.
     * @example
     * // Count the number of Servicio_ventas
     * const count = await prisma.servicio_venta.count({
     *   where: {
     *     // ... the filter for the Servicio_ventas we want to count
     *   }
     * })
    **/
    count<T extends servicio_ventaCountArgs>(
      args?: Subset<T, servicio_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_ventaAggregateArgs>(args: Subset<T, Servicio_ventaAggregateArgs>): Prisma.PrismaPromise<GetServicio_ventaAggregateType<T>>

    /**
     * Group by Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Servicio_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Servicio_ventaGroupByArgs['orderBy'] }
        : { orderBy?: Servicio_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Servicio_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_ventaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_venta base type for findUnique actions
   */
  export type servicio_ventaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }

  /**
   * servicio_venta findUnique
   */
  export interface servicio_ventaFindUniqueArgs extends servicio_ventaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findUniqueOrThrow
   */
  export type servicio_ventaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta base type for findFirst actions
   */
  export type servicio_ventaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: Enumerable<servicio_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Enumerable<Servicio_ventaScalarFieldEnum>
  }

  /**
   * servicio_venta findFirst
   */
  export interface servicio_ventaFindFirstArgs extends servicio_ventaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findFirstOrThrow
   */
  export type servicio_ventaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: Enumerable<servicio_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Enumerable<Servicio_ventaScalarFieldEnum>
  }


  /**
   * servicio_venta findMany
   */
  export type servicio_ventaFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter, which servicio_ventas to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: Enumerable<servicio_ventaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    distinct?: Enumerable<Servicio_ventaScalarFieldEnum>
  }


  /**
   * servicio_venta create
   */
  export type servicio_ventaCreateArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * The data needed to create a servicio_venta.
     */
    data: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
  }


  /**
   * servicio_venta createMany
   */
  export type servicio_ventaCreateManyArgs = {
    /**
     * The data used to create many servicio_ventas.
     */
    data: Enumerable<servicio_ventaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicio_venta update
   */
  export type servicio_ventaUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * The data needed to update a servicio_venta.
     */
    data: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
    /**
     * Choose, which servicio_venta to update.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta updateMany
   */
  export type servicio_ventaUpdateManyArgs = {
    /**
     * The data used to update servicio_ventas.
     */
    data: XOR<servicio_ventaUpdateManyMutationInput, servicio_ventaUncheckedUpdateManyInput>
    /**
     * Filter which servicio_ventas to update
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta upsert
   */
  export type servicio_ventaUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * The filter to search for the servicio_venta to update in case it exists.
     */
    where: servicio_ventaWhereUniqueInput
    /**
     * In case the servicio_venta found by the `where` argument doesn't exist, create a new servicio_venta with this data.
     */
    create: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
    /**
     * In case the servicio_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
  }


  /**
   * servicio_venta delete
   */
  export type servicio_ventaDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
    /**
     * Filter which servicio_venta to delete.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta deleteMany
   */
  export type servicio_ventaDeleteManyArgs = {
    /**
     * Filter which servicio_ventas to delete
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta without action
   */
  export type servicio_ventaArgs = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect | null
  }



  /**
   * Model servicios
   */


  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: Date | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: Date | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    idservicio: number
    empresa: number
    dni: number
    apellido: number
    nombre: number
    edad: number
    fecha_fallecimiento: number
    lugar_fallecimiento: number
    tipo_servicio: number
    casa_mortuaria: number
    fecha_inhumacion: number
    hora_inhumacion: number
    cementerio: number
    estado: number
    contrato: number
    fecha_recepcion: number
    sucursal: number
    motivo: number
    retiro: number
    solicitado: number
    parentesco: number
    altura: number
    peso: number
    dni_nuevotitular: number
    operador: number
    idataud: number
    dni_solicitante: number
    impactado: number
    cremacion: number
    idparcela: number
    liquidado: number
    fecha_liquidacion: number
    gastos_cargados: number
    obra_soc: number
    importe: number
    donacion: number
    domicilio_solicitante: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
  }

  export type ServiciosSumAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
  }

  export type ServiciosMinAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
  }

  export type ServiciosMaxAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
  }

  export type ServiciosCountAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
    _all?: true
  }

  export type ServiciosAggregateArgs = {
    /**
     * Filter which servicios to aggregate.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: Enumerable<serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type ServiciosGroupByArgs = {
    where?: serviciosWhereInput
    orderBy?: Enumerable<serviciosOrderByWithAggregationInput>
    by: ServiciosScalarFieldEnum[]
    having?: serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }


  export type ServiciosGroupByOutputType = {
    idservicio: number
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: Date | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends ServiciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type serviciosSelect = {
    idservicio?: boolean
    empresa?: boolean
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    fecha_fallecimiento?: boolean
    lugar_fallecimiento?: boolean
    tipo_servicio?: boolean
    casa_mortuaria?: boolean
    fecha_inhumacion?: boolean
    hora_inhumacion?: boolean
    cementerio?: boolean
    estado?: boolean
    contrato?: boolean
    fecha_recepcion?: boolean
    sucursal?: boolean
    motivo?: boolean
    retiro?: boolean
    solicitado?: boolean
    parentesco?: boolean
    altura?: boolean
    peso?: boolean
    dni_nuevotitular?: boolean
    operador?: boolean
    idataud?: boolean
    dni_solicitante?: boolean
    impactado?: boolean
    cremacion?: boolean
    idparcela?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    gastos_cargados?: boolean
    obra_soc?: boolean
    importe?: boolean
    donacion?: boolean
    domicilio_solicitante?: boolean
  }


  export type serviciosGetPayload<S extends boolean | null | undefined | serviciosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? servicios :
    S extends undefined ? never :
    S extends { include: any } & (serviciosArgs | serviciosFindManyArgs)
    ? servicios 
    : S extends { select: any } & (serviciosArgs | serviciosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof servicios ? servicios[P] : never
  } 
      : servicios


  type serviciosCountArgs = 
    Omit<serviciosFindManyArgs, 'select' | 'include'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Servicios that matches the filter.
     * @param {serviciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviciosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviciosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios'> extends True ? Prisma__serviciosClient<serviciosGetPayload<T>> : Prisma__serviciosClient<serviciosGetPayload<T> | null, null>

    /**
     * Find one Servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serviciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serviciosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, serviciosFindUniqueOrThrowArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviciosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviciosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios'> extends True ? Prisma__serviciosClient<serviciosGetPayload<T>> : Prisma__serviciosClient<serviciosGetPayload<T> | null, null>

    /**
     * Find the first Servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serviciosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, serviciosFindFirstOrThrowArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `idservicio`
     * const serviciosWithIdservicioOnly = await prisma.servicios.findMany({ select: { idservicio: true } })
     * 
    **/
    findMany<T extends serviciosFindManyArgs>(
      args?: SelectSubset<T, serviciosFindManyArgs>
    ): Prisma.PrismaPromise<Array<serviciosGetPayload<T>>>

    /**
     * Create a Servicios.
     * @param {serviciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
    **/
    create<T extends serviciosCreateArgs>(
      args: SelectSubset<T, serviciosCreateArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Create many Servicios.
     *     @param {serviciosCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicios = await prisma.servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serviciosCreateManyArgs>(
      args?: SelectSubset<T, serviciosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {serviciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
    **/
    delete<T extends serviciosDeleteArgs>(
      args: SelectSubset<T, serviciosDeleteArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Update one Servicios.
     * @param {serviciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviciosUpdateArgs>(
      args: SelectSubset<T, serviciosUpdateArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Delete zero or more Servicios.
     * @param {serviciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviciosDeleteManyArgs>(
      args?: SelectSubset<T, serviciosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviciosUpdateManyArgs>(
      args: SelectSubset<T, serviciosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {serviciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
    **/
    upsert<T extends serviciosUpsertArgs>(
      args: SelectSubset<T, serviciosUpsertArgs>
    ): Prisma__serviciosClient<serviciosGetPayload<T>>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends serviciosCountArgs>(
      args?: Subset<T, serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiciosGroupByArgs['orderBy'] }
        : { orderBy?: ServiciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviciosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios base type for findUnique actions
   */
  export type serviciosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios findUnique
   */
  export interface serviciosFindUniqueArgs extends serviciosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findUniqueOrThrow
   */
  export type serviciosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios base type for findFirst actions
   */
  export type serviciosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: Enumerable<serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: Enumerable<ServiciosScalarFieldEnum>
  }

  /**
   * servicios findFirst
   */
  export interface serviciosFindFirstArgs extends serviciosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findFirstOrThrow
   */
  export type serviciosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: Enumerable<serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: Enumerable<ServiciosScalarFieldEnum>
  }


  /**
   * servicios findMany
   */
  export type serviciosFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: Enumerable<serviciosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    distinct?: Enumerable<ServiciosScalarFieldEnum>
  }


  /**
   * servicios create
   */
  export type serviciosCreateArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * The data needed to create a servicios.
     */
    data: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
  }


  /**
   * servicios createMany
   */
  export type serviciosCreateManyArgs = {
    /**
     * The data used to create many servicios.
     */
    data: Enumerable<serviciosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicios update
   */
  export type serviciosUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * The data needed to update a servicios.
     */
    data: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
    /**
     * Choose, which servicios to update.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios updateMany
   */
  export type serviciosUpdateManyArgs = {
    /**
     * The data used to update servicios.
     */
    data: XOR<serviciosUpdateManyMutationInput, serviciosUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios upsert
   */
  export type serviciosUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * The filter to search for the servicios to update in case it exists.
     */
    where: serviciosWhereUniqueInput
    /**
     * In case the servicios found by the `where` argument doesn't exist, create a new servicios with this data.
     */
    create: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
    /**
     * In case the servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
  }


  /**
   * servicios delete
   */
  export type serviciosDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
    /**
     * Filter which servicios to delete.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios deleteMany
   */
  export type serviciosDeleteManyArgs = {
    /**
     * Filter which servicios to delete
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios without action
   */
  export type serviciosArgs = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect | null
  }



  /**
   * Model servicios_liquidacion
   */


  export type AggregateServicios_liquidacion = {
    _count: Servicios_liquidacionCountAggregateOutputType | null
    _avg: Servicios_liquidacionAvgAggregateOutputType | null
    _sum: Servicios_liquidacionSumAggregateOutputType | null
    _min: Servicios_liquidacionMinAggregateOutputType | null
    _max: Servicios_liquidacionMaxAggregateOutputType | null
  }

  export type Servicios_liquidacionAvgAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
  }

  export type Servicios_liquidacionSumAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
  }

  export type Servicios_liquidacionMinAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
  }

  export type Servicios_liquidacionMaxAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
  }

  export type Servicios_liquidacionCountAggregateOutputType = {
    idliquidacion: number
    idservicio: number
    total_liquidacion: number
    fecha_liquidacion: number
    operador: number
    _all: number
  }


  export type Servicios_liquidacionAvgAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
  }

  export type Servicios_liquidacionSumAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
  }

  export type Servicios_liquidacionMinAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
  }

  export type Servicios_liquidacionMaxAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
  }

  export type Servicios_liquidacionCountAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
    _all?: true
  }

  export type Servicios_liquidacionAggregateArgs = {
    /**
     * Filter which servicios_liquidacion to aggregate.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: Enumerable<servicios_liquidacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios_liquidacions
    **/
    _count?: true | Servicios_liquidacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicios_liquidacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicios_liquidacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicios_liquidacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicios_liquidacionMaxAggregateInputType
  }

  export type GetServicios_liquidacionAggregateType<T extends Servicios_liquidacionAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios_liquidacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios_liquidacion[P]>
      : GetScalarType<T[P], AggregateServicios_liquidacion[P]>
  }




  export type Servicios_liquidacionGroupByArgs = {
    where?: servicios_liquidacionWhereInput
    orderBy?: Enumerable<servicios_liquidacionOrderByWithAggregationInput>
    by: Servicios_liquidacionScalarFieldEnum[]
    having?: servicios_liquidacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicios_liquidacionCountAggregateInputType | true
    _avg?: Servicios_liquidacionAvgAggregateInputType
    _sum?: Servicios_liquidacionSumAggregateInputType
    _min?: Servicios_liquidacionMinAggregateInputType
    _max?: Servicios_liquidacionMaxAggregateInputType
  }


  export type Servicios_liquidacionGroupByOutputType = {
    idliquidacion: number
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
    _count: Servicios_liquidacionCountAggregateOutputType | null
    _avg: Servicios_liquidacionAvgAggregateOutputType | null
    _sum: Servicios_liquidacionSumAggregateOutputType | null
    _min: Servicios_liquidacionMinAggregateOutputType | null
    _max: Servicios_liquidacionMaxAggregateOutputType | null
  }

  type GetServicios_liquidacionGroupByPayload<T extends Servicios_liquidacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Servicios_liquidacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicios_liquidacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicios_liquidacionGroupByOutputType[P]>
            : GetScalarType<T[P], Servicios_liquidacionGroupByOutputType[P]>
        }
      >
    >


  export type servicios_liquidacionSelect = {
    idliquidacion?: boolean
    idservicio?: boolean
    total_liquidacion?: boolean
    fecha_liquidacion?: boolean
    operador?: boolean
  }


  export type servicios_liquidacionGetPayload<S extends boolean | null | undefined | servicios_liquidacionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? servicios_liquidacion :
    S extends undefined ? never :
    S extends { include: any } & (servicios_liquidacionArgs | servicios_liquidacionFindManyArgs)
    ? servicios_liquidacion 
    : S extends { select: any } & (servicios_liquidacionArgs | servicios_liquidacionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof servicios_liquidacion ? servicios_liquidacion[P] : never
  } 
      : servicios_liquidacion


  type servicios_liquidacionCountArgs = 
    Omit<servicios_liquidacionFindManyArgs, 'select' | 'include'> & {
      select?: Servicios_liquidacionCountAggregateInputType | true
    }

  export interface servicios_liquidacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Servicios_liquidacion that matches the filter.
     * @param {servicios_liquidacionFindUniqueArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicios_liquidacionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicios_liquidacionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios_liquidacion'> extends True ? Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>> : Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T> | null, null>

    /**
     * Find one Servicios_liquidacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicios_liquidacionFindUniqueOrThrowArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicios_liquidacionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicios_liquidacionFindUniqueOrThrowArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Find the first Servicios_liquidacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindFirstArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicios_liquidacionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicios_liquidacionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios_liquidacion'> extends True ? Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>> : Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T> | null, null>

    /**
     * Find the first Servicios_liquidacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindFirstOrThrowArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicios_liquidacionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicios_liquidacionFindFirstOrThrowArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Find zero or more Servicios_liquidacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios_liquidacions
     * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany()
     * 
     * // Get first 10 Servicios_liquidacions
     * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany({ take: 10 })
     * 
     * // Only select the `idliquidacion`
     * const servicios_liquidacionWithIdliquidacionOnly = await prisma.servicios_liquidacion.findMany({ select: { idliquidacion: true } })
     * 
    **/
    findMany<T extends servicios_liquidacionFindManyArgs>(
      args?: SelectSubset<T, servicios_liquidacionFindManyArgs>
    ): Prisma.PrismaPromise<Array<servicios_liquidacionGetPayload<T>>>

    /**
     * Create a Servicios_liquidacion.
     * @param {servicios_liquidacionCreateArgs} args - Arguments to create a Servicios_liquidacion.
     * @example
     * // Create one Servicios_liquidacion
     * const Servicios_liquidacion = await prisma.servicios_liquidacion.create({
     *   data: {
     *     // ... data to create a Servicios_liquidacion
     *   }
     * })
     * 
    **/
    create<T extends servicios_liquidacionCreateArgs>(
      args: SelectSubset<T, servicios_liquidacionCreateArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Create many Servicios_liquidacions.
     *     @param {servicios_liquidacionCreateManyArgs} args - Arguments to create many Servicios_liquidacions.
     *     @example
     *     // Create many Servicios_liquidacions
     *     const servicios_liquidacion = await prisma.servicios_liquidacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicios_liquidacionCreateManyArgs>(
      args?: SelectSubset<T, servicios_liquidacionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios_liquidacion.
     * @param {servicios_liquidacionDeleteArgs} args - Arguments to delete one Servicios_liquidacion.
     * @example
     * // Delete one Servicios_liquidacion
     * const Servicios_liquidacion = await prisma.servicios_liquidacion.delete({
     *   where: {
     *     // ... filter to delete one Servicios_liquidacion
     *   }
     * })
     * 
    **/
    delete<T extends servicios_liquidacionDeleteArgs>(
      args: SelectSubset<T, servicios_liquidacionDeleteArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Update one Servicios_liquidacion.
     * @param {servicios_liquidacionUpdateArgs} args - Arguments to update one Servicios_liquidacion.
     * @example
     * // Update one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicios_liquidacionUpdateArgs>(
      args: SelectSubset<T, servicios_liquidacionUpdateArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Delete zero or more Servicios_liquidacions.
     * @param {servicios_liquidacionDeleteManyArgs} args - Arguments to filter Servicios_liquidacions to delete.
     * @example
     * // Delete a few Servicios_liquidacions
     * const { count } = await prisma.servicios_liquidacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicios_liquidacionDeleteManyArgs>(
      args?: SelectSubset<T, servicios_liquidacionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios_liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios_liquidacions
     * const servicios_liquidacion = await prisma.servicios_liquidacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicios_liquidacionUpdateManyArgs>(
      args: SelectSubset<T, servicios_liquidacionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios_liquidacion.
     * @param {servicios_liquidacionUpsertArgs} args - Arguments to update or create a Servicios_liquidacion.
     * @example
     * // Update or create a Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.upsert({
     *   create: {
     *     // ... data to create a Servicios_liquidacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios_liquidacion we want to update
     *   }
     * })
    **/
    upsert<T extends servicios_liquidacionUpsertArgs>(
      args: SelectSubset<T, servicios_liquidacionUpsertArgs>
    ): Prisma__servicios_liquidacionClient<servicios_liquidacionGetPayload<T>>

    /**
     * Count the number of Servicios_liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionCountArgs} args - Arguments to filter Servicios_liquidacions to count.
     * @example
     * // Count the number of Servicios_liquidacions
     * const count = await prisma.servicios_liquidacion.count({
     *   where: {
     *     // ... the filter for the Servicios_liquidacions we want to count
     *   }
     * })
    **/
    count<T extends servicios_liquidacionCountArgs>(
      args?: Subset<T, servicios_liquidacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicios_liquidacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios_liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicios_liquidacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicios_liquidacionAggregateArgs>(args: Subset<T, Servicios_liquidacionAggregateArgs>): Prisma.PrismaPromise<GetServicios_liquidacionAggregateType<T>>

    /**
     * Group by Servicios_liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicios_liquidacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Servicios_liquidacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Servicios_liquidacionGroupByArgs['orderBy'] }
        : { orderBy?: Servicios_liquidacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Servicios_liquidacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicios_liquidacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios_liquidacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicios_liquidacionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios_liquidacion base type for findUnique actions
   */
  export type servicios_liquidacionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where: servicios_liquidacionWhereUniqueInput
  }

  /**
   * servicios_liquidacion findUnique
   */
  export interface servicios_liquidacionFindUniqueArgs extends servicios_liquidacionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_liquidacion findUniqueOrThrow
   */
  export type servicios_liquidacionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion base type for findFirst actions
   */
  export type servicios_liquidacionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: Enumerable<servicios_liquidacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_liquidacions.
     */
    distinct?: Enumerable<Servicios_liquidacionScalarFieldEnum>
  }

  /**
   * servicios_liquidacion findFirst
   */
  export interface servicios_liquidacionFindFirstArgs extends servicios_liquidacionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_liquidacion findFirstOrThrow
   */
  export type servicios_liquidacionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: Enumerable<servicios_liquidacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_liquidacions.
     */
    distinct?: Enumerable<Servicios_liquidacionScalarFieldEnum>
  }


  /**
   * servicios_liquidacion findMany
   */
  export type servicios_liquidacionFindManyArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter, which servicios_liquidacions to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: Enumerable<servicios_liquidacionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    distinct?: Enumerable<Servicios_liquidacionScalarFieldEnum>
  }


  /**
   * servicios_liquidacion create
   */
  export type servicios_liquidacionCreateArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * The data needed to create a servicios_liquidacion.
     */
    data: XOR<servicios_liquidacionCreateInput, servicios_liquidacionUncheckedCreateInput>
  }


  /**
   * servicios_liquidacion createMany
   */
  export type servicios_liquidacionCreateManyArgs = {
    /**
     * The data used to create many servicios_liquidacions.
     */
    data: Enumerable<servicios_liquidacionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * servicios_liquidacion update
   */
  export type servicios_liquidacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * The data needed to update a servicios_liquidacion.
     */
    data: XOR<servicios_liquidacionUpdateInput, servicios_liquidacionUncheckedUpdateInput>
    /**
     * Choose, which servicios_liquidacion to update.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion updateMany
   */
  export type servicios_liquidacionUpdateManyArgs = {
    /**
     * The data used to update servicios_liquidacions.
     */
    data: XOR<servicios_liquidacionUpdateManyMutationInput, servicios_liquidacionUncheckedUpdateManyInput>
    /**
     * Filter which servicios_liquidacions to update
     */
    where?: servicios_liquidacionWhereInput
  }


  /**
   * servicios_liquidacion upsert
   */
  export type servicios_liquidacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * The filter to search for the servicios_liquidacion to update in case it exists.
     */
    where: servicios_liquidacionWhereUniqueInput
    /**
     * In case the servicios_liquidacion found by the `where` argument doesn't exist, create a new servicios_liquidacion with this data.
     */
    create: XOR<servicios_liquidacionCreateInput, servicios_liquidacionUncheckedCreateInput>
    /**
     * In case the servicios_liquidacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicios_liquidacionUpdateInput, servicios_liquidacionUncheckedUpdateInput>
  }


  /**
   * servicios_liquidacion delete
   */
  export type servicios_liquidacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
    /**
     * Filter which servicios_liquidacion to delete.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion deleteMany
   */
  export type servicios_liquidacionDeleteManyArgs = {
    /**
     * Filter which servicios_liquidacions to delete
     */
    where?: servicios_liquidacionWhereInput
  }


  /**
   * servicios_liquidacion without action
   */
  export type servicios_liquidacionArgs = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect | null
  }



  /**
   * Model tareas
   */


  export type AggregateTareas = {
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  export type TareasAvgAggregateOutputType = {
    idevents: number | null
    allDay: number | null
  }

  export type TareasSumAggregateOutputType = {
    idevents: number | null
    allDay: number | null
  }

  export type TareasMinAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: boolean | null
  }

  export type TareasMaxAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: boolean | null
  }

  export type TareasCountAggregateOutputType = {
    idevents: number
    title: number
    allDay: number
    start: number
    end: number
    priority: number
    _all: number
  }


  export type TareasAvgAggregateInputType = {
    idevents?: true
    allDay?: true
  }

  export type TareasSumAggregateInputType = {
    idevents?: true
    allDay?: true
  }

  export type TareasMinAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasMaxAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasCountAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    _all?: true
  }

  export type TareasAggregateArgs = {
    /**
     * Filter which tareas to aggregate.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: Enumerable<tareasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas
    **/
    _count?: true | TareasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TareasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TareasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TareasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TareasMaxAggregateInputType
  }

  export type GetTareasAggregateType<T extends TareasAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas[P]>
      : GetScalarType<T[P], AggregateTareas[P]>
  }




  export type TareasGroupByArgs = {
    where?: tareasWhereInput
    orderBy?: Enumerable<tareasOrderByWithAggregationInput>
    by: TareasScalarFieldEnum[]
    having?: tareasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TareasCountAggregateInputType | true
    _avg?: TareasAvgAggregateInputType
    _sum?: TareasSumAggregateInputType
    _min?: TareasMinAggregateInputType
    _max?: TareasMaxAggregateInputType
  }


  export type TareasGroupByOutputType = {
    idevents: number
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: boolean | null
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  type GetTareasGroupByPayload<T extends TareasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TareasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TareasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TareasGroupByOutputType[P]>
            : GetScalarType<T[P], TareasGroupByOutputType[P]>
        }
      >
    >


  export type tareasSelect = {
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
  }


  export type tareasGetPayload<S extends boolean | null | undefined | tareasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tareas :
    S extends undefined ? never :
    S extends { include: any } & (tareasArgs | tareasFindManyArgs)
    ? tareas 
    : S extends { select: any } & (tareasArgs | tareasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tareas ? tareas[P] : never
  } 
      : tareas


  type tareasCountArgs = 
    Omit<tareasFindManyArgs, 'select' | 'include'> & {
      select?: TareasCountAggregateInputType | true
    }

  export interface tareasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tareas that matches the filter.
     * @param {tareasFindUniqueArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas'> extends True ? Prisma__tareasClient<tareasGetPayload<T>> : Prisma__tareasClient<tareasGetPayload<T> | null, null>

    /**
     * Find one Tareas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareasFindUniqueOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tareasFindUniqueOrThrowArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Find the first Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas'> extends True ? Prisma__tareasClient<tareasGetPayload<T>> : Prisma__tareasClient<tareasGetPayload<T> | null, null>

    /**
     * Find the first Tareas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tareasFindFirstOrThrowArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Find zero or more Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas
     * const tareas = await prisma.tareas.findMany()
     * 
     * // Get first 10 Tareas
     * const tareas = await prisma.tareas.findMany({ take: 10 })
     * 
     * // Only select the `idevents`
     * const tareasWithIdeventsOnly = await prisma.tareas.findMany({ select: { idevents: true } })
     * 
    **/
    findMany<T extends tareasFindManyArgs>(
      args?: SelectSubset<T, tareasFindManyArgs>
    ): Prisma.PrismaPromise<Array<tareasGetPayload<T>>>

    /**
     * Create a Tareas.
     * @param {tareasCreateArgs} args - Arguments to create a Tareas.
     * @example
     * // Create one Tareas
     * const Tareas = await prisma.tareas.create({
     *   data: {
     *     // ... data to create a Tareas
     *   }
     * })
     * 
    **/
    create<T extends tareasCreateArgs>(
      args: SelectSubset<T, tareasCreateArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Create many Tareas.
     *     @param {tareasCreateManyArgs} args - Arguments to create many Tareas.
     *     @example
     *     // Create many Tareas
     *     const tareas = await prisma.tareas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareasCreateManyArgs>(
      args?: SelectSubset<T, tareasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas.
     * @param {tareasDeleteArgs} args - Arguments to delete one Tareas.
     * @example
     * // Delete one Tareas
     * const Tareas = await prisma.tareas.delete({
     *   where: {
     *     // ... filter to delete one Tareas
     *   }
     * })
     * 
    **/
    delete<T extends tareasDeleteArgs>(
      args: SelectSubset<T, tareasDeleteArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Update one Tareas.
     * @param {tareasUpdateArgs} args - Arguments to update one Tareas.
     * @example
     * // Update one Tareas
     * const tareas = await prisma.tareas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareasUpdateArgs>(
      args: SelectSubset<T, tareasUpdateArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Delete zero or more Tareas.
     * @param {tareasDeleteManyArgs} args - Arguments to filter Tareas to delete.
     * @example
     * // Delete a few Tareas
     * const { count } = await prisma.tareas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareasDeleteManyArgs>(
      args?: SelectSubset<T, tareasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas
     * const tareas = await prisma.tareas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareasUpdateManyArgs>(
      args: SelectSubset<T, tareasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas.
     * @param {tareasUpsertArgs} args - Arguments to update or create a Tareas.
     * @example
     * // Update or create a Tareas
     * const tareas = await prisma.tareas.upsert({
     *   create: {
     *     // ... data to create a Tareas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas we want to update
     *   }
     * })
    **/
    upsert<T extends tareasUpsertArgs>(
      args: SelectSubset<T, tareasUpsertArgs>
    ): Prisma__tareasClient<tareasGetPayload<T>>

    /**
     * Count the number of Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasCountArgs} args - Arguments to filter Tareas to count.
     * @example
     * // Count the number of Tareas
     * const count = await prisma.tareas.count({
     *   where: {
     *     // ... the filter for the Tareas we want to count
     *   }
     * })
    **/
    count<T extends tareasCountArgs>(
      args?: Subset<T, tareasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TareasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TareasAggregateArgs>(args: Subset<T, TareasAggregateArgs>): Prisma.PrismaPromise<GetTareasAggregateType<T>>

    /**
     * Group by Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TareasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TareasGroupByArgs['orderBy'] }
        : { orderBy?: TareasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TareasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas base type for findUnique actions
   */
  export type tareasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }

  /**
   * tareas findUnique
   */
  export interface tareasFindUniqueArgs extends tareasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findUniqueOrThrow
   */
  export type tareasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas base type for findFirst actions
   */
  export type tareasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: Enumerable<tareasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: Enumerable<TareasScalarFieldEnum>
  }

  /**
   * tareas findFirst
   */
  export interface tareasFindFirstArgs extends tareasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findFirstOrThrow
   */
  export type tareasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: Enumerable<tareasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: Enumerable<TareasScalarFieldEnum>
  }


  /**
   * tareas findMany
   */
  export type tareasFindManyArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: Enumerable<tareasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    distinct?: Enumerable<TareasScalarFieldEnum>
  }


  /**
   * tareas create
   */
  export type tareasCreateArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * The data needed to create a tareas.
     */
    data: XOR<tareasCreateInput, tareasUncheckedCreateInput>
  }


  /**
   * tareas createMany
   */
  export type tareasCreateManyArgs = {
    /**
     * The data used to create many tareas.
     */
    data: Enumerable<tareasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tareas update
   */
  export type tareasUpdateArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * The data needed to update a tareas.
     */
    data: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
    /**
     * Choose, which tareas to update.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas updateMany
   */
  export type tareasUpdateManyArgs = {
    /**
     * The data used to update tareas.
     */
    data: XOR<tareasUpdateManyMutationInput, tareasUncheckedUpdateManyInput>
    /**
     * Filter which tareas to update
     */
    where?: tareasWhereInput
  }


  /**
   * tareas upsert
   */
  export type tareasUpsertArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * The filter to search for the tareas to update in case it exists.
     */
    where: tareasWhereUniqueInput
    /**
     * In case the tareas found by the `where` argument doesn't exist, create a new tareas with this data.
     */
    create: XOR<tareasCreateInput, tareasUncheckedCreateInput>
    /**
     * In case the tareas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
  }


  /**
   * tareas delete
   */
  export type tareasDeleteArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
    /**
     * Filter which tareas to delete.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas deleteMany
   */
  export type tareasDeleteManyArgs = {
    /**
     * Filter which tareas to delete
     */
    where?: tareasWhereInput
  }


  /**
   * tareas without action
   */
  export type tareasArgs = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect | null
  }



  /**
   * Model tareas_adicionales
   */


  export type AggregateTareas_adicionales = {
    _count: Tareas_adicionalesCountAggregateOutputType | null
    _avg: Tareas_adicionalesAvgAggregateOutputType | null
    _sum: Tareas_adicionalesSumAggregateOutputType | null
    _min: Tareas_adicionalesMinAggregateOutputType | null
    _max: Tareas_adicionalesMaxAggregateOutputType | null
  }

  export type Tareas_adicionalesAvgAggregateOutputType = {
    idtarea: number | null
    feriado: number | null
  }

  export type Tareas_adicionalesSumAggregateOutputType = {
    idtarea: number | null
    feriado: number | null
  }

  export type Tareas_adicionalesMinAggregateOutputType = {
    idtarea: number | null
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
  }

  export type Tareas_adicionalesMaxAggregateOutputType = {
    idtarea: number | null
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
  }

  export type Tareas_adicionalesCountAggregateOutputType = {
    idtarea: number
    inicio: number
    fin: number
    tarea: number
    operador: number
    observaciones: number
    horas: number
    feriado: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    aprobado: number
    fecha_aprobacion: number
    operadorap: number
    mes_planificacion: number
    _all: number
  }


  export type Tareas_adicionalesAvgAggregateInputType = {
    idtarea?: true
    feriado?: true
  }

  export type Tareas_adicionalesSumAggregateInputType = {
    idtarea?: true
    feriado?: true
  }

  export type Tareas_adicionalesMinAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
  }

  export type Tareas_adicionalesMaxAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
  }

  export type Tareas_adicionalesCountAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
    _all?: true
  }

  export type Tareas_adicionalesAggregateArgs = {
    /**
     * Filter which tareas_adicionales to aggregate.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: Enumerable<tareas_adicionalesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas_adicionales
    **/
    _count?: true | Tareas_adicionalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tareas_adicionalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tareas_adicionalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tareas_adicionalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tareas_adicionalesMaxAggregateInputType
  }

  export type GetTareas_adicionalesAggregateType<T extends Tareas_adicionalesAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas_adicionales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas_adicionales[P]>
      : GetScalarType<T[P], AggregateTareas_adicionales[P]>
  }




  export type Tareas_adicionalesGroupByArgs = {
    where?: tareas_adicionalesWhereInput
    orderBy?: Enumerable<tareas_adicionalesOrderByWithAggregationInput>
    by: Tareas_adicionalesScalarFieldEnum[]
    having?: tareas_adicionalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tareas_adicionalesCountAggregateInputType | true
    _avg?: Tareas_adicionalesAvgAggregateInputType
    _sum?: Tareas_adicionalesSumAggregateInputType
    _min?: Tareas_adicionalesMinAggregateInputType
    _max?: Tareas_adicionalesMaxAggregateInputType
  }


  export type Tareas_adicionalesGroupByOutputType = {
    idtarea: number
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
    _count: Tareas_adicionalesCountAggregateOutputType | null
    _avg: Tareas_adicionalesAvgAggregateOutputType | null
    _sum: Tareas_adicionalesSumAggregateOutputType | null
    _min: Tareas_adicionalesMinAggregateOutputType | null
    _max: Tareas_adicionalesMaxAggregateOutputType | null
  }

  type GetTareas_adicionalesGroupByPayload<T extends Tareas_adicionalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tareas_adicionalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tareas_adicionalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tareas_adicionalesGroupByOutputType[P]>
            : GetScalarType<T[P], Tareas_adicionalesGroupByOutputType[P]>
        }
      >
    >


  export type tareas_adicionalesSelect = {
    idtarea?: boolean
    inicio?: boolean
    fin?: boolean
    tarea?: boolean
    operador?: boolean
    observaciones?: boolean
    horas?: boolean
    feriado?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    mes_planificacion?: boolean
  }


  export type tareas_adicionalesGetPayload<S extends boolean | null | undefined | tareas_adicionalesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tareas_adicionales :
    S extends undefined ? never :
    S extends { include: any } & (tareas_adicionalesArgs | tareas_adicionalesFindManyArgs)
    ? tareas_adicionales 
    : S extends { select: any } & (tareas_adicionalesArgs | tareas_adicionalesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tareas_adicionales ? tareas_adicionales[P] : never
  } 
      : tareas_adicionales


  type tareas_adicionalesCountArgs = 
    Omit<tareas_adicionalesFindManyArgs, 'select' | 'include'> & {
      select?: Tareas_adicionalesCountAggregateInputType | true
    }

  export interface tareas_adicionalesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tareas_adicionales that matches the filter.
     * @param {tareas_adicionalesFindUniqueArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareas_adicionalesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareas_adicionalesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas_adicionales'> extends True ? Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>> : Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T> | null, null>

    /**
     * Find one Tareas_adicionales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareas_adicionalesFindUniqueOrThrowArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareas_adicionalesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tareas_adicionalesFindUniqueOrThrowArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Find the first Tareas_adicionales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindFirstArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareas_adicionalesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareas_adicionalesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas_adicionales'> extends True ? Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>> : Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T> | null, null>

    /**
     * Find the first Tareas_adicionales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindFirstOrThrowArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareas_adicionalesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tareas_adicionalesFindFirstOrThrowArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Find zero or more Tareas_adicionales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findMany()
     * 
     * // Get first 10 Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findMany({ take: 10 })
     * 
     * // Only select the `idtarea`
     * const tareas_adicionalesWithIdtareaOnly = await prisma.tareas_adicionales.findMany({ select: { idtarea: true } })
     * 
    **/
    findMany<T extends tareas_adicionalesFindManyArgs>(
      args?: SelectSubset<T, tareas_adicionalesFindManyArgs>
    ): Prisma.PrismaPromise<Array<tareas_adicionalesGetPayload<T>>>

    /**
     * Create a Tareas_adicionales.
     * @param {tareas_adicionalesCreateArgs} args - Arguments to create a Tareas_adicionales.
     * @example
     * // Create one Tareas_adicionales
     * const Tareas_adicionales = await prisma.tareas_adicionales.create({
     *   data: {
     *     // ... data to create a Tareas_adicionales
     *   }
     * })
     * 
    **/
    create<T extends tareas_adicionalesCreateArgs>(
      args: SelectSubset<T, tareas_adicionalesCreateArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Create many Tareas_adicionales.
     *     @param {tareas_adicionalesCreateManyArgs} args - Arguments to create many Tareas_adicionales.
     *     @example
     *     // Create many Tareas_adicionales
     *     const tareas_adicionales = await prisma.tareas_adicionales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareas_adicionalesCreateManyArgs>(
      args?: SelectSubset<T, tareas_adicionalesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas_adicionales.
     * @param {tareas_adicionalesDeleteArgs} args - Arguments to delete one Tareas_adicionales.
     * @example
     * // Delete one Tareas_adicionales
     * const Tareas_adicionales = await prisma.tareas_adicionales.delete({
     *   where: {
     *     // ... filter to delete one Tareas_adicionales
     *   }
     * })
     * 
    **/
    delete<T extends tareas_adicionalesDeleteArgs>(
      args: SelectSubset<T, tareas_adicionalesDeleteArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Update one Tareas_adicionales.
     * @param {tareas_adicionalesUpdateArgs} args - Arguments to update one Tareas_adicionales.
     * @example
     * // Update one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareas_adicionalesUpdateArgs>(
      args: SelectSubset<T, tareas_adicionalesUpdateArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Delete zero or more Tareas_adicionales.
     * @param {tareas_adicionalesDeleteManyArgs} args - Arguments to filter Tareas_adicionales to delete.
     * @example
     * // Delete a few Tareas_adicionales
     * const { count } = await prisma.tareas_adicionales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareas_adicionalesDeleteManyArgs>(
      args?: SelectSubset<T, tareas_adicionalesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareas_adicionalesUpdateManyArgs>(
      args: SelectSubset<T, tareas_adicionalesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas_adicionales.
     * @param {tareas_adicionalesUpsertArgs} args - Arguments to update or create a Tareas_adicionales.
     * @example
     * // Update or create a Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.upsert({
     *   create: {
     *     // ... data to create a Tareas_adicionales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas_adicionales we want to update
     *   }
     * })
    **/
    upsert<T extends tareas_adicionalesUpsertArgs>(
      args: SelectSubset<T, tareas_adicionalesUpsertArgs>
    ): Prisma__tareas_adicionalesClient<tareas_adicionalesGetPayload<T>>

    /**
     * Count the number of Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesCountArgs} args - Arguments to filter Tareas_adicionales to count.
     * @example
     * // Count the number of Tareas_adicionales
     * const count = await prisma.tareas_adicionales.count({
     *   where: {
     *     // ... the filter for the Tareas_adicionales we want to count
     *   }
     * })
    **/
    count<T extends tareas_adicionalesCountArgs>(
      args?: Subset<T, tareas_adicionalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tareas_adicionalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tareas_adicionalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tareas_adicionalesAggregateArgs>(args: Subset<T, Tareas_adicionalesAggregateArgs>): Prisma.PrismaPromise<GetTareas_adicionalesAggregateType<T>>

    /**
     * Group by Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tareas_adicionalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tareas_adicionalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tareas_adicionalesGroupByArgs['orderBy'] }
        : { orderBy?: Tareas_adicionalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tareas_adicionalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareas_adicionalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas_adicionales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareas_adicionalesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas_adicionales base type for findUnique actions
   */
  export type tareas_adicionalesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where: tareas_adicionalesWhereUniqueInput
  }

  /**
   * tareas_adicionales findUnique
   */
  export interface tareas_adicionalesFindUniqueArgs extends tareas_adicionalesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_adicionales findUniqueOrThrow
   */
  export type tareas_adicionalesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales base type for findFirst actions
   */
  export type tareas_adicionalesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: Enumerable<tareas_adicionalesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_adicionales.
     */
    distinct?: Enumerable<Tareas_adicionalesScalarFieldEnum>
  }

  /**
   * tareas_adicionales findFirst
   */
  export interface tareas_adicionalesFindFirstArgs extends tareas_adicionalesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_adicionales findFirstOrThrow
   */
  export type tareas_adicionalesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: Enumerable<tareas_adicionalesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_adicionales.
     */
    distinct?: Enumerable<Tareas_adicionalesScalarFieldEnum>
  }


  /**
   * tareas_adicionales findMany
   */
  export type tareas_adicionalesFindManyArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: Enumerable<tareas_adicionalesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    distinct?: Enumerable<Tareas_adicionalesScalarFieldEnum>
  }


  /**
   * tareas_adicionales create
   */
  export type tareas_adicionalesCreateArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * The data needed to create a tareas_adicionales.
     */
    data: XOR<tareas_adicionalesCreateInput, tareas_adicionalesUncheckedCreateInput>
  }


  /**
   * tareas_adicionales createMany
   */
  export type tareas_adicionalesCreateManyArgs = {
    /**
     * The data used to create many tareas_adicionales.
     */
    data: Enumerable<tareas_adicionalesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tareas_adicionales update
   */
  export type tareas_adicionalesUpdateArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * The data needed to update a tareas_adicionales.
     */
    data: XOR<tareas_adicionalesUpdateInput, tareas_adicionalesUncheckedUpdateInput>
    /**
     * Choose, which tareas_adicionales to update.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales updateMany
   */
  export type tareas_adicionalesUpdateManyArgs = {
    /**
     * The data used to update tareas_adicionales.
     */
    data: XOR<tareas_adicionalesUpdateManyMutationInput, tareas_adicionalesUncheckedUpdateManyInput>
    /**
     * Filter which tareas_adicionales to update
     */
    where?: tareas_adicionalesWhereInput
  }


  /**
   * tareas_adicionales upsert
   */
  export type tareas_adicionalesUpsertArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * The filter to search for the tareas_adicionales to update in case it exists.
     */
    where: tareas_adicionalesWhereUniqueInput
    /**
     * In case the tareas_adicionales found by the `where` argument doesn't exist, create a new tareas_adicionales with this data.
     */
    create: XOR<tareas_adicionalesCreateInput, tareas_adicionalesUncheckedCreateInput>
    /**
     * In case the tareas_adicionales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareas_adicionalesUpdateInput, tareas_adicionalesUncheckedUpdateInput>
  }


  /**
   * tareas_adicionales delete
   */
  export type tareas_adicionalesDeleteArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
    /**
     * Filter which tareas_adicionales to delete.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales deleteMany
   */
  export type tareas_adicionalesDeleteManyArgs = {
    /**
     * Filter which tareas_adicionales to delete
     */
    where?: tareas_adicionalesWhereInput
  }


  /**
   * tareas_adicionales without action
   */
  export type tareas_adicionalesArgs = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect | null
  }



  /**
   * Model tipo_detalle
   */


  export type AggregateTipo_detalle = {
    _count: Tipo_detalleCountAggregateOutputType | null
    _avg: Tipo_detalleAvgAggregateOutputType | null
    _sum: Tipo_detalleSumAggregateOutputType | null
    _min: Tipo_detalleMinAggregateOutputType | null
    _max: Tipo_detalleMaxAggregateOutputType | null
  }

  export type Tipo_detalleAvgAggregateOutputType = {
    idtipodetalle: number | null
  }

  export type Tipo_detalleSumAggregateOutputType = {
    idtipodetalle: number | null
  }

  export type Tipo_detalleMinAggregateOutputType = {
    idtipodetalle: number | null
    tipo_detalle: string | null
    observacion: string | null
  }

  export type Tipo_detalleMaxAggregateOutputType = {
    idtipodetalle: number | null
    tipo_detalle: string | null
    observacion: string | null
  }

  export type Tipo_detalleCountAggregateOutputType = {
    idtipodetalle: number
    tipo_detalle: number
    observacion: number
    _all: number
  }


  export type Tipo_detalleAvgAggregateInputType = {
    idtipodetalle?: true
  }

  export type Tipo_detalleSumAggregateInputType = {
    idtipodetalle?: true
  }

  export type Tipo_detalleMinAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
  }

  export type Tipo_detalleMaxAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
  }

  export type Tipo_detalleCountAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
    _all?: true
  }

  export type Tipo_detalleAggregateArgs = {
    /**
     * Filter which tipo_detalle to aggregate.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: Enumerable<tipo_detalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_detalles
    **/
    _count?: true | Tipo_detalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_detalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_detalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_detalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_detalleMaxAggregateInputType
  }

  export type GetTipo_detalleAggregateType<T extends Tipo_detalleAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_detalle[P]>
      : GetScalarType<T[P], AggregateTipo_detalle[P]>
  }




  export type Tipo_detalleGroupByArgs = {
    where?: tipo_detalleWhereInput
    orderBy?: Enumerable<tipo_detalleOrderByWithAggregationInput>
    by: Tipo_detalleScalarFieldEnum[]
    having?: tipo_detalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_detalleCountAggregateInputType | true
    _avg?: Tipo_detalleAvgAggregateInputType
    _sum?: Tipo_detalleSumAggregateInputType
    _min?: Tipo_detalleMinAggregateInputType
    _max?: Tipo_detalleMaxAggregateInputType
  }


  export type Tipo_detalleGroupByOutputType = {
    idtipodetalle: number
    tipo_detalle: string | null
    observacion: string | null
    _count: Tipo_detalleCountAggregateOutputType | null
    _avg: Tipo_detalleAvgAggregateOutputType | null
    _sum: Tipo_detalleSumAggregateOutputType | null
    _min: Tipo_detalleMinAggregateOutputType | null
    _max: Tipo_detalleMaxAggregateOutputType | null
  }

  type GetTipo_detalleGroupByPayload<T extends Tipo_detalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tipo_detalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_detalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_detalleGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_detalleGroupByOutputType[P]>
        }
      >
    >


  export type tipo_detalleSelect = {
    idtipodetalle?: boolean
    tipo_detalle?: boolean
    observacion?: boolean
  }


  export type tipo_detalleGetPayload<S extends boolean | null | undefined | tipo_detalleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tipo_detalle :
    S extends undefined ? never :
    S extends { include: any } & (tipo_detalleArgs | tipo_detalleFindManyArgs)
    ? tipo_detalle 
    : S extends { select: any } & (tipo_detalleArgs | tipo_detalleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tipo_detalle ? tipo_detalle[P] : never
  } 
      : tipo_detalle


  type tipo_detalleCountArgs = 
    Omit<tipo_detalleFindManyArgs, 'select' | 'include'> & {
      select?: Tipo_detalleCountAggregateInputType | true
    }

  export interface tipo_detalleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tipo_detalle that matches the filter.
     * @param {tipo_detalleFindUniqueArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipo_detalleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tipo_detalleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tipo_detalle'> extends True ? Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>> : Prisma__tipo_detalleClient<tipo_detalleGetPayload<T> | null, null>

    /**
     * Find one Tipo_detalle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipo_detalleFindUniqueOrThrowArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipo_detalleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tipo_detalleFindUniqueOrThrowArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Find the first Tipo_detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindFirstArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipo_detalleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tipo_detalleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tipo_detalle'> extends True ? Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>> : Prisma__tipo_detalleClient<tipo_detalleGetPayload<T> | null, null>

    /**
     * Find the first Tipo_detalle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindFirstOrThrowArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipo_detalleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tipo_detalleFindFirstOrThrowArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Find zero or more Tipo_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_detalles
     * const tipo_detalles = await prisma.tipo_detalle.findMany()
     * 
     * // Get first 10 Tipo_detalles
     * const tipo_detalles = await prisma.tipo_detalle.findMany({ take: 10 })
     * 
     * // Only select the `idtipodetalle`
     * const tipo_detalleWithIdtipodetalleOnly = await prisma.tipo_detalle.findMany({ select: { idtipodetalle: true } })
     * 
    **/
    findMany<T extends tipo_detalleFindManyArgs>(
      args?: SelectSubset<T, tipo_detalleFindManyArgs>
    ): Prisma.PrismaPromise<Array<tipo_detalleGetPayload<T>>>

    /**
     * Create a Tipo_detalle.
     * @param {tipo_detalleCreateArgs} args - Arguments to create a Tipo_detalle.
     * @example
     * // Create one Tipo_detalle
     * const Tipo_detalle = await prisma.tipo_detalle.create({
     *   data: {
     *     // ... data to create a Tipo_detalle
     *   }
     * })
     * 
    **/
    create<T extends tipo_detalleCreateArgs>(
      args: SelectSubset<T, tipo_detalleCreateArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Create many Tipo_detalles.
     *     @param {tipo_detalleCreateManyArgs} args - Arguments to create many Tipo_detalles.
     *     @example
     *     // Create many Tipo_detalles
     *     const tipo_detalle = await prisma.tipo_detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipo_detalleCreateManyArgs>(
      args?: SelectSubset<T, tipo_detalleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_detalle.
     * @param {tipo_detalleDeleteArgs} args - Arguments to delete one Tipo_detalle.
     * @example
     * // Delete one Tipo_detalle
     * const Tipo_detalle = await prisma.tipo_detalle.delete({
     *   where: {
     *     // ... filter to delete one Tipo_detalle
     *   }
     * })
     * 
    **/
    delete<T extends tipo_detalleDeleteArgs>(
      args: SelectSubset<T, tipo_detalleDeleteArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Update one Tipo_detalle.
     * @param {tipo_detalleUpdateArgs} args - Arguments to update one Tipo_detalle.
     * @example
     * // Update one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipo_detalleUpdateArgs>(
      args: SelectSubset<T, tipo_detalleUpdateArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Delete zero or more Tipo_detalles.
     * @param {tipo_detalleDeleteManyArgs} args - Arguments to filter Tipo_detalles to delete.
     * @example
     * // Delete a few Tipo_detalles
     * const { count } = await prisma.tipo_detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipo_detalleDeleteManyArgs>(
      args?: SelectSubset<T, tipo_detalleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_detalles
     * const tipo_detalle = await prisma.tipo_detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipo_detalleUpdateManyArgs>(
      args: SelectSubset<T, tipo_detalleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_detalle.
     * @param {tipo_detalleUpsertArgs} args - Arguments to update or create a Tipo_detalle.
     * @example
     * // Update or create a Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.upsert({
     *   create: {
     *     // ... data to create a Tipo_detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_detalle we want to update
     *   }
     * })
    **/
    upsert<T extends tipo_detalleUpsertArgs>(
      args: SelectSubset<T, tipo_detalleUpsertArgs>
    ): Prisma__tipo_detalleClient<tipo_detalleGetPayload<T>>

    /**
     * Count the number of Tipo_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleCountArgs} args - Arguments to filter Tipo_detalles to count.
     * @example
     * // Count the number of Tipo_detalles
     * const count = await prisma.tipo_detalle.count({
     *   where: {
     *     // ... the filter for the Tipo_detalles we want to count
     *   }
     * })
    **/
    count<T extends tipo_detalleCountArgs>(
      args?: Subset<T, tipo_detalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_detalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_detalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_detalleAggregateArgs>(args: Subset<T, Tipo_detalleAggregateArgs>): Prisma.PrismaPromise<GetTipo_detalleAggregateType<T>>

    /**
     * Group by Tipo_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_detalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_detalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_detalleGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_detalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_detalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_detalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tipo_detalleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tipo_detalle base type for findUnique actions
   */
  export type tipo_detalleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where: tipo_detalleWhereUniqueInput
  }

  /**
   * tipo_detalle findUnique
   */
  export interface tipo_detalleFindUniqueArgs extends tipo_detalleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_detalle findUniqueOrThrow
   */
  export type tipo_detalleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle base type for findFirst actions
   */
  export type tipo_detalleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: Enumerable<tipo_detalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_detalles.
     */
    distinct?: Enumerable<Tipo_detalleScalarFieldEnum>
  }

  /**
   * tipo_detalle findFirst
   */
  export interface tipo_detalleFindFirstArgs extends tipo_detalleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_detalle findFirstOrThrow
   */
  export type tipo_detalleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: Enumerable<tipo_detalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_detalles.
     */
    distinct?: Enumerable<Tipo_detalleScalarFieldEnum>
  }


  /**
   * tipo_detalle findMany
   */
  export type tipo_detalleFindManyArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter, which tipo_detalles to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: Enumerable<tipo_detalleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    distinct?: Enumerable<Tipo_detalleScalarFieldEnum>
  }


  /**
   * tipo_detalle create
   */
  export type tipo_detalleCreateArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * The data needed to create a tipo_detalle.
     */
    data: XOR<tipo_detalleCreateInput, tipo_detalleUncheckedCreateInput>
  }


  /**
   * tipo_detalle createMany
   */
  export type tipo_detalleCreateManyArgs = {
    /**
     * The data used to create many tipo_detalles.
     */
    data: Enumerable<tipo_detalleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tipo_detalle update
   */
  export type tipo_detalleUpdateArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * The data needed to update a tipo_detalle.
     */
    data: XOR<tipo_detalleUpdateInput, tipo_detalleUncheckedUpdateInput>
    /**
     * Choose, which tipo_detalle to update.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle updateMany
   */
  export type tipo_detalleUpdateManyArgs = {
    /**
     * The data used to update tipo_detalles.
     */
    data: XOR<tipo_detalleUpdateManyMutationInput, tipo_detalleUncheckedUpdateManyInput>
    /**
     * Filter which tipo_detalles to update
     */
    where?: tipo_detalleWhereInput
  }


  /**
   * tipo_detalle upsert
   */
  export type tipo_detalleUpsertArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * The filter to search for the tipo_detalle to update in case it exists.
     */
    where: tipo_detalleWhereUniqueInput
    /**
     * In case the tipo_detalle found by the `where` argument doesn't exist, create a new tipo_detalle with this data.
     */
    create: XOR<tipo_detalleCreateInput, tipo_detalleUncheckedCreateInput>
    /**
     * In case the tipo_detalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_detalleUpdateInput, tipo_detalleUncheckedUpdateInput>
  }


  /**
   * tipo_detalle delete
   */
  export type tipo_detalleDeleteArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
    /**
     * Filter which tipo_detalle to delete.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle deleteMany
   */
  export type tipo_detalleDeleteManyArgs = {
    /**
     * Filter which tipo_detalles to delete
     */
    where?: tipo_detalleWhereInput
  }


  /**
   * tipo_detalle without action
   */
  export type tipo_detalleArgs = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect | null
  }



  /**
   * Model visitantes
   */


  export type AggregateVisitantes = {
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  export type VisitantesAvgAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesSumAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesMinAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesMaxAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesCountAggregateOutputType = {
    idvisitante: number
    idservicio: number
    nombre: number
    apellido: number
    dni: number
    telefono: number
    parentezco: number
    operador: number
    fecha: number
    temperatura: number
    _all: number
  }


  export type VisitantesAvgAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesSumAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesMinAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesMaxAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesCountAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
    _all?: true
  }

  export type VisitantesAggregateArgs = {
    /**
     * Filter which visitantes to aggregate.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: Enumerable<visitantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned visitantes
    **/
    _count?: true | VisitantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitantesMaxAggregateInputType
  }

  export type GetVisitantesAggregateType<T extends VisitantesAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitantes[P]>
      : GetScalarType<T[P], AggregateVisitantes[P]>
  }




  export type VisitantesGroupByArgs = {
    where?: visitantesWhereInput
    orderBy?: Enumerable<visitantesOrderByWithAggregationInput>
    by: VisitantesScalarFieldEnum[]
    having?: visitantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitantesCountAggregateInputType | true
    _avg?: VisitantesAvgAggregateInputType
    _sum?: VisitantesSumAggregateInputType
    _min?: VisitantesMinAggregateInputType
    _max?: VisitantesMaxAggregateInputType
  }


  export type VisitantesGroupByOutputType = {
    idvisitante: number
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  type GetVisitantesGroupByPayload<T extends VisitantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VisitantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
            : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
        }
      >
    >


  export type visitantesSelect = {
    idvisitante?: boolean
    idservicio?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    operador?: boolean
    fecha?: boolean
    temperatura?: boolean
  }


  export type visitantesGetPayload<S extends boolean | null | undefined | visitantesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? visitantes :
    S extends undefined ? never :
    S extends { include: any } & (visitantesArgs | visitantesFindManyArgs)
    ? visitantes 
    : S extends { select: any } & (visitantesArgs | visitantesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof visitantes ? visitantes[P] : never
  } 
      : visitantes


  type visitantesCountArgs = 
    Omit<visitantesFindManyArgs, 'select' | 'include'> & {
      select?: VisitantesCountAggregateInputType | true
    }

  export interface visitantesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Visitantes that matches the filter.
     * @param {visitantesFindUniqueArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends visitantesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, visitantesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'visitantes'> extends True ? Prisma__visitantesClient<visitantesGetPayload<T>> : Prisma__visitantesClient<visitantesGetPayload<T> | null, null>

    /**
     * Find one Visitantes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {visitantesFindUniqueOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends visitantesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, visitantesFindUniqueOrThrowArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Find the first Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends visitantesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, visitantesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'visitantes'> extends True ? Prisma__visitantesClient<visitantesGetPayload<T>> : Prisma__visitantesClient<visitantesGetPayload<T> | null, null>

    /**
     * Find the first Visitantes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends visitantesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, visitantesFindFirstOrThrowArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Find zero or more Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitantes
     * const visitantes = await prisma.visitantes.findMany()
     * 
     * // Get first 10 Visitantes
     * const visitantes = await prisma.visitantes.findMany({ take: 10 })
     * 
     * // Only select the `idvisitante`
     * const visitantesWithIdvisitanteOnly = await prisma.visitantes.findMany({ select: { idvisitante: true } })
     * 
    **/
    findMany<T extends visitantesFindManyArgs>(
      args?: SelectSubset<T, visitantesFindManyArgs>
    ): Prisma.PrismaPromise<Array<visitantesGetPayload<T>>>

    /**
     * Create a Visitantes.
     * @param {visitantesCreateArgs} args - Arguments to create a Visitantes.
     * @example
     * // Create one Visitantes
     * const Visitantes = await prisma.visitantes.create({
     *   data: {
     *     // ... data to create a Visitantes
     *   }
     * })
     * 
    **/
    create<T extends visitantesCreateArgs>(
      args: SelectSubset<T, visitantesCreateArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Create many Visitantes.
     *     @param {visitantesCreateManyArgs} args - Arguments to create many Visitantes.
     *     @example
     *     // Create many Visitantes
     *     const visitantes = await prisma.visitantes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends visitantesCreateManyArgs>(
      args?: SelectSubset<T, visitantesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitantes.
     * @param {visitantesDeleteArgs} args - Arguments to delete one Visitantes.
     * @example
     * // Delete one Visitantes
     * const Visitantes = await prisma.visitantes.delete({
     *   where: {
     *     // ... filter to delete one Visitantes
     *   }
     * })
     * 
    **/
    delete<T extends visitantesDeleteArgs>(
      args: SelectSubset<T, visitantesDeleteArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Update one Visitantes.
     * @param {visitantesUpdateArgs} args - Arguments to update one Visitantes.
     * @example
     * // Update one Visitantes
     * const visitantes = await prisma.visitantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends visitantesUpdateArgs>(
      args: SelectSubset<T, visitantesUpdateArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Delete zero or more Visitantes.
     * @param {visitantesDeleteManyArgs} args - Arguments to filter Visitantes to delete.
     * @example
     * // Delete a few Visitantes
     * const { count } = await prisma.visitantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends visitantesDeleteManyArgs>(
      args?: SelectSubset<T, visitantesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitantes
     * const visitantes = await prisma.visitantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends visitantesUpdateManyArgs>(
      args: SelectSubset<T, visitantesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitantes.
     * @param {visitantesUpsertArgs} args - Arguments to update or create a Visitantes.
     * @example
     * // Update or create a Visitantes
     * const visitantes = await prisma.visitantes.upsert({
     *   create: {
     *     // ... data to create a Visitantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitantes we want to update
     *   }
     * })
    **/
    upsert<T extends visitantesUpsertArgs>(
      args: SelectSubset<T, visitantesUpsertArgs>
    ): Prisma__visitantesClient<visitantesGetPayload<T>>

    /**
     * Count the number of Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesCountArgs} args - Arguments to filter Visitantes to count.
     * @example
     * // Count the number of Visitantes
     * const count = await prisma.visitantes.count({
     *   where: {
     *     // ... the filter for the Visitantes we want to count
     *   }
     * })
    **/
    count<T extends visitantesCountArgs>(
      args?: Subset<T, visitantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitantesAggregateArgs>(args: Subset<T, VisitantesAggregateArgs>): Prisma.PrismaPromise<GetVisitantesAggregateType<T>>

    /**
     * Group by Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitantesGroupByArgs['orderBy'] }
        : { orderBy?: VisitantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for visitantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__visitantesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * visitantes base type for findUnique actions
   */
  export type visitantesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }

  /**
   * visitantes findUnique
   */
  export interface visitantesFindUniqueArgs extends visitantesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findUniqueOrThrow
   */
  export type visitantesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes base type for findFirst actions
   */
  export type visitantesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: Enumerable<visitantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: Enumerable<VisitantesScalarFieldEnum>
  }

  /**
   * visitantes findFirst
   */
  export interface visitantesFindFirstArgs extends visitantesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findFirstOrThrow
   */
  export type visitantesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: Enumerable<visitantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: Enumerable<VisitantesScalarFieldEnum>
  }


  /**
   * visitantes findMany
   */
  export type visitantesFindManyArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: Enumerable<visitantesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    distinct?: Enumerable<VisitantesScalarFieldEnum>
  }


  /**
   * visitantes create
   */
  export type visitantesCreateArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * The data needed to create a visitantes.
     */
    data: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
  }


  /**
   * visitantes createMany
   */
  export type visitantesCreateManyArgs = {
    /**
     * The data used to create many visitantes.
     */
    data: Enumerable<visitantesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * visitantes update
   */
  export type visitantesUpdateArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * The data needed to update a visitantes.
     */
    data: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
    /**
     * Choose, which visitantes to update.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes updateMany
   */
  export type visitantesUpdateManyArgs = {
    /**
     * The data used to update visitantes.
     */
    data: XOR<visitantesUpdateManyMutationInput, visitantesUncheckedUpdateManyInput>
    /**
     * Filter which visitantes to update
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes upsert
   */
  export type visitantesUpsertArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * The filter to search for the visitantes to update in case it exists.
     */
    where: visitantesWhereUniqueInput
    /**
     * In case the visitantes found by the `where` argument doesn't exist, create a new visitantes with this data.
     */
    create: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
    /**
     * In case the visitantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
  }


  /**
   * visitantes delete
   */
  export type visitantesDeleteArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
    /**
     * Filter which visitantes to delete.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes deleteMany
   */
  export type visitantesDeleteManyArgs = {
    /**
     * Filter which visitantes to delete
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes without action
   */
  export type visitantesArgs = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Ataud_precioScalarFieldEnum: {
    idprecio: 'idprecio',
    idataud: 'idataud',
    codigo: 'codigo',
    ataud: 'ataud',
    precio: 'precio',
    pri_desc: 'pri_desc',
    sec_desc: 'sec_desc',
    fecha: 'fecha',
    operador: 'operador',
    estado: 'estado'
  };

  export type Ataud_precioScalarFieldEnum = (typeof Ataud_precioScalarFieldEnum)[keyof typeof Ataud_precioScalarFieldEnum]


  export const Ataud_ventaScalarFieldEnum: {
    idataudventa: 'idataudventa',
    idataud: 'idataud',
    contrato: 'contrato',
    apellido_fall: 'apellido_fall',
    nombre_fall: 'nombre_fall',
    dni_fall: 'dni_fall',
    dom_fall: 'dom_fall',
    ndom_fall: 'ndom_fall',
    barrio_fall: 'barrio_fall',
    telefono_fall: 'telefono_fall',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    telefono_sol: 'telefono_sol',
    fecha: 'fecha',
    operador: 'operador',
    ataud: 'ataud'
  };

  export type Ataud_ventaScalarFieldEnum = (typeof Ataud_ventaScalarFieldEnum)[keyof typeof Ataud_ventaScalarFieldEnum]


  export const AtaudesScalarFieldEnum: {
    idataud: 'idataud',
    nombre: 'nombre',
    tipo: 'tipo',
    medidas: 'medidas',
    uso: 'uso',
    fabricante: 'fabricante',
    codigo: 'codigo',
    fecha_alta: 'fecha_alta',
    stock: 'stock',
    fecha_reposicion: 'fecha_reposicion',
    fecha_baja: 'fecha_baja',
    observaciones: 'observaciones',
    estado: 'estado',
    operador: 'operador'
  };

  export type AtaudesScalarFieldEnum = (typeof AtaudesScalarFieldEnum)[keyof typeof AtaudesScalarFieldEnum]


  export const AutosScalarFieldEnum: {
    patente: 'patente',
    auto: 'auto',
    kilometros: 'kilometros',
    responsable: 'responsable',
    nro_poliza: 'nro_poliza',
    empresa: 'empresa',
    vencimiento: 'vencimiento',
    motor: 'motor',
    chasis: 'chasis',
    modelo: 'modelo',
    cobertura: 'cobertura',
    idauto: 'idauto',
    estado: 'estado',
    operador: 'operador'
  };

  export type AutosScalarFieldEnum = (typeof AutosScalarFieldEnum)[keyof typeof AutosScalarFieldEnum]


  export const Autos_hoja_rutaScalarFieldEnum: {
    idhojaruta: 'idhojaruta',
    patente: 'patente',
    auto: 'auto',
    conductor: 'conductor',
    idservicio: 'idservicio',
    fecha_salida: 'fecha_salida',
    km_salida: 'km_salida',
    fecha_llegada: 'fecha_llegada',
    km_llegada: 'km_llegada',
    fecha_registro: 'fecha_registro',
    operador: 'operador'
  };

  export type Autos_hoja_rutaScalarFieldEnum = (typeof Autos_hoja_rutaScalarFieldEnum)[keyof typeof Autos_hoja_rutaScalarFieldEnum]


  export const Autos_novedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    patente: 'patente',
    fecha: 'fecha',
    novedad: 'novedad',
    operador: 'operador',
    auto: 'auto'
  };

  export type Autos_novedadesScalarFieldEnum = (typeof Autos_novedadesScalarFieldEnum)[keyof typeof Autos_novedadesScalarFieldEnum]


  export const Autos_pago_patenteScalarFieldEnum: {
    idpago: 'idpago',
    patente: 'patente',
    mes: 'mes',
    ano: 'ano',
    importe: 'importe',
    cod_pago: 'cod_pago',
    idauto: 'idauto',
    operador: 'operador'
  };

  export type Autos_pago_patenteScalarFieldEnum = (typeof Autos_pago_patenteScalarFieldEnum)[keyof typeof Autos_pago_patenteScalarFieldEnum]


  export const Caja_sepelioScalarFieldEnum: {
    idcaja: 'idcaja',
    operador: 'operador',
    detalle: 'detalle',
    monto: 'monto',
    estado: 'estado',
    fecha: 'fecha',
    gastos: 'gastos',
    totalcaja: 'totalcaja',
    empresa: 'empresa',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    ptoventa: 'ptoventa',
    concepto: 'concepto',
    cierre: 'cierre',
    ultimacarga: 'ultimacarga'
  };

  export type Caja_sepelioScalarFieldEnum = (typeof Caja_sepelioScalarFieldEnum)[keyof typeof Caja_sepelioScalarFieldEnum]


  export const ConceptosScalarFieldEnum: {
    idconcepto: 'idconcepto',
    concepto: 'concepto',
    tipo: 'tipo'
  };

  export type ConceptosScalarFieldEnum = (typeof ConceptosScalarFieldEnum)[keyof typeof ConceptosScalarFieldEnum]


  export const Fabricante_ataudScalarFieldEnum: {
    idfabricante: 'idfabricante',
    fabricante: 'fabricante'
  };

  export type Fabricante_ataudScalarFieldEnum = (typeof Fabricante_ataudScalarFieldEnum)[keyof typeof Fabricante_ataudScalarFieldEnum]


  export const Gasto_lutoScalarFieldEnum: {
    idgastoluto: 'idgastoluto',
    idservicio: 'idservicio',
    contrato: 'contrato',
    dni_extinto: 'dni_extinto',
    extinto: 'extinto',
    gasto_luto: 'gasto_luto',
    idataud: 'idataud',
    apellido_ben: 'apellido_ben',
    nombre_ben: 'nombre_ben',
    telefono_ben: 'telefono_ben',
    fecha: 'fecha',
    operador: 'operador',
    parentezco: 'parentezco'
  };

  export type Gasto_lutoScalarFieldEnum = (typeof Gasto_lutoScalarFieldEnum)[keyof typeof Gasto_lutoScalarFieldEnum]


  export const Gastos_cajaScalarFieldEnum: {
    idgastos: 'idgastos',
    idcaja: 'idcaja',
    concepto: 'concepto',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    fecha: 'fecha',
    operadorgestion: 'operadorgestion',
    operadortramite: 'operadortramite',
    ptoventa: 'ptoventa',
    porciva: 'porciva',
    montoiva: 'montoiva',
    retiibb: 'retiibb',
    retggcias: 'retggcias',
    perciva: 'perciva',
    detalle: 'detalle',
    mediopago: 'mediopago',
    proveedor: 'proveedor',
    empresa: 'empresa',
    total: 'total',
    idservicio: 'idservicio'
  };

  export type Gastos_cajaScalarFieldEnum = (typeof Gastos_cajaScalarFieldEnum)[keyof typeof Gastos_cajaScalarFieldEnum]


  export const Historial_autosScalarFieldEnum: {
    idhistorial: 'idhistorial',
    patente: 'patente',
    idauto: 'idauto',
    operador: 'operador',
    fecha: 'fecha',
    accion: 'accion'
  };

  export type Historial_autosScalarFieldEnum = (typeof Historial_autosScalarFieldEnum)[keyof typeof Historial_autosScalarFieldEnum]


  export const Historial_stock_ataudScalarFieldEnum: {
    idhistorial: 'idhistorial',
    idataud: 'idataud',
    fecha_carga: 'fecha_carga',
    stock_anterior: 'stock_anterior',
    stock_nuevo: 'stock_nuevo',
    remito: 'remito',
    operador: 'operador',
    fecha_recepcion: 'fecha_recepcion'
  };

  export type Historial_stock_ataudScalarFieldEnum = (typeof Historial_stock_ataudScalarFieldEnum)[keyof typeof Historial_stock_ataudScalarFieldEnum]


  export const HonorariosScalarFieldEnum: {
    idtrabajo: 'idtrabajo',
    trabajo: 'trabajo',
    dias_habiles: 'dias_habiles',
    finde: 'finde',
    feriado: 'feriado'
  };

  export type HonorariosScalarFieldEnum = (typeof HonorariosScalarFieldEnum)[keyof typeof HonorariosScalarFieldEnum]


  export const Ingreso_cajaScalarFieldEnum: {
    idingreso: 'idingreso',
    idcaja: 'idcaja',
    concepto: 'concepto',
    monto: 'monto',
    operador: 'operador',
    fecha: 'fecha',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    empresa: 'empresa',
    detalle: 'detalle',
    ptoventa: 'ptoventa'
  };

  export type Ingreso_cajaScalarFieldEnum = (typeof Ingreso_cajaScalarFieldEnum)[keyof typeof Ingreso_cajaScalarFieldEnum]


  export const Legajo_virtual_autosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    patente: 'patente',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida'
  };

  export type Legajo_virtual_autosScalarFieldEnum = (typeof Legajo_virtual_autosScalarFieldEnum)[keyof typeof Legajo_virtual_autosScalarFieldEnum]


  export const Legajo_virtual_serviciosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    servicio: 'servicio',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa'
  };

  export type Legajo_virtual_serviciosScalarFieldEnum = (typeof Legajo_virtual_serviciosScalarFieldEnum)[keyof typeof Legajo_virtual_serviciosScalarFieldEnum]


  export const NovedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    novedad: 'novedad',
    fecha: 'fecha',
    operador: 'operador'
  };

  export type NovedadesScalarFieldEnum = (typeof NovedadesScalarFieldEnum)[keyof typeof NovedadesScalarFieldEnum]


  export const OperadorsepScalarFieldEnum: {
    idoperador: 'idoperador',
    operador: 'operador'
  };

  export type OperadorsepScalarFieldEnum = (typeof OperadorsepScalarFieldEnum)[keyof typeof OperadorsepScalarFieldEnum]


  export const ParcelasScalarFieldEnum: {
    idparcela: 'idparcela',
    idservicio: 'idservicio',
    dni_extinto: 'dni_extinto',
    ficha: 'ficha',
    parcela: 'parcela',
    mza: 'mza',
    lote: 'lote',
    asignada: 'asignada',
    fecha: 'fecha',
    cementerio: 'cementerio',
    operador: 'operador',
    fecha_alta: 'fecha_alta',
    operador_asignacion: 'operador_asignacion',
    fecha_asignacion: 'fecha_asignacion',
    lugares: 'lugares'
  };

  export type ParcelasScalarFieldEnum = (typeof ParcelasScalarFieldEnum)[keyof typeof ParcelasScalarFieldEnum]


  export const Planificacion_guardiasScalarFieldEnum: {
    idturno: 'idturno',
    lugar: 'lugar',
    inicio: 'inicio',
    fin: 'fin',
    horas: 'horas',
    operador: 'operador',
    mes_planificacion: 'mes_planificacion',
    feriado: 'feriado',
    tarea: 'tarea',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    operadorap: 'operadorap',
    ano_planificacion: 'ano_planificacion'
  };

  export type Planificacion_guardiasScalarFieldEnum = (typeof Planificacion_guardiasScalarFieldEnum)[keyof typeof Planificacion_guardiasScalarFieldEnum]


  export const Precio_servicioScalarFieldEnum: {
    idprecio: 'idprecio',
    codigo: 'codigo',
    contado: 'contado',
    contado_cremacion: 'contado_cremacion',
    descuento1: 'descuento1',
    descuento1_cremacion: 'descuento1_cremacion',
    descuento2: 'descuento2',
    descuento2_cremacion: 'descuento2_cremacion',
    fecha_vigencia: 'fecha_vigencia'
  };

  export type Precio_servicioScalarFieldEnum = (typeof Precio_servicioScalarFieldEnum)[keyof typeof Precio_servicioScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    idproveedor: 'idproveedor',
    razon: 'razon',
    cuit: 'cuit',
    domicilio: 'domicilio',
    telefonos: 'telefonos',
    estado: 'estado',
    operador: 'operador'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const Servicio_detallesScalarFieldEnum: {
    iddetalles: 'iddetalles',
    idservicio: 'idservicio',
    detalle: 'detalle',
    lugar: 'lugar',
    monto: 'monto',
    patente: 'patente',
    operador: 'operador',
    fecha: 'fecha',
    observacion: 'observacion'
  };

  export type Servicio_detallesScalarFieldEnum = (typeof Servicio_detallesScalarFieldEnum)[keyof typeof Servicio_detallesScalarFieldEnum]


  export const Servicio_gastosScalarFieldEnum: {
    idgastos: 'idgastos',
    idservicio: 'idservicio',
    tipo_gasto: 'tipo_gasto',
    horas: 'horas',
    operador: 'operador',
    observaciones: 'observaciones',
    inicio: 'inicio',
    fin: 'fin',
    feriado: 'feriado',
    liquidado: 'liquidado',
    operadorliq: 'operadorliq',
    fecha_liquidacion: 'fecha_liquidacion',
    aprobado: 'aprobado',
    operadorap: 'operadorap',
    fecha_aprobacion: 'fecha_aprobacion'
  };

  export type Servicio_gastosScalarFieldEnum = (typeof Servicio_gastosScalarFieldEnum)[keyof typeof Servicio_gastosScalarFieldEnum]


  export const Servicio_ventaScalarFieldEnum: {
    idventa: 'idventa',
    idservicio: 'idservicio',
    monto: 'monto',
    operador: 'operador',
    fecha_venta: 'fecha_venta',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    parentesco: 'parentesco',
    operador_venta: 'operador_venta',
    liquidado: 'liquidado',
    operadorliq: 'operadorliq',
    fecha_liquidacion: 'fecha_liquidacion',
    aprobado: 'aprobado',
    operadorap: 'operadorap',
    fecha_aprobacion: 'fecha_aprobacion',
    comision: 'comision',
    fecha_carga: 'fecha_carga',
    valor_cuota: 'valor_cuota',
    plan_cuota: 'plan_cuota',
    monto_financiacion: 'monto_financiacion',
    financiacion: 'financiacion',
    efectivo: 'efectivo'
  };

  export type Servicio_ventaScalarFieldEnum = (typeof Servicio_ventaScalarFieldEnum)[keyof typeof Servicio_ventaScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    idservicio: 'idservicio',
    empresa: 'empresa',
    dni: 'dni',
    apellido: 'apellido',
    nombre: 'nombre',
    edad: 'edad',
    fecha_fallecimiento: 'fecha_fallecimiento',
    lugar_fallecimiento: 'lugar_fallecimiento',
    tipo_servicio: 'tipo_servicio',
    casa_mortuaria: 'casa_mortuaria',
    fecha_inhumacion: 'fecha_inhumacion',
    hora_inhumacion: 'hora_inhumacion',
    cementerio: 'cementerio',
    estado: 'estado',
    contrato: 'contrato',
    fecha_recepcion: 'fecha_recepcion',
    sucursal: 'sucursal',
    motivo: 'motivo',
    retiro: 'retiro',
    solicitado: 'solicitado',
    parentesco: 'parentesco',
    altura: 'altura',
    peso: 'peso',
    dni_nuevotitular: 'dni_nuevotitular',
    operador: 'operador',
    idataud: 'idataud',
    dni_solicitante: 'dni_solicitante',
    impactado: 'impactado',
    cremacion: 'cremacion',
    idparcela: 'idparcela',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    gastos_cargados: 'gastos_cargados',
    obra_soc: 'obra_soc',
    importe: 'importe',
    donacion: 'donacion',
    domicilio_solicitante: 'domicilio_solicitante'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const Servicios_liquidacionScalarFieldEnum: {
    idliquidacion: 'idliquidacion',
    idservicio: 'idservicio',
    total_liquidacion: 'total_liquidacion',
    fecha_liquidacion: 'fecha_liquidacion',
    operador: 'operador'
  };

  export type Servicios_liquidacionScalarFieldEnum = (typeof Servicios_liquidacionScalarFieldEnum)[keyof typeof Servicios_liquidacionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TareasScalarFieldEnum: {
    idevents: 'idevents',
    title: 'title',
    allDay: 'allDay',
    start: 'start',
    end: 'end',
    priority: 'priority'
  };

  export type TareasScalarFieldEnum = (typeof TareasScalarFieldEnum)[keyof typeof TareasScalarFieldEnum]


  export const Tareas_adicionalesScalarFieldEnum: {
    idtarea: 'idtarea',
    inicio: 'inicio',
    fin: 'fin',
    tarea: 'tarea',
    operador: 'operador',
    observaciones: 'observaciones',
    horas: 'horas',
    feriado: 'feriado',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    operadorap: 'operadorap',
    mes_planificacion: 'mes_planificacion'
  };

  export type Tareas_adicionalesScalarFieldEnum = (typeof Tareas_adicionalesScalarFieldEnum)[keyof typeof Tareas_adicionalesScalarFieldEnum]


  export const Tipo_detalleScalarFieldEnum: {
    idtipodetalle: 'idtipodetalle',
    tipo_detalle: 'tipo_detalle',
    observacion: 'observacion'
  };

  export type Tipo_detalleScalarFieldEnum = (typeof Tipo_detalleScalarFieldEnum)[keyof typeof Tipo_detalleScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VisitantesScalarFieldEnum: {
    idvisitante: 'idvisitante',
    idservicio: 'idservicio',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    telefono: 'telefono',
    parentezco: 'parentezco',
    operador: 'operador',
    fecha: 'fecha',
    temperatura: 'temperatura'
  };

  export type VisitantesScalarFieldEnum = (typeof VisitantesScalarFieldEnum)[keyof typeof VisitantesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type ataud_precioWhereInput = {
    AND?: Enumerable<ataud_precioWhereInput>
    OR?: Enumerable<ataud_precioWhereInput>
    NOT?: Enumerable<ataud_precioWhereInput>
    idprecio?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    ataud?: StringNullableFilter | string | null
    precio?: FloatNullableFilter | number | null
    pri_desc?: FloatNullableFilter | number | null
    sec_desc?: FloatNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type ataud_precioOrderByWithRelationInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioWhereUniqueInput = {
    idprecio?: number
  }

  export type ataud_precioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
    _count?: ataud_precioCountOrderByAggregateInput
    _avg?: ataud_precioAvgOrderByAggregateInput
    _max?: ataud_precioMaxOrderByAggregateInput
    _min?: ataud_precioMinOrderByAggregateInput
    _sum?: ataud_precioSumOrderByAggregateInput
  }

  export type ataud_precioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ataud_precioScalarWhereWithAggregatesInput>
    OR?: Enumerable<ataud_precioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ataud_precioScalarWhereWithAggregatesInput>
    idprecio?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    ataud?: StringNullableWithAggregatesFilter | string | null
    precio?: FloatNullableWithAggregatesFilter | number | null
    pri_desc?: FloatNullableWithAggregatesFilter | number | null
    sec_desc?: FloatNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ataud_ventaWhereInput = {
    AND?: Enumerable<ataud_ventaWhereInput>
    OR?: Enumerable<ataud_ventaWhereInput>
    NOT?: Enumerable<ataud_ventaWhereInput>
    idataudventa?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    apellido_fall?: StringNullableFilter | string | null
    nombre_fall?: StringNullableFilter | string | null
    dni_fall?: IntNullableFilter | number | null
    dom_fall?: StringNullableFilter | string | null
    ndom_fall?: IntNullableFilter | number | null
    barrio_fall?: StringNullableFilter | string | null
    telefono_fall?: StringNullableFilter | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    telefono_sol?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    ataud?: StringNullableFilter | string | null
  }

  export type ataud_ventaOrderByWithRelationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaWhereUniqueInput = {
    idataudventa?: number
  }

  export type ataud_ventaOrderByWithAggregationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
    _count?: ataud_ventaCountOrderByAggregateInput
    _avg?: ataud_ventaAvgOrderByAggregateInput
    _max?: ataud_ventaMaxOrderByAggregateInput
    _min?: ataud_ventaMinOrderByAggregateInput
    _sum?: ataud_ventaSumOrderByAggregateInput
  }

  export type ataud_ventaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ataud_ventaScalarWhereWithAggregatesInput>
    OR?: Enumerable<ataud_ventaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ataud_ventaScalarWhereWithAggregatesInput>
    idataudventa?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    apellido_fall?: StringNullableWithAggregatesFilter | string | null
    nombre_fall?: StringNullableWithAggregatesFilter | string | null
    dni_fall?: IntNullableWithAggregatesFilter | number | null
    dom_fall?: StringNullableWithAggregatesFilter | string | null
    ndom_fall?: IntNullableWithAggregatesFilter | number | null
    barrio_fall?: StringNullableWithAggregatesFilter | string | null
    telefono_fall?: StringNullableWithAggregatesFilter | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    telefono_sol?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    ataud?: StringNullableWithAggregatesFilter | string | null
  }

  export type ataudesWhereInput = {
    AND?: Enumerable<ataudesWhereInput>
    OR?: Enumerable<ataudesWhereInput>
    NOT?: Enumerable<ataudesWhereInput>
    idataud?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    medidas?: StringNullableFilter | string | null
    uso?: StringNullableFilter | string | null
    fabricante?: StringNullableFilter | string | null
    codigo?: IntNullableFilter | number | null
    fecha_alta?: DateTimeNullableFilter | Date | string | null
    stock?: IntNullableFilter | number | null
    fecha_reposicion?: DateTimeNullableFilter | Date | string | null
    fecha_baja?: DateTimeNullableFilter | Date | string | null
    observaciones?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type ataudesOrderByWithRelationInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesWhereUniqueInput = {
    idataud?: number
  }

  export type ataudesOrderByWithAggregationInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
    _count?: ataudesCountOrderByAggregateInput
    _avg?: ataudesAvgOrderByAggregateInput
    _max?: ataudesMaxOrderByAggregateInput
    _min?: ataudesMinOrderByAggregateInput
    _sum?: ataudesSumOrderByAggregateInput
  }

  export type ataudesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ataudesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ataudesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ataudesScalarWhereWithAggregatesInput>
    idataud?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    medidas?: StringNullableWithAggregatesFilter | string | null
    uso?: StringNullableWithAggregatesFilter | string | null
    fabricante?: StringNullableWithAggregatesFilter | string | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    fecha_alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock?: IntNullableWithAggregatesFilter | number | null
    fecha_reposicion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha_baja?: DateTimeNullableWithAggregatesFilter | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autosWhereInput = {
    AND?: Enumerable<autosWhereInput>
    OR?: Enumerable<autosWhereInput>
    NOT?: Enumerable<autosWhereInput>
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    kilometros?: FloatNullableFilter | number | null
    responsable?: StringNullableFilter | string | null
    nro_poliza?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    vencimiento?: DateTimeNullableFilter | Date | string | null
    motor?: StringNullableFilter | string | null
    chasis?: StringNullableFilter | string | null
    modelo?: IntNullableFilter | number | null
    cobertura?: StringNullableFilter | string | null
    idauto?: IntFilter | number
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type autosOrderByWithRelationInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosWhereUniqueInput = {
    idauto?: number
  }

  export type autosOrderByWithAggregationInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
    _count?: autosCountOrderByAggregateInput
    _avg?: autosAvgOrderByAggregateInput
    _max?: autosMaxOrderByAggregateInput
    _min?: autosMinOrderByAggregateInput
    _sum?: autosSumOrderByAggregateInput
  }

  export type autosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<autosScalarWhereWithAggregatesInput>
    OR?: Enumerable<autosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<autosScalarWhereWithAggregatesInput>
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    kilometros?: FloatNullableWithAggregatesFilter | number | null
    responsable?: StringNullableWithAggregatesFilter | string | null
    nro_poliza?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    vencimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    motor?: StringNullableWithAggregatesFilter | string | null
    chasis?: StringNullableWithAggregatesFilter | string | null
    modelo?: IntNullableWithAggregatesFilter | number | null
    cobertura?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntWithAggregatesFilter | number
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_hoja_rutaWhereInput = {
    AND?: Enumerable<autos_hoja_rutaWhereInput>
    OR?: Enumerable<autos_hoja_rutaWhereInput>
    NOT?: Enumerable<autos_hoja_rutaWhereInput>
    idhojaruta?: IntFilter | number
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    conductor?: StringNullableFilter | string | null
    idservicio?: IntNullableFilter | number | null
    fecha_salida?: DateTimeNullableFilter | Date | string | null
    km_salida?: IntNullableFilter | number | null
    fecha_llegada?: DateTimeNullableFilter | Date | string | null
    km_llegada?: IntNullableFilter | number | null
    fecha_registro?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_hoja_rutaOrderByWithRelationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaWhereUniqueInput = {
    idhojaruta?: number
  }

  export type autos_hoja_rutaOrderByWithAggregationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
    _count?: autos_hoja_rutaCountOrderByAggregateInput
    _avg?: autos_hoja_rutaAvgOrderByAggregateInput
    _max?: autos_hoja_rutaMaxOrderByAggregateInput
    _min?: autos_hoja_rutaMinOrderByAggregateInput
    _sum?: autos_hoja_rutaSumOrderByAggregateInput
  }

  export type autos_hoja_rutaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<autos_hoja_rutaScalarWhereWithAggregatesInput>
    OR?: Enumerable<autos_hoja_rutaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<autos_hoja_rutaScalarWhereWithAggregatesInput>
    idhojaruta?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    conductor?: StringNullableWithAggregatesFilter | string | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    fecha_salida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_salida?: IntNullableWithAggregatesFilter | number | null
    fecha_llegada?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_llegada?: IntNullableWithAggregatesFilter | number | null
    fecha_registro?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_novedadesWhereInput = {
    AND?: Enumerable<autos_novedadesWhereInput>
    OR?: Enumerable<autos_novedadesWhereInput>
    NOT?: Enumerable<autos_novedadesWhereInput>
    idnovedad?: IntFilter | number
    patente?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    novedad?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
  }

  export type autos_novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type autos_novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
    _count?: autos_novedadesCountOrderByAggregateInput
    _avg?: autos_novedadesAvgOrderByAggregateInput
    _max?: autos_novedadesMaxOrderByAggregateInput
    _min?: autos_novedadesMinOrderByAggregateInput
    _sum?: autos_novedadesSumOrderByAggregateInput
  }

  export type autos_novedadesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<autos_novedadesScalarWhereWithAggregatesInput>
    OR?: Enumerable<autos_novedadesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<autos_novedadesScalarWhereWithAggregatesInput>
    idnovedad?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    novedad?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_pago_patenteWhereInput = {
    AND?: Enumerable<autos_pago_patenteWhereInput>
    OR?: Enumerable<autos_pago_patenteWhereInput>
    NOT?: Enumerable<autos_pago_patenteWhereInput>
    idpago?: IntFilter | number
    patente?: StringNullableFilter | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    cod_pago?: IntNullableFilter | number | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_pago_patenteOrderByWithRelationInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteWhereUniqueInput = {
    idpago?: number
  }

  export type autos_pago_patenteOrderByWithAggregationInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    _count?: autos_pago_patenteCountOrderByAggregateInput
    _avg?: autos_pago_patenteAvgOrderByAggregateInput
    _max?: autos_pago_patenteMaxOrderByAggregateInput
    _min?: autos_pago_patenteMinOrderByAggregateInput
    _sum?: autos_pago_patenteSumOrderByAggregateInput
  }

  export type autos_pago_patenteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<autos_pago_patenteScalarWhereWithAggregatesInput>
    OR?: Enumerable<autos_pago_patenteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<autos_pago_patenteScalarWhereWithAggregatesInput>
    idpago?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    cod_pago?: IntNullableWithAggregatesFilter | number | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_sepelioWhereInput = {
    AND?: Enumerable<caja_sepelioWhereInput>
    OR?: Enumerable<caja_sepelioWhereInput>
    NOT?: Enumerable<caja_sepelioWhereInput>
    idcaja?: IntFilter | number
    operador?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    estado?: BoolNullableFilter | boolean | null
    fecha?: DateTimeNullableFilter | Date | string | null
    gastos?: FloatNullableFilter | number | null
    totalcaja?: FloatNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: IntNullableFilter | number | null
    ptoventa?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    cierre?: DateTimeNullableFilter | Date | string | null
    ultimacarga?: DateTimeNullableFilter | Date | string | null
  }

  export type caja_sepelioOrderByWithRelationInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_sepelioOrderByWithAggregationInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
    _count?: caja_sepelioCountOrderByAggregateInput
    _avg?: caja_sepelioAvgOrderByAggregateInput
    _max?: caja_sepelioMaxOrderByAggregateInput
    _min?: caja_sepelioMinOrderByAggregateInput
    _sum?: caja_sepelioSumOrderByAggregateInput
  }

  export type caja_sepelioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<caja_sepelioScalarWhereWithAggregatesInput>
    OR?: Enumerable<caja_sepelioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<caja_sepelioScalarWhereWithAggregatesInput>
    idcaja?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gastos?: FloatNullableWithAggregatesFilter | number | null
    totalcaja?: FloatNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: IntNullableWithAggregatesFilter | number | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    cierre?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ultimacarga?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type conceptosWhereInput = {
    AND?: Enumerable<conceptosWhereInput>
    OR?: Enumerable<conceptosWhereInput>
    NOT?: Enumerable<conceptosWhereInput>
    idconcepto?: IntFilter | number
    concepto?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
  }

  export type conceptosOrderByWithRelationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosWhereUniqueInput = {
    idconcepto?: number
  }

  export type conceptosOrderByWithAggregationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
    _count?: conceptosCountOrderByAggregateInput
    _avg?: conceptosAvgOrderByAggregateInput
    _max?: conceptosMaxOrderByAggregateInput
    _min?: conceptosMinOrderByAggregateInput
    _sum?: conceptosSumOrderByAggregateInput
  }

  export type conceptosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<conceptosScalarWhereWithAggregatesInput>
    OR?: Enumerable<conceptosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<conceptosScalarWhereWithAggregatesInput>
    idconcepto?: IntWithAggregatesFilter | number
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type fabricante_ataudWhereInput = {
    AND?: Enumerable<fabricante_ataudWhereInput>
    OR?: Enumerable<fabricante_ataudWhereInput>
    NOT?: Enumerable<fabricante_ataudWhereInput>
    idfabricante?: IntFilter | number
    fabricante?: StringNullableFilter | string | null
  }

  export type fabricante_ataudOrderByWithRelationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudWhereUniqueInput = {
    idfabricante?: number
  }

  export type fabricante_ataudOrderByWithAggregationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
    _count?: fabricante_ataudCountOrderByAggregateInput
    _avg?: fabricante_ataudAvgOrderByAggregateInput
    _max?: fabricante_ataudMaxOrderByAggregateInput
    _min?: fabricante_ataudMinOrderByAggregateInput
    _sum?: fabricante_ataudSumOrderByAggregateInput
  }

  export type fabricante_ataudScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fabricante_ataudScalarWhereWithAggregatesInput>
    OR?: Enumerable<fabricante_ataudScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fabricante_ataudScalarWhereWithAggregatesInput>
    idfabricante?: IntWithAggregatesFilter | number
    fabricante?: StringNullableWithAggregatesFilter | string | null
  }

  export type gasto_lutoWhereInput = {
    AND?: Enumerable<gasto_lutoWhereInput>
    OR?: Enumerable<gasto_lutoWhereInput>
    NOT?: Enumerable<gasto_lutoWhereInput>
    idgastoluto?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    extinto?: StringNullableFilter | string | null
    gasto_luto?: FloatNullableFilter | number | null
    idataud?: IntNullableFilter | number | null
    apellido_ben?: StringNullableFilter | string | null
    nombre_ben?: StringNullableFilter | string | null
    telefono_ben?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    parentezco?: StringNullableFilter | string | null
  }

  export type gasto_lutoOrderByWithRelationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoWhereUniqueInput = {
    idgastoluto?: number
  }

  export type gasto_lutoOrderByWithAggregationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
    _count?: gasto_lutoCountOrderByAggregateInput
    _avg?: gasto_lutoAvgOrderByAggregateInput
    _max?: gasto_lutoMaxOrderByAggregateInput
    _min?: gasto_lutoMinOrderByAggregateInput
    _sum?: gasto_lutoSumOrderByAggregateInput
  }

  export type gasto_lutoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gasto_lutoScalarWhereWithAggregatesInput>
    OR?: Enumerable<gasto_lutoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gasto_lutoScalarWhereWithAggregatesInput>
    idgastoluto?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    extinto?: StringNullableWithAggregatesFilter | string | null
    gasto_luto?: FloatNullableWithAggregatesFilter | number | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    apellido_ben?: StringNullableWithAggregatesFilter | string | null
    nombre_ben?: StringNullableWithAggregatesFilter | string | null
    telefono_ben?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
  }

  export type gastos_cajaWhereInput = {
    AND?: Enumerable<gastos_cajaWhereInput>
    OR?: Enumerable<gastos_cajaWhereInput>
    NOT?: Enumerable<gastos_cajaWhereInput>
    idgastos?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operadorgestion?: StringNullableFilter | string | null
    operadortramite?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
    porciva?: StringNullableFilter | string | null
    montoiva?: IntNullableFilter | number | null
    retiibb?: FloatNullableFilter | number | null
    retggcias?: FloatNullableFilter | number | null
    perciva?: FloatNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    mediopago?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
  }

  export type gastos_cajaOrderByWithRelationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaWhereUniqueInput = {
    idgastos?: number
  }

  export type gastos_cajaOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
    _count?: gastos_cajaCountOrderByAggregateInput
    _avg?: gastos_cajaAvgOrderByAggregateInput
    _max?: gastos_cajaMaxOrderByAggregateInput
    _min?: gastos_cajaMinOrderByAggregateInput
    _sum?: gastos_cajaSumOrderByAggregateInput
  }

  export type gastos_cajaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<gastos_cajaScalarWhereWithAggregatesInput>
    OR?: Enumerable<gastos_cajaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<gastos_cajaScalarWhereWithAggregatesInput>
    idgastos?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorgestion?: StringNullableWithAggregatesFilter | string | null
    operadortramite?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    porciva?: StringNullableWithAggregatesFilter | string | null
    montoiva?: IntNullableWithAggregatesFilter | number | null
    retiibb?: FloatNullableWithAggregatesFilter | number | null
    retggcias?: FloatNullableWithAggregatesFilter | number | null
    perciva?: FloatNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    mediopago?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
  }

  export type historial_autosWhereInput = {
    AND?: Enumerable<historial_autosWhereInput>
    OR?: Enumerable<historial_autosWhereInput>
    NOT?: Enumerable<historial_autosWhereInput>
    idhistorial?: IntFilter | number
    patente?: StringNullableFilter | string | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    accion?: StringNullableFilter | string | null
  }

  export type historial_autosOrderByWithRelationInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_autosOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
    _count?: historial_autosCountOrderByAggregateInput
    _avg?: historial_autosAvgOrderByAggregateInput
    _max?: historial_autosMaxOrderByAggregateInput
    _min?: historial_autosMinOrderByAggregateInput
    _sum?: historial_autosSumOrderByAggregateInput
  }

  export type historial_autosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<historial_autosScalarWhereWithAggregatesInput>
    OR?: Enumerable<historial_autosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<historial_autosScalarWhereWithAggregatesInput>
    idhistorial?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
  }

  export type historial_stock_ataudWhereInput = {
    AND?: Enumerable<historial_stock_ataudWhereInput>
    OR?: Enumerable<historial_stock_ataudWhereInput>
    NOT?: Enumerable<historial_stock_ataudWhereInput>
    idhistorial?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    stock_anterior?: IntNullableFilter | number | null
    stock_nuevo?: IntNullableFilter | number | null
    remito?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_recepcion?: DateTimeNullableFilter | Date | string | null
  }

  export type historial_stock_ataudOrderByWithRelationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_stock_ataudOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
    _count?: historial_stock_ataudCountOrderByAggregateInput
    _avg?: historial_stock_ataudAvgOrderByAggregateInput
    _max?: historial_stock_ataudMaxOrderByAggregateInput
    _min?: historial_stock_ataudMinOrderByAggregateInput
    _sum?: historial_stock_ataudSumOrderByAggregateInput
  }

  export type historial_stock_ataudScalarWhereWithAggregatesInput = {
    AND?: Enumerable<historial_stock_ataudScalarWhereWithAggregatesInput>
    OR?: Enumerable<historial_stock_ataudScalarWhereWithAggregatesInput>
    NOT?: Enumerable<historial_stock_ataudScalarWhereWithAggregatesInput>
    idhistorial?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock_anterior?: IntNullableWithAggregatesFilter | number | null
    stock_nuevo?: IntNullableWithAggregatesFilter | number | null
    remito?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_recepcion?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type honorariosWhereInput = {
    AND?: Enumerable<honorariosWhereInput>
    OR?: Enumerable<honorariosWhereInput>
    NOT?: Enumerable<honorariosWhereInput>
    idtrabajo?: IntFilter | number
    trabajo?: StringNullableFilter | string | null
    dias_habiles?: IntNullableFilter | number | null
    finde?: IntNullableFilter | number | null
    feriado?: IntNullableFilter | number | null
  }

  export type honorariosOrderByWithRelationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosWhereUniqueInput = {
    idtrabajo?: number
  }

  export type honorariosOrderByWithAggregationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
    _count?: honorariosCountOrderByAggregateInput
    _avg?: honorariosAvgOrderByAggregateInput
    _max?: honorariosMaxOrderByAggregateInput
    _min?: honorariosMinOrderByAggregateInput
    _sum?: honorariosSumOrderByAggregateInput
  }

  export type honorariosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<honorariosScalarWhereWithAggregatesInput>
    OR?: Enumerable<honorariosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<honorariosScalarWhereWithAggregatesInput>
    idtrabajo?: IntWithAggregatesFilter | number
    trabajo?: StringNullableWithAggregatesFilter | string | null
    dias_habiles?: IntNullableWithAggregatesFilter | number | null
    finde?: IntNullableWithAggregatesFilter | number | null
    feriado?: IntNullableWithAggregatesFilter | number | null
  }

  export type ingreso_cajaWhereInput = {
    AND?: Enumerable<ingreso_cajaWhereInput>
    OR?: Enumerable<ingreso_cajaWhereInput>
    NOT?: Enumerable<ingreso_cajaWhereInput>
    idingreso?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: IntNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
  }

  export type ingreso_cajaOrderByWithRelationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaWhereUniqueInput = {
    idingreso?: number
  }

  export type ingreso_cajaOrderByWithAggregationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
    _count?: ingreso_cajaCountOrderByAggregateInput
    _avg?: ingreso_cajaAvgOrderByAggregateInput
    _max?: ingreso_cajaMaxOrderByAggregateInput
    _min?: ingreso_cajaMinOrderByAggregateInput
    _sum?: ingreso_cajaSumOrderByAggregateInput
  }

  export type ingreso_cajaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ingreso_cajaScalarWhereWithAggregatesInput>
    OR?: Enumerable<ingreso_cajaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ingreso_cajaScalarWhereWithAggregatesInput>
    idingreso?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: IntNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
  }

  export type legajo_virtual_autosWhereInput = {
    AND?: Enumerable<legajo_virtual_autosWhereInput>
    OR?: Enumerable<legajo_virtual_autosWhereInput>
    NOT?: Enumerable<legajo_virtual_autosWhereInput>
    idlegajo?: IntFilter | number
    patente?: StringNullableFilter | string | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
  }

  export type legajo_virtual_autosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_autosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    _count?: legajo_virtual_autosCountOrderByAggregateInput
    _avg?: legajo_virtual_autosAvgOrderByAggregateInput
    _max?: legajo_virtual_autosMaxOrderByAggregateInput
    _min?: legajo_virtual_autosMinOrderByAggregateInput
    _sum?: legajo_virtual_autosSumOrderByAggregateInput
  }

  export type legajo_virtual_autosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<legajo_virtual_autosScalarWhereWithAggregatesInput>
    OR?: Enumerable<legajo_virtual_autosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<legajo_virtual_autosScalarWhereWithAggregatesInput>
    idlegajo?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type legajo_virtual_serviciosWhereInput = {
    AND?: Enumerable<legajo_virtual_serviciosWhereInput>
    OR?: Enumerable<legajo_virtual_serviciosWhereInput>
    NOT?: Enumerable<legajo_virtual_serviciosWhereInput>
    idlegajo?: IntFilter | number
    servicio?: StringNullableFilter | string | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
  }

  export type legajo_virtual_serviciosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_serviciosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
    _count?: legajo_virtual_serviciosCountOrderByAggregateInput
    _avg?: legajo_virtual_serviciosAvgOrderByAggregateInput
    _max?: legajo_virtual_serviciosMaxOrderByAggregateInput
    _min?: legajo_virtual_serviciosMinOrderByAggregateInput
    _sum?: legajo_virtual_serviciosSumOrderByAggregateInput
  }

  export type legajo_virtual_serviciosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<legajo_virtual_serviciosScalarWhereWithAggregatesInput>
    OR?: Enumerable<legajo_virtual_serviciosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<legajo_virtual_serviciosScalarWhereWithAggregatesInput>
    idlegajo?: IntWithAggregatesFilter | number
    servicio?: StringNullableWithAggregatesFilter | string | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type novedadesWhereInput = {
    AND?: Enumerable<novedadesWhereInput>
    OR?: Enumerable<novedadesWhereInput>
    NOT?: Enumerable<novedadesWhereInput>
    idnovedad?: IntFilter | number
    novedad?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    _count?: novedadesCountOrderByAggregateInput
    _avg?: novedadesAvgOrderByAggregateInput
    _max?: novedadesMaxOrderByAggregateInput
    _min?: novedadesMinOrderByAggregateInput
    _sum?: novedadesSumOrderByAggregateInput
  }

  export type novedadesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<novedadesScalarWhereWithAggregatesInput>
    OR?: Enumerable<novedadesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<novedadesScalarWhereWithAggregatesInput>
    idnovedad?: IntWithAggregatesFilter | number
    novedad?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type operadorsepWhereInput = {
    AND?: Enumerable<operadorsepWhereInput>
    OR?: Enumerable<operadorsepWhereInput>
    NOT?: Enumerable<operadorsepWhereInput>
    idoperador?: IntFilter | number
    operador?: StringNullableFilter | string | null
  }

  export type operadorsepOrderByWithRelationInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepWhereUniqueInput = {
    idoperador?: number
  }

  export type operadorsepOrderByWithAggregationInput = {
    idoperador?: SortOrder
    operador?: SortOrder
    _count?: operadorsepCountOrderByAggregateInput
    _avg?: operadorsepAvgOrderByAggregateInput
    _max?: operadorsepMaxOrderByAggregateInput
    _min?: operadorsepMinOrderByAggregateInput
    _sum?: operadorsepSumOrderByAggregateInput
  }

  export type operadorsepScalarWhereWithAggregatesInput = {
    AND?: Enumerable<operadorsepScalarWhereWithAggregatesInput>
    OR?: Enumerable<operadorsepScalarWhereWithAggregatesInput>
    NOT?: Enumerable<operadorsepScalarWhereWithAggregatesInput>
    idoperador?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type parcelasWhereInput = {
    AND?: Enumerable<parcelasWhereInput>
    OR?: Enumerable<parcelasWhereInput>
    NOT?: Enumerable<parcelasWhereInput>
    idparcela?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    ficha?: IntNullableFilter | number | null
    parcela?: StringNullableFilter | string | null
    mza?: IntNullableFilter | number | null
    lote?: IntNullableFilter | number | null
    asignada?: BoolNullableFilter | boolean | null
    fecha?: StringNullableFilter | string | null
    cementerio?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_alta?: StringNullableFilter | string | null
    operador_asignacion?: StringNullableFilter | string | null
    fecha_asignacion?: StringNullableFilter | string | null
    lugares?: IntNullableFilter | number | null
  }

  export type parcelasOrderByWithRelationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasWhereUniqueInput = {
    idparcela?: number
  }

  export type parcelasOrderByWithAggregationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
    _count?: parcelasCountOrderByAggregateInput
    _avg?: parcelasAvgOrderByAggregateInput
    _max?: parcelasMaxOrderByAggregateInput
    _min?: parcelasMinOrderByAggregateInput
    _sum?: parcelasSumOrderByAggregateInput
  }

  export type parcelasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<parcelasScalarWhereWithAggregatesInput>
    OR?: Enumerable<parcelasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<parcelasScalarWhereWithAggregatesInput>
    idparcela?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    ficha?: IntNullableWithAggregatesFilter | number | null
    parcela?: StringNullableWithAggregatesFilter | string | null
    mza?: IntNullableWithAggregatesFilter | number | null
    lote?: IntNullableWithAggregatesFilter | number | null
    asignada?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_alta?: StringNullableWithAggregatesFilter | string | null
    operador_asignacion?: StringNullableWithAggregatesFilter | string | null
    fecha_asignacion?: StringNullableWithAggregatesFilter | string | null
    lugares?: IntNullableWithAggregatesFilter | number | null
  }

  export type planificacion_guardiasWhereInput = {
    AND?: Enumerable<planificacion_guardiasWhereInput>
    OR?: Enumerable<planificacion_guardiasWhereInput>
    NOT?: Enumerable<planificacion_guardiasWhereInput>
    idturno?: IntFilter | number
    lugar?: StringNullableFilter | string | null
    inicio?: DateTimeNullableFilter | Date | string | null
    fin?: DateTimeNullableFilter | Date | string | null
    horas?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    mes_planificacion?: StringNullableFilter | string | null
    feriado?: BoolNullableFilter | boolean | null
    tarea?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    operadorliq?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    fecha_aprobacion?: StringNullableFilter | string | null
    operadorap?: StringNullableFilter | string | null
    ano_planificacion?: IntNullableFilter | number | null
  }

  export type planificacion_guardiasOrderByWithRelationInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasWhereUniqueInput = {
    idturno?: number
  }

  export type planificacion_guardiasOrderByWithAggregationInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
    _count?: planificacion_guardiasCountOrderByAggregateInput
    _avg?: planificacion_guardiasAvgOrderByAggregateInput
    _max?: planificacion_guardiasMaxOrderByAggregateInput
    _min?: planificacion_guardiasMinOrderByAggregateInput
    _sum?: planificacion_guardiasSumOrderByAggregateInput
  }

  export type planificacion_guardiasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<planificacion_guardiasScalarWhereWithAggregatesInput>
    OR?: Enumerable<planificacion_guardiasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<planificacion_guardiasScalarWhereWithAggregatesInput>
    idturno?: IntWithAggregatesFilter | number
    lugar?: StringNullableWithAggregatesFilter | string | null
    inicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    horas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    mes_planificacion?: StringNullableWithAggregatesFilter | string | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
    tarea?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    ano_planificacion?: IntNullableWithAggregatesFilter | number | null
  }

  export type precio_servicioWhereInput = {
    AND?: Enumerable<precio_servicioWhereInput>
    OR?: Enumerable<precio_servicioWhereInput>
    NOT?: Enumerable<precio_servicioWhereInput>
    idprecio?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    contado?: IntNullableFilter | number | null
    contado_cremacion?: IntNullableFilter | number | null
    descuento1?: IntNullableFilter | number | null
    descuento1_cremacion?: IntNullableFilter | number | null
    descuento2?: IntNullableFilter | number | null
    descuento2_cremacion?: IntNullableFilter | number | null
    fecha_vigencia?: DateTimeNullableFilter | Date | string | null
  }

  export type precio_servicioOrderByWithRelationInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioWhereUniqueInput = {
    idprecio?: number
  }

  export type precio_servicioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
    _count?: precio_servicioCountOrderByAggregateInput
    _avg?: precio_servicioAvgOrderByAggregateInput
    _max?: precio_servicioMaxOrderByAggregateInput
    _min?: precio_servicioMinOrderByAggregateInput
    _sum?: precio_servicioSumOrderByAggregateInput
  }

  export type precio_servicioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<precio_servicioScalarWhereWithAggregatesInput>
    OR?: Enumerable<precio_servicioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<precio_servicioScalarWhereWithAggregatesInput>
    idprecio?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    contado?: IntNullableWithAggregatesFilter | number | null
    contado_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento1?: IntNullableWithAggregatesFilter | number | null
    descuento1_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento2?: IntNullableWithAggregatesFilter | number | null
    descuento2_cremacion?: IntNullableWithAggregatesFilter | number | null
    fecha_vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type proveedoresWhereInput = {
    AND?: Enumerable<proveedoresWhereInput>
    OR?: Enumerable<proveedoresWhereInput>
    NOT?: Enumerable<proveedoresWhereInput>
    idproveedor?: IntFilter | number
    razon?: StringNullableFilter | string | null
    cuit?: StringNullableFilter | string | null
    domicilio?: StringNullableFilter | string | null
    telefonos?: StringNullableFilter | string | null
    estado?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type proveedoresOrderByWithRelationInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresWhereUniqueInput = {
    idproveedor?: number
  }

  export type proveedoresOrderByWithAggregationInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
    _count?: proveedoresCountOrderByAggregateInput
    _avg?: proveedoresAvgOrderByAggregateInput
    _max?: proveedoresMaxOrderByAggregateInput
    _min?: proveedoresMinOrderByAggregateInput
    _sum?: proveedoresSumOrderByAggregateInput
  }

  export type proveedoresScalarWhereWithAggregatesInput = {
    AND?: Enumerable<proveedoresScalarWhereWithAggregatesInput>
    OR?: Enumerable<proveedoresScalarWhereWithAggregatesInput>
    NOT?: Enumerable<proveedoresScalarWhereWithAggregatesInput>
    idproveedor?: IntWithAggregatesFilter | number
    razon?: StringNullableWithAggregatesFilter | string | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    domicilio?: StringNullableWithAggregatesFilter | string | null
    telefonos?: StringNullableWithAggregatesFilter | string | null
    estado?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_detallesWhereInput = {
    AND?: Enumerable<servicio_detallesWhereInput>
    OR?: Enumerable<servicio_detallesWhereInput>
    NOT?: Enumerable<servicio_detallesWhereInput>
    iddetalles?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    lugar?: StringNullableFilter | string | null
    monto?: StringNullableFilter | string | null
    patente?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type servicio_detallesOrderByWithRelationInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesWhereUniqueInput = {
    iddetalles?: number
  }

  export type servicio_detallesOrderByWithAggregationInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
    _count?: servicio_detallesCountOrderByAggregateInput
    _avg?: servicio_detallesAvgOrderByAggregateInput
    _max?: servicio_detallesMaxOrderByAggregateInput
    _min?: servicio_detallesMinOrderByAggregateInput
    _sum?: servicio_detallesSumOrderByAggregateInput
  }

  export type servicio_detallesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicio_detallesScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicio_detallesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicio_detallesScalarWhereWithAggregatesInput>
    iddetalles?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    lugar?: StringNullableWithAggregatesFilter | string | null
    monto?: StringNullableWithAggregatesFilter | string | null
    patente?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_gastosWhereInput = {
    AND?: Enumerable<servicio_gastosWhereInput>
    OR?: Enumerable<servicio_gastosWhereInput>
    NOT?: Enumerable<servicio_gastosWhereInput>
    idgastos?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    tipo_gasto?: StringNullableFilter | string | null
    horas?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    observaciones?: StringNullableFilter | string | null
    inicio?: StringNullableFilter | string | null
    fin?: StringNullableFilter | string | null
    feriado?: BoolNullableFilter | boolean | null
    liquidado?: BoolNullableFilter | boolean | null
    operadorliq?: StringNullableFilter | string | null
    fecha_liquidacion?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    operadorap?: StringNullableFilter | string | null
    fecha_aprobacion?: StringNullableFilter | string | null
  }

  export type servicio_gastosOrderByWithRelationInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosWhereUniqueInput = {
    idgastos?: number
  }

  export type servicio_gastosOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    _count?: servicio_gastosCountOrderByAggregateInput
    _avg?: servicio_gastosAvgOrderByAggregateInput
    _max?: servicio_gastosMaxOrderByAggregateInput
    _min?: servicio_gastosMinOrderByAggregateInput
    _sum?: servicio_gastosSumOrderByAggregateInput
  }

  export type servicio_gastosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicio_gastosScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicio_gastosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicio_gastosScalarWhereWithAggregatesInput>
    idgastos?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    tipo_gasto?: StringNullableWithAggregatesFilter | string | null
    horas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    inicio?: StringNullableWithAggregatesFilter | string | null
    fin?: StringNullableWithAggregatesFilter | string | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_ventaWhereInput = {
    AND?: Enumerable<servicio_ventaWhereInput>
    OR?: Enumerable<servicio_ventaWhereInput>
    NOT?: Enumerable<servicio_ventaWhereInput>
    idventa?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha_venta?: DateTimeNullableFilter | Date | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    parentesco?: StringNullableFilter | string | null
    operador_venta?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    operadorliq?: StringNullableFilter | string | null
    fecha_liquidacion?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    operadorap?: StringNullableFilter | string | null
    fecha_aprobacion?: StringNullableFilter | string | null
    comision?: FloatNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    valor_cuota?: FloatNullableFilter | number | null
    plan_cuota?: IntNullableFilter | number | null
    monto_financiacion?: FloatNullableFilter | number | null
    financiacion?: BoolNullableFilter | boolean | null
    efectivo?: FloatNullableFilter | number | null
  }

  export type servicio_ventaOrderByWithRelationInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaWhereUniqueInput = {
    idventa?: number
  }

  export type servicio_ventaOrderByWithAggregationInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
    _count?: servicio_ventaCountOrderByAggregateInput
    _avg?: servicio_ventaAvgOrderByAggregateInput
    _max?: servicio_ventaMaxOrderByAggregateInput
    _min?: servicio_ventaMinOrderByAggregateInput
    _sum?: servicio_ventaSumOrderByAggregateInput
  }

  export type servicio_ventaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicio_ventaScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicio_ventaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicio_ventaScalarWhereWithAggregatesInput>
    idventa?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_venta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    operador_venta?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    comision?: FloatNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    valor_cuota?: FloatNullableWithAggregatesFilter | number | null
    plan_cuota?: IntNullableWithAggregatesFilter | number | null
    monto_financiacion?: FloatNullableWithAggregatesFilter | number | null
    financiacion?: BoolNullableWithAggregatesFilter | boolean | null
    efectivo?: FloatNullableWithAggregatesFilter | number | null
  }

  export type serviciosWhereInput = {
    AND?: Enumerable<serviciosWhereInput>
    OR?: Enumerable<serviciosWhereInput>
    NOT?: Enumerable<serviciosWhereInput>
    idservicio?: IntFilter | number
    empresa?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    edad?: IntNullableFilter | number | null
    fecha_fallecimiento?: DateTimeNullableFilter | Date | string | null
    lugar_fallecimiento?: StringNullableFilter | string | null
    tipo_servicio?: StringNullableFilter | string | null
    casa_mortuaria?: StringNullableFilter | string | null
    fecha_inhumacion?: DateTimeNullableFilter | Date | string | null
    hora_inhumacion?: DateTimeNullableFilter | Date | string | null
    cementerio?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    contrato?: IntNullableFilter | number | null
    fecha_recepcion?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
    motivo?: StringNullableFilter | string | null
    retiro?: StringNullableFilter | string | null
    solicitado?: StringNullableFilter | string | null
    parentesco?: StringNullableFilter | string | null
    altura?: FloatNullableFilter | number | null
    peso?: FloatNullableFilter | number | null
    dni_nuevotitular?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    idataud?: IntNullableFilter | number | null
    dni_solicitante?: IntNullableFilter | number | null
    impactado?: BoolNullableFilter | boolean | null
    cremacion?: BoolNullableFilter | boolean | null
    idparcela?: IntNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    gastos_cargados?: IntNullableFilter | number | null
    obra_soc?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
    donacion?: BoolNullableFilter | boolean | null
    domicilio_solicitante?: StringNullableFilter | string | null
  }

  export type serviciosOrderByWithRelationInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosWhereUniqueInput = {
    idservicio?: number
  }

  export type serviciosOrderByWithAggregationInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
    _count?: serviciosCountOrderByAggregateInput
    _avg?: serviciosAvgOrderByAggregateInput
    _max?: serviciosMaxOrderByAggregateInput
    _min?: serviciosMinOrderByAggregateInput
    _sum?: serviciosSumOrderByAggregateInput
  }

  export type serviciosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    OR?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<serviciosScalarWhereWithAggregatesInput>
    idservicio?: IntWithAggregatesFilter | number
    empresa?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    edad?: IntNullableWithAggregatesFilter | number | null
    fecha_fallecimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    lugar_fallecimiento?: StringNullableWithAggregatesFilter | string | null
    tipo_servicio?: StringNullableWithAggregatesFilter | string | null
    casa_mortuaria?: StringNullableWithAggregatesFilter | string | null
    fecha_inhumacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hora_inhumacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    fecha_recepcion?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    retiro?: StringNullableWithAggregatesFilter | string | null
    solicitado?: StringNullableWithAggregatesFilter | string | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    altura?: FloatNullableWithAggregatesFilter | number | null
    peso?: FloatNullableWithAggregatesFilter | number | null
    dni_nuevotitular?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    dni_solicitante?: IntNullableWithAggregatesFilter | number | null
    impactado?: BoolNullableWithAggregatesFilter | boolean | null
    cremacion?: BoolNullableWithAggregatesFilter | boolean | null
    idparcela?: IntNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    gastos_cargados?: IntNullableWithAggregatesFilter | number | null
    obra_soc?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    donacion?: BoolNullableWithAggregatesFilter | boolean | null
    domicilio_solicitante?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicios_liquidacionWhereInput = {
    AND?: Enumerable<servicios_liquidacionWhereInput>
    OR?: Enumerable<servicios_liquidacionWhereInput>
    NOT?: Enumerable<servicios_liquidacionWhereInput>
    idliquidacion?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    total_liquidacion?: IntNullableFilter | number | null
    fecha_liquidacion?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type servicios_liquidacionOrderByWithRelationInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionWhereUniqueInput = {
    idliquidacion?: number
  }

  export type servicios_liquidacionOrderByWithAggregationInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
    _count?: servicios_liquidacionCountOrderByAggregateInput
    _avg?: servicios_liquidacionAvgOrderByAggregateInput
    _max?: servicios_liquidacionMaxOrderByAggregateInput
    _min?: servicios_liquidacionMinOrderByAggregateInput
    _sum?: servicios_liquidacionSumOrderByAggregateInput
  }

  export type servicios_liquidacionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicios_liquidacionScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicios_liquidacionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicios_liquidacionScalarWhereWithAggregatesInput>
    idliquidacion?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    total_liquidacion?: IntNullableWithAggregatesFilter | number | null
    fecha_liquidacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type tareasWhereInput = {
    AND?: Enumerable<tareasWhereInput>
    OR?: Enumerable<tareasWhereInput>
    NOT?: Enumerable<tareasWhereInput>
    idevents?: IntFilter | number
    title?: StringNullableFilter | string | null
    allDay?: IntNullableFilter | number | null
    start?: StringNullableFilter | string | null
    end?: StringNullableFilter | string | null
    priority?: BoolNullableFilter | boolean | null
  }

  export type tareasOrderByWithRelationInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasWhereUniqueInput = {
    idevents?: number
  }

  export type tareasOrderByWithAggregationInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
    _count?: tareasCountOrderByAggregateInput
    _avg?: tareasAvgOrderByAggregateInput
    _max?: tareasMaxOrderByAggregateInput
    _min?: tareasMinOrderByAggregateInput
    _sum?: tareasSumOrderByAggregateInput
  }

  export type tareasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tareasScalarWhereWithAggregatesInput>
    OR?: Enumerable<tareasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tareasScalarWhereWithAggregatesInput>
    idevents?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    start?: StringNullableWithAggregatesFilter | string | null
    end?: StringNullableWithAggregatesFilter | string | null
    priority?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type tareas_adicionalesWhereInput = {
    AND?: Enumerable<tareas_adicionalesWhereInput>
    OR?: Enumerable<tareas_adicionalesWhereInput>
    NOT?: Enumerable<tareas_adicionalesWhereInput>
    idtarea?: IntFilter | number
    inicio?: DateTimeNullableFilter | Date | string | null
    fin?: DateTimeNullableFilter | Date | string | null
    tarea?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    observaciones?: StringNullableFilter | string | null
    horas?: DateTimeNullableFilter | Date | string | null
    feriado?: IntNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    operadorliq?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    fecha_aprobacion?: StringNullableFilter | string | null
    operadorap?: StringNullableFilter | string | null
    mes_planificacion?: StringNullableFilter | string | null
  }

  export type tareas_adicionalesOrderByWithRelationInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesWhereUniqueInput = {
    idtarea?: number
  }

  export type tareas_adicionalesOrderByWithAggregationInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
    _count?: tareas_adicionalesCountOrderByAggregateInput
    _avg?: tareas_adicionalesAvgOrderByAggregateInput
    _max?: tareas_adicionalesMaxOrderByAggregateInput
    _min?: tareas_adicionalesMinOrderByAggregateInput
    _sum?: tareas_adicionalesSumOrderByAggregateInput
  }

  export type tareas_adicionalesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tareas_adicionalesScalarWhereWithAggregatesInput>
    OR?: Enumerable<tareas_adicionalesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tareas_adicionalesScalarWhereWithAggregatesInput>
    idtarea?: IntWithAggregatesFilter | number
    inicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tarea?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    horas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    feriado?: IntNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    mes_planificacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type tipo_detalleWhereInput = {
    AND?: Enumerable<tipo_detalleWhereInput>
    OR?: Enumerable<tipo_detalleWhereInput>
    NOT?: Enumerable<tipo_detalleWhereInput>
    idtipodetalle?: IntFilter | number
    tipo_detalle?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type tipo_detalleOrderByWithRelationInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleWhereUniqueInput = {
    idtipodetalle?: number
  }

  export type tipo_detalleOrderByWithAggregationInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
    _count?: tipo_detalleCountOrderByAggregateInput
    _avg?: tipo_detalleAvgOrderByAggregateInput
    _max?: tipo_detalleMaxOrderByAggregateInput
    _min?: tipo_detalleMinOrderByAggregateInput
    _sum?: tipo_detalleSumOrderByAggregateInput
  }

  export type tipo_detalleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tipo_detalleScalarWhereWithAggregatesInput>
    OR?: Enumerable<tipo_detalleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tipo_detalleScalarWhereWithAggregatesInput>
    idtipodetalle?: IntWithAggregatesFilter | number
    tipo_detalle?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type visitantesWhereInput = {
    AND?: Enumerable<visitantesWhereInput>
    OR?: Enumerable<visitantesWhereInput>
    NOT?: Enumerable<visitantesWhereInput>
    idvisitante?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    telefono?: IntNullableFilter | number | null
    parentezco?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    temperatura?: StringNullableFilter | string | null
  }

  export type visitantesOrderByWithRelationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesWhereUniqueInput = {
    idvisitante?: number
  }

  export type visitantesOrderByWithAggregationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
    _count?: visitantesCountOrderByAggregateInput
    _avg?: visitantesAvgOrderByAggregateInput
    _max?: visitantesMaxOrderByAggregateInput
    _min?: visitantesMinOrderByAggregateInput
    _sum?: visitantesSumOrderByAggregateInput
  }

  export type visitantesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<visitantesScalarWhereWithAggregatesInput>
    OR?: Enumerable<visitantesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<visitantesScalarWhereWithAggregatesInput>
    idvisitante?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    temperatura?: StringNullableWithAggregatesFilter | string | null
  }

  export type ataud_precioCreateInput = {
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUncheckedCreateInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioCreateManyInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_ventaCreateInput = {
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUncheckedCreateInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaCreateManyInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateManyInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateInput = {
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUncheckedCreateInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateManyInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateManyInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUncheckedCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosCreateManyInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateManyInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateInput = {
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUncheckedCreateInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateManyInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateManyInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateInput = {
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUncheckedCreateInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateManyInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateInput = {
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUncheckedCreateInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateManyInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateManyInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sepelioCreateInput = {
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUncheckedCreateInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioCreateManyInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conceptosCreateInput = {
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUncheckedCreateInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosCreateManyInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateManyMutationInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateManyInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateInput = {
    fabricante?: string | null
  }

  export type fabricante_ataudUncheckedCreateInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateManyInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateManyMutationInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateManyInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateInput = {
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUncheckedCreateInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateManyInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateManyInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gastos_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUncheckedCreateInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaCreateManyInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_autosCreateInput = {
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUncheckedCreateInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosCreateManyInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_stock_ataudCreateInput = {
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUncheckedCreateInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudCreateManyInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type honorariosCreateInput = {
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUncheckedCreateInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosCreateManyInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateManyMutationInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateManyInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: number | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUncheckedCreateInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: number | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaCreateManyInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: number | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateManyInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type legajo_virtual_autosCreateInput = {
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUncheckedCreateInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosCreateManyInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_serviciosCreateInput = {
    servicio?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUncheckedCreateInput = {
    idlegajo?: number
    servicio?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateInput = {
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosCreateManyInput = {
    idlegajo?: number
    servicio?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateManyMutationInput = {
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesCreateInput = {
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUncheckedCreateInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesCreateManyInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateManyMutationInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateInput = {
    operador?: string | null
  }

  export type operadorsepUncheckedCreateInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateManyInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateManyInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelasCreateInput = {
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUncheckedCreateInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasCreateManyInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateManyInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasCreateInput = {
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: Date | string | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUncheckedCreateInput = {
    idturno?: number
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: Date | string | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUpdateInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasUncheckedUpdateInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasCreateManyInput = {
    idturno?: number
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: Date | string | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUpdateManyMutationInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasUncheckedUpdateManyInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type precio_servicioCreateInput = {
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUncheckedCreateInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioCreateManyInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proveedoresCreateInput = {
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUncheckedCreateInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresCreateManyInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateManyMutationInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateManyInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesCreateInput = {
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUncheckedCreateInput = {
    iddetalles?: number
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesUncheckedUpdateInput = {
    iddetalles?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesCreateManyInput = {
    iddetalles?: number
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesUncheckedUpdateManyInput = {
    iddetalles?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosCreateInput = {
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUncheckedCreateInput = {
    idgastos?: number
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosCreateManyInput = {
    idgastos?: number
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_ventaCreateInput = {
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUncheckedCreateInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaCreateManyInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateManyInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type serviciosCreateInput = {
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: Date | string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUncheckedCreateInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: Date | string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUpdateInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosCreateManyInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: Date | string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUpdateManyMutationInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateManyInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionCreateInput = {
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUncheckedCreateInput = {
    idliquidacion?: number
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionUncheckedUpdateInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionCreateManyInput = {
    idliquidacion?: number
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionUncheckedUpdateManyInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareasCreateInput = {
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: boolean | null
  }

  export type tareasUncheckedCreateInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: boolean | null
  }

  export type tareasUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareasUncheckedUpdateInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareasCreateManyInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: boolean | null
  }

  export type tareasUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareasUncheckedUpdateManyInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type tareas_adicionalesCreateInput = {
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUncheckedCreateInput = {
    idtarea?: number
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUpdateInput = {
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesUncheckedUpdateInput = {
    idtarea?: IntFieldUpdateOperationsInput | number
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesCreateManyInput = {
    idtarea?: number
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUpdateManyMutationInput = {
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesUncheckedUpdateManyInput = {
    idtarea?: IntFieldUpdateOperationsInput | number
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleCreateInput = {
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUncheckedCreateInput = {
    idtipodetalle?: number
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUpdateInput = {
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleUncheckedUpdateInput = {
    idtipodetalle?: IntFieldUpdateOperationsInput | number
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleCreateManyInput = {
    idtipodetalle?: number
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUpdateManyMutationInput = {
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleUncheckedUpdateManyInput = {
    idtipodetalle?: IntFieldUpdateOperationsInput | number
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesCreateInput = {
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUncheckedCreateInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesCreateManyInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateManyInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type ataud_precioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type ataud_precioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type ataud_ventaCountOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaAvgOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataud_ventaMaxOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaMinOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaSumOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataudesCountOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesAvgOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type ataudesMaxOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesMinOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesSumOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type autosCountOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosAvgOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autosMaxOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosMinOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosSumOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autos_hoja_rutaCountOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaAvgOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_hoja_rutaMaxOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaMinOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaSumOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_pago_patenteCountOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteAvgOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type autos_pago_patenteMaxOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteMinOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteSumOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type caja_sepelioCountOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type caja_sepelioMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioMinOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioSumOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type conceptosCountOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosAvgOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type conceptosMaxOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosMinOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosSumOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type fabricante_ataudCountOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudAvgOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type fabricante_ataudMaxOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudMinOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudSumOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type gasto_lutoCountOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoAvgOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gasto_lutoMaxOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoMinOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoSumOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gastos_cajaCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type historial_autosCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_autosMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_stock_ataudCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type historial_stock_ataudMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type honorariosCountOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosAvgOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMaxOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMinOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosSumOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type ingreso_cajaCountOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaAvgOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMaxOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMinOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaSumOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type legajo_virtual_autosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_autosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_serviciosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_serviciosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type operadorsepCountOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepAvgOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type operadorsepMaxOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepMinOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepSumOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type parcelasCountOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasAvgOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMaxOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMinOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasSumOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type planificacion_guardiasCountOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasAvgOrderByAggregateInput = {
    idturno?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasMaxOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasMinOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasSumOrderByAggregateInput = {
    idturno?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type precio_servicioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type precio_servicioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type proveedoresCountOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresAvgOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedoresMaxOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresMinOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresSumOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type servicio_detallesCountOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesAvgOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_detallesMaxOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesMinOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesSumOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_gastosCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_gastosMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_ventaCountOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaAvgOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMaxOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMinOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaSumOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type serviciosCountOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosAvgOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
  }

  export type serviciosMaxOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosMinOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosSumOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
  }

  export type servicios_liquidacionCountOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionAvgOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
  }

  export type servicios_liquidacionMaxOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionMinOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionSumOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
  }

  export type tareasCountOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasAvgOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
  }

  export type tareasMaxOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasMinOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasSumOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
  }

  export type tareas_adicionalesCountOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesAvgOrderByAggregateInput = {
    idtarea?: SortOrder
    feriado?: SortOrder
  }

  export type tareas_adicionalesMaxOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesMinOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesSumOrderByAggregateInput = {
    idtarea?: SortOrder
    feriado?: SortOrder
  }

  export type tipo_detalleCountOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleAvgOrderByAggregateInput = {
    idtipodetalle?: SortOrder
  }

  export type tipo_detalleMaxOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleMinOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleSumOrderByAggregateInput = {
    idtipodetalle?: SortOrder
  }

  export type visitantesCountOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesAvgOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type visitantesMaxOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesMinOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesSumOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}