
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type ataud_precioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idprecio: number
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }, ExtArgs["result"]["ataud_precio"]>
  composites: {}
}

/**
 * Model ataud_precio
 * 
 */
export type ataud_precio = runtime.Types.DefaultSelection<ataud_precioPayload>
export type ataud_ventaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idataudventa: number
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }, ExtArgs["result"]["ataud_venta"]>
  composites: {}
}

/**
 * Model ataud_venta
 * 
 */
export type ataud_venta = runtime.Types.DefaultSelection<ataud_ventaPayload>
export type ataudesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idataud: number
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }, ExtArgs["result"]["ataudes"]>
  composites: {}
}

/**
 * Model ataudes
 * 
 */
export type ataudes = runtime.Types.DefaultSelection<ataudesPayload>
export type autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number
    estado: boolean | null
    operador: string | null
  }, ExtArgs["result"]["autos"]>
  composites: {}
}

/**
 * Model autos
 * 
 */
export type autos = runtime.Types.DefaultSelection<autosPayload>
export type autos_hoja_rutaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhojaruta: number
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }, ExtArgs["result"]["autos_hoja_ruta"]>
  composites: {}
}

/**
 * Model autos_hoja_ruta
 * 
 */
export type autos_hoja_ruta = runtime.Types.DefaultSelection<autos_hoja_rutaPayload>
export type autos_novedadesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovedad: number
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }, ExtArgs["result"]["autos_novedades"]>
  composites: {}
}

/**
 * Model autos_novedades
 * 
 */
export type autos_novedades = runtime.Types.DefaultSelection<autos_novedadesPayload>
export type autos_pago_patentePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idpago: number
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }, ExtArgs["result"]["autos_pago_patente"]>
  composites: {}
}

/**
 * Model autos_pago_patente
 * 
 */
export type autos_pago_patente = runtime.Types.DefaultSelection<autos_pago_patentePayload>
export type caja_sepelioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }, ExtArgs["result"]["caja_sepelio"]>
  composites: {}
}

/**
 * Model caja_sepelio
 * 
 */
export type caja_sepelio = runtime.Types.DefaultSelection<caja_sepelioPayload>
export type conceptosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idconcepto: number
    concepto: string | null
    tipo: string | null
  }, ExtArgs["result"]["conceptos"]>
  composites: {}
}

/**
 * Model conceptos
 * 
 */
export type conceptos = runtime.Types.DefaultSelection<conceptosPayload>
export type fabricante_ataudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idfabricante: number
    fabricante: string | null
  }, ExtArgs["result"]["fabricante_ataud"]>
  composites: {}
}

/**
 * Model fabricante_ataud
 * 
 */
export type fabricante_ataud = runtime.Types.DefaultSelection<fabricante_ataudPayload>
export type gasto_lutoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastoluto: number
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }, ExtArgs["result"]["gasto_luto"]>
  composites: {}
}

/**
 * Model gasto_luto
 * 
 */
export type gasto_luto = runtime.Types.DefaultSelection<gasto_lutoPayload>
export type gastos_cajaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }, ExtArgs["result"]["gastos_caja"]>
  composites: {}
}

/**
 * Model gastos_caja
 * 
 */
export type gastos_caja = runtime.Types.DefaultSelection<gastos_cajaPayload>
export type historial_autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhistorial: number
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }, ExtArgs["result"]["historial_autos"]>
  composites: {}
}

/**
 * Model historial_autos
 * 
 */
export type historial_autos = runtime.Types.DefaultSelection<historial_autosPayload>
export type historial_stock_ataudPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idhistorial: number
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }, ExtArgs["result"]["historial_stock_ataud"]>
  composites: {}
}

/**
 * Model historial_stock_ataud
 * 
 */
export type historial_stock_ataud = runtime.Types.DefaultSelection<historial_stock_ataudPayload>
export type honorariosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtrabajo: number
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }, ExtArgs["result"]["honorarios"]>
  composites: {}
}

/**
 * Model honorarios
 * 
 */
export type honorarios = runtime.Types.DefaultSelection<honorariosPayload>
export type ingreso_cajaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idingreso: number
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }, ExtArgs["result"]["ingreso_caja"]>
  composites: {}
}

/**
 * Model ingreso_caja
 * 
 */
export type ingreso_caja = runtime.Types.DefaultSelection<ingreso_cajaPayload>
export type legajo_virtual_autosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }, ExtArgs["result"]["legajo_virtual_autos"]>
  composites: {}
}

/**
 * Model legajo_virtual_autos
 * 
 */
export type legajo_virtual_autos = runtime.Types.DefaultSelection<legajo_virtual_autosPayload>
export type legajo_virtual_serviciosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlegajo: number
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }, ExtArgs["result"]["legajo_virtual_servicios"]>
  composites: {}
}

/**
 * Model legajo_virtual_servicios
 * 
 */
export type legajo_virtual_servicios = runtime.Types.DefaultSelection<legajo_virtual_serviciosPayload>
export type novedadesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idnovedad: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }, ExtArgs["result"]["novedades"]>
  composites: {}
}

/**
 * Model novedades
 * 
 */
export type novedades = runtime.Types.DefaultSelection<novedadesPayload>
export type operadorsepPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idoperador: number
    operador: string | null
  }, ExtArgs["result"]["operadorsep"]>
  composites: {}
}

/**
 * Model operadorsep
 * 
 */
export type operadorsep = runtime.Types.DefaultSelection<operadorsepPayload>
export type parcelasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idparcela: number
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }, ExtArgs["result"]["parcelas"]>
  composites: {}
}

/**
 * Model parcelas
 * 
 */
export type parcelas = runtime.Types.DefaultSelection<parcelasPayload>
export type planificacion_guardiasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idturno: number
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: number | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
  }, ExtArgs["result"]["planificacion_guardias"]>
  composites: {}
}

/**
 * Model planificacion_guardias
 * 
 */
export type planificacion_guardias = runtime.Types.DefaultSelection<planificacion_guardiasPayload>
export type precio_servicioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idprecio: number
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }, ExtArgs["result"]["precio_servicio"]>
  composites: {}
}

/**
 * Model precio_servicio
 * 
 */
export type precio_servicio = runtime.Types.DefaultSelection<precio_servicioPayload>
export type proveedoresPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idproveedor: number
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }, ExtArgs["result"]["proveedores"]>
  composites: {}
}

/**
 * Model proveedores
 * 
 */
export type proveedores = runtime.Types.DefaultSelection<proveedoresPayload>
export type servicio_detallesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    iddetalles: number
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
  }, ExtArgs["result"]["servicio_detalles"]>
  composites: {}
}

/**
 * Model servicio_detalles
 * 
 */
export type servicio_detalles = runtime.Types.DefaultSelection<servicio_detallesPayload>
export type servicio_gastosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgastos: number
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
  }, ExtArgs["result"]["servicio_gastos"]>
  composites: {}
}

/**
 * Model servicio_gastos
 * 
 */
export type servicio_gastos = runtime.Types.DefaultSelection<servicio_gastosPayload>
export type servicio_ventaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idventa: number
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }, ExtArgs["result"]["servicio_venta"]>
  composites: {}
}

/**
 * Model servicio_venta
 * 
 */
export type servicio_venta = runtime.Types.DefaultSelection<servicio_ventaPayload>
export type serviciosPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idservicio: number
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
  }, ExtArgs["result"]["servicios"]>
  composites: {}
}

/**
 * Model servicios
 * 
 */
export type servicios = runtime.Types.DefaultSelection<serviciosPayload>
export type servicios_liquidacionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idliquidacion: number
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
  }, ExtArgs["result"]["servicios_liquidacion"]>
  composites: {}
}

/**
 * Model servicios_liquidacion
 * 
 */
export type servicios_liquidacion = runtime.Types.DefaultSelection<servicios_liquidacionPayload>
export type tareasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idevents: number
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }, ExtArgs["result"]["tareas"]>
  composites: {}
}

/**
 * Model tareas
 * 
 */
export type tareas = runtime.Types.DefaultSelection<tareasPayload>
export type tareas_adicionalesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtarea: number
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
  }, ExtArgs["result"]["tareas_adicionales"]>
  composites: {}
}

/**
 * Model tareas_adicionales
 * 
 */
export type tareas_adicionales = runtime.Types.DefaultSelection<tareas_adicionalesPayload>
export type tipo_detallePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idtipodetalle: number
    tipo_detalle: string | null
    observacion: string | null
  }, ExtArgs["result"]["tipo_detalle"]>
  composites: {}
}

/**
 * Model tipo_detalle
 * 
 */
export type tipo_detalle = runtime.Types.DefaultSelection<tipo_detallePayload>
export type visitantesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idvisitante: number
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }, ExtArgs["result"]["visitantes"]>
  composites: {}
}

/**
 * Model visitantes
 * 
 */
export type visitantes = runtime.Types.DefaultSelection<visitantesPayload>
export type parcelas_lugaresPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idlugar: number
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }, ExtArgs["result"]["parcelas_lugares"]>
  composites: {}
}

/**
 * Model parcelas_lugares
 * 
 */
export type parcelas_lugares = runtime.Types.DefaultSelection<parcelas_lugaresPayload>
export type caja_saPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }, ExtArgs["result"]["caja_sa"]>
  composites: {}
}

/**
 * Model caja_sa
 * 
 */
export type caja_sa = runtime.Types.DefaultSelection<caja_saPayload>
export type caja_srlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }, ExtArgs["result"]["caja_srl"]>
  composites: {}
}

/**
 * Model caja_srl
 * 
 */
export type caja_srl = runtime.Types.DefaultSelection<caja_srlPayload>
export type generacion_cajasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    idgeneracion: number
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }, ExtArgs["result"]["generacion_cajas"]>
  composites: {}
}

/**
 * Model generacion_cajas
 * 
 */
export type generacion_cajas = runtime.Types.DefaultSelection<generacion_cajasPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ataud_precios
 * const ataud_precios = await prisma.ataud_precio.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ataud_precios
   * const ataud_precios = await prisma.ataud_precio.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.ataud_precio`: Exposes CRUD operations for the **ataud_precio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_precios
    * const ataud_precios = await prisma.ataud_precio.findMany()
    * ```
    */
  get ataud_precio(): Prisma.ataud_precioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ataud_venta`: Exposes CRUD operations for the **ataud_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataud_ventas
    * const ataud_ventas = await prisma.ataud_venta.findMany()
    * ```
    */
  get ataud_venta(): Prisma.ataud_ventaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ataudes`: Exposes CRUD operations for the **ataudes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ataudes
    * const ataudes = await prisma.ataudes.findMany()
    * ```
    */
  get ataudes(): Prisma.ataudesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos`: Exposes CRUD operations for the **autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos
    * const autos = await prisma.autos.findMany()
    * ```
    */
  get autos(): Prisma.autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_hoja_ruta`: Exposes CRUD operations for the **autos_hoja_ruta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_hoja_rutas
    * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
    * ```
    */
  get autos_hoja_ruta(): Prisma.autos_hoja_rutaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_novedades`: Exposes CRUD operations for the **autos_novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_novedades
    * const autos_novedades = await prisma.autos_novedades.findMany()
    * ```
    */
  get autos_novedades(): Prisma.autos_novedadesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.autos_pago_patente`: Exposes CRUD operations for the **autos_pago_patente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Autos_pago_patentes
    * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
    * ```
    */
  get autos_pago_patente(): Prisma.autos_pago_patenteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_sepelio`: Exposes CRUD operations for the **caja_sepelio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sepelios
    * const caja_sepelios = await prisma.caja_sepelio.findMany()
    * ```
    */
  get caja_sepelio(): Prisma.caja_sepelioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.conceptos`: Exposes CRUD operations for the **conceptos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conceptos
    * const conceptos = await prisma.conceptos.findMany()
    * ```
    */
  get conceptos(): Prisma.conceptosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fabricante_ataud`: Exposes CRUD operations for the **fabricante_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fabricante_atauds
    * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
    * ```
    */
  get fabricante_ataud(): Prisma.fabricante_ataudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gasto_luto`: Exposes CRUD operations for the **gasto_luto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gasto_lutos
    * const gasto_lutos = await prisma.gasto_luto.findMany()
    * ```
    */
  get gasto_luto(): Prisma.gasto_lutoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gastos_caja`: Exposes CRUD operations for the **gastos_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gastos_cajas
    * const gastos_cajas = await prisma.gastos_caja.findMany()
    * ```
    */
  get gastos_caja(): Prisma.gastos_cajaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_autos`: Exposes CRUD operations for the **historial_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_autos
    * const historial_autos = await prisma.historial_autos.findMany()
    * ```
    */
  get historial_autos(): Prisma.historial_autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.historial_stock_ataud`: Exposes CRUD operations for the **historial_stock_ataud** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historial_stock_atauds
    * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
    * ```
    */
  get historial_stock_ataud(): Prisma.historial_stock_ataudDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.honorarios`: Exposes CRUD operations for the **honorarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Honorarios
    * const honorarios = await prisma.honorarios.findMany()
    * ```
    */
  get honorarios(): Prisma.honorariosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ingreso_caja`: Exposes CRUD operations for the **ingreso_caja** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingreso_cajas
    * const ingreso_cajas = await prisma.ingreso_caja.findMany()
    * ```
    */
  get ingreso_caja(): Prisma.ingreso_cajaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_autos`: Exposes CRUD operations for the **legajo_virtual_autos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_autos
    * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
    * ```
    */
  get legajo_virtual_autos(): Prisma.legajo_virtual_autosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.legajo_virtual_servicios`: Exposes CRUD operations for the **legajo_virtual_servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legajo_virtual_servicios
    * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
    * ```
    */
  get legajo_virtual_servicios(): Prisma.legajo_virtual_serviciosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.novedades`: Exposes CRUD operations for the **novedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Novedades
    * const novedades = await prisma.novedades.findMany()
    * ```
    */
  get novedades(): Prisma.novedadesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.operadorsep`: Exposes CRUD operations for the **operadorsep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operadorseps
    * const operadorseps = await prisma.operadorsep.findMany()
    * ```
    */
  get operadorsep(): Prisma.operadorsepDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parcelas`: Exposes CRUD operations for the **parcelas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcelas
    * const parcelas = await prisma.parcelas.findMany()
    * ```
    */
  get parcelas(): Prisma.parcelasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.planificacion_guardias`: Exposes CRUD operations for the **planificacion_guardias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planificacion_guardias
    * const planificacion_guardias = await prisma.planificacion_guardias.findMany()
    * ```
    */
  get planificacion_guardias(): Prisma.planificacion_guardiasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.precio_servicio`: Exposes CRUD operations for the **precio_servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Precio_servicios
    * const precio_servicios = await prisma.precio_servicio.findMany()
    * ```
    */
  get precio_servicio(): Prisma.precio_servicioDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.proveedores`: Exposes CRUD operations for the **proveedores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedores
    * const proveedores = await prisma.proveedores.findMany()
    * ```
    */
  get proveedores(): Prisma.proveedoresDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_detalles`: Exposes CRUD operations for the **servicio_detalles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_detalles
    * const servicio_detalles = await prisma.servicio_detalles.findMany()
    * ```
    */
  get servicio_detalles(): Prisma.servicio_detallesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_gastos`: Exposes CRUD operations for the **servicio_gastos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_gastos
    * const servicio_gastos = await prisma.servicio_gastos.findMany()
    * ```
    */
  get servicio_gastos(): Prisma.servicio_gastosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicio_venta`: Exposes CRUD operations for the **servicio_venta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicio_ventas
    * const servicio_ventas = await prisma.servicio_venta.findMany()
    * ```
    */
  get servicio_venta(): Prisma.servicio_ventaDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.serviciosDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.servicios_liquidacion`: Exposes CRUD operations for the **servicios_liquidacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios_liquidacions
    * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany()
    * ```
    */
  get servicios_liquidacion(): Prisma.servicios_liquidacionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tareas`: Exposes CRUD operations for the **tareas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas
    * const tareas = await prisma.tareas.findMany()
    * ```
    */
  get tareas(): Prisma.tareasDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tareas_adicionales`: Exposes CRUD operations for the **tareas_adicionales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tareas_adicionales
    * const tareas_adicionales = await prisma.tareas_adicionales.findMany()
    * ```
    */
  get tareas_adicionales(): Prisma.tareas_adicionalesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.tipo_detalle`: Exposes CRUD operations for the **tipo_detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_detalles
    * const tipo_detalles = await prisma.tipo_detalle.findMany()
    * ```
    */
  get tipo_detalle(): Prisma.tipo_detalleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.visitantes`: Exposes CRUD operations for the **visitantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitantes
    * const visitantes = await prisma.visitantes.findMany()
    * ```
    */
  get visitantes(): Prisma.visitantesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.parcelas_lugares`: Exposes CRUD operations for the **parcelas_lugares** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parcelas_lugares
    * const parcelas_lugares = await prisma.parcelas_lugares.findMany()
    * ```
    */
  get parcelas_lugares(): Prisma.parcelas_lugaresDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_sa`: Exposes CRUD operations for the **caja_sa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_sas
    * const caja_sas = await prisma.caja_sa.findMany()
    * ```
    */
  get caja_sa(): Prisma.caja_saDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.caja_srl`: Exposes CRUD operations for the **caja_srl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caja_srls
    * const caja_srls = await prisma.caja_srl.findMany()
    * ```
    */
  get caja_srl(): Prisma.caja_srlDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.generacion_cajas`: Exposes CRUD operations for the **generacion_cajas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generacion_cajas
    * const generacion_cajas = await prisma.generacion_cajas.findMany()
    * ```
    */
  get generacion_cajas(): Prisma.generacion_cajasDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.17.0-dev.38
   * Query Engine version: e6267db1c1bc827b8eb87f644288c3cb0800ec89
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ataud_precio: 'ataud_precio',
    ataud_venta: 'ataud_venta',
    ataudes: 'ataudes',
    autos: 'autos',
    autos_hoja_ruta: 'autos_hoja_ruta',
    autos_novedades: 'autos_novedades',
    autos_pago_patente: 'autos_pago_patente',
    caja_sepelio: 'caja_sepelio',
    conceptos: 'conceptos',
    fabricante_ataud: 'fabricante_ataud',
    gasto_luto: 'gasto_luto',
    gastos_caja: 'gastos_caja',
    historial_autos: 'historial_autos',
    historial_stock_ataud: 'historial_stock_ataud',
    honorarios: 'honorarios',
    ingreso_caja: 'ingreso_caja',
    legajo_virtual_autos: 'legajo_virtual_autos',
    legajo_virtual_servicios: 'legajo_virtual_servicios',
    novedades: 'novedades',
    operadorsep: 'operadorsep',
    parcelas: 'parcelas',
    planificacion_guardias: 'planificacion_guardias',
    precio_servicio: 'precio_servicio',
    proveedores: 'proveedores',
    servicio_detalles: 'servicio_detalles',
    servicio_gastos: 'servicio_gastos',
    servicio_venta: 'servicio_venta',
    servicios: 'servicios',
    servicios_liquidacion: 'servicios_liquidacion',
    tareas: 'tareas',
    tareas_adicionales: 'tareas_adicionales',
    tipo_detalle: 'tipo_detalle',
    visitantes: 'visitantes',
    parcelas_lugares: 'parcelas_lugares',
    caja_sa: 'caja_sa',
    caja_srl: 'caja_srl',
    generacion_cajas: 'generacion_cajas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'ataud_precio' | 'ataud_venta' | 'ataudes' | 'autos' | 'autos_hoja_ruta' | 'autos_novedades' | 'autos_pago_patente' | 'caja_sepelio' | 'conceptos' | 'fabricante_ataud' | 'gasto_luto' | 'gastos_caja' | 'historial_autos' | 'historial_stock_ataud' | 'honorarios' | 'ingreso_caja' | 'legajo_virtual_autos' | 'legajo_virtual_servicios' | 'novedades' | 'operadorsep' | 'parcelas' | 'planificacion_guardias' | 'precio_servicio' | 'proveedores' | 'servicio_detalles' | 'servicio_gastos' | 'servicio_venta' | 'servicios' | 'servicios_liquidacion' | 'tareas' | 'tareas_adicionales' | 'tipo_detalle' | 'visitantes' | 'parcelas_lugares' | 'caja_sa' | 'caja_srl' | 'generacion_cajas'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      ataud_precio: {
        operations: {
          findUnique: {
            args: Prisma.ataud_precioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload> | null
            payload: ataud_precioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataud_precioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataud_precioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload> | null
            payload: ataud_precioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataud_precioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataud_precioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>[]
            payload: ataud_precioPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataud_precioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataud_precioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataud_precioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataud_precioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataud_precioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataud_precioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_precioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataud_precioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_precioPayload>
            payload: ataud_precioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ataud_precioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaud_precio>
            payload: ataud_precioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataud_precioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_precioGroupByOutputType>[]
            payload: ataud_precioPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataud_precioCountArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_precioCountAggregateOutputType> | number
            payload: ataud_precioPayload<ExtArgs>
          }
        }
      }
      ataud_venta: {
        operations: {
          findUnique: {
            args: Prisma.ataud_ventaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload> | null
            payload: ataud_ventaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataud_ventaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataud_ventaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload> | null
            payload: ataud_ventaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataud_ventaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataud_ventaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>[]
            payload: ataud_ventaPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataud_ventaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataud_ventaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataud_ventaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataud_ventaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataud_ventaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataud_ventaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataud_ventaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataud_ventaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataud_ventaPayload>
            payload: ataud_ventaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ataud_ventaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaud_venta>
            payload: ataud_ventaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataud_ventaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_ventaGroupByOutputType>[]
            payload: ataud_ventaPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataud_ventaCountArgs<ExtArgs>,
            result: $Utils.Optional<Ataud_ventaCountAggregateOutputType> | number
            payload: ataud_ventaPayload<ExtArgs>
          }
        }
      }
      ataudes: {
        operations: {
          findUnique: {
            args: Prisma.ataudesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload> | null
            payload: ataudesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ataudesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ataudesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload> | null
            payload: ataudesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ataudesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ataudesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>[]
            payload: ataudesPayload<ExtArgs>
          }
          create: {
            args: Prisma.ataudesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ataudesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ataudesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          update: {
            args: Prisma.ataudesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ataudesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ataudesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ataudesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ataudesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ataudesPayload>
            payload: ataudesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AtaudesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtaudes>
            payload: ataudesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ataudesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AtaudesGroupByOutputType>[]
            payload: ataudesPayload<ExtArgs>
          }
          count: {
            args: Prisma.ataudesCountArgs<ExtArgs>,
            result: $Utils.Optional<AtaudesCountAggregateOutputType> | number
            payload: ataudesPayload<ExtArgs>
          }
        }
      }
      autos: {
        operations: {
          findUnique: {
            args: Prisma.autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload> | null
            payload: autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload> | null
            payload: autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>[]
            payload: autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autosPayload>
            payload: autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AutosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos>
            payload: autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AutosGroupByOutputType>[]
            payload: autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.autosCountArgs<ExtArgs>,
            result: $Utils.Optional<AutosCountAggregateOutputType> | number
            payload: autosPayload<ExtArgs>
          }
        }
      }
      autos_hoja_ruta: {
        operations: {
          findUnique: {
            args: Prisma.autos_hoja_rutaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload> | null
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_hoja_rutaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload> | null
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_hoja_rutaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>[]
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_hoja_rutaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_hoja_rutaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_hoja_rutaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_hoja_rutaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_hoja_rutaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_hoja_rutaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_hoja_rutaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_hoja_rutaPayload>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_hoja_rutaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_hoja_ruta>
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_hoja_rutaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_hoja_rutaGroupByOutputType>[]
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_hoja_rutaCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_hoja_rutaCountAggregateOutputType> | number
            payload: autos_hoja_rutaPayload<ExtArgs>
          }
        }
      }
      autos_novedades: {
        operations: {
          findUnique: {
            args: Prisma.autos_novedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload> | null
            payload: autos_novedadesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_novedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_novedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload> | null
            payload: autos_novedadesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_novedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_novedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>[]
            payload: autos_novedadesPayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_novedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_novedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_novedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_novedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_novedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_novedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_novedadesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_novedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_novedadesPayload>
            payload: autos_novedadesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_novedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_novedades>
            payload: autos_novedadesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_novedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_novedadesGroupByOutputType>[]
            payload: autos_novedadesPayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_novedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_novedadesCountAggregateOutputType> | number
            payload: autos_novedadesPayload<ExtArgs>
          }
        }
      }
      autos_pago_patente: {
        operations: {
          findUnique: {
            args: Prisma.autos_pago_patenteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload> | null
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.autos_pago_patenteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload> | null
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.autos_pago_patenteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>[]
            payload: autos_pago_patentePayload<ExtArgs>
          }
          create: {
            args: Prisma.autos_pago_patenteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.autos_pago_patenteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          delete: {
            args: Prisma.autos_pago_patenteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          update: {
            args: Prisma.autos_pago_patenteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.autos_pago_patenteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.autos_pago_patenteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: autos_pago_patentePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.autos_pago_patenteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<autos_pago_patentePayload>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Autos_pago_patenteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAutos_pago_patente>
            payload: autos_pago_patentePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.autos_pago_patenteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Autos_pago_patenteGroupByOutputType>[]
            payload: autos_pago_patentePayload<ExtArgs>
          }
          count: {
            args: Prisma.autos_pago_patenteCountArgs<ExtArgs>,
            result: $Utils.Optional<Autos_pago_patenteCountAggregateOutputType> | number
            payload: autos_pago_patentePayload<ExtArgs>
          }
        }
      }
      caja_sepelio: {
        operations: {
          findUnique: {
            args: Prisma.caja_sepelioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload> | null
            payload: caja_sepelioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_sepelioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_sepelioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload> | null
            payload: caja_sepelioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_sepelioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_sepelioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>[]
            payload: caja_sepelioPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_sepelioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_sepelioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_sepelioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_sepelioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_sepelioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_sepelioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_sepelioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_sepelioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_sepelioPayload>
            payload: caja_sepelioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_sepelioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_sepelio>
            payload: caja_sepelioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_sepelioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sepelioGroupByOutputType>[]
            payload: caja_sepelioPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_sepelioCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_sepelioCountAggregateOutputType> | number
            payload: caja_sepelioPayload<ExtArgs>
          }
        }
      }
      conceptos: {
        operations: {
          findUnique: {
            args: Prisma.conceptosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload> | null
            payload: conceptosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.conceptosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.conceptosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload> | null
            payload: conceptosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.conceptosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.conceptosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>[]
            payload: conceptosPayload<ExtArgs>
          }
          create: {
            args: Prisma.conceptosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.conceptosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.conceptosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          update: {
            args: Prisma.conceptosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.conceptosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.conceptosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: conceptosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.conceptosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<conceptosPayload>
            payload: conceptosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ConceptosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConceptos>
            payload: conceptosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.conceptosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConceptosGroupByOutputType>[]
            payload: conceptosPayload<ExtArgs>
          }
          count: {
            args: Prisma.conceptosCountArgs<ExtArgs>,
            result: $Utils.Optional<ConceptosCountAggregateOutputType> | number
            payload: conceptosPayload<ExtArgs>
          }
        }
      }
      fabricante_ataud: {
        operations: {
          findUnique: {
            args: Prisma.fabricante_ataudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.fabricante_ataudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload> | null
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.fabricante_ataudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.fabricante_ataudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          create: {
            args: Prisma.fabricante_ataudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.fabricante_ataudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          delete: {
            args: Prisma.fabricante_ataudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          update: {
            args: Prisma.fabricante_ataudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.fabricante_ataudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.fabricante_ataudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fabricante_ataudPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.fabricante_ataudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fabricante_ataudPayload>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Fabricante_ataudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFabricante_ataud>
            payload: fabricante_ataudPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.fabricante_ataudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudGroupByOutputType>[]
            payload: fabricante_ataudPayload<ExtArgs>
          }
          count: {
            args: Prisma.fabricante_ataudCountArgs<ExtArgs>,
            result: $Utils.Optional<Fabricante_ataudCountAggregateOutputType> | number
            payload: fabricante_ataudPayload<ExtArgs>
          }
        }
      }
      gasto_luto: {
        operations: {
          findUnique: {
            args: Prisma.gasto_lutoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload> | null
            payload: gasto_lutoPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gasto_lutoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gasto_lutoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload> | null
            payload: gasto_lutoPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gasto_lutoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gasto_lutoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>[]
            payload: gasto_lutoPayload<ExtArgs>
          }
          create: {
            args: Prisma.gasto_lutoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gasto_lutoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gasto_lutoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          update: {
            args: Prisma.gasto_lutoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gasto_lutoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gasto_lutoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gasto_lutoPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gasto_lutoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gasto_lutoPayload>
            payload: gasto_lutoPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Gasto_lutoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGasto_luto>
            payload: gasto_lutoPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gasto_lutoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gasto_lutoGroupByOutputType>[]
            payload: gasto_lutoPayload<ExtArgs>
          }
          count: {
            args: Prisma.gasto_lutoCountArgs<ExtArgs>,
            result: $Utils.Optional<Gasto_lutoCountAggregateOutputType> | number
            payload: gasto_lutoPayload<ExtArgs>
          }
        }
      }
      gastos_caja: {
        operations: {
          findUnique: {
            args: Prisma.gastos_cajaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload> | null
            payload: gastos_cajaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.gastos_cajaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.gastos_cajaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload> | null
            payload: gastos_cajaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.gastos_cajaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.gastos_cajaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>[]
            payload: gastos_cajaPayload<ExtArgs>
          }
          create: {
            args: Prisma.gastos_cajaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.gastos_cajaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.gastos_cajaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          update: {
            args: Prisma.gastos_cajaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.gastos_cajaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.gastos_cajaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: gastos_cajaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.gastos_cajaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<gastos_cajaPayload>
            payload: gastos_cajaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Gastos_cajaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGastos_caja>
            payload: gastos_cajaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.gastos_cajaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_cajaGroupByOutputType>[]
            payload: gastos_cajaPayload<ExtArgs>
          }
          count: {
            args: Prisma.gastos_cajaCountArgs<ExtArgs>,
            result: $Utils.Optional<Gastos_cajaCountAggregateOutputType> | number
            payload: gastos_cajaPayload<ExtArgs>
          }
        }
      }
      historial_autos: {
        operations: {
          findUnique: {
            args: Prisma.historial_autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload> | null
            payload: historial_autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload> | null
            payload: historial_autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>[]
            payload: historial_autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_autosPayload>
            payload: historial_autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_autosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_autos>
            payload: historial_autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_autosGroupByOutputType>[]
            payload: historial_autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_autosCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_autosCountAggregateOutputType> | number
            payload: historial_autosPayload<ExtArgs>
          }
        }
      }
      historial_stock_ataud: {
        operations: {
          findUnique: {
            args: Prisma.historial_stock_ataudFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload> | null
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.historial_stock_ataudFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload> | null
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.historial_stock_ataudFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>[]
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          create: {
            args: Prisma.historial_stock_ataudCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.historial_stock_ataudCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          delete: {
            args: Prisma.historial_stock_ataudDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          update: {
            args: Prisma.historial_stock_ataudUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.historial_stock_ataudDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.historial_stock_ataudUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.historial_stock_ataudUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<historial_stock_ataudPayload>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Historial_stock_ataudAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorial_stock_ataud>
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.historial_stock_ataudGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Historial_stock_ataudGroupByOutputType>[]
            payload: historial_stock_ataudPayload<ExtArgs>
          }
          count: {
            args: Prisma.historial_stock_ataudCountArgs<ExtArgs>,
            result: $Utils.Optional<Historial_stock_ataudCountAggregateOutputType> | number
            payload: historial_stock_ataudPayload<ExtArgs>
          }
        }
      }
      honorarios: {
        operations: {
          findUnique: {
            args: Prisma.honorariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload> | null
            payload: honorariosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.honorariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.honorariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload> | null
            payload: honorariosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.honorariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.honorariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>[]
            payload: honorariosPayload<ExtArgs>
          }
          create: {
            args: Prisma.honorariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.honorariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.honorariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          update: {
            args: Prisma.honorariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.honorariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.honorariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: honorariosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.honorariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<honorariosPayload>
            payload: honorariosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.HonorariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHonorarios>
            payload: honorariosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.honorariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HonorariosGroupByOutputType>[]
            payload: honorariosPayload<ExtArgs>
          }
          count: {
            args: Prisma.honorariosCountArgs<ExtArgs>,
            result: $Utils.Optional<HonorariosCountAggregateOutputType> | number
            payload: honorariosPayload<ExtArgs>
          }
        }
      }
      ingreso_caja: {
        operations: {
          findUnique: {
            args: Prisma.ingreso_cajaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload> | null
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ingreso_cajaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload> | null
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ingreso_cajaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ingreso_cajaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>[]
            payload: ingreso_cajaPayload<ExtArgs>
          }
          create: {
            args: Prisma.ingreso_cajaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ingreso_cajaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ingreso_cajaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          update: {
            args: Prisma.ingreso_cajaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ingreso_cajaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ingreso_cajaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ingreso_cajaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ingreso_cajaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ingreso_cajaPayload>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Ingreso_cajaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngreso_caja>
            payload: ingreso_cajaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ingreso_cajaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ingreso_cajaGroupByOutputType>[]
            payload: ingreso_cajaPayload<ExtArgs>
          }
          count: {
            args: Prisma.ingreso_cajaCountArgs<ExtArgs>,
            result: $Utils.Optional<Ingreso_cajaCountAggregateOutputType> | number
            payload: ingreso_cajaPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_autos: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_autosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload> | null
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_autosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload> | null
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_autosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>[]
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_autosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_autosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_autosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_autosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_autosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_autosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_autosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_autosPayload>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_autosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_autos>
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_autosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_autosGroupByOutputType>[]
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_autosCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_autosCountAggregateOutputType> | number
            payload: legajo_virtual_autosPayload<ExtArgs>
          }
        }
      }
      legajo_virtual_servicios: {
        operations: {
          findUnique: {
            args: Prisma.legajo_virtual_serviciosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload> | null
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.legajo_virtual_serviciosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload> | null
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.legajo_virtual_serviciosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>[]
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          create: {
            args: Prisma.legajo_virtual_serviciosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.legajo_virtual_serviciosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.legajo_virtual_serviciosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          update: {
            args: Prisma.legajo_virtual_serviciosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.legajo_virtual_serviciosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.legajo_virtual_serviciosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.legajo_virtual_serviciosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<legajo_virtual_serviciosPayload>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Legajo_virtual_serviciosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLegajo_virtual_servicios>
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.legajo_virtual_serviciosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_serviciosGroupByOutputType>[]
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
          count: {
            args: Prisma.legajo_virtual_serviciosCountArgs<ExtArgs>,
            result: $Utils.Optional<Legajo_virtual_serviciosCountAggregateOutputType> | number
            payload: legajo_virtual_serviciosPayload<ExtArgs>
          }
        }
      }
      novedades: {
        operations: {
          findUnique: {
            args: Prisma.novedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.novedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.novedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload> | null
            payload: novedadesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.novedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.novedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>[]
            payload: novedadesPayload<ExtArgs>
          }
          create: {
            args: Prisma.novedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.novedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.novedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          update: {
            args: Prisma.novedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.novedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.novedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: novedadesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.novedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<novedadesPayload>
            payload: novedadesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NovedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNovedades>
            payload: novedadesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.novedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesGroupByOutputType>[]
            payload: novedadesPayload<ExtArgs>
          }
          count: {
            args: Prisma.novedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<NovedadesCountAggregateOutputType> | number
            payload: novedadesPayload<ExtArgs>
          }
        }
      }
      operadorsep: {
        operations: {
          findUnique: {
            args: Prisma.operadorsepFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload> | null
            payload: operadorsepPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.operadorsepFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.operadorsepFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload> | null
            payload: operadorsepPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.operadorsepFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.operadorsepFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>[]
            payload: operadorsepPayload<ExtArgs>
          }
          create: {
            args: Prisma.operadorsepCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.operadorsepCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          delete: {
            args: Prisma.operadorsepDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          update: {
            args: Prisma.operadorsepUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.operadorsepDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.operadorsepUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: operadorsepPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.operadorsepUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<operadorsepPayload>
            payload: operadorsepPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.OperadorsepAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOperadorsep>
            payload: operadorsepPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.operadorsepGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OperadorsepGroupByOutputType>[]
            payload: operadorsepPayload<ExtArgs>
          }
          count: {
            args: Prisma.operadorsepCountArgs<ExtArgs>,
            result: $Utils.Optional<OperadorsepCountAggregateOutputType> | number
            payload: operadorsepPayload<ExtArgs>
          }
        }
      }
      parcelas: {
        operations: {
          findUnique: {
            args: Prisma.parcelasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload> | null
            payload: parcelasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.parcelasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.parcelasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload> | null
            payload: parcelasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.parcelasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.parcelasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>[]
            payload: parcelasPayload<ExtArgs>
          }
          create: {
            args: Prisma.parcelasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.parcelasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.parcelasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          update: {
            args: Prisma.parcelasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.parcelasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.parcelasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.parcelasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelasPayload>
            payload: parcelasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ParcelasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParcelas>
            payload: parcelasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.parcelasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParcelasGroupByOutputType>[]
            payload: parcelasPayload<ExtArgs>
          }
          count: {
            args: Prisma.parcelasCountArgs<ExtArgs>,
            result: $Utils.Optional<ParcelasCountAggregateOutputType> | number
            payload: parcelasPayload<ExtArgs>
          }
        }
      }
      planificacion_guardias: {
        operations: {
          findUnique: {
            args: Prisma.planificacion_guardiasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload> | null
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.planificacion_guardiasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.planificacion_guardiasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload> | null
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.planificacion_guardiasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.planificacion_guardiasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>[]
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          create: {
            args: Prisma.planificacion_guardiasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.planificacion_guardiasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.planificacion_guardiasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          update: {
            args: Prisma.planificacion_guardiasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.planificacion_guardiasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.planificacion_guardiasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.planificacion_guardiasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<planificacion_guardiasPayload>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Planificacion_guardiasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlanificacion_guardias>
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.planificacion_guardiasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Planificacion_guardiasGroupByOutputType>[]
            payload: planificacion_guardiasPayload<ExtArgs>
          }
          count: {
            args: Prisma.planificacion_guardiasCountArgs<ExtArgs>,
            result: $Utils.Optional<Planificacion_guardiasCountAggregateOutputType> | number
            payload: planificacion_guardiasPayload<ExtArgs>
          }
        }
      }
      precio_servicio: {
        operations: {
          findUnique: {
            args: Prisma.precio_servicioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload> | null
            payload: precio_servicioPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.precio_servicioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.precio_servicioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload> | null
            payload: precio_servicioPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.precio_servicioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.precio_servicioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>[]
            payload: precio_servicioPayload<ExtArgs>
          }
          create: {
            args: Prisma.precio_servicioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.precio_servicioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          delete: {
            args: Prisma.precio_servicioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          update: {
            args: Prisma.precio_servicioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.precio_servicioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.precio_servicioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: precio_servicioPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.precio_servicioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<precio_servicioPayload>
            payload: precio_servicioPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Precio_servicioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrecio_servicio>
            payload: precio_servicioPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.precio_servicioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Precio_servicioGroupByOutputType>[]
            payload: precio_servicioPayload<ExtArgs>
          }
          count: {
            args: Prisma.precio_servicioCountArgs<ExtArgs>,
            result: $Utils.Optional<Precio_servicioCountAggregateOutputType> | number
            payload: precio_servicioPayload<ExtArgs>
          }
        }
      }
      proveedores: {
        operations: {
          findUnique: {
            args: Prisma.proveedoresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload> | null
            payload: proveedoresPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.proveedoresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.proveedoresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload> | null
            payload: proveedoresPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.proveedoresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.proveedoresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>[]
            payload: proveedoresPayload<ExtArgs>
          }
          create: {
            args: Prisma.proveedoresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.proveedoresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          delete: {
            args: Prisma.proveedoresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          update: {
            args: Prisma.proveedoresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.proveedoresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.proveedoresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: proveedoresPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.proveedoresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<proveedoresPayload>
            payload: proveedoresPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ProveedoresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProveedores>
            payload: proveedoresPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.proveedoresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProveedoresGroupByOutputType>[]
            payload: proveedoresPayload<ExtArgs>
          }
          count: {
            args: Prisma.proveedoresCountArgs<ExtArgs>,
            result: $Utils.Optional<ProveedoresCountAggregateOutputType> | number
            payload: proveedoresPayload<ExtArgs>
          }
        }
      }
      servicio_detalles: {
        operations: {
          findUnique: {
            args: Prisma.servicio_detallesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload> | null
            payload: servicio_detallesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_detallesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_detallesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload> | null
            payload: servicio_detallesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_detallesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_detallesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>[]
            payload: servicio_detallesPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_detallesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_detallesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_detallesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_detallesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_detallesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_detallesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_detallesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_detallesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_detallesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_detallesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_detallesPayload>
            payload: servicio_detallesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_detallesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_detalles>
            payload: servicio_detallesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_detallesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_detallesGroupByOutputType>[]
            payload: servicio_detallesPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_detallesCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_detallesCountAggregateOutputType> | number
            payload: servicio_detallesPayload<ExtArgs>
          }
        }
      }
      servicio_gastos: {
        operations: {
          findUnique: {
            args: Prisma.servicio_gastosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload> | null
            payload: servicio_gastosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_gastosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_gastosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload> | null
            payload: servicio_gastosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_gastosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_gastosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>[]
            payload: servicio_gastosPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_gastosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_gastosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_gastosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_gastosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_gastosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_gastosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_gastosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_gastosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_gastosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_gastosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_gastosPayload>
            payload: servicio_gastosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_gastosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_gastos>
            payload: servicio_gastosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_gastosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_gastosGroupByOutputType>[]
            payload: servicio_gastosPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_gastosCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_gastosCountAggregateOutputType> | number
            payload: servicio_gastosPayload<ExtArgs>
          }
        }
      }
      servicio_venta: {
        operations: {
          findUnique: {
            args: Prisma.servicio_ventaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload> | null
            payload: servicio_ventaPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicio_ventaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicio_ventaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload> | null
            payload: servicio_ventaPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicio_ventaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicio_ventaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>[]
            payload: servicio_ventaPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicio_ventaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicio_ventaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicio_ventaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicio_ventaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicio_ventaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicio_ventaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicio_ventaPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicio_ventaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicio_ventaPayload>
            payload: servicio_ventaPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicio_ventaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicio_venta>
            payload: servicio_ventaPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicio_ventaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_ventaGroupByOutputType>[]
            payload: servicio_ventaPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicio_ventaCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicio_ventaCountAggregateOutputType> | number
            payload: servicio_ventaPayload<ExtArgs>
          }
        }
      }
      servicios: {
        operations: {
          findUnique: {
            args: Prisma.serviciosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload> | null
            payload: serviciosPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.serviciosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.serviciosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload> | null
            payload: serviciosPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.serviciosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.serviciosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>[]
            payload: serviciosPayload<ExtArgs>
          }
          create: {
            args: Prisma.serviciosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.serviciosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          delete: {
            args: Prisma.serviciosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          update: {
            args: Prisma.serviciosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.serviciosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.serviciosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: serviciosPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.serviciosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<serviciosPayload>
            payload: serviciosPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ServiciosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios>
            payload: serviciosPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.serviciosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosGroupByOutputType>[]
            payload: serviciosPayload<ExtArgs>
          }
          count: {
            args: Prisma.serviciosCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiciosCountAggregateOutputType> | number
            payload: serviciosPayload<ExtArgs>
          }
        }
      }
      servicios_liquidacion: {
        operations: {
          findUnique: {
            args: Prisma.servicios_liquidacionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload> | null
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.servicios_liquidacionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.servicios_liquidacionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload> | null
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.servicios_liquidacionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.servicios_liquidacionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>[]
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          create: {
            args: Prisma.servicios_liquidacionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.servicios_liquidacionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.servicios_liquidacionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          update: {
            args: Prisma.servicios_liquidacionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.servicios_liquidacionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.servicios_liquidacionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.servicios_liquidacionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<servicios_liquidacionPayload>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Servicios_liquidacionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServicios_liquidacion>
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.servicios_liquidacionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_liquidacionGroupByOutputType>[]
            payload: servicios_liquidacionPayload<ExtArgs>
          }
          count: {
            args: Prisma.servicios_liquidacionCountArgs<ExtArgs>,
            result: $Utils.Optional<Servicios_liquidacionCountAggregateOutputType> | number
            payload: servicios_liquidacionPayload<ExtArgs>
          }
        }
      }
      tareas: {
        operations: {
          findUnique: {
            args: Prisma.tareasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload> | null
            payload: tareasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tareasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tareasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload> | null
            payload: tareasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tareasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tareasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>[]
            payload: tareasPayload<ExtArgs>
          }
          create: {
            args: Prisma.tareasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tareasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tareasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          update: {
            args: Prisma.tareasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tareasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tareasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tareasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareasPayload>
            payload: tareasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.TareasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTareas>
            payload: tareasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tareasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TareasGroupByOutputType>[]
            payload: tareasPayload<ExtArgs>
          }
          count: {
            args: Prisma.tareasCountArgs<ExtArgs>,
            result: $Utils.Optional<TareasCountAggregateOutputType> | number
            payload: tareasPayload<ExtArgs>
          }
        }
      }
      tareas_adicionales: {
        operations: {
          findUnique: {
            args: Prisma.tareas_adicionalesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload> | null
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tareas_adicionalesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tareas_adicionalesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload> | null
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tareas_adicionalesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tareas_adicionalesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>[]
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          create: {
            args: Prisma.tareas_adicionalesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tareas_adicionalesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.tareas_adicionalesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          update: {
            args: Prisma.tareas_adicionalesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tareas_adicionalesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tareas_adicionalesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tareas_adicionalesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tareas_adicionalesPayload>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tareas_adicionalesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTareas_adicionales>
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tareas_adicionalesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tareas_adicionalesGroupByOutputType>[]
            payload: tareas_adicionalesPayload<ExtArgs>
          }
          count: {
            args: Prisma.tareas_adicionalesCountArgs<ExtArgs>,
            result: $Utils.Optional<Tareas_adicionalesCountAggregateOutputType> | number
            payload: tareas_adicionalesPayload<ExtArgs>
          }
        }
      }
      tipo_detalle: {
        operations: {
          findUnique: {
            args: Prisma.tipo_detalleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload> | null
            payload: tipo_detallePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.tipo_detalleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.tipo_detalleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload> | null
            payload: tipo_detallePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.tipo_detalleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.tipo_detalleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>[]
            payload: tipo_detallePayload<ExtArgs>
          }
          create: {
            args: Prisma.tipo_detalleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.tipo_detalleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_detallePayload<ExtArgs>
          }
          delete: {
            args: Prisma.tipo_detalleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          update: {
            args: Prisma.tipo_detalleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.tipo_detalleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_detallePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.tipo_detalleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: tipo_detallePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.tipo_detalleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<tipo_detallePayload>
            payload: tipo_detallePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Tipo_detalleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipo_detalle>
            payload: tipo_detallePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.tipo_detalleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_detalleGroupByOutputType>[]
            payload: tipo_detallePayload<ExtArgs>
          }
          count: {
            args: Prisma.tipo_detalleCountArgs<ExtArgs>,
            result: $Utils.Optional<Tipo_detalleCountAggregateOutputType> | number
            payload: tipo_detallePayload<ExtArgs>
          }
        }
      }
      visitantes: {
        operations: {
          findUnique: {
            args: Prisma.visitantesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload> | null
            payload: visitantesPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.visitantesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.visitantesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload> | null
            payload: visitantesPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.visitantesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.visitantesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>[]
            payload: visitantesPayload<ExtArgs>
          }
          create: {
            args: Prisma.visitantesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.visitantesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          delete: {
            args: Prisma.visitantesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          update: {
            args: Prisma.visitantesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.visitantesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.visitantesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: visitantesPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.visitantesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<visitantesPayload>
            payload: visitantesPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.VisitantesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVisitantes>
            payload: visitantesPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.visitantesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VisitantesGroupByOutputType>[]
            payload: visitantesPayload<ExtArgs>
          }
          count: {
            args: Prisma.visitantesCountArgs<ExtArgs>,
            result: $Utils.Optional<VisitantesCountAggregateOutputType> | number
            payload: visitantesPayload<ExtArgs>
          }
        }
      }
      parcelas_lugares: {
        operations: {
          findUnique: {
            args: Prisma.parcelas_lugaresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload> | null
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.parcelas_lugaresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload> | null
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.parcelas_lugaresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>[]
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          create: {
            args: Prisma.parcelas_lugaresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.parcelas_lugaresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          delete: {
            args: Prisma.parcelas_lugaresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          update: {
            args: Prisma.parcelas_lugaresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.parcelas_lugaresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.parcelas_lugaresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.parcelas_lugaresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<parcelas_lugaresPayload>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Parcelas_lugaresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParcelas_lugares>
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.parcelas_lugaresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Parcelas_lugaresGroupByOutputType>[]
            payload: parcelas_lugaresPayload<ExtArgs>
          }
          count: {
            args: Prisma.parcelas_lugaresCountArgs<ExtArgs>,
            result: $Utils.Optional<Parcelas_lugaresCountAggregateOutputType> | number
            payload: parcelas_lugaresPayload<ExtArgs>
          }
        }
      }
      caja_sa: {
        operations: {
          findUnique: {
            args: Prisma.caja_saFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload> | null
            payload: caja_saPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_saFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_saFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload> | null
            payload: caja_saPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_saFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_saFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>[]
            payload: caja_saPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_saCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_saCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_saDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_saUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_saDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_saUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_saPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_saUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_saPayload>
            payload: caja_saPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_saAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_sa>
            payload: caja_saPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_saGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_saGroupByOutputType>[]
            payload: caja_saPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_saCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_saCountAggregateOutputType> | number
            payload: caja_saPayload<ExtArgs>
          }
        }
      }
      caja_srl: {
        operations: {
          findUnique: {
            args: Prisma.caja_srlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload> | null
            payload: caja_srlPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.caja_srlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.caja_srlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload> | null
            payload: caja_srlPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.caja_srlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.caja_srlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>[]
            payload: caja_srlPayload<ExtArgs>
          }
          create: {
            args: Prisma.caja_srlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.caja_srlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          delete: {
            args: Prisma.caja_srlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          update: {
            args: Prisma.caja_srlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.caja_srlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.caja_srlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: caja_srlPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.caja_srlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<caja_srlPayload>
            payload: caja_srlPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Caja_srlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCaja_srl>
            payload: caja_srlPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.caja_srlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Caja_srlGroupByOutputType>[]
            payload: caja_srlPayload<ExtArgs>
          }
          count: {
            args: Prisma.caja_srlCountArgs<ExtArgs>,
            result: $Utils.Optional<Caja_srlCountAggregateOutputType> | number
            payload: caja_srlPayload<ExtArgs>
          }
        }
      }
      generacion_cajas: {
        operations: {
          findUnique: {
            args: Prisma.generacion_cajasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload> | null
            payload: generacion_cajasPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.generacion_cajasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.generacion_cajasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload> | null
            payload: generacion_cajasPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.generacion_cajasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.generacion_cajasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>[]
            payload: generacion_cajasPayload<ExtArgs>
          }
          create: {
            args: Prisma.generacion_cajasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.generacion_cajasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          delete: {
            args: Prisma.generacion_cajasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          update: {
            args: Prisma.generacion_cajasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.generacion_cajasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.generacion_cajasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: generacion_cajasPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.generacion_cajasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<generacion_cajasPayload>
            payload: generacion_cajasPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Generacion_cajasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGeneracion_cajas>
            payload: generacion_cajasPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.generacion_cajasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Generacion_cajasGroupByOutputType>[]
            payload: generacion_cajasPayload<ExtArgs>
          }
          count: {
            args: Prisma.generacion_cajasCountArgs<ExtArgs>,
            result: $Utils.Optional<Generacion_cajasCountAggregateOutputType> | number
            payload: generacion_cajasPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model ataud_precio
   */


  export type AggregateAtaud_precio = {
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  export type Ataud_precioAvgAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioSumAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
  }

  export type Ataud_precioMinAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioMaxAggregateOutputType = {
    idprecio: number | null
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
  }

  export type Ataud_precioCountAggregateOutputType = {
    idprecio: number
    idataud: number
    codigo: number
    ataud: number
    precio: number
    pri_desc: number
    sec_desc: number
    fecha: number
    operador: number
    estado: number
    _all: number
  }


  export type Ataud_precioAvgAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioSumAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
  }

  export type Ataud_precioMinAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioMaxAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
  }

  export type Ataud_precioCountAggregateInputType = {
    idprecio?: true
    idataud?: true
    codigo?: true
    ataud?: true
    precio?: true
    pri_desc?: true
    sec_desc?: true
    fecha?: true
    operador?: true
    estado?: true
    _all?: true
  }

  export type Ataud_precioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_precio to aggregate.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_precios
    **/
    _count?: true | Ataud_precioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_precioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_precioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_precioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_precioMaxAggregateInputType
  }

  export type GetAtaud_precioAggregateType<T extends Ataud_precioAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_precio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_precio[P]>
      : GetScalarType<T[P], AggregateAtaud_precio[P]>
  }




  export type ataud_precioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataud_precioWhereInput
    orderBy?: ataud_precioOrderByWithAggregationInput | ataud_precioOrderByWithAggregationInput[]
    by: Ataud_precioScalarFieldEnum[] | Ataud_precioScalarFieldEnum
    having?: ataud_precioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_precioCountAggregateInputType | true
    _avg?: Ataud_precioAvgAggregateInputType
    _sum?: Ataud_precioSumAggregateInputType
    _min?: Ataud_precioMinAggregateInputType
    _max?: Ataud_precioMaxAggregateInputType
  }


  export type Ataud_precioGroupByOutputType = {
    idprecio: number
    idataud: number | null
    codigo: number | null
    ataud: string | null
    precio: number | null
    pri_desc: number | null
    sec_desc: number | null
    fecha: Date | null
    operador: string | null
    estado: boolean | null
    _count: Ataud_precioCountAggregateOutputType | null
    _avg: Ataud_precioAvgAggregateOutputType | null
    _sum: Ataud_precioSumAggregateOutputType | null
    _min: Ataud_precioMinAggregateOutputType | null
    _max: Ataud_precioMaxAggregateOutputType | null
  }

  type GetAtaud_precioGroupByPayload<T extends ataud_precioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ataud_precioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_precioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_precioGroupByOutputType[P]>
        }
      >
    >


  export type ataud_precioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprecio?: boolean
    idataud?: boolean
    codigo?: boolean
    ataud?: boolean
    precio?: boolean
    pri_desc?: boolean
    sec_desc?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }, ExtArgs["result"]["ataud_precio"]>

  export type ataud_precioSelectScalar = {
    idprecio?: boolean
    idataud?: boolean
    codigo?: boolean
    ataud?: boolean
    precio?: boolean
    pri_desc?: boolean
    sec_desc?: boolean
    fecha?: boolean
    operador?: boolean
    estado?: boolean
  }


  type ataud_precioGetPayload<S extends boolean | null | undefined | ataud_precioArgs> = $Types.GetResult<ataud_precioPayload, S>

  type ataud_precioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataud_precioFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_precioCountAggregateInputType | true
    }

  export interface ataud_precioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataud_precio'], meta: { name: 'ataud_precio' } }
    /**
     * Find zero or one Ataud_precio that matches the filter.
     * @param {ataud_precioFindUniqueArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_precioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_precioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataud_precio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_precioFindUniqueOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_precioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataud_precio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_precioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_precioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_precio'> extends True ? Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataud_precio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindFirstOrThrowArgs} args - Arguments to find a Ataud_precio
     * @example
     * // Get one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_precioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataud_precios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany()
     * 
     * // Get first 10 Ataud_precios
     * const ataud_precios = await prisma.ataud_precio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const ataud_precioWithIdprecioOnly = await prisma.ataud_precio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends ataud_precioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataud_precio.
     * @param {ataud_precioCreateArgs} args - Arguments to create a Ataud_precio.
     * @example
     * // Create one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.create({
     *   data: {
     *     // ... data to create a Ataud_precio
     *   }
     * })
     * 
    **/
    create<T extends ataud_precioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioCreateArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataud_precios.
     *     @param {ataud_precioCreateManyArgs} args - Arguments to create many Ataud_precios.
     *     @example
     *     // Create many Ataud_precios
     *     const ataud_precio = await prisma.ataud_precio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_precioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_precio.
     * @param {ataud_precioDeleteArgs} args - Arguments to delete one Ataud_precio.
     * @example
     * // Delete one Ataud_precio
     * const Ataud_precio = await prisma.ataud_precio.delete({
     *   where: {
     *     // ... filter to delete one Ataud_precio
     *   }
     * })
     * 
    **/
    delete<T extends ataud_precioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioDeleteArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataud_precio.
     * @param {ataud_precioUpdateArgs} args - Arguments to update one Ataud_precio.
     * @example
     * // Update one Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_precioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpdateArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataud_precios.
     * @param {ataud_precioDeleteManyArgs} args - Arguments to filter Ataud_precios to delete.
     * @example
     * // Delete a few Ataud_precios
     * const { count } = await prisma.ataud_precio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_precioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_precioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_precios
     * const ataud_precio = await prisma.ataud_precio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_precioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_precio.
     * @param {ataud_precioUpsertArgs} args - Arguments to update or create a Ataud_precio.
     * @example
     * // Update or create a Ataud_precio
     * const ataud_precio = await prisma.ataud_precio.upsert({
     *   create: {
     *     // ... data to create a Ataud_precio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_precio we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_precioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_precioUpsertArgs<ExtArgs>>
    ): Prisma__ataud_precioClient<$Types.GetResult<ataud_precioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataud_precios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioCountArgs} args - Arguments to filter Ataud_precios to count.
     * @example
     * // Count the number of Ataud_precios
     * const count = await prisma.ataud_precio.count({
     *   where: {
     *     // ... the filter for the Ataud_precios we want to count
     *   }
     * })
    **/
    count<T extends ataud_precioCountArgs>(
      args?: Subset<T, ataud_precioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_precioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_precioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_precioAggregateArgs>(args: Subset<T, Ataud_precioAggregateArgs>): Prisma.PrismaPromise<GetAtaud_precioAggregateType<T>>

    /**
     * Group by Ataud_precio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_precioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataud_precioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataud_precioGroupByArgs['orderBy'] }
        : { orderBy?: ataud_precioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataud_precioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_precioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_precio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_precioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_precio base type for findUnique actions
   */
  export type ataud_precioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }

  /**
   * ataud_precio findUnique
   */
  export interface ataud_precioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_precioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findUniqueOrThrow
   */
  export type ataud_precioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio base type for findFirst actions
   */
  export type ataud_precioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }

  /**
   * ataud_precio findFirst
   */
  export interface ataud_precioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_precioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_precio findFirstOrThrow
   */
  export type ataud_precioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precio to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_precios.
     */
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }


  /**
   * ataud_precio findMany
   */
  export type ataud_precioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter, which ataud_precios to fetch.
     */
    where?: ataud_precioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_precios to fetch.
     */
    orderBy?: ataud_precioOrderByWithRelationInput | ataud_precioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_precios.
     */
    cursor?: ataud_precioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_precios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_precios.
     */
    skip?: number
    distinct?: Ataud_precioScalarFieldEnum | Ataud_precioScalarFieldEnum[]
  }


  /**
   * ataud_precio create
   */
  export type ataud_precioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The data needed to create a ataud_precio.
     */
    data?: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
  }


  /**
   * ataud_precio createMany
   */
  export type ataud_precioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataud_precios.
     */
    data: ataud_precioCreateManyInput | ataud_precioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataud_precio update
   */
  export type ataud_precioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The data needed to update a ataud_precio.
     */
    data: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
    /**
     * Choose, which ataud_precio to update.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio updateMany
   */
  export type ataud_precioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataud_precios.
     */
    data: XOR<ataud_precioUpdateManyMutationInput, ataud_precioUncheckedUpdateManyInput>
    /**
     * Filter which ataud_precios to update
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio upsert
   */
  export type ataud_precioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * The filter to search for the ataud_precio to update in case it exists.
     */
    where: ataud_precioWhereUniqueInput
    /**
     * In case the ataud_precio found by the `where` argument doesn't exist, create a new ataud_precio with this data.
     */
    create: XOR<ataud_precioCreateInput, ataud_precioUncheckedCreateInput>
    /**
     * In case the ataud_precio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_precioUpdateInput, ataud_precioUncheckedUpdateInput>
  }


  /**
   * ataud_precio delete
   */
  export type ataud_precioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
    /**
     * Filter which ataud_precio to delete.
     */
    where: ataud_precioWhereUniqueInput
  }


  /**
   * ataud_precio deleteMany
   */
  export type ataud_precioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_precios to delete
     */
    where?: ataud_precioWhereInput
  }


  /**
   * ataud_precio without action
   */
  export type ataud_precioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_precio
     */
    select?: ataud_precioSelect<ExtArgs> | null
  }



  /**
   * Model ataud_venta
   */


  export type AggregateAtaud_venta = {
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  export type Ataud_ventaAvgAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaSumAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    dni_fall: number | null
    ndom_fall: number | null
    dni_sol: number | null
  }

  export type Ataud_ventaMinAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaMaxAggregateOutputType = {
    idataudventa: number | null
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
  }

  export type Ataud_ventaCountAggregateOutputType = {
    idataudventa: number
    idataud: number
    contrato: number
    apellido_fall: number
    nombre_fall: number
    dni_fall: number
    dom_fall: number
    ndom_fall: number
    barrio_fall: number
    telefono_fall: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    telefono_sol: number
    fecha: number
    operador: number
    ataud: number
    _all: number
  }


  export type Ataud_ventaAvgAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaSumAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    dni_fall?: true
    ndom_fall?: true
    dni_sol?: true
  }

  export type Ataud_ventaMinAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaMaxAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
  }

  export type Ataud_ventaCountAggregateInputType = {
    idataudventa?: true
    idataud?: true
    contrato?: true
    apellido_fall?: true
    nombre_fall?: true
    dni_fall?: true
    dom_fall?: true
    ndom_fall?: true
    barrio_fall?: true
    telefono_fall?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    telefono_sol?: true
    fecha?: true
    operador?: true
    ataud?: true
    _all?: true
  }

  export type Ataud_ventaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_venta to aggregate.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataud_ventas
    **/
    _count?: true | Ataud_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ataud_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ataud_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ataud_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ataud_ventaMaxAggregateInputType
  }

  export type GetAtaud_ventaAggregateType<T extends Ataud_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaud_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaud_venta[P]>
      : GetScalarType<T[P], AggregateAtaud_venta[P]>
  }




  export type ataud_ventaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataud_ventaWhereInput
    orderBy?: ataud_ventaOrderByWithAggregationInput | ataud_ventaOrderByWithAggregationInput[]
    by: Ataud_ventaScalarFieldEnum[] | Ataud_ventaScalarFieldEnum
    having?: ataud_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ataud_ventaCountAggregateInputType | true
    _avg?: Ataud_ventaAvgAggregateInputType
    _sum?: Ataud_ventaSumAggregateInputType
    _min?: Ataud_ventaMinAggregateInputType
    _max?: Ataud_ventaMaxAggregateInputType
  }


  export type Ataud_ventaGroupByOutputType = {
    idataudventa: number
    idataud: number | null
    contrato: number | null
    apellido_fall: string | null
    nombre_fall: string | null
    dni_fall: number | null
    dom_fall: string | null
    ndom_fall: number | null
    barrio_fall: string | null
    telefono_fall: string | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    telefono_sol: string | null
    fecha: Date | null
    operador: string | null
    ataud: string | null
    _count: Ataud_ventaCountAggregateOutputType | null
    _avg: Ataud_ventaAvgAggregateOutputType | null
    _sum: Ataud_ventaSumAggregateOutputType | null
    _min: Ataud_ventaMinAggregateOutputType | null
    _max: Ataud_ventaMaxAggregateOutputType | null
  }

  type GetAtaud_ventaGroupByPayload<T extends ataud_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ataud_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ataud_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Ataud_ventaGroupByOutputType[P]>
        }
      >
    >


  export type ataud_ventaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idataudventa?: boolean
    idataud?: boolean
    contrato?: boolean
    apellido_fall?: boolean
    nombre_fall?: boolean
    dni_fall?: boolean
    dom_fall?: boolean
    ndom_fall?: boolean
    barrio_fall?: boolean
    telefono_fall?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    telefono_sol?: boolean
    fecha?: boolean
    operador?: boolean
    ataud?: boolean
  }, ExtArgs["result"]["ataud_venta"]>

  export type ataud_ventaSelectScalar = {
    idataudventa?: boolean
    idataud?: boolean
    contrato?: boolean
    apellido_fall?: boolean
    nombre_fall?: boolean
    dni_fall?: boolean
    dom_fall?: boolean
    ndom_fall?: boolean
    barrio_fall?: boolean
    telefono_fall?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    telefono_sol?: boolean
    fecha?: boolean
    operador?: boolean
    ataud?: boolean
  }


  type ataud_ventaGetPayload<S extends boolean | null | undefined | ataud_ventaArgs> = $Types.GetResult<ataud_ventaPayload, S>

  type ataud_ventaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataud_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Ataud_ventaCountAggregateInputType | true
    }

  export interface ataud_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataud_venta'], meta: { name: 'ataud_venta' } }
    /**
     * Find zero or one Ataud_venta that matches the filter.
     * @param {ataud_ventaFindUniqueArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataud_ventaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataud_ventaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataud_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataud_ventaFindUniqueOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataud_ventaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataud_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataud_ventaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataud_ventaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataud_venta'> extends True ? Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataud_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindFirstOrThrowArgs} args - Arguments to find a Ataud_venta
     * @example
     * // Get one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataud_ventaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataud_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany()
     * 
     * // Get first 10 Ataud_ventas
     * const ataud_ventas = await prisma.ataud_venta.findMany({ take: 10 })
     * 
     * // Only select the `idataudventa`
     * const ataud_ventaWithIdataudventaOnly = await prisma.ataud_venta.findMany({ select: { idataudventa: true } })
     * 
    **/
    findMany<T extends ataud_ventaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataud_venta.
     * @param {ataud_ventaCreateArgs} args - Arguments to create a Ataud_venta.
     * @example
     * // Create one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.create({
     *   data: {
     *     // ... data to create a Ataud_venta
     *   }
     * })
     * 
    **/
    create<T extends ataud_ventaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaCreateArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataud_ventas.
     *     @param {ataud_ventaCreateManyArgs} args - Arguments to create many Ataud_ventas.
     *     @example
     *     // Create many Ataud_ventas
     *     const ataud_venta = await prisma.ataud_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataud_ventaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataud_venta.
     * @param {ataud_ventaDeleteArgs} args - Arguments to delete one Ataud_venta.
     * @example
     * // Delete one Ataud_venta
     * const Ataud_venta = await prisma.ataud_venta.delete({
     *   where: {
     *     // ... filter to delete one Ataud_venta
     *   }
     * })
     * 
    **/
    delete<T extends ataud_ventaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaDeleteArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataud_venta.
     * @param {ataud_ventaUpdateArgs} args - Arguments to update one Ataud_venta.
     * @example
     * // Update one Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataud_ventaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpdateArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataud_ventas.
     * @param {ataud_ventaDeleteManyArgs} args - Arguments to filter Ataud_ventas to delete.
     * @example
     * // Delete a few Ataud_ventas
     * const { count } = await prisma.ataud_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataud_ventaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataud_ventaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataud_ventas
     * const ataud_venta = await prisma.ataud_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataud_ventaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataud_venta.
     * @param {ataud_ventaUpsertArgs} args - Arguments to update or create a Ataud_venta.
     * @example
     * // Update or create a Ataud_venta
     * const ataud_venta = await prisma.ataud_venta.upsert({
     *   create: {
     *     // ... data to create a Ataud_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataud_venta we want to update
     *   }
     * })
    **/
    upsert<T extends ataud_ventaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataud_ventaUpsertArgs<ExtArgs>>
    ): Prisma__ataud_ventaClient<$Types.GetResult<ataud_ventaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataud_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaCountArgs} args - Arguments to filter Ataud_ventas to count.
     * @example
     * // Count the number of Ataud_ventas
     * const count = await prisma.ataud_venta.count({
     *   where: {
     *     // ... the filter for the Ataud_ventas we want to count
     *   }
     * })
    **/
    count<T extends ataud_ventaCountArgs>(
      args?: Subset<T, ataud_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ataud_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ataud_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ataud_ventaAggregateArgs>(args: Subset<T, Ataud_ventaAggregateArgs>): Prisma.PrismaPromise<GetAtaud_ventaAggregateType<T>>

    /**
     * Group by Ataud_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataud_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataud_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataud_ventaGroupByArgs['orderBy'] }
        : { orderBy?: ataud_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataud_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaud_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataud_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataud_ventaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataud_venta base type for findUnique actions
   */
  export type ataud_ventaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }

  /**
   * ataud_venta findUnique
   */
  export interface ataud_ventaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_ventaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findUniqueOrThrow
   */
  export type ataud_ventaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta base type for findFirst actions
   */
  export type ataud_ventaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }

  /**
   * ataud_venta findFirst
   */
  export interface ataud_ventaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataud_ventaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataud_venta findFirstOrThrow
   */
  export type ataud_ventaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_venta to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataud_ventas.
     */
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }


  /**
   * ataud_venta findMany
   */
  export type ataud_ventaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter, which ataud_ventas to fetch.
     */
    where?: ataud_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataud_ventas to fetch.
     */
    orderBy?: ataud_ventaOrderByWithRelationInput | ataud_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataud_ventas.
     */
    cursor?: ataud_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataud_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataud_ventas.
     */
    skip?: number
    distinct?: Ataud_ventaScalarFieldEnum | Ataud_ventaScalarFieldEnum[]
  }


  /**
   * ataud_venta create
   */
  export type ataud_ventaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The data needed to create a ataud_venta.
     */
    data?: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
  }


  /**
   * ataud_venta createMany
   */
  export type ataud_ventaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataud_ventas.
     */
    data: ataud_ventaCreateManyInput | ataud_ventaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataud_venta update
   */
  export type ataud_ventaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The data needed to update a ataud_venta.
     */
    data: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
    /**
     * Choose, which ataud_venta to update.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta updateMany
   */
  export type ataud_ventaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataud_ventas.
     */
    data: XOR<ataud_ventaUpdateManyMutationInput, ataud_ventaUncheckedUpdateManyInput>
    /**
     * Filter which ataud_ventas to update
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta upsert
   */
  export type ataud_ventaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * The filter to search for the ataud_venta to update in case it exists.
     */
    where: ataud_ventaWhereUniqueInput
    /**
     * In case the ataud_venta found by the `where` argument doesn't exist, create a new ataud_venta with this data.
     */
    create: XOR<ataud_ventaCreateInput, ataud_ventaUncheckedCreateInput>
    /**
     * In case the ataud_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataud_ventaUpdateInput, ataud_ventaUncheckedUpdateInput>
  }


  /**
   * ataud_venta delete
   */
  export type ataud_ventaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
    /**
     * Filter which ataud_venta to delete.
     */
    where: ataud_ventaWhereUniqueInput
  }


  /**
   * ataud_venta deleteMany
   */
  export type ataud_ventaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataud_ventas to delete
     */
    where?: ataud_ventaWhereInput
  }


  /**
   * ataud_venta without action
   */
  export type ataud_ventaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataud_venta
     */
    select?: ataud_ventaSelect<ExtArgs> | null
  }



  /**
   * Model ataudes
   */


  export type AggregateAtaudes = {
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  export type AtaudesAvgAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesSumAggregateOutputType = {
    idataud: number | null
    codigo: number | null
    stock: number | null
  }

  export type AtaudesMinAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesMaxAggregateOutputType = {
    idataud: number | null
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
  }

  export type AtaudesCountAggregateOutputType = {
    idataud: number
    nombre: number
    tipo: number
    medidas: number
    uso: number
    fabricante: number
    codigo: number
    fecha_alta: number
    stock: number
    fecha_reposicion: number
    fecha_baja: number
    observaciones: number
    estado: number
    operador: number
    _all: number
  }


  export type AtaudesAvgAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesSumAggregateInputType = {
    idataud?: true
    codigo?: true
    stock?: true
  }

  export type AtaudesMinAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesMaxAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
  }

  export type AtaudesCountAggregateInputType = {
    idataud?: true
    nombre?: true
    tipo?: true
    medidas?: true
    uso?: true
    fabricante?: true
    codigo?: true
    fecha_alta?: true
    stock?: true
    fecha_reposicion?: true
    fecha_baja?: true
    observaciones?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AtaudesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataudes to aggregate.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ataudes
    **/
    _count?: true | AtaudesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtaudesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtaudesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtaudesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtaudesMaxAggregateInputType
  }

  export type GetAtaudesAggregateType<T extends AtaudesAggregateArgs> = {
        [P in keyof T & keyof AggregateAtaudes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtaudes[P]>
      : GetScalarType<T[P], AggregateAtaudes[P]>
  }




  export type ataudesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ataudesWhereInput
    orderBy?: ataudesOrderByWithAggregationInput | ataudesOrderByWithAggregationInput[]
    by: AtaudesScalarFieldEnum[] | AtaudesScalarFieldEnum
    having?: ataudesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtaudesCountAggregateInputType | true
    _avg?: AtaudesAvgAggregateInputType
    _sum?: AtaudesSumAggregateInputType
    _min?: AtaudesMinAggregateInputType
    _max?: AtaudesMaxAggregateInputType
  }


  export type AtaudesGroupByOutputType = {
    idataud: number
    nombre: string | null
    tipo: string | null
    medidas: string | null
    uso: string | null
    fabricante: string | null
    codigo: number | null
    fecha_alta: Date | null
    stock: number | null
    fecha_reposicion: Date | null
    fecha_baja: Date | null
    observaciones: string | null
    estado: boolean | null
    operador: string | null
    _count: AtaudesCountAggregateOutputType | null
    _avg: AtaudesAvgAggregateOutputType | null
    _sum: AtaudesSumAggregateOutputType | null
    _min: AtaudesMinAggregateOutputType | null
    _max: AtaudesMaxAggregateOutputType | null
  }

  type GetAtaudesGroupByPayload<T extends ataudesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtaudesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtaudesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
            : GetScalarType<T[P], AtaudesGroupByOutputType[P]>
        }
      >
    >


  export type ataudesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idataud?: boolean
    nombre?: boolean
    tipo?: boolean
    medidas?: boolean
    uso?: boolean
    fabricante?: boolean
    codigo?: boolean
    fecha_alta?: boolean
    stock?: boolean
    fecha_reposicion?: boolean
    fecha_baja?: boolean
    observaciones?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["ataudes"]>

  export type ataudesSelectScalar = {
    idataud?: boolean
    nombre?: boolean
    tipo?: boolean
    medidas?: boolean
    uso?: boolean
    fabricante?: boolean
    codigo?: boolean
    fecha_alta?: boolean
    stock?: boolean
    fecha_reposicion?: boolean
    fecha_baja?: boolean
    observaciones?: boolean
    estado?: boolean
    operador?: boolean
  }


  type ataudesGetPayload<S extends boolean | null | undefined | ataudesArgs> = $Types.GetResult<ataudesPayload, S>

  type ataudesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ataudesFindManyArgs, 'select' | 'include'> & {
      select?: AtaudesCountAggregateInputType | true
    }

  export interface ataudesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ataudes'], meta: { name: 'ataudes' } }
    /**
     * Find zero or one Ataudes that matches the filter.
     * @param {ataudesFindUniqueArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ataudesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ataudesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ataudes'> extends True ? Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ataudes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ataudesFindUniqueOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ataudesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ataudesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ataudesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ataudes'> extends True ? Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ataudes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindFirstOrThrowArgs} args - Arguments to find a Ataudes
     * @example
     * // Get one Ataudes
     * const ataudes = await prisma.ataudes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ataudesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ataudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ataudes
     * const ataudes = await prisma.ataudes.findMany()
     * 
     * // Get first 10 Ataudes
     * const ataudes = await prisma.ataudes.findMany({ take: 10 })
     * 
     * // Only select the `idataud`
     * const ataudesWithIdataudOnly = await prisma.ataudes.findMany({ select: { idataud: true } })
     * 
    **/
    findMany<T extends ataudesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ataudes.
     * @param {ataudesCreateArgs} args - Arguments to create a Ataudes.
     * @example
     * // Create one Ataudes
     * const Ataudes = await prisma.ataudes.create({
     *   data: {
     *     // ... data to create a Ataudes
     *   }
     * })
     * 
    **/
    create<T extends ataudesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesCreateArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ataudes.
     *     @param {ataudesCreateManyArgs} args - Arguments to create many Ataudes.
     *     @example
     *     // Create many Ataudes
     *     const ataudes = await prisma.ataudes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ataudesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ataudes.
     * @param {ataudesDeleteArgs} args - Arguments to delete one Ataudes.
     * @example
     * // Delete one Ataudes
     * const Ataudes = await prisma.ataudes.delete({
     *   where: {
     *     // ... filter to delete one Ataudes
     *   }
     * })
     * 
    **/
    delete<T extends ataudesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesDeleteArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ataudes.
     * @param {ataudesUpdateArgs} args - Arguments to update one Ataudes.
     * @example
     * // Update one Ataudes
     * const ataudes = await prisma.ataudes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ataudesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpdateArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ataudes.
     * @param {ataudesDeleteManyArgs} args - Arguments to filter Ataudes to delete.
     * @example
     * // Delete a few Ataudes
     * const { count } = await prisma.ataudes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ataudesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ataudesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ataudes
     * const ataudes = await prisma.ataudes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ataudesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ataudes.
     * @param {ataudesUpsertArgs} args - Arguments to update or create a Ataudes.
     * @example
     * // Update or create a Ataudes
     * const ataudes = await prisma.ataudes.upsert({
     *   create: {
     *     // ... data to create a Ataudes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ataudes we want to update
     *   }
     * })
    **/
    upsert<T extends ataudesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ataudesUpsertArgs<ExtArgs>>
    ): Prisma__ataudesClient<$Types.GetResult<ataudesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesCountArgs} args - Arguments to filter Ataudes to count.
     * @example
     * // Count the number of Ataudes
     * const count = await prisma.ataudes.count({
     *   where: {
     *     // ... the filter for the Ataudes we want to count
     *   }
     * })
    **/
    count<T extends ataudesCountArgs>(
      args?: Subset<T, ataudesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtaudesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtaudesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtaudesAggregateArgs>(args: Subset<T, AtaudesAggregateArgs>): Prisma.PrismaPromise<GetAtaudesAggregateType<T>>

    /**
     * Group by Ataudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ataudesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ataudesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ataudesGroupByArgs['orderBy'] }
        : { orderBy?: ataudesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ataudesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtaudesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ataudes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ataudesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ataudes base type for findUnique actions
   */
  export type ataudesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }

  /**
   * ataudes findUnique
   */
  export interface ataudesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataudesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findUniqueOrThrow
   */
  export type ataudesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes base type for findFirst actions
   */
  export type ataudesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }

  /**
   * ataudes findFirst
   */
  export interface ataudesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ataudesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ataudes findFirstOrThrow
   */
  export type ataudesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ataudes.
     */
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }


  /**
   * ataudes findMany
   */
  export type ataudesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter, which ataudes to fetch.
     */
    where?: ataudesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ataudes to fetch.
     */
    orderBy?: ataudesOrderByWithRelationInput | ataudesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ataudes.
     */
    cursor?: ataudesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ataudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ataudes.
     */
    skip?: number
    distinct?: AtaudesScalarFieldEnum | AtaudesScalarFieldEnum[]
  }


  /**
   * ataudes create
   */
  export type ataudesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The data needed to create a ataudes.
     */
    data?: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
  }


  /**
   * ataudes createMany
   */
  export type ataudesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ataudes.
     */
    data: ataudesCreateManyInput | ataudesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ataudes update
   */
  export type ataudesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The data needed to update a ataudes.
     */
    data: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
    /**
     * Choose, which ataudes to update.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes updateMany
   */
  export type ataudesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ataudes.
     */
    data: XOR<ataudesUpdateManyMutationInput, ataudesUncheckedUpdateManyInput>
    /**
     * Filter which ataudes to update
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes upsert
   */
  export type ataudesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * The filter to search for the ataudes to update in case it exists.
     */
    where: ataudesWhereUniqueInput
    /**
     * In case the ataudes found by the `where` argument doesn't exist, create a new ataudes with this data.
     */
    create: XOR<ataudesCreateInput, ataudesUncheckedCreateInput>
    /**
     * In case the ataudes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ataudesUpdateInput, ataudesUncheckedUpdateInput>
  }


  /**
   * ataudes delete
   */
  export type ataudesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
    /**
     * Filter which ataudes to delete.
     */
    where: ataudesWhereUniqueInput
  }


  /**
   * ataudes deleteMany
   */
  export type ataudesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ataudes to delete
     */
    where?: ataudesWhereInput
  }


  /**
   * ataudes without action
   */
  export type ataudesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ataudes
     */
    select?: ataudesSelect<ExtArgs> | null
  }



  /**
   * Model autos
   */


  export type AggregateAutos = {
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  export type AutosAvgAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosSumAggregateOutputType = {
    kilometros: number | null
    modelo: number | null
    idauto: number | null
  }

  export type AutosMinAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosMaxAggregateOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number | null
    estado: boolean | null
    operador: string | null
  }

  export type AutosCountAggregateOutputType = {
    patente: number
    auto: number
    kilometros: number
    responsable: number
    nro_poliza: number
    empresa: number
    vencimiento: number
    motor: number
    chasis: number
    modelo: number
    cobertura: number
    idauto: number
    estado: number
    operador: number
    _all: number
  }


  export type AutosAvgAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosSumAggregateInputType = {
    kilometros?: true
    modelo?: true
    idauto?: true
  }

  export type AutosMinAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosMaxAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
  }

  export type AutosCountAggregateInputType = {
    patente?: true
    auto?: true
    kilometros?: true
    responsable?: true
    nro_poliza?: true
    empresa?: true
    vencimiento?: true
    motor?: true
    chasis?: true
    modelo?: true
    cobertura?: true
    idauto?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type AutosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos to aggregate.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos
    **/
    _count?: true | AutosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutosMaxAggregateInputType
  }

  export type GetAutosAggregateType<T extends AutosAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos[P]>
      : GetScalarType<T[P], AggregateAutos[P]>
  }




  export type autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autosWhereInput
    orderBy?: autosOrderByWithAggregationInput | autosOrderByWithAggregationInput[]
    by: AutosScalarFieldEnum[] | AutosScalarFieldEnum
    having?: autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutosCountAggregateInputType | true
    _avg?: AutosAvgAggregateInputType
    _sum?: AutosSumAggregateInputType
    _min?: AutosMinAggregateInputType
    _max?: AutosMaxAggregateInputType
  }


  export type AutosGroupByOutputType = {
    patente: string | null
    auto: string | null
    kilometros: number | null
    responsable: string | null
    nro_poliza: string | null
    empresa: string | null
    vencimiento: Date | null
    motor: string | null
    chasis: string | null
    modelo: number | null
    cobertura: string | null
    idauto: number
    estado: boolean | null
    operador: string | null
    _count: AutosCountAggregateOutputType | null
    _avg: AutosAvgAggregateOutputType | null
    _sum: AutosSumAggregateOutputType | null
    _min: AutosMinAggregateOutputType | null
    _max: AutosMaxAggregateOutputType | null
  }

  type GetAutosGroupByPayload<T extends autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutosGroupByOutputType[P]>
            : GetScalarType<T[P], AutosGroupByOutputType[P]>
        }
      >
    >


  export type autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patente?: boolean
    auto?: boolean
    kilometros?: boolean
    responsable?: boolean
    nro_poliza?: boolean
    empresa?: boolean
    vencimiento?: boolean
    motor?: boolean
    chasis?: boolean
    modelo?: boolean
    cobertura?: boolean
    idauto?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos"]>

  export type autosSelectScalar = {
    patente?: boolean
    auto?: boolean
    kilometros?: boolean
    responsable?: boolean
    nro_poliza?: boolean
    empresa?: boolean
    vencimiento?: boolean
    motor?: boolean
    chasis?: boolean
    modelo?: boolean
    cobertura?: boolean
    idauto?: boolean
    estado?: boolean
    operador?: boolean
  }


  type autosGetPayload<S extends boolean | null | undefined | autosArgs> = $Types.GetResult<autosPayload, S>

  type autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autosFindManyArgs, 'select' | 'include'> & {
      select?: AutosCountAggregateInputType | true
    }

  export interface autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos'], meta: { name: 'autos' } }
    /**
     * Find zero or one Autos that matches the filter.
     * @param {autosFindUniqueArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos'> extends True ? Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autosFindUniqueOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos'> extends True ? Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindFirstOrThrowArgs} args - Arguments to find a Autos
     * @example
     * // Get one Autos
     * const autos = await prisma.autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos
     * const autos = await prisma.autos.findMany()
     * 
     * // Get first 10 Autos
     * const autos = await prisma.autos.findMany({ take: 10 })
     * 
     * // Only select the `patente`
     * const autosWithPatenteOnly = await prisma.autos.findMany({ select: { patente: true } })
     * 
    **/
    findMany<T extends autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos.
     * @param {autosCreateArgs} args - Arguments to create a Autos.
     * @example
     * // Create one Autos
     * const Autos = await prisma.autos.create({
     *   data: {
     *     // ... data to create a Autos
     *   }
     * })
     * 
    **/
    create<T extends autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autosCreateArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos.
     *     @param {autosCreateManyArgs} args - Arguments to create many Autos.
     *     @example
     *     // Create many Autos
     *     const autos = await prisma.autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos.
     * @param {autosDeleteArgs} args - Arguments to delete one Autos.
     * @example
     * // Delete one Autos
     * const Autos = await prisma.autos.delete({
     *   where: {
     *     // ... filter to delete one Autos
     *   }
     * })
     * 
    **/
    delete<T extends autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autosDeleteArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos.
     * @param {autosUpdateArgs} args - Arguments to update one Autos.
     * @example
     * // Update one Autos
     * const autos = await prisma.autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpdateArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos.
     * @param {autosDeleteManyArgs} args - Arguments to filter Autos to delete.
     * @example
     * // Delete a few Autos
     * const { count } = await prisma.autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos
     * const autos = await prisma.autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos.
     * @param {autosUpsertArgs} args - Arguments to update or create a Autos.
     * @example
     * // Update or create a Autos
     * const autos = await prisma.autos.upsert({
     *   create: {
     *     // ... data to create a Autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos we want to update
     *   }
     * })
    **/
    upsert<T extends autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autosUpsertArgs<ExtArgs>>
    ): Prisma__autosClient<$Types.GetResult<autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosCountArgs} args - Arguments to filter Autos to count.
     * @example
     * // Count the number of Autos
     * const count = await prisma.autos.count({
     *   where: {
     *     // ... the filter for the Autos we want to count
     *   }
     * })
    **/
    count<T extends autosCountArgs>(
      args?: Subset<T, autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutosAggregateArgs>(args: Subset<T, AutosAggregateArgs>): Prisma.PrismaPromise<GetAutosAggregateType<T>>

    /**
     * Group by Autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autosGroupByArgs['orderBy'] }
        : { orderBy?: autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos base type for findUnique actions
   */
  export type autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }

  /**
   * autos findUnique
   */
  export interface autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findUniqueOrThrow
   */
  export type autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos base type for findFirst actions
   */
  export type autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }

  /**
   * autos findFirst
   */
  export interface autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos findFirstOrThrow
   */
  export type autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos.
     */
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }


  /**
   * autos findMany
   */
  export type autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter, which autos to fetch.
     */
    where?: autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos to fetch.
     */
    orderBy?: autosOrderByWithRelationInput | autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos.
     */
    cursor?: autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos.
     */
    skip?: number
    distinct?: AutosScalarFieldEnum | AutosScalarFieldEnum[]
  }


  /**
   * autos create
   */
  export type autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The data needed to create a autos.
     */
    data?: XOR<autosCreateInput, autosUncheckedCreateInput>
  }


  /**
   * autos createMany
   */
  export type autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos.
     */
    data: autosCreateManyInput | autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos update
   */
  export type autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The data needed to update a autos.
     */
    data: XOR<autosUpdateInput, autosUncheckedUpdateInput>
    /**
     * Choose, which autos to update.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos updateMany
   */
  export type autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos.
     */
    data: XOR<autosUpdateManyMutationInput, autosUncheckedUpdateManyInput>
    /**
     * Filter which autos to update
     */
    where?: autosWhereInput
  }


  /**
   * autos upsert
   */
  export type autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * The filter to search for the autos to update in case it exists.
     */
    where: autosWhereUniqueInput
    /**
     * In case the autos found by the `where` argument doesn't exist, create a new autos with this data.
     */
    create: XOR<autosCreateInput, autosUncheckedCreateInput>
    /**
     * In case the autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autosUpdateInput, autosUncheckedUpdateInput>
  }


  /**
   * autos delete
   */
  export type autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
    /**
     * Filter which autos to delete.
     */
    where: autosWhereUniqueInput
  }


  /**
   * autos deleteMany
   */
  export type autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos to delete
     */
    where?: autosWhereInput
  }


  /**
   * autos without action
   */
  export type autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos
     */
    select?: autosSelect<ExtArgs> | null
  }



  /**
   * Model autos_hoja_ruta
   */


  export type AggregateAutos_hoja_ruta = {
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  export type Autos_hoja_rutaAvgAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaSumAggregateOutputType = {
    idhojaruta: number | null
    idservicio: number | null
    km_salida: number | null
    km_llegada: number | null
  }

  export type Autos_hoja_rutaMinAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaMaxAggregateOutputType = {
    idhojaruta: number | null
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
  }

  export type Autos_hoja_rutaCountAggregateOutputType = {
    idhojaruta: number
    patente: number
    auto: number
    conductor: number
    idservicio: number
    fecha_salida: number
    km_salida: number
    fecha_llegada: number
    km_llegada: number
    fecha_registro: number
    operador: number
    _all: number
  }


  export type Autos_hoja_rutaAvgAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaSumAggregateInputType = {
    idhojaruta?: true
    idservicio?: true
    km_salida?: true
    km_llegada?: true
  }

  export type Autos_hoja_rutaMinAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaMaxAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
  }

  export type Autos_hoja_rutaCountAggregateInputType = {
    idhojaruta?: true
    patente?: true
    auto?: true
    conductor?: true
    idservicio?: true
    fecha_salida?: true
    km_salida?: true
    fecha_llegada?: true
    km_llegada?: true
    fecha_registro?: true
    operador?: true
    _all?: true
  }

  export type Autos_hoja_rutaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_hoja_ruta to aggregate.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_hoja_rutas
    **/
    _count?: true | Autos_hoja_rutaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_hoja_rutaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_hoja_rutaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }

  export type GetAutos_hoja_rutaAggregateType<T extends Autos_hoja_rutaAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_hoja_ruta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
      : GetScalarType<T[P], AggregateAutos_hoja_ruta[P]>
  }




  export type autos_hoja_rutaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_hoja_rutaWhereInput
    orderBy?: autos_hoja_rutaOrderByWithAggregationInput | autos_hoja_rutaOrderByWithAggregationInput[]
    by: Autos_hoja_rutaScalarFieldEnum[] | Autos_hoja_rutaScalarFieldEnum
    having?: autos_hoja_rutaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_hoja_rutaCountAggregateInputType | true
    _avg?: Autos_hoja_rutaAvgAggregateInputType
    _sum?: Autos_hoja_rutaSumAggregateInputType
    _min?: Autos_hoja_rutaMinAggregateInputType
    _max?: Autos_hoja_rutaMaxAggregateInputType
  }


  export type Autos_hoja_rutaGroupByOutputType = {
    idhojaruta: number
    patente: string | null
    auto: string | null
    conductor: string | null
    idservicio: number | null
    fecha_salida: Date | null
    km_salida: number | null
    fecha_llegada: Date | null
    km_llegada: number | null
    fecha_registro: Date | null
    operador: string | null
    _count: Autos_hoja_rutaCountAggregateOutputType | null
    _avg: Autos_hoja_rutaAvgAggregateOutputType | null
    _sum: Autos_hoja_rutaSumAggregateOutputType | null
    _min: Autos_hoja_rutaMinAggregateOutputType | null
    _max: Autos_hoja_rutaMaxAggregateOutputType | null
  }

  type GetAutos_hoja_rutaGroupByPayload<T extends autos_hoja_rutaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_hoja_rutaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_hoja_rutaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_hoja_rutaGroupByOutputType[P]>
        }
      >
    >


  export type autos_hoja_rutaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhojaruta?: boolean
    patente?: boolean
    auto?: boolean
    conductor?: boolean
    idservicio?: boolean
    fecha_salida?: boolean
    km_salida?: boolean
    fecha_llegada?: boolean
    km_llegada?: boolean
    fecha_registro?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos_hoja_ruta"]>

  export type autos_hoja_rutaSelectScalar = {
    idhojaruta?: boolean
    patente?: boolean
    auto?: boolean
    conductor?: boolean
    idservicio?: boolean
    fecha_salida?: boolean
    km_salida?: boolean
    fecha_llegada?: boolean
    km_llegada?: boolean
    fecha_registro?: boolean
    operador?: boolean
  }


  type autos_hoja_rutaGetPayload<S extends boolean | null | undefined | autos_hoja_rutaArgs> = $Types.GetResult<autos_hoja_rutaPayload, S>

  type autos_hoja_rutaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_hoja_rutaFindManyArgs, 'select' | 'include'> & {
      select?: Autos_hoja_rutaCountAggregateInputType | true
    }

  export interface autos_hoja_rutaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_hoja_ruta'], meta: { name: 'autos_hoja_ruta' } }
    /**
     * Find zero or one Autos_hoja_ruta that matches the filter.
     * @param {autos_hoja_rutaFindUniqueArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_hoja_rutaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_hoja_rutaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_hoja_ruta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_hoja_rutaFindUniqueOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_hoja_ruta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_hoja_rutaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_hoja_ruta'> extends True ? Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_hoja_ruta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindFirstOrThrowArgs} args - Arguments to find a Autos_hoja_ruta
     * @example
     * // Get one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_hoja_rutas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany()
     * 
     * // Get first 10 Autos_hoja_rutas
     * const autos_hoja_rutas = await prisma.autos_hoja_ruta.findMany({ take: 10 })
     * 
     * // Only select the `idhojaruta`
     * const autos_hoja_rutaWithIdhojarutaOnly = await prisma.autos_hoja_ruta.findMany({ select: { idhojaruta: true } })
     * 
    **/
    findMany<T extends autos_hoja_rutaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_hoja_ruta.
     * @param {autos_hoja_rutaCreateArgs} args - Arguments to create a Autos_hoja_ruta.
     * @example
     * // Create one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.create({
     *   data: {
     *     // ... data to create a Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    create<T extends autos_hoja_rutaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaCreateArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_hoja_rutas.
     *     @param {autos_hoja_rutaCreateManyArgs} args - Arguments to create many Autos_hoja_rutas.
     *     @example
     *     // Create many Autos_hoja_rutas
     *     const autos_hoja_ruta = await prisma.autos_hoja_ruta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_hoja_rutaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_hoja_ruta.
     * @param {autos_hoja_rutaDeleteArgs} args - Arguments to delete one Autos_hoja_ruta.
     * @example
     * // Delete one Autos_hoja_ruta
     * const Autos_hoja_ruta = await prisma.autos_hoja_ruta.delete({
     *   where: {
     *     // ... filter to delete one Autos_hoja_ruta
     *   }
     * })
     * 
    **/
    delete<T extends autos_hoja_rutaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaDeleteArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpdateArgs} args - Arguments to update one Autos_hoja_ruta.
     * @example
     * // Update one Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_hoja_rutaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpdateArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_hoja_rutas.
     * @param {autos_hoja_rutaDeleteManyArgs} args - Arguments to filter Autos_hoja_rutas to delete.
     * @example
     * // Delete a few Autos_hoja_rutas
     * const { count } = await prisma.autos_hoja_ruta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_hoja_rutaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_hoja_rutaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_hoja_rutas
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_hoja_rutaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_hoja_ruta.
     * @param {autos_hoja_rutaUpsertArgs} args - Arguments to update or create a Autos_hoja_ruta.
     * @example
     * // Update or create a Autos_hoja_ruta
     * const autos_hoja_ruta = await prisma.autos_hoja_ruta.upsert({
     *   create: {
     *     // ... data to create a Autos_hoja_ruta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_hoja_ruta we want to update
     *   }
     * })
    **/
    upsert<T extends autos_hoja_rutaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_hoja_rutaUpsertArgs<ExtArgs>>
    ): Prisma__autos_hoja_rutaClient<$Types.GetResult<autos_hoja_rutaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_hoja_rutas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaCountArgs} args - Arguments to filter Autos_hoja_rutas to count.
     * @example
     * // Count the number of Autos_hoja_rutas
     * const count = await prisma.autos_hoja_ruta.count({
     *   where: {
     *     // ... the filter for the Autos_hoja_rutas we want to count
     *   }
     * })
    **/
    count<T extends autos_hoja_rutaCountArgs>(
      args?: Subset<T, autos_hoja_rutaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_hoja_rutaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_hoja_rutaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_hoja_rutaAggregateArgs>(args: Subset<T, Autos_hoja_rutaAggregateArgs>): Prisma.PrismaPromise<GetAutos_hoja_rutaAggregateType<T>>

    /**
     * Group by Autos_hoja_ruta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_hoja_rutaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_hoja_rutaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_hoja_rutaGroupByArgs['orderBy'] }
        : { orderBy?: autos_hoja_rutaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_hoja_rutaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_hoja_rutaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_hoja_ruta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_hoja_rutaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_hoja_ruta base type for findUnique actions
   */
  export type autos_hoja_rutaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }

  /**
   * autos_hoja_ruta findUnique
   */
  export interface autos_hoja_rutaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_hoja_rutaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findUniqueOrThrow
   */
  export type autos_hoja_rutaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta base type for findFirst actions
   */
  export type autos_hoja_rutaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }

  /**
   * autos_hoja_ruta findFirst
   */
  export interface autos_hoja_rutaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_hoja_rutaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_hoja_ruta findFirstOrThrow
   */
  export type autos_hoja_rutaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_ruta to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_hoja_rutas.
     */
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }


  /**
   * autos_hoja_ruta findMany
   */
  export type autos_hoja_rutaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter, which autos_hoja_rutas to fetch.
     */
    where?: autos_hoja_rutaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_hoja_rutas to fetch.
     */
    orderBy?: autos_hoja_rutaOrderByWithRelationInput | autos_hoja_rutaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_hoja_rutas.
     */
    cursor?: autos_hoja_rutaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_hoja_rutas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_hoja_rutas.
     */
    skip?: number
    distinct?: Autos_hoja_rutaScalarFieldEnum | Autos_hoja_rutaScalarFieldEnum[]
  }


  /**
   * autos_hoja_ruta create
   */
  export type autos_hoja_rutaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_hoja_ruta.
     */
    data?: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
  }


  /**
   * autos_hoja_ruta createMany
   */
  export type autos_hoja_rutaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_hoja_rutas.
     */
    data: autos_hoja_rutaCreateManyInput | autos_hoja_rutaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_hoja_ruta update
   */
  export type autos_hoja_rutaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_hoja_ruta.
     */
    data: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
    /**
     * Choose, which autos_hoja_ruta to update.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta updateMany
   */
  export type autos_hoja_rutaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_hoja_rutas.
     */
    data: XOR<autos_hoja_rutaUpdateManyMutationInput, autos_hoja_rutaUncheckedUpdateManyInput>
    /**
     * Filter which autos_hoja_rutas to update
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta upsert
   */
  export type autos_hoja_rutaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_hoja_ruta to update in case it exists.
     */
    where: autos_hoja_rutaWhereUniqueInput
    /**
     * In case the autos_hoja_ruta found by the `where` argument doesn't exist, create a new autos_hoja_ruta with this data.
     */
    create: XOR<autos_hoja_rutaCreateInput, autos_hoja_rutaUncheckedCreateInput>
    /**
     * In case the autos_hoja_ruta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_hoja_rutaUpdateInput, autos_hoja_rutaUncheckedUpdateInput>
  }


  /**
   * autos_hoja_ruta delete
   */
  export type autos_hoja_rutaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
    /**
     * Filter which autos_hoja_ruta to delete.
     */
    where: autos_hoja_rutaWhereUniqueInput
  }


  /**
   * autos_hoja_ruta deleteMany
   */
  export type autos_hoja_rutaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_hoja_rutas to delete
     */
    where?: autos_hoja_rutaWhereInput
  }


  /**
   * autos_hoja_ruta without action
   */
  export type autos_hoja_rutaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_hoja_ruta
     */
    select?: autos_hoja_rutaSelect<ExtArgs> | null
  }



  /**
   * Model autos_novedades
   */


  export type AggregateAutos_novedades = {
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  export type Autos_novedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type Autos_novedadesMinAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesMaxAggregateOutputType = {
    idnovedad: number | null
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
  }

  export type Autos_novedadesCountAggregateOutputType = {
    idnovedad: number
    patente: number
    fecha: number
    novedad: number
    operador: number
    auto: number
    _all: number
  }


  export type Autos_novedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type Autos_novedadesMinAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesMaxAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
  }

  export type Autos_novedadesCountAggregateInputType = {
    idnovedad?: true
    patente?: true
    fecha?: true
    novedad?: true
    operador?: true
    auto?: true
    _all?: true
  }

  export type Autos_novedadesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_novedades to aggregate.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_novedades
    **/
    _count?: true | Autos_novedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_novedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_novedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_novedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_novedadesMaxAggregateInputType
  }

  export type GetAutos_novedadesAggregateType<T extends Autos_novedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_novedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_novedades[P]>
      : GetScalarType<T[P], AggregateAutos_novedades[P]>
  }




  export type autos_novedadesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_novedadesWhereInput
    orderBy?: autos_novedadesOrderByWithAggregationInput | autos_novedadesOrderByWithAggregationInput[]
    by: Autos_novedadesScalarFieldEnum[] | Autos_novedadesScalarFieldEnum
    having?: autos_novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_novedadesCountAggregateInputType | true
    _avg?: Autos_novedadesAvgAggregateInputType
    _sum?: Autos_novedadesSumAggregateInputType
    _min?: Autos_novedadesMinAggregateInputType
    _max?: Autos_novedadesMaxAggregateInputType
  }


  export type Autos_novedadesGroupByOutputType = {
    idnovedad: number
    patente: string | null
    fecha: Date | null
    novedad: string | null
    operador: string | null
    auto: string | null
    _count: Autos_novedadesCountAggregateOutputType | null
    _avg: Autos_novedadesAvgAggregateOutputType | null
    _sum: Autos_novedadesSumAggregateOutputType | null
    _min: Autos_novedadesMinAggregateOutputType | null
    _max: Autos_novedadesMaxAggregateOutputType | null
  }

  type GetAutos_novedadesGroupByPayload<T extends autos_novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_novedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_novedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_novedadesGroupByOutputType[P]>
        }
      >
    >


  export type autos_novedadesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovedad?: boolean
    patente?: boolean
    fecha?: boolean
    novedad?: boolean
    operador?: boolean
    auto?: boolean
  }, ExtArgs["result"]["autos_novedades"]>

  export type autos_novedadesSelectScalar = {
    idnovedad?: boolean
    patente?: boolean
    fecha?: boolean
    novedad?: boolean
    operador?: boolean
    auto?: boolean
  }


  type autos_novedadesGetPayload<S extends boolean | null | undefined | autos_novedadesArgs> = $Types.GetResult<autos_novedadesPayload, S>

  type autos_novedadesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_novedadesFindManyArgs, 'select' | 'include'> & {
      select?: Autos_novedadesCountAggregateInputType | true
    }

  export interface autos_novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_novedades'], meta: { name: 'autos_novedades' } }
    /**
     * Find zero or one Autos_novedades that matches the filter.
     * @param {autos_novedadesFindUniqueArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_novedadesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_novedadesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_novedadesFindUniqueOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_novedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_novedadesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_novedadesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_novedades'> extends True ? Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindFirstOrThrowArgs} args - Arguments to find a Autos_novedades
     * @example
     * // Get one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_novedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany()
     * 
     * // Get first 10 Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const autos_novedadesWithIdnovedadOnly = await prisma.autos_novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends autos_novedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_novedades.
     * @param {autos_novedadesCreateArgs} args - Arguments to create a Autos_novedades.
     * @example
     * // Create one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.create({
     *   data: {
     *     // ... data to create a Autos_novedades
     *   }
     * })
     * 
    **/
    create<T extends autos_novedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesCreateArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_novedades.
     *     @param {autos_novedadesCreateManyArgs} args - Arguments to create many Autos_novedades.
     *     @example
     *     // Create many Autos_novedades
     *     const autos_novedades = await prisma.autos_novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_novedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_novedades.
     * @param {autos_novedadesDeleteArgs} args - Arguments to delete one Autos_novedades.
     * @example
     * // Delete one Autos_novedades
     * const Autos_novedades = await prisma.autos_novedades.delete({
     *   where: {
     *     // ... filter to delete one Autos_novedades
     *   }
     * })
     * 
    **/
    delete<T extends autos_novedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesDeleteArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_novedades.
     * @param {autos_novedadesUpdateArgs} args - Arguments to update one Autos_novedades.
     * @example
     * // Update one Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_novedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpdateArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_novedades.
     * @param {autos_novedadesDeleteManyArgs} args - Arguments to filter Autos_novedades to delete.
     * @example
     * // Delete a few Autos_novedades
     * const { count } = await prisma.autos_novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_novedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_novedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_novedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_novedades.
     * @param {autos_novedadesUpsertArgs} args - Arguments to update or create a Autos_novedades.
     * @example
     * // Update or create a Autos_novedades
     * const autos_novedades = await prisma.autos_novedades.upsert({
     *   create: {
     *     // ... data to create a Autos_novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_novedades we want to update
     *   }
     * })
    **/
    upsert<T extends autos_novedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_novedadesUpsertArgs<ExtArgs>>
    ): Prisma__autos_novedadesClient<$Types.GetResult<autos_novedadesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesCountArgs} args - Arguments to filter Autos_novedades to count.
     * @example
     * // Count the number of Autos_novedades
     * const count = await prisma.autos_novedades.count({
     *   where: {
     *     // ... the filter for the Autos_novedades we want to count
     *   }
     * })
    **/
    count<T extends autos_novedadesCountArgs>(
      args?: Subset<T, autos_novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_novedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_novedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_novedadesAggregateArgs>(args: Subset<T, Autos_novedadesAggregateArgs>): Prisma.PrismaPromise<GetAutos_novedadesAggregateType<T>>

    /**
     * Group by Autos_novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_novedadesGroupByArgs['orderBy'] }
        : { orderBy?: autos_novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_novedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_novedadesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_novedades base type for findUnique actions
   */
  export type autos_novedadesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }

  /**
   * autos_novedades findUnique
   */
  export interface autos_novedadesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_novedadesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findUniqueOrThrow
   */
  export type autos_novedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades base type for findFirst actions
   */
  export type autos_novedadesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }

  /**
   * autos_novedades findFirst
   */
  export interface autos_novedadesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_novedadesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_novedades findFirstOrThrow
   */
  export type autos_novedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_novedades.
     */
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }


  /**
   * autos_novedades findMany
   */
  export type autos_novedadesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter, which autos_novedades to fetch.
     */
    where?: autos_novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_novedades to fetch.
     */
    orderBy?: autos_novedadesOrderByWithRelationInput | autos_novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_novedades.
     */
    cursor?: autos_novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_novedades.
     */
    skip?: number
    distinct?: Autos_novedadesScalarFieldEnum | Autos_novedadesScalarFieldEnum[]
  }


  /**
   * autos_novedades create
   */
  export type autos_novedadesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_novedades.
     */
    data?: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
  }


  /**
   * autos_novedades createMany
   */
  export type autos_novedadesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_novedades.
     */
    data: autos_novedadesCreateManyInput | autos_novedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_novedades update
   */
  export type autos_novedadesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_novedades.
     */
    data: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
    /**
     * Choose, which autos_novedades to update.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades updateMany
   */
  export type autos_novedadesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_novedades.
     */
    data: XOR<autos_novedadesUpdateManyMutationInput, autos_novedadesUncheckedUpdateManyInput>
    /**
     * Filter which autos_novedades to update
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades upsert
   */
  export type autos_novedadesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_novedades to update in case it exists.
     */
    where: autos_novedadesWhereUniqueInput
    /**
     * In case the autos_novedades found by the `where` argument doesn't exist, create a new autos_novedades with this data.
     */
    create: XOR<autos_novedadesCreateInput, autos_novedadesUncheckedCreateInput>
    /**
     * In case the autos_novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_novedadesUpdateInput, autos_novedadesUncheckedUpdateInput>
  }


  /**
   * autos_novedades delete
   */
  export type autos_novedadesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
    /**
     * Filter which autos_novedades to delete.
     */
    where: autos_novedadesWhereUniqueInput
  }


  /**
   * autos_novedades deleteMany
   */
  export type autos_novedadesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_novedades to delete
     */
    where?: autos_novedadesWhereInput
  }


  /**
   * autos_novedades without action
   */
  export type autos_novedadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_novedades
     */
    select?: autos_novedadesSelect<ExtArgs> | null
  }



  /**
   * Model autos_pago_patente
   */


  export type AggregateAutos_pago_patente = {
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  export type Autos_pago_patenteAvgAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteSumAggregateOutputType = {
    idpago: number | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
  }

  export type Autos_pago_patenteMinAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteMaxAggregateOutputType = {
    idpago: number | null
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
  }

  export type Autos_pago_patenteCountAggregateOutputType = {
    idpago: number
    patente: number
    mes: number
    ano: number
    importe: number
    cod_pago: number
    idauto: number
    operador: number
    _all: number
  }


  export type Autos_pago_patenteAvgAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteSumAggregateInputType = {
    idpago?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
  }

  export type Autos_pago_patenteMinAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteMaxAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
  }

  export type Autos_pago_patenteCountAggregateInputType = {
    idpago?: true
    patente?: true
    mes?: true
    ano?: true
    importe?: true
    cod_pago?: true
    idauto?: true
    operador?: true
    _all?: true
  }

  export type Autos_pago_patenteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_pago_patente to aggregate.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned autos_pago_patentes
    **/
    _count?: true | Autos_pago_patenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Autos_pago_patenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Autos_pago_patenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Autos_pago_patenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Autos_pago_patenteMaxAggregateInputType
  }

  export type GetAutos_pago_patenteAggregateType<T extends Autos_pago_patenteAggregateArgs> = {
        [P in keyof T & keyof AggregateAutos_pago_patente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
      : GetScalarType<T[P], AggregateAutos_pago_patente[P]>
  }




  export type autos_pago_patenteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: autos_pago_patenteWhereInput
    orderBy?: autos_pago_patenteOrderByWithAggregationInput | autos_pago_patenteOrderByWithAggregationInput[]
    by: Autos_pago_patenteScalarFieldEnum[] | Autos_pago_patenteScalarFieldEnum
    having?: autos_pago_patenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Autos_pago_patenteCountAggregateInputType | true
    _avg?: Autos_pago_patenteAvgAggregateInputType
    _sum?: Autos_pago_patenteSumAggregateInputType
    _min?: Autos_pago_patenteMinAggregateInputType
    _max?: Autos_pago_patenteMaxAggregateInputType
  }


  export type Autos_pago_patenteGroupByOutputType = {
    idpago: number
    patente: string | null
    mes: number | null
    ano: number | null
    importe: number | null
    cod_pago: number | null
    idauto: number | null
    operador: string | null
    _count: Autos_pago_patenteCountAggregateOutputType | null
    _avg: Autos_pago_patenteAvgAggregateOutputType | null
    _sum: Autos_pago_patenteSumAggregateOutputType | null
    _min: Autos_pago_patenteMinAggregateOutputType | null
    _max: Autos_pago_patenteMaxAggregateOutputType | null
  }

  type GetAutos_pago_patenteGroupByPayload<T extends autos_pago_patenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Autos_pago_patenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Autos_pago_patenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
            : GetScalarType<T[P], Autos_pago_patenteGroupByOutputType[P]>
        }
      >
    >


  export type autos_pago_patenteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idpago?: boolean
    patente?: boolean
    mes?: boolean
    ano?: boolean
    importe?: boolean
    cod_pago?: boolean
    idauto?: boolean
    operador?: boolean
  }, ExtArgs["result"]["autos_pago_patente"]>

  export type autos_pago_patenteSelectScalar = {
    idpago?: boolean
    patente?: boolean
    mes?: boolean
    ano?: boolean
    importe?: boolean
    cod_pago?: boolean
    idauto?: boolean
    operador?: boolean
  }


  type autos_pago_patenteGetPayload<S extends boolean | null | undefined | autos_pago_patenteArgs> = $Types.GetResult<autos_pago_patentePayload, S>

  type autos_pago_patenteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<autos_pago_patenteFindManyArgs, 'select' | 'include'> & {
      select?: Autos_pago_patenteCountAggregateInputType | true
    }

  export interface autos_pago_patenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['autos_pago_patente'], meta: { name: 'autos_pago_patente' } }
    /**
     * Find zero or one Autos_pago_patente that matches the filter.
     * @param {autos_pago_patenteFindUniqueArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends autos_pago_patenteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, autos_pago_patenteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Autos_pago_patente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {autos_pago_patenteFindUniqueOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Autos_pago_patente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends autos_pago_patenteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'autos_pago_patente'> extends True ? Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Autos_pago_patente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindFirstOrThrowArgs} args - Arguments to find a Autos_pago_patente
     * @example
     * // Get one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Autos_pago_patentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany()
     * 
     * // Get first 10 Autos_pago_patentes
     * const autos_pago_patentes = await prisma.autos_pago_patente.findMany({ take: 10 })
     * 
     * // Only select the `idpago`
     * const autos_pago_patenteWithIdpagoOnly = await prisma.autos_pago_patente.findMany({ select: { idpago: true } })
     * 
    **/
    findMany<T extends autos_pago_patenteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Autos_pago_patente.
     * @param {autos_pago_patenteCreateArgs} args - Arguments to create a Autos_pago_patente.
     * @example
     * // Create one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.create({
     *   data: {
     *     // ... data to create a Autos_pago_patente
     *   }
     * })
     * 
    **/
    create<T extends autos_pago_patenteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteCreateArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Autos_pago_patentes.
     *     @param {autos_pago_patenteCreateManyArgs} args - Arguments to create many Autos_pago_patentes.
     *     @example
     *     // Create many Autos_pago_patentes
     *     const autos_pago_patente = await prisma.autos_pago_patente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends autos_pago_patenteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Autos_pago_patente.
     * @param {autos_pago_patenteDeleteArgs} args - Arguments to delete one Autos_pago_patente.
     * @example
     * // Delete one Autos_pago_patente
     * const Autos_pago_patente = await prisma.autos_pago_patente.delete({
     *   where: {
     *     // ... filter to delete one Autos_pago_patente
     *   }
     * })
     * 
    **/
    delete<T extends autos_pago_patenteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteDeleteArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Autos_pago_patente.
     * @param {autos_pago_patenteUpdateArgs} args - Arguments to update one Autos_pago_patente.
     * @example
     * // Update one Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends autos_pago_patenteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpdateArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Autos_pago_patentes.
     * @param {autos_pago_patenteDeleteManyArgs} args - Arguments to filter Autos_pago_patentes to delete.
     * @example
     * // Delete a few Autos_pago_patentes
     * const { count } = await prisma.autos_pago_patente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends autos_pago_patenteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, autos_pago_patenteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Autos_pago_patentes
     * const autos_pago_patente = await prisma.autos_pago_patente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends autos_pago_patenteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Autos_pago_patente.
     * @param {autos_pago_patenteUpsertArgs} args - Arguments to update or create a Autos_pago_patente.
     * @example
     * // Update or create a Autos_pago_patente
     * const autos_pago_patente = await prisma.autos_pago_patente.upsert({
     *   create: {
     *     // ... data to create a Autos_pago_patente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Autos_pago_patente we want to update
     *   }
     * })
    **/
    upsert<T extends autos_pago_patenteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, autos_pago_patenteUpsertArgs<ExtArgs>>
    ): Prisma__autos_pago_patenteClient<$Types.GetResult<autos_pago_patentePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Autos_pago_patentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteCountArgs} args - Arguments to filter Autos_pago_patentes to count.
     * @example
     * // Count the number of Autos_pago_patentes
     * const count = await prisma.autos_pago_patente.count({
     *   where: {
     *     // ... the filter for the Autos_pago_patentes we want to count
     *   }
     * })
    **/
    count<T extends autos_pago_patenteCountArgs>(
      args?: Subset<T, autos_pago_patenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Autos_pago_patenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Autos_pago_patenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Autos_pago_patenteAggregateArgs>(args: Subset<T, Autos_pago_patenteAggregateArgs>): Prisma.PrismaPromise<GetAutos_pago_patenteAggregateType<T>>

    /**
     * Group by Autos_pago_patente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {autos_pago_patenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends autos_pago_patenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: autos_pago_patenteGroupByArgs['orderBy'] }
        : { orderBy?: autos_pago_patenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, autos_pago_patenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutos_pago_patenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for autos_pago_patente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__autos_pago_patenteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * autos_pago_patente base type for findUnique actions
   */
  export type autos_pago_patenteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }

  /**
   * autos_pago_patente findUnique
   */
  export interface autos_pago_patenteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_pago_patenteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findUniqueOrThrow
   */
  export type autos_pago_patenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente base type for findFirst actions
   */
  export type autos_pago_patenteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }

  /**
   * autos_pago_patente findFirst
   */
  export interface autos_pago_patenteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends autos_pago_patenteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * autos_pago_patente findFirstOrThrow
   */
  export type autos_pago_patenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patente to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of autos_pago_patentes.
     */
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }


  /**
   * autos_pago_patente findMany
   */
  export type autos_pago_patenteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter, which autos_pago_patentes to fetch.
     */
    where?: autos_pago_patenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of autos_pago_patentes to fetch.
     */
    orderBy?: autos_pago_patenteOrderByWithRelationInput | autos_pago_patenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing autos_pago_patentes.
     */
    cursor?: autos_pago_patenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` autos_pago_patentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` autos_pago_patentes.
     */
    skip?: number
    distinct?: Autos_pago_patenteScalarFieldEnum | Autos_pago_patenteScalarFieldEnum[]
  }


  /**
   * autos_pago_patente create
   */
  export type autos_pago_patenteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The data needed to create a autos_pago_patente.
     */
    data?: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
  }


  /**
   * autos_pago_patente createMany
   */
  export type autos_pago_patenteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many autos_pago_patentes.
     */
    data: autos_pago_patenteCreateManyInput | autos_pago_patenteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * autos_pago_patente update
   */
  export type autos_pago_patenteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The data needed to update a autos_pago_patente.
     */
    data: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
    /**
     * Choose, which autos_pago_patente to update.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente updateMany
   */
  export type autos_pago_patenteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update autos_pago_patentes.
     */
    data: XOR<autos_pago_patenteUpdateManyMutationInput, autos_pago_patenteUncheckedUpdateManyInput>
    /**
     * Filter which autos_pago_patentes to update
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente upsert
   */
  export type autos_pago_patenteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * The filter to search for the autos_pago_patente to update in case it exists.
     */
    where: autos_pago_patenteWhereUniqueInput
    /**
     * In case the autos_pago_patente found by the `where` argument doesn't exist, create a new autos_pago_patente with this data.
     */
    create: XOR<autos_pago_patenteCreateInput, autos_pago_patenteUncheckedCreateInput>
    /**
     * In case the autos_pago_patente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<autos_pago_patenteUpdateInput, autos_pago_patenteUncheckedUpdateInput>
  }


  /**
   * autos_pago_patente delete
   */
  export type autos_pago_patenteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
    /**
     * Filter which autos_pago_patente to delete.
     */
    where: autos_pago_patenteWhereUniqueInput
  }


  /**
   * autos_pago_patente deleteMany
   */
  export type autos_pago_patenteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which autos_pago_patentes to delete
     */
    where?: autos_pago_patenteWhereInput
  }


  /**
   * autos_pago_patente without action
   */
  export type autos_pago_patenteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the autos_pago_patente
     */
    select?: autos_pago_patenteSelect<ExtArgs> | null
  }



  /**
   * Model caja_sepelio
   */


  export type AggregateCaja_sepelio = {
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  export type Caja_sepelioAvgAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioSumAggregateOutputType = {
    idcaja: number | null
    monto: number | null
    gastos: number | null
    totalcaja: number | null
    nfactura: number | null
    ptoventa: number | null
  }

  export type Caja_sepelioMinAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioMaxAggregateOutputType = {
    idcaja: number | null
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
  }

  export type Caja_sepelioCountAggregateOutputType = {
    idcaja: number
    operador: number
    detalle: number
    monto: number
    estado: number
    fecha: number
    gastos: number
    totalcaja: number
    empresa: number
    tipofactura: number
    nfactura: number
    ptoventa: number
    concepto: number
    cierre: number
    ultimacarga: number
    _all: number
  }


  export type Caja_sepelioAvgAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioSumAggregateInputType = {
    idcaja?: true
    monto?: true
    gastos?: true
    totalcaja?: true
    nfactura?: true
    ptoventa?: true
  }

  export type Caja_sepelioMinAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioMaxAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
  }

  export type Caja_sepelioCountAggregateInputType = {
    idcaja?: true
    operador?: true
    detalle?: true
    monto?: true
    estado?: true
    fecha?: true
    gastos?: true
    totalcaja?: true
    empresa?: true
    tipofactura?: true
    nfactura?: true
    ptoventa?: true
    concepto?: true
    cierre?: true
    ultimacarga?: true
    _all?: true
  }

  export type Caja_sepelioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sepelio to aggregate.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sepelios
    **/
    _count?: true | Caja_sepelioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_sepelioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_sepelioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_sepelioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_sepelioMaxAggregateInputType
  }

  export type GetCaja_sepelioAggregateType<T extends Caja_sepelioAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sepelio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sepelio[P]>
      : GetScalarType<T[P], AggregateCaja_sepelio[P]>
  }




  export type caja_sepelioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_sepelioWhereInput
    orderBy?: caja_sepelioOrderByWithAggregationInput | caja_sepelioOrderByWithAggregationInput[]
    by: Caja_sepelioScalarFieldEnum[] | Caja_sepelioScalarFieldEnum
    having?: caja_sepelioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_sepelioCountAggregateInputType | true
    _avg?: Caja_sepelioAvgAggregateInputType
    _sum?: Caja_sepelioSumAggregateInputType
    _min?: Caja_sepelioMinAggregateInputType
    _max?: Caja_sepelioMaxAggregateInputType
  }


  export type Caja_sepelioGroupByOutputType = {
    idcaja: number
    operador: string | null
    detalle: string | null
    monto: number | null
    estado: boolean | null
    fecha: Date | null
    gastos: number | null
    totalcaja: number | null
    empresa: string | null
    tipofactura: string | null
    nfactura: number | null
    ptoventa: number | null
    concepto: string | null
    cierre: Date | null
    ultimacarga: Date | null
    _count: Caja_sepelioCountAggregateOutputType | null
    _avg: Caja_sepelioAvgAggregateOutputType | null
    _sum: Caja_sepelioSumAggregateOutputType | null
    _min: Caja_sepelioMinAggregateOutputType | null
    _max: Caja_sepelioMaxAggregateOutputType | null
  }

  type GetCaja_sepelioGroupByPayload<T extends caja_sepelioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_sepelioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_sepelioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_sepelioGroupByOutputType[P]>
        }
      >
    >


  export type caja_sepelioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    operador?: boolean
    detalle?: boolean
    monto?: boolean
    estado?: boolean
    fecha?: boolean
    gastos?: boolean
    totalcaja?: boolean
    empresa?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    ptoventa?: boolean
    concepto?: boolean
    cierre?: boolean
    ultimacarga?: boolean
  }, ExtArgs["result"]["caja_sepelio"]>

  export type caja_sepelioSelectScalar = {
    idcaja?: boolean
    operador?: boolean
    detalle?: boolean
    monto?: boolean
    estado?: boolean
    fecha?: boolean
    gastos?: boolean
    totalcaja?: boolean
    empresa?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    ptoventa?: boolean
    concepto?: boolean
    cierre?: boolean
    ultimacarga?: boolean
  }


  type caja_sepelioGetPayload<S extends boolean | null | undefined | caja_sepelioArgs> = $Types.GetResult<caja_sepelioPayload, S>

  type caja_sepelioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_sepelioFindManyArgs, 'select' | 'include'> & {
      select?: Caja_sepelioCountAggregateInputType | true
    }

  export interface caja_sepelioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_sepelio'], meta: { name: 'caja_sepelio' } }
    /**
     * Find zero or one Caja_sepelio that matches the filter.
     * @param {caja_sepelioFindUniqueArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_sepelioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_sepelioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_sepelio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_sepelioFindUniqueOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_sepelioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_sepelio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_sepelioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_sepelioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sepelio'> extends True ? Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_sepelio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindFirstOrThrowArgs} args - Arguments to find a Caja_sepelio
     * @example
     * // Get one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_sepelioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_sepelios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany()
     * 
     * // Get first 10 Caja_sepelios
     * const caja_sepelios = await prisma.caja_sepelio.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_sepelioWithIdcajaOnly = await prisma.caja_sepelio.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_sepelioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_sepelio.
     * @param {caja_sepelioCreateArgs} args - Arguments to create a Caja_sepelio.
     * @example
     * // Create one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.create({
     *   data: {
     *     // ... data to create a Caja_sepelio
     *   }
     * })
     * 
    **/
    create<T extends caja_sepelioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioCreateArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_sepelios.
     *     @param {caja_sepelioCreateManyArgs} args - Arguments to create many Caja_sepelios.
     *     @example
     *     // Create many Caja_sepelios
     *     const caja_sepelio = await prisma.caja_sepelio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_sepelioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sepelio.
     * @param {caja_sepelioDeleteArgs} args - Arguments to delete one Caja_sepelio.
     * @example
     * // Delete one Caja_sepelio
     * const Caja_sepelio = await prisma.caja_sepelio.delete({
     *   where: {
     *     // ... filter to delete one Caja_sepelio
     *   }
     * })
     * 
    **/
    delete<T extends caja_sepelioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioDeleteArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_sepelio.
     * @param {caja_sepelioUpdateArgs} args - Arguments to update one Caja_sepelio.
     * @example
     * // Update one Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_sepelioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpdateArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_sepelios.
     * @param {caja_sepelioDeleteManyArgs} args - Arguments to filter Caja_sepelios to delete.
     * @example
     * // Delete a few Caja_sepelios
     * const { count } = await prisma.caja_sepelio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_sepelioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_sepelioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sepelios
     * const caja_sepelio = await prisma.caja_sepelio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_sepelioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sepelio.
     * @param {caja_sepelioUpsertArgs} args - Arguments to update or create a Caja_sepelio.
     * @example
     * // Update or create a Caja_sepelio
     * const caja_sepelio = await prisma.caja_sepelio.upsert({
     *   create: {
     *     // ... data to create a Caja_sepelio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sepelio we want to update
     *   }
     * })
    **/
    upsert<T extends caja_sepelioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_sepelioUpsertArgs<ExtArgs>>
    ): Prisma__caja_sepelioClient<$Types.GetResult<caja_sepelioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_sepelios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioCountArgs} args - Arguments to filter Caja_sepelios to count.
     * @example
     * // Count the number of Caja_sepelios
     * const count = await prisma.caja_sepelio.count({
     *   where: {
     *     // ... the filter for the Caja_sepelios we want to count
     *   }
     * })
    **/
    count<T extends caja_sepelioCountArgs>(
      args?: Subset<T, caja_sepelioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_sepelioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_sepelioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_sepelioAggregateArgs>(args: Subset<T, Caja_sepelioAggregateArgs>): Prisma.PrismaPromise<GetCaja_sepelioAggregateType<T>>

    /**
     * Group by Caja_sepelio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_sepelioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_sepelioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_sepelioGroupByArgs['orderBy'] }
        : { orderBy?: caja_sepelioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_sepelioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_sepelioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sepelio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_sepelioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sepelio base type for findUnique actions
   */
  export type caja_sepelioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }

  /**
   * caja_sepelio findUnique
   */
  export interface caja_sepelioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sepelioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findUniqueOrThrow
   */
  export type caja_sepelioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio base type for findFirst actions
   */
  export type caja_sepelioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }

  /**
   * caja_sepelio findFirst
   */
  export interface caja_sepelioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_sepelioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sepelio findFirstOrThrow
   */
  export type caja_sepelioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelio to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sepelios.
     */
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }


  /**
   * caja_sepelio findMany
   */
  export type caja_sepelioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter, which caja_sepelios to fetch.
     */
    where?: caja_sepelioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sepelios to fetch.
     */
    orderBy?: caja_sepelioOrderByWithRelationInput | caja_sepelioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sepelios.
     */
    cursor?: caja_sepelioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sepelios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sepelios.
     */
    skip?: number
    distinct?: Caja_sepelioScalarFieldEnum | Caja_sepelioScalarFieldEnum[]
  }


  /**
   * caja_sepelio create
   */
  export type caja_sepelioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_sepelio.
     */
    data?: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
  }


  /**
   * caja_sepelio createMany
   */
  export type caja_sepelioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_sepelios.
     */
    data: caja_sepelioCreateManyInput | caja_sepelioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_sepelio update
   */
  export type caja_sepelioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_sepelio.
     */
    data: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
    /**
     * Choose, which caja_sepelio to update.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio updateMany
   */
  export type caja_sepelioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_sepelios.
     */
    data: XOR<caja_sepelioUpdateManyMutationInput, caja_sepelioUncheckedUpdateManyInput>
    /**
     * Filter which caja_sepelios to update
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio upsert
   */
  export type caja_sepelioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_sepelio to update in case it exists.
     */
    where: caja_sepelioWhereUniqueInput
    /**
     * In case the caja_sepelio found by the `where` argument doesn't exist, create a new caja_sepelio with this data.
     */
    create: XOR<caja_sepelioCreateInput, caja_sepelioUncheckedCreateInput>
    /**
     * In case the caja_sepelio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_sepelioUpdateInput, caja_sepelioUncheckedUpdateInput>
  }


  /**
   * caja_sepelio delete
   */
  export type caja_sepelioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
    /**
     * Filter which caja_sepelio to delete.
     */
    where: caja_sepelioWhereUniqueInput
  }


  /**
   * caja_sepelio deleteMany
   */
  export type caja_sepelioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sepelios to delete
     */
    where?: caja_sepelioWhereInput
  }


  /**
   * caja_sepelio without action
   */
  export type caja_sepelioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sepelio
     */
    select?: caja_sepelioSelect<ExtArgs> | null
  }



  /**
   * Model conceptos
   */


  export type AggregateConceptos = {
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  export type ConceptosAvgAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosSumAggregateOutputType = {
    idconcepto: number | null
  }

  export type ConceptosMinAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosMaxAggregateOutputType = {
    idconcepto: number | null
    concepto: string | null
    tipo: string | null
  }

  export type ConceptosCountAggregateOutputType = {
    idconcepto: number
    concepto: number
    tipo: number
    _all: number
  }


  export type ConceptosAvgAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosSumAggregateInputType = {
    idconcepto?: true
  }

  export type ConceptosMinAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosMaxAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
  }

  export type ConceptosCountAggregateInputType = {
    idconcepto?: true
    concepto?: true
    tipo?: true
    _all?: true
  }

  export type ConceptosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos to aggregate.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conceptos
    **/
    _count?: true | ConceptosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptosMaxAggregateInputType
  }

  export type GetConceptosAggregateType<T extends ConceptosAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptos[P]>
      : GetScalarType<T[P], AggregateConceptos[P]>
  }




  export type conceptosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: conceptosWhereInput
    orderBy?: conceptosOrderByWithAggregationInput | conceptosOrderByWithAggregationInput[]
    by: ConceptosScalarFieldEnum[] | ConceptosScalarFieldEnum
    having?: conceptosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptosCountAggregateInputType | true
    _avg?: ConceptosAvgAggregateInputType
    _sum?: ConceptosSumAggregateInputType
    _min?: ConceptosMinAggregateInputType
    _max?: ConceptosMaxAggregateInputType
  }


  export type ConceptosGroupByOutputType = {
    idconcepto: number
    concepto: string | null
    tipo: string | null
    _count: ConceptosCountAggregateOutputType | null
    _avg: ConceptosAvgAggregateOutputType | null
    _sum: ConceptosSumAggregateOutputType | null
    _min: ConceptosMinAggregateOutputType | null
    _max: ConceptosMaxAggregateOutputType | null
  }

  type GetConceptosGroupByPayload<T extends conceptosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptosGroupByOutputType[P]>
        }
      >
    >


  export type conceptosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idconcepto?: boolean
    concepto?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["conceptos"]>

  export type conceptosSelectScalar = {
    idconcepto?: boolean
    concepto?: boolean
    tipo?: boolean
  }


  type conceptosGetPayload<S extends boolean | null | undefined | conceptosArgs> = $Types.GetResult<conceptosPayload, S>

  type conceptosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<conceptosFindManyArgs, 'select' | 'include'> & {
      select?: ConceptosCountAggregateInputType | true
    }

  export interface conceptosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conceptos'], meta: { name: 'conceptos' } }
    /**
     * Find zero or one Conceptos that matches the filter.
     * @param {conceptosFindUniqueArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends conceptosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, conceptosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'conceptos'> extends True ? Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Conceptos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {conceptosFindUniqueOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends conceptosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends conceptosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, conceptosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'conceptos'> extends True ? Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Conceptos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindFirstOrThrowArgs} args - Arguments to find a Conceptos
     * @example
     * // Get one Conceptos
     * const conceptos = await prisma.conceptos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends conceptosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Conceptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conceptos
     * const conceptos = await prisma.conceptos.findMany()
     * 
     * // Get first 10 Conceptos
     * const conceptos = await prisma.conceptos.findMany({ take: 10 })
     * 
     * // Only select the `idconcepto`
     * const conceptosWithIdconceptoOnly = await prisma.conceptos.findMany({ select: { idconcepto: true } })
     * 
    **/
    findMany<T extends conceptosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Conceptos.
     * @param {conceptosCreateArgs} args - Arguments to create a Conceptos.
     * @example
     * // Create one Conceptos
     * const Conceptos = await prisma.conceptos.create({
     *   data: {
     *     // ... data to create a Conceptos
     *   }
     * })
     * 
    **/
    create<T extends conceptosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosCreateArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Conceptos.
     *     @param {conceptosCreateManyArgs} args - Arguments to create many Conceptos.
     *     @example
     *     // Create many Conceptos
     *     const conceptos = await prisma.conceptos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends conceptosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conceptos.
     * @param {conceptosDeleteArgs} args - Arguments to delete one Conceptos.
     * @example
     * // Delete one Conceptos
     * const Conceptos = await prisma.conceptos.delete({
     *   where: {
     *     // ... filter to delete one Conceptos
     *   }
     * })
     * 
    **/
    delete<T extends conceptosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosDeleteArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Conceptos.
     * @param {conceptosUpdateArgs} args - Arguments to update one Conceptos.
     * @example
     * // Update one Conceptos
     * const conceptos = await prisma.conceptos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends conceptosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpdateArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Conceptos.
     * @param {conceptosDeleteManyArgs} args - Arguments to filter Conceptos to delete.
     * @example
     * // Delete a few Conceptos
     * const { count } = await prisma.conceptos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends conceptosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, conceptosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conceptos
     * const conceptos = await prisma.conceptos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends conceptosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conceptos.
     * @param {conceptosUpsertArgs} args - Arguments to update or create a Conceptos.
     * @example
     * // Update or create a Conceptos
     * const conceptos = await prisma.conceptos.upsert({
     *   create: {
     *     // ... data to create a Conceptos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conceptos we want to update
     *   }
     * })
    **/
    upsert<T extends conceptosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, conceptosUpsertArgs<ExtArgs>>
    ): Prisma__conceptosClient<$Types.GetResult<conceptosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosCountArgs} args - Arguments to filter Conceptos to count.
     * @example
     * // Count the number of Conceptos
     * const count = await prisma.conceptos.count({
     *   where: {
     *     // ... the filter for the Conceptos we want to count
     *   }
     * })
    **/
    count<T extends conceptosCountArgs>(
      args?: Subset<T, conceptosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptosAggregateArgs>(args: Subset<T, ConceptosAggregateArgs>): Prisma.PrismaPromise<GetConceptosAggregateType<T>>

    /**
     * Group by Conceptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conceptosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conceptosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conceptosGroupByArgs['orderBy'] }
        : { orderBy?: conceptosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conceptosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for conceptos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__conceptosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * conceptos base type for findUnique actions
   */
  export type conceptosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }

  /**
   * conceptos findUnique
   */
  export interface conceptosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findUniqueOrThrow
   */
  export type conceptosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos base type for findFirst actions
   */
  export type conceptosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }

  /**
   * conceptos findFirst
   */
  export interface conceptosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends conceptosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * conceptos findFirstOrThrow
   */
  export type conceptosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conceptos.
     */
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }


  /**
   * conceptos findMany
   */
  export type conceptosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter, which conceptos to fetch.
     */
    where?: conceptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conceptos to fetch.
     */
    orderBy?: conceptosOrderByWithRelationInput | conceptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conceptos.
     */
    cursor?: conceptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conceptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conceptos.
     */
    skip?: number
    distinct?: ConceptosScalarFieldEnum | ConceptosScalarFieldEnum[]
  }


  /**
   * conceptos create
   */
  export type conceptosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The data needed to create a conceptos.
     */
    data?: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
  }


  /**
   * conceptos createMany
   */
  export type conceptosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conceptos.
     */
    data: conceptosCreateManyInput | conceptosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * conceptos update
   */
  export type conceptosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The data needed to update a conceptos.
     */
    data: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
    /**
     * Choose, which conceptos to update.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos updateMany
   */
  export type conceptosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conceptos.
     */
    data: XOR<conceptosUpdateManyMutationInput, conceptosUncheckedUpdateManyInput>
    /**
     * Filter which conceptos to update
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos upsert
   */
  export type conceptosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * The filter to search for the conceptos to update in case it exists.
     */
    where: conceptosWhereUniqueInput
    /**
     * In case the conceptos found by the `where` argument doesn't exist, create a new conceptos with this data.
     */
    create: XOR<conceptosCreateInput, conceptosUncheckedCreateInput>
    /**
     * In case the conceptos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conceptosUpdateInput, conceptosUncheckedUpdateInput>
  }


  /**
   * conceptos delete
   */
  export type conceptosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
    /**
     * Filter which conceptos to delete.
     */
    where: conceptosWhereUniqueInput
  }


  /**
   * conceptos deleteMany
   */
  export type conceptosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which conceptos to delete
     */
    where?: conceptosWhereInput
  }


  /**
   * conceptos without action
   */
  export type conceptosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conceptos
     */
    select?: conceptosSelect<ExtArgs> | null
  }



  /**
   * Model fabricante_ataud
   */


  export type AggregateFabricante_ataud = {
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  export type Fabricante_ataudAvgAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudSumAggregateOutputType = {
    idfabricante: number | null
  }

  export type Fabricante_ataudMinAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudMaxAggregateOutputType = {
    idfabricante: number | null
    fabricante: string | null
  }

  export type Fabricante_ataudCountAggregateOutputType = {
    idfabricante: number
    fabricante: number
    _all: number
  }


  export type Fabricante_ataudAvgAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudSumAggregateInputType = {
    idfabricante?: true
  }

  export type Fabricante_ataudMinAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudMaxAggregateInputType = {
    idfabricante?: true
    fabricante?: true
  }

  export type Fabricante_ataudCountAggregateInputType = {
    idfabricante?: true
    fabricante?: true
    _all?: true
  }

  export type Fabricante_ataudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_ataud to aggregate.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fabricante_atauds
    **/
    _count?: true | Fabricante_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fabricante_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fabricante_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fabricante_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fabricante_ataudMaxAggregateInputType
  }

  export type GetFabricante_ataudAggregateType<T extends Fabricante_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateFabricante_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFabricante_ataud[P]>
      : GetScalarType<T[P], AggregateFabricante_ataud[P]>
  }




  export type fabricante_ataudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fabricante_ataudWhereInput
    orderBy?: fabricante_ataudOrderByWithAggregationInput | fabricante_ataudOrderByWithAggregationInput[]
    by: Fabricante_ataudScalarFieldEnum[] | Fabricante_ataudScalarFieldEnum
    having?: fabricante_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fabricante_ataudCountAggregateInputType | true
    _avg?: Fabricante_ataudAvgAggregateInputType
    _sum?: Fabricante_ataudSumAggregateInputType
    _min?: Fabricante_ataudMinAggregateInputType
    _max?: Fabricante_ataudMaxAggregateInputType
  }


  export type Fabricante_ataudGroupByOutputType = {
    idfabricante: number
    fabricante: string | null
    _count: Fabricante_ataudCountAggregateOutputType | null
    _avg: Fabricante_ataudAvgAggregateOutputType | null
    _sum: Fabricante_ataudSumAggregateOutputType | null
    _min: Fabricante_ataudMinAggregateOutputType | null
    _max: Fabricante_ataudMaxAggregateOutputType | null
  }

  type GetFabricante_ataudGroupByPayload<T extends fabricante_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fabricante_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fabricante_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Fabricante_ataudGroupByOutputType[P]>
        }
      >
    >


  export type fabricante_ataudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idfabricante?: boolean
    fabricante?: boolean
  }, ExtArgs["result"]["fabricante_ataud"]>

  export type fabricante_ataudSelectScalar = {
    idfabricante?: boolean
    fabricante?: boolean
  }


  type fabricante_ataudGetPayload<S extends boolean | null | undefined | fabricante_ataudArgs> = $Types.GetResult<fabricante_ataudPayload, S>

  type fabricante_ataudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fabricante_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Fabricante_ataudCountAggregateInputType | true
    }

  export interface fabricante_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fabricante_ataud'], meta: { name: 'fabricante_ataud' } }
    /**
     * Find zero or one Fabricante_ataud that matches the filter.
     * @param {fabricante_ataudFindUniqueArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fabricante_ataudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fabricante_ataudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fabricante_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fabricante_ataudFindUniqueOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fabricante_ataudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fabricante_ataudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fabricante_ataud'> extends True ? Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fabricante_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindFirstOrThrowArgs} args - Arguments to find a Fabricante_ataud
     * @example
     * // Get one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fabricante_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany()
     * 
     * // Get first 10 Fabricante_atauds
     * const fabricante_atauds = await prisma.fabricante_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idfabricante`
     * const fabricante_ataudWithIdfabricanteOnly = await prisma.fabricante_ataud.findMany({ select: { idfabricante: true } })
     * 
    **/
    findMany<T extends fabricante_ataudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fabricante_ataud.
     * @param {fabricante_ataudCreateArgs} args - Arguments to create a Fabricante_ataud.
     * @example
     * // Create one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.create({
     *   data: {
     *     // ... data to create a Fabricante_ataud
     *   }
     * })
     * 
    **/
    create<T extends fabricante_ataudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudCreateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fabricante_atauds.
     *     @param {fabricante_ataudCreateManyArgs} args - Arguments to create many Fabricante_atauds.
     *     @example
     *     // Create many Fabricante_atauds
     *     const fabricante_ataud = await prisma.fabricante_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fabricante_ataudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fabricante_ataud.
     * @param {fabricante_ataudDeleteArgs} args - Arguments to delete one Fabricante_ataud.
     * @example
     * // Delete one Fabricante_ataud
     * const Fabricante_ataud = await prisma.fabricante_ataud.delete({
     *   where: {
     *     // ... filter to delete one Fabricante_ataud
     *   }
     * })
     * 
    **/
    delete<T extends fabricante_ataudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudDeleteArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fabricante_ataud.
     * @param {fabricante_ataudUpdateArgs} args - Arguments to update one Fabricante_ataud.
     * @example
     * // Update one Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fabricante_ataudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fabricante_atauds.
     * @param {fabricante_ataudDeleteManyArgs} args - Arguments to filter Fabricante_atauds to delete.
     * @example
     * // Delete a few Fabricante_atauds
     * const { count } = await prisma.fabricante_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fabricante_ataudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fabricante_ataudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fabricante_atauds
     * const fabricante_ataud = await prisma.fabricante_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fabricante_ataudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fabricante_ataud.
     * @param {fabricante_ataudUpsertArgs} args - Arguments to update or create a Fabricante_ataud.
     * @example
     * // Update or create a Fabricante_ataud
     * const fabricante_ataud = await prisma.fabricante_ataud.upsert({
     *   create: {
     *     // ... data to create a Fabricante_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fabricante_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends fabricante_ataudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fabricante_ataudUpsertArgs<ExtArgs>>
    ): Prisma__fabricante_ataudClient<$Types.GetResult<fabricante_ataudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fabricante_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudCountArgs} args - Arguments to filter Fabricante_atauds to count.
     * @example
     * // Count the number of Fabricante_atauds
     * const count = await prisma.fabricante_ataud.count({
     *   where: {
     *     // ... the filter for the Fabricante_atauds we want to count
     *   }
     * })
    **/
    count<T extends fabricante_ataudCountArgs>(
      args?: Subset<T, fabricante_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fabricante_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fabricante_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fabricante_ataudAggregateArgs>(args: Subset<T, Fabricante_ataudAggregateArgs>): Prisma.PrismaPromise<GetFabricante_ataudAggregateType<T>>

    /**
     * Group by Fabricante_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fabricante_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fabricante_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fabricante_ataudGroupByArgs['orderBy'] }
        : { orderBy?: fabricante_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fabricante_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFabricante_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fabricante_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fabricante_ataudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fabricante_ataud base type for findUnique actions
   */
  export type fabricante_ataudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }

  /**
   * fabricante_ataud findUnique
   */
  export interface fabricante_ataudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findUniqueOrThrow
   */
  export type fabricante_ataudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud base type for findFirst actions
   */
  export type fabricante_ataudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }

  /**
   * fabricante_ataud findFirst
   */
  export interface fabricante_ataudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fabricante_ataudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fabricante_ataud findFirstOrThrow
   */
  export type fabricante_ataudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_ataud to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fabricante_atauds.
     */
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud findMany
   */
  export type fabricante_ataudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter, which fabricante_atauds to fetch.
     */
    where?: fabricante_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fabricante_atauds to fetch.
     */
    orderBy?: fabricante_ataudOrderByWithRelationInput | fabricante_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fabricante_atauds.
     */
    cursor?: fabricante_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fabricante_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fabricante_atauds.
     */
    skip?: number
    distinct?: Fabricante_ataudScalarFieldEnum | Fabricante_ataudScalarFieldEnum[]
  }


  /**
   * fabricante_ataud create
   */
  export type fabricante_ataudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to create a fabricante_ataud.
     */
    data?: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
  }


  /**
   * fabricante_ataud createMany
   */
  export type fabricante_ataudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fabricante_atauds.
     */
    data: fabricante_ataudCreateManyInput | fabricante_ataudCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * fabricante_ataud update
   */
  export type fabricante_ataudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The data needed to update a fabricante_ataud.
     */
    data: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
    /**
     * Choose, which fabricante_ataud to update.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud updateMany
   */
  export type fabricante_ataudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fabricante_atauds.
     */
    data: XOR<fabricante_ataudUpdateManyMutationInput, fabricante_ataudUncheckedUpdateManyInput>
    /**
     * Filter which fabricante_atauds to update
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud upsert
   */
  export type fabricante_ataudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * The filter to search for the fabricante_ataud to update in case it exists.
     */
    where: fabricante_ataudWhereUniqueInput
    /**
     * In case the fabricante_ataud found by the `where` argument doesn't exist, create a new fabricante_ataud with this data.
     */
    create: XOR<fabricante_ataudCreateInput, fabricante_ataudUncheckedCreateInput>
    /**
     * In case the fabricante_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fabricante_ataudUpdateInput, fabricante_ataudUncheckedUpdateInput>
  }


  /**
   * fabricante_ataud delete
   */
  export type fabricante_ataudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
    /**
     * Filter which fabricante_ataud to delete.
     */
    where: fabricante_ataudWhereUniqueInput
  }


  /**
   * fabricante_ataud deleteMany
   */
  export type fabricante_ataudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fabricante_atauds to delete
     */
    where?: fabricante_ataudWhereInput
  }


  /**
   * fabricante_ataud without action
   */
  export type fabricante_ataudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fabricante_ataud
     */
    select?: fabricante_ataudSelect<ExtArgs> | null
  }



  /**
   * Model gasto_luto
   */


  export type AggregateGasto_luto = {
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  export type Gasto_lutoAvgAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoSumAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    gasto_luto: number | null
    idataud: number | null
  }

  export type Gasto_lutoMinAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoMaxAggregateOutputType = {
    idgastoluto: number | null
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
  }

  export type Gasto_lutoCountAggregateOutputType = {
    idgastoluto: number
    idservicio: number
    contrato: number
    dni_extinto: number
    extinto: number
    gasto_luto: number
    idataud: number
    apellido_ben: number
    nombre_ben: number
    telefono_ben: number
    fecha: number
    operador: number
    parentezco: number
    _all: number
  }


  export type Gasto_lutoAvgAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoSumAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    gasto_luto?: true
    idataud?: true
  }

  export type Gasto_lutoMinAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoMaxAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
  }

  export type Gasto_lutoCountAggregateInputType = {
    idgastoluto?: true
    idservicio?: true
    contrato?: true
    dni_extinto?: true
    extinto?: true
    gasto_luto?: true
    idataud?: true
    apellido_ben?: true
    nombre_ben?: true
    telefono_ben?: true
    fecha?: true
    operador?: true
    parentezco?: true
    _all?: true
  }

  export type Gasto_lutoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gasto_luto to aggregate.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gasto_lutos
    **/
    _count?: true | Gasto_lutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gasto_lutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gasto_lutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gasto_lutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gasto_lutoMaxAggregateInputType
  }

  export type GetGasto_lutoAggregateType<T extends Gasto_lutoAggregateArgs> = {
        [P in keyof T & keyof AggregateGasto_luto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGasto_luto[P]>
      : GetScalarType<T[P], AggregateGasto_luto[P]>
  }




  export type gasto_lutoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gasto_lutoWhereInput
    orderBy?: gasto_lutoOrderByWithAggregationInput | gasto_lutoOrderByWithAggregationInput[]
    by: Gasto_lutoScalarFieldEnum[] | Gasto_lutoScalarFieldEnum
    having?: gasto_lutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gasto_lutoCountAggregateInputType | true
    _avg?: Gasto_lutoAvgAggregateInputType
    _sum?: Gasto_lutoSumAggregateInputType
    _min?: Gasto_lutoMinAggregateInputType
    _max?: Gasto_lutoMaxAggregateInputType
  }


  export type Gasto_lutoGroupByOutputType = {
    idgastoluto: number
    idservicio: number | null
    contrato: number | null
    dni_extinto: number | null
    extinto: string | null
    gasto_luto: number | null
    idataud: number | null
    apellido_ben: string | null
    nombre_ben: string | null
    telefono_ben: string | null
    fecha: string | null
    operador: string | null
    parentezco: string | null
    _count: Gasto_lutoCountAggregateOutputType | null
    _avg: Gasto_lutoAvgAggregateOutputType | null
    _sum: Gasto_lutoSumAggregateOutputType | null
    _min: Gasto_lutoMinAggregateOutputType | null
    _max: Gasto_lutoMaxAggregateOutputType | null
  }

  type GetGasto_lutoGroupByPayload<T extends gasto_lutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gasto_lutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gasto_lutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
            : GetScalarType<T[P], Gasto_lutoGroupByOutputType[P]>
        }
      >
    >


  export type gasto_lutoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastoluto?: boolean
    idservicio?: boolean
    contrato?: boolean
    dni_extinto?: boolean
    extinto?: boolean
    gasto_luto?: boolean
    idataud?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    telefono_ben?: boolean
    fecha?: boolean
    operador?: boolean
    parentezco?: boolean
  }, ExtArgs["result"]["gasto_luto"]>

  export type gasto_lutoSelectScalar = {
    idgastoluto?: boolean
    idservicio?: boolean
    contrato?: boolean
    dni_extinto?: boolean
    extinto?: boolean
    gasto_luto?: boolean
    idataud?: boolean
    apellido_ben?: boolean
    nombre_ben?: boolean
    telefono_ben?: boolean
    fecha?: boolean
    operador?: boolean
    parentezco?: boolean
  }


  type gasto_lutoGetPayload<S extends boolean | null | undefined | gasto_lutoArgs> = $Types.GetResult<gasto_lutoPayload, S>

  type gasto_lutoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gasto_lutoFindManyArgs, 'select' | 'include'> & {
      select?: Gasto_lutoCountAggregateInputType | true
    }

  export interface gasto_lutoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gasto_luto'], meta: { name: 'gasto_luto' } }
    /**
     * Find zero or one Gasto_luto that matches the filter.
     * @param {gasto_lutoFindUniqueArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gasto_lutoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gasto_lutoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gasto_luto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gasto_lutoFindUniqueOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gasto_lutoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gasto_luto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gasto_lutoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gasto_lutoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gasto_luto'> extends True ? Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gasto_luto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindFirstOrThrowArgs} args - Arguments to find a Gasto_luto
     * @example
     * // Get one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gasto_lutoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gasto_lutos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany()
     * 
     * // Get first 10 Gasto_lutos
     * const gasto_lutos = await prisma.gasto_luto.findMany({ take: 10 })
     * 
     * // Only select the `idgastoluto`
     * const gasto_lutoWithIdgastolutoOnly = await prisma.gasto_luto.findMany({ select: { idgastoluto: true } })
     * 
    **/
    findMany<T extends gasto_lutoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gasto_luto.
     * @param {gasto_lutoCreateArgs} args - Arguments to create a Gasto_luto.
     * @example
     * // Create one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.create({
     *   data: {
     *     // ... data to create a Gasto_luto
     *   }
     * })
     * 
    **/
    create<T extends gasto_lutoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoCreateArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gasto_lutos.
     *     @param {gasto_lutoCreateManyArgs} args - Arguments to create many Gasto_lutos.
     *     @example
     *     // Create many Gasto_lutos
     *     const gasto_luto = await prisma.gasto_luto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gasto_lutoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gasto_luto.
     * @param {gasto_lutoDeleteArgs} args - Arguments to delete one Gasto_luto.
     * @example
     * // Delete one Gasto_luto
     * const Gasto_luto = await prisma.gasto_luto.delete({
     *   where: {
     *     // ... filter to delete one Gasto_luto
     *   }
     * })
     * 
    **/
    delete<T extends gasto_lutoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoDeleteArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gasto_luto.
     * @param {gasto_lutoUpdateArgs} args - Arguments to update one Gasto_luto.
     * @example
     * // Update one Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gasto_lutoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpdateArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gasto_lutos.
     * @param {gasto_lutoDeleteManyArgs} args - Arguments to filter Gasto_lutos to delete.
     * @example
     * // Delete a few Gasto_lutos
     * const { count } = await prisma.gasto_luto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gasto_lutoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gasto_lutoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gasto_lutos
     * const gasto_luto = await prisma.gasto_luto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gasto_lutoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gasto_luto.
     * @param {gasto_lutoUpsertArgs} args - Arguments to update or create a Gasto_luto.
     * @example
     * // Update or create a Gasto_luto
     * const gasto_luto = await prisma.gasto_luto.upsert({
     *   create: {
     *     // ... data to create a Gasto_luto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gasto_luto we want to update
     *   }
     * })
    **/
    upsert<T extends gasto_lutoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gasto_lutoUpsertArgs<ExtArgs>>
    ): Prisma__gasto_lutoClient<$Types.GetResult<gasto_lutoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gasto_lutos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoCountArgs} args - Arguments to filter Gasto_lutos to count.
     * @example
     * // Count the number of Gasto_lutos
     * const count = await prisma.gasto_luto.count({
     *   where: {
     *     // ... the filter for the Gasto_lutos we want to count
     *   }
     * })
    **/
    count<T extends gasto_lutoCountArgs>(
      args?: Subset<T, gasto_lutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gasto_lutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gasto_lutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gasto_lutoAggregateArgs>(args: Subset<T, Gasto_lutoAggregateArgs>): Prisma.PrismaPromise<GetGasto_lutoAggregateType<T>>

    /**
     * Group by Gasto_luto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gasto_lutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gasto_lutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gasto_lutoGroupByArgs['orderBy'] }
        : { orderBy?: gasto_lutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gasto_lutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGasto_lutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gasto_luto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gasto_lutoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gasto_luto base type for findUnique actions
   */
  export type gasto_lutoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }

  /**
   * gasto_luto findUnique
   */
  export interface gasto_lutoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gasto_lutoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findUniqueOrThrow
   */
  export type gasto_lutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto base type for findFirst actions
   */
  export type gasto_lutoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }

  /**
   * gasto_luto findFirst
   */
  export interface gasto_lutoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gasto_lutoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gasto_luto findFirstOrThrow
   */
  export type gasto_lutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_luto to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gasto_lutos.
     */
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }


  /**
   * gasto_luto findMany
   */
  export type gasto_lutoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter, which gasto_lutos to fetch.
     */
    where?: gasto_lutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gasto_lutos to fetch.
     */
    orderBy?: gasto_lutoOrderByWithRelationInput | gasto_lutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gasto_lutos.
     */
    cursor?: gasto_lutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gasto_lutos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gasto_lutos.
     */
    skip?: number
    distinct?: Gasto_lutoScalarFieldEnum | Gasto_lutoScalarFieldEnum[]
  }


  /**
   * gasto_luto create
   */
  export type gasto_lutoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The data needed to create a gasto_luto.
     */
    data?: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
  }


  /**
   * gasto_luto createMany
   */
  export type gasto_lutoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gasto_lutos.
     */
    data: gasto_lutoCreateManyInput | gasto_lutoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gasto_luto update
   */
  export type gasto_lutoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The data needed to update a gasto_luto.
     */
    data: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
    /**
     * Choose, which gasto_luto to update.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto updateMany
   */
  export type gasto_lutoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gasto_lutos.
     */
    data: XOR<gasto_lutoUpdateManyMutationInput, gasto_lutoUncheckedUpdateManyInput>
    /**
     * Filter which gasto_lutos to update
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto upsert
   */
  export type gasto_lutoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * The filter to search for the gasto_luto to update in case it exists.
     */
    where: gasto_lutoWhereUniqueInput
    /**
     * In case the gasto_luto found by the `where` argument doesn't exist, create a new gasto_luto with this data.
     */
    create: XOR<gasto_lutoCreateInput, gasto_lutoUncheckedCreateInput>
    /**
     * In case the gasto_luto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gasto_lutoUpdateInput, gasto_lutoUncheckedUpdateInput>
  }


  /**
   * gasto_luto delete
   */
  export type gasto_lutoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
    /**
     * Filter which gasto_luto to delete.
     */
    where: gasto_lutoWhereUniqueInput
  }


  /**
   * gasto_luto deleteMany
   */
  export type gasto_lutoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gasto_lutos to delete
     */
    where?: gasto_lutoWhereInput
  }


  /**
   * gasto_luto without action
   */
  export type gasto_lutoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gasto_luto
     */
    select?: gasto_lutoSelect<ExtArgs> | null
  }



  /**
   * Model gastos_caja
   */


  export type AggregateGastos_caja = {
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  export type Gastos_cajaAvgAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaSumAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    ptoventa: number | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMinAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaMaxAggregateOutputType = {
    idgastos: number | null
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
  }

  export type Gastos_cajaCountAggregateOutputType = {
    idgastos: number
    idcaja: number
    concepto: number
    tipofactura: number
    nfactura: number
    fecha: number
    operadorgestion: number
    operadortramite: number
    ptoventa: number
    porciva: number
    montoiva: number
    retiibb: number
    retggcias: number
    perciva: number
    detalle: number
    mediopago: number
    proveedor: number
    empresa: number
    total: number
    idservicio: number
    _all: number
  }


  export type Gastos_cajaAvgAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaSumAggregateInputType = {
    idgastos?: true
    idcaja?: true
    ptoventa?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMinAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaMaxAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
  }

  export type Gastos_cajaCountAggregateInputType = {
    idgastos?: true
    idcaja?: true
    concepto?: true
    tipofactura?: true
    nfactura?: true
    fecha?: true
    operadorgestion?: true
    operadortramite?: true
    ptoventa?: true
    porciva?: true
    montoiva?: true
    retiibb?: true
    retggcias?: true
    perciva?: true
    detalle?: true
    mediopago?: true
    proveedor?: true
    empresa?: true
    total?: true
    idservicio?: true
    _all?: true
  }

  export type Gastos_cajaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_caja to aggregate.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gastos_cajas
    **/
    _count?: true | Gastos_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gastos_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gastos_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gastos_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gastos_cajaMaxAggregateInputType
  }

  export type GetGastos_cajaAggregateType<T extends Gastos_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateGastos_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGastos_caja[P]>
      : GetScalarType<T[P], AggregateGastos_caja[P]>
  }




  export type gastos_cajaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: gastos_cajaWhereInput
    orderBy?: gastos_cajaOrderByWithAggregationInput | gastos_cajaOrderByWithAggregationInput[]
    by: Gastos_cajaScalarFieldEnum[] | Gastos_cajaScalarFieldEnum
    having?: gastos_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gastos_cajaCountAggregateInputType | true
    _avg?: Gastos_cajaAvgAggregateInputType
    _sum?: Gastos_cajaSumAggregateInputType
    _min?: Gastos_cajaMinAggregateInputType
    _max?: Gastos_cajaMaxAggregateInputType
  }


  export type Gastos_cajaGroupByOutputType = {
    idgastos: number
    idcaja: number | null
    concepto: string | null
    tipofactura: string | null
    nfactura: string | null
    fecha: Date | null
    operadorgestion: string | null
    operadortramite: string | null
    ptoventa: number | null
    porciva: string | null
    montoiva: number | null
    retiibb: number | null
    retggcias: number | null
    perciva: number | null
    detalle: string | null
    mediopago: string | null
    proveedor: string | null
    empresa: string | null
    total: number | null
    idservicio: number | null
    _count: Gastos_cajaCountAggregateOutputType | null
    _avg: Gastos_cajaAvgAggregateOutputType | null
    _sum: Gastos_cajaSumAggregateOutputType | null
    _min: Gastos_cajaMinAggregateOutputType | null
    _max: Gastos_cajaMaxAggregateOutputType | null
  }

  type GetGastos_cajaGroupByPayload<T extends gastos_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gastos_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gastos_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Gastos_cajaGroupByOutputType[P]>
        }
      >
    >


  export type gastos_cajaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }, ExtArgs["result"]["gastos_caja"]>

  export type gastos_cajaSelectScalar = {
    idgastos?: boolean
    idcaja?: boolean
    concepto?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    fecha?: boolean
    operadorgestion?: boolean
    operadortramite?: boolean
    ptoventa?: boolean
    porciva?: boolean
    montoiva?: boolean
    retiibb?: boolean
    retggcias?: boolean
    perciva?: boolean
    detalle?: boolean
    mediopago?: boolean
    proveedor?: boolean
    empresa?: boolean
    total?: boolean
    idservicio?: boolean
  }


  type gastos_cajaGetPayload<S extends boolean | null | undefined | gastos_cajaArgs> = $Types.GetResult<gastos_cajaPayload, S>

  type gastos_cajaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<gastos_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Gastos_cajaCountAggregateInputType | true
    }

  export interface gastos_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gastos_caja'], meta: { name: 'gastos_caja' } }
    /**
     * Find zero or one Gastos_caja that matches the filter.
     * @param {gastos_cajaFindUniqueArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends gastos_cajaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, gastos_cajaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gastos_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {gastos_cajaFindUniqueOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends gastos_cajaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gastos_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends gastos_cajaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, gastos_cajaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gastos_caja'> extends True ? Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gastos_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindFirstOrThrowArgs} args - Arguments to find a Gastos_caja
     * @example
     * // Get one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends gastos_cajaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Gastos_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany()
     * 
     * // Get first 10 Gastos_cajas
     * const gastos_cajas = await prisma.gastos_caja.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const gastos_cajaWithIdgastosOnly = await prisma.gastos_caja.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends gastos_cajaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gastos_caja.
     * @param {gastos_cajaCreateArgs} args - Arguments to create a Gastos_caja.
     * @example
     * // Create one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.create({
     *   data: {
     *     // ... data to create a Gastos_caja
     *   }
     * })
     * 
    **/
    create<T extends gastos_cajaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaCreateArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Gastos_cajas.
     *     @param {gastos_cajaCreateManyArgs} args - Arguments to create many Gastos_cajas.
     *     @example
     *     // Create many Gastos_cajas
     *     const gastos_caja = await prisma.gastos_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends gastos_cajaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gastos_caja.
     * @param {gastos_cajaDeleteArgs} args - Arguments to delete one Gastos_caja.
     * @example
     * // Delete one Gastos_caja
     * const Gastos_caja = await prisma.gastos_caja.delete({
     *   where: {
     *     // ... filter to delete one Gastos_caja
     *   }
     * })
     * 
    **/
    delete<T extends gastos_cajaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaDeleteArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gastos_caja.
     * @param {gastos_cajaUpdateArgs} args - Arguments to update one Gastos_caja.
     * @example
     * // Update one Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends gastos_cajaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpdateArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Gastos_cajas.
     * @param {gastos_cajaDeleteManyArgs} args - Arguments to filter Gastos_cajas to delete.
     * @example
     * // Delete a few Gastos_cajas
     * const { count } = await prisma.gastos_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends gastos_cajaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, gastos_cajaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gastos_cajas
     * const gastos_caja = await prisma.gastos_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends gastos_cajaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gastos_caja.
     * @param {gastos_cajaUpsertArgs} args - Arguments to update or create a Gastos_caja.
     * @example
     * // Update or create a Gastos_caja
     * const gastos_caja = await prisma.gastos_caja.upsert({
     *   create: {
     *     // ... data to create a Gastos_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gastos_caja we want to update
     *   }
     * })
    **/
    upsert<T extends gastos_cajaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, gastos_cajaUpsertArgs<ExtArgs>>
    ): Prisma__gastos_cajaClient<$Types.GetResult<gastos_cajaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Gastos_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaCountArgs} args - Arguments to filter Gastos_cajas to count.
     * @example
     * // Count the number of Gastos_cajas
     * const count = await prisma.gastos_caja.count({
     *   where: {
     *     // ... the filter for the Gastos_cajas we want to count
     *   }
     * })
    **/
    count<T extends gastos_cajaCountArgs>(
      args?: Subset<T, gastos_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gastos_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gastos_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gastos_cajaAggregateArgs>(args: Subset<T, Gastos_cajaAggregateArgs>): Prisma.PrismaPromise<GetGastos_cajaAggregateType<T>>

    /**
     * Group by Gastos_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gastos_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gastos_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gastos_cajaGroupByArgs['orderBy'] }
        : { orderBy?: gastos_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gastos_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGastos_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gastos_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__gastos_cajaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gastos_caja base type for findUnique actions
   */
  export type gastos_cajaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }

  /**
   * gastos_caja findUnique
   */
  export interface gastos_cajaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_cajaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findUniqueOrThrow
   */
  export type gastos_cajaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja base type for findFirst actions
   */
  export type gastos_cajaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }

  /**
   * gastos_caja findFirst
   */
  export interface gastos_cajaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends gastos_cajaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gastos_caja findFirstOrThrow
   */
  export type gastos_cajaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_caja to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gastos_cajas.
     */
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }


  /**
   * gastos_caja findMany
   */
  export type gastos_cajaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter, which gastos_cajas to fetch.
     */
    where?: gastos_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gastos_cajas to fetch.
     */
    orderBy?: gastos_cajaOrderByWithRelationInput | gastos_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gastos_cajas.
     */
    cursor?: gastos_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gastos_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gastos_cajas.
     */
    skip?: number
    distinct?: Gastos_cajaScalarFieldEnum | Gastos_cajaScalarFieldEnum[]
  }


  /**
   * gastos_caja create
   */
  export type gastos_cajaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The data needed to create a gastos_caja.
     */
    data?: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
  }


  /**
   * gastos_caja createMany
   */
  export type gastos_cajaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gastos_cajas.
     */
    data: gastos_cajaCreateManyInput | gastos_cajaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * gastos_caja update
   */
  export type gastos_cajaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The data needed to update a gastos_caja.
     */
    data: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
    /**
     * Choose, which gastos_caja to update.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja updateMany
   */
  export type gastos_cajaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gastos_cajas.
     */
    data: XOR<gastos_cajaUpdateManyMutationInput, gastos_cajaUncheckedUpdateManyInput>
    /**
     * Filter which gastos_cajas to update
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja upsert
   */
  export type gastos_cajaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * The filter to search for the gastos_caja to update in case it exists.
     */
    where: gastos_cajaWhereUniqueInput
    /**
     * In case the gastos_caja found by the `where` argument doesn't exist, create a new gastos_caja with this data.
     */
    create: XOR<gastos_cajaCreateInput, gastos_cajaUncheckedCreateInput>
    /**
     * In case the gastos_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gastos_cajaUpdateInput, gastos_cajaUncheckedUpdateInput>
  }


  /**
   * gastos_caja delete
   */
  export type gastos_cajaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
    /**
     * Filter which gastos_caja to delete.
     */
    where: gastos_cajaWhereUniqueInput
  }


  /**
   * gastos_caja deleteMany
   */
  export type gastos_cajaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which gastos_cajas to delete
     */
    where?: gastos_cajaWhereInput
  }


  /**
   * gastos_caja without action
   */
  export type gastos_cajaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gastos_caja
     */
    select?: gastos_cajaSelect<ExtArgs> | null
  }



  /**
   * Model historial_autos
   */


  export type AggregateHistorial_autos = {
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  export type Historial_autosAvgAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosSumAggregateOutputType = {
    idhistorial: number | null
    idauto: number | null
  }

  export type Historial_autosMinAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosMaxAggregateOutputType = {
    idhistorial: number | null
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
  }

  export type Historial_autosCountAggregateOutputType = {
    idhistorial: number
    patente: number
    idauto: number
    operador: number
    fecha: number
    accion: number
    _all: number
  }


  export type Historial_autosAvgAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosSumAggregateInputType = {
    idhistorial?: true
    idauto?: true
  }

  export type Historial_autosMinAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosMaxAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
  }

  export type Historial_autosCountAggregateInputType = {
    idhistorial?: true
    patente?: true
    idauto?: true
    operador?: true
    fecha?: true
    accion?: true
    _all?: true
  }

  export type Historial_autosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_autos to aggregate.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_autos
    **/
    _count?: true | Historial_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_autosMaxAggregateInputType
  }

  export type GetHistorial_autosAggregateType<T extends Historial_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_autos[P]>
      : GetScalarType<T[P], AggregateHistorial_autos[P]>
  }




  export type historial_autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_autosWhereInput
    orderBy?: historial_autosOrderByWithAggregationInput | historial_autosOrderByWithAggregationInput[]
    by: Historial_autosScalarFieldEnum[] | Historial_autosScalarFieldEnum
    having?: historial_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_autosCountAggregateInputType | true
    _avg?: Historial_autosAvgAggregateInputType
    _sum?: Historial_autosSumAggregateInputType
    _min?: Historial_autosMinAggregateInputType
    _max?: Historial_autosMaxAggregateInputType
  }


  export type Historial_autosGroupByOutputType = {
    idhistorial: number
    patente: string | null
    idauto: number | null
    operador: string | null
    fecha: Date | null
    accion: string | null
    _count: Historial_autosCountAggregateOutputType | null
    _avg: Historial_autosAvgAggregateOutputType | null
    _sum: Historial_autosSumAggregateOutputType | null
    _min: Historial_autosMinAggregateOutputType | null
    _max: Historial_autosMaxAggregateOutputType | null
  }

  type GetHistorial_autosGroupByPayload<T extends historial_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_autosGroupByOutputType[P]>
        }
      >
    >


  export type historial_autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhistorial?: boolean
    patente?: boolean
    idauto?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }, ExtArgs["result"]["historial_autos"]>

  export type historial_autosSelectScalar = {
    idhistorial?: boolean
    patente?: boolean
    idauto?: boolean
    operador?: boolean
    fecha?: boolean
    accion?: boolean
  }


  type historial_autosGetPayload<S extends boolean | null | undefined | historial_autosArgs> = $Types.GetResult<historial_autosPayload, S>

  type historial_autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_autosFindManyArgs, 'select' | 'include'> & {
      select?: Historial_autosCountAggregateInputType | true
    }

  export interface historial_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_autos'], meta: { name: 'historial_autos' } }
    /**
     * Find zero or one Historial_autos that matches the filter.
     * @param {historial_autosFindUniqueArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_autos'> extends True ? Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_autosFindUniqueOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_autos'> extends True ? Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindFirstOrThrowArgs} args - Arguments to find a Historial_autos
     * @example
     * // Get one Historial_autos
     * const historial_autos = await prisma.historial_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany()
     * 
     * // Get first 10 Historial_autos
     * const historial_autos = await prisma.historial_autos.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_autosWithIdhistorialOnly = await prisma.historial_autos.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_autos.
     * @param {historial_autosCreateArgs} args - Arguments to create a Historial_autos.
     * @example
     * // Create one Historial_autos
     * const Historial_autos = await prisma.historial_autos.create({
     *   data: {
     *     // ... data to create a Historial_autos
     *   }
     * })
     * 
    **/
    create<T extends historial_autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosCreateArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_autos.
     *     @param {historial_autosCreateManyArgs} args - Arguments to create many Historial_autos.
     *     @example
     *     // Create many Historial_autos
     *     const historial_autos = await prisma.historial_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_autos.
     * @param {historial_autosDeleteArgs} args - Arguments to delete one Historial_autos.
     * @example
     * // Delete one Historial_autos
     * const Historial_autos = await prisma.historial_autos.delete({
     *   where: {
     *     // ... filter to delete one Historial_autos
     *   }
     * })
     * 
    **/
    delete<T extends historial_autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosDeleteArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_autos.
     * @param {historial_autosUpdateArgs} args - Arguments to update one Historial_autos.
     * @example
     * // Update one Historial_autos
     * const historial_autos = await prisma.historial_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpdateArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_autos.
     * @param {historial_autosDeleteManyArgs} args - Arguments to filter Historial_autos to delete.
     * @example
     * // Delete a few Historial_autos
     * const { count } = await prisma.historial_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_autos
     * const historial_autos = await prisma.historial_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_autos.
     * @param {historial_autosUpsertArgs} args - Arguments to update or create a Historial_autos.
     * @example
     * // Update or create a Historial_autos
     * const historial_autos = await prisma.historial_autos.upsert({
     *   create: {
     *     // ... data to create a Historial_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_autos we want to update
     *   }
     * })
    **/
    upsert<T extends historial_autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_autosUpsertArgs<ExtArgs>>
    ): Prisma__historial_autosClient<$Types.GetResult<historial_autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosCountArgs} args - Arguments to filter Historial_autos to count.
     * @example
     * // Count the number of Historial_autos
     * const count = await prisma.historial_autos.count({
     *   where: {
     *     // ... the filter for the Historial_autos we want to count
     *   }
     * })
    **/
    count<T extends historial_autosCountArgs>(
      args?: Subset<T, historial_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_autosAggregateArgs>(args: Subset<T, Historial_autosAggregateArgs>): Prisma.PrismaPromise<GetHistorial_autosAggregateType<T>>

    /**
     * Group by Historial_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_autosGroupByArgs['orderBy'] }
        : { orderBy?: historial_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_autos base type for findUnique actions
   */
  export type historial_autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }

  /**
   * historial_autos findUnique
   */
  export interface historial_autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findUniqueOrThrow
   */
  export type historial_autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos base type for findFirst actions
   */
  export type historial_autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }

  /**
   * historial_autos findFirst
   */
  export interface historial_autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_autos findFirstOrThrow
   */
  export type historial_autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_autos.
     */
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }


  /**
   * historial_autos findMany
   */
  export type historial_autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter, which historial_autos to fetch.
     */
    where?: historial_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_autos to fetch.
     */
    orderBy?: historial_autosOrderByWithRelationInput | historial_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_autos.
     */
    cursor?: historial_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_autos.
     */
    skip?: number
    distinct?: Historial_autosScalarFieldEnum | Historial_autosScalarFieldEnum[]
  }


  /**
   * historial_autos create
   */
  export type historial_autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_autos.
     */
    data?: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
  }


  /**
   * historial_autos createMany
   */
  export type historial_autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_autos.
     */
    data: historial_autosCreateManyInput | historial_autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_autos update
   */
  export type historial_autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_autos.
     */
    data: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
    /**
     * Choose, which historial_autos to update.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos updateMany
   */
  export type historial_autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_autos.
     */
    data: XOR<historial_autosUpdateManyMutationInput, historial_autosUncheckedUpdateManyInput>
    /**
     * Filter which historial_autos to update
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos upsert
   */
  export type historial_autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_autos to update in case it exists.
     */
    where: historial_autosWhereUniqueInput
    /**
     * In case the historial_autos found by the `where` argument doesn't exist, create a new historial_autos with this data.
     */
    create: XOR<historial_autosCreateInput, historial_autosUncheckedCreateInput>
    /**
     * In case the historial_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_autosUpdateInput, historial_autosUncheckedUpdateInput>
  }


  /**
   * historial_autos delete
   */
  export type historial_autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
    /**
     * Filter which historial_autos to delete.
     */
    where: historial_autosWhereUniqueInput
  }


  /**
   * historial_autos deleteMany
   */
  export type historial_autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_autos to delete
     */
    where?: historial_autosWhereInput
  }


  /**
   * historial_autos without action
   */
  export type historial_autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_autos
     */
    select?: historial_autosSelect<ExtArgs> | null
  }



  /**
   * Model historial_stock_ataud
   */


  export type AggregateHistorial_stock_ataud = {
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  export type Historial_stock_ataudAvgAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudSumAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    stock_anterior: number | null
    stock_nuevo: number | null
  }

  export type Historial_stock_ataudMinAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudMaxAggregateOutputType = {
    idhistorial: number | null
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
  }

  export type Historial_stock_ataudCountAggregateOutputType = {
    idhistorial: number
    idataud: number
    fecha_carga: number
    stock_anterior: number
    stock_nuevo: number
    remito: number
    operador: number
    fecha_recepcion: number
    _all: number
  }


  export type Historial_stock_ataudAvgAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudSumAggregateInputType = {
    idhistorial?: true
    idataud?: true
    stock_anterior?: true
    stock_nuevo?: true
  }

  export type Historial_stock_ataudMinAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudMaxAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
  }

  export type Historial_stock_ataudCountAggregateInputType = {
    idhistorial?: true
    idataud?: true
    fecha_carga?: true
    stock_anterior?: true
    stock_nuevo?: true
    remito?: true
    operador?: true
    fecha_recepcion?: true
    _all?: true
  }

  export type Historial_stock_ataudAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_stock_ataud to aggregate.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historial_stock_atauds
    **/
    _count?: true | Historial_stock_ataudCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Historial_stock_ataudAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Historial_stock_ataudSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Historial_stock_ataudMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Historial_stock_ataudMaxAggregateInputType
  }

  export type GetHistorial_stock_ataudAggregateType<T extends Historial_stock_ataudAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorial_stock_ataud]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
      : GetScalarType<T[P], AggregateHistorial_stock_ataud[P]>
  }




  export type historial_stock_ataudGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: historial_stock_ataudWhereInput
    orderBy?: historial_stock_ataudOrderByWithAggregationInput | historial_stock_ataudOrderByWithAggregationInput[]
    by: Historial_stock_ataudScalarFieldEnum[] | Historial_stock_ataudScalarFieldEnum
    having?: historial_stock_ataudScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Historial_stock_ataudCountAggregateInputType | true
    _avg?: Historial_stock_ataudAvgAggregateInputType
    _sum?: Historial_stock_ataudSumAggregateInputType
    _min?: Historial_stock_ataudMinAggregateInputType
    _max?: Historial_stock_ataudMaxAggregateInputType
  }


  export type Historial_stock_ataudGroupByOutputType = {
    idhistorial: number
    idataud: number | null
    fecha_carga: Date | null
    stock_anterior: number | null
    stock_nuevo: number | null
    remito: string | null
    operador: string | null
    fecha_recepcion: Date | null
    _count: Historial_stock_ataudCountAggregateOutputType | null
    _avg: Historial_stock_ataudAvgAggregateOutputType | null
    _sum: Historial_stock_ataudSumAggregateOutputType | null
    _min: Historial_stock_ataudMinAggregateOutputType | null
    _max: Historial_stock_ataudMaxAggregateOutputType | null
  }

  type GetHistorial_stock_ataudGroupByPayload<T extends historial_stock_ataudGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Historial_stock_ataudGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Historial_stock_ataudGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
            : GetScalarType<T[P], Historial_stock_ataudGroupByOutputType[P]>
        }
      >
    >


  export type historial_stock_ataudSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idhistorial?: boolean
    idataud?: boolean
    fecha_carga?: boolean
    stock_anterior?: boolean
    stock_nuevo?: boolean
    remito?: boolean
    operador?: boolean
    fecha_recepcion?: boolean
  }, ExtArgs["result"]["historial_stock_ataud"]>

  export type historial_stock_ataudSelectScalar = {
    idhistorial?: boolean
    idataud?: boolean
    fecha_carga?: boolean
    stock_anterior?: boolean
    stock_nuevo?: boolean
    remito?: boolean
    operador?: boolean
    fecha_recepcion?: boolean
  }


  type historial_stock_ataudGetPayload<S extends boolean | null | undefined | historial_stock_ataudArgs> = $Types.GetResult<historial_stock_ataudPayload, S>

  type historial_stock_ataudCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<historial_stock_ataudFindManyArgs, 'select' | 'include'> & {
      select?: Historial_stock_ataudCountAggregateInputType | true
    }

  export interface historial_stock_ataudDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historial_stock_ataud'], meta: { name: 'historial_stock_ataud' } }
    /**
     * Find zero or one Historial_stock_ataud that matches the filter.
     * @param {historial_stock_ataudFindUniqueArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends historial_stock_ataudFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, historial_stock_ataudFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Historial_stock_ataud that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {historial_stock_ataudFindUniqueOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Historial_stock_ataud that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends historial_stock_ataudFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'historial_stock_ataud'> extends True ? Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Historial_stock_ataud that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindFirstOrThrowArgs} args - Arguments to find a Historial_stock_ataud
     * @example
     * // Get one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Historial_stock_atauds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany()
     * 
     * // Get first 10 Historial_stock_atauds
     * const historial_stock_atauds = await prisma.historial_stock_ataud.findMany({ take: 10 })
     * 
     * // Only select the `idhistorial`
     * const historial_stock_ataudWithIdhistorialOnly = await prisma.historial_stock_ataud.findMany({ select: { idhistorial: true } })
     * 
    **/
    findMany<T extends historial_stock_ataudFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Historial_stock_ataud.
     * @param {historial_stock_ataudCreateArgs} args - Arguments to create a Historial_stock_ataud.
     * @example
     * // Create one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.create({
     *   data: {
     *     // ... data to create a Historial_stock_ataud
     *   }
     * })
     * 
    **/
    create<T extends historial_stock_ataudCreateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudCreateArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Historial_stock_atauds.
     *     @param {historial_stock_ataudCreateManyArgs} args - Arguments to create many Historial_stock_atauds.
     *     @example
     *     // Create many Historial_stock_atauds
     *     const historial_stock_ataud = await prisma.historial_stock_ataud.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends historial_stock_ataudCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historial_stock_ataud.
     * @param {historial_stock_ataudDeleteArgs} args - Arguments to delete one Historial_stock_ataud.
     * @example
     * // Delete one Historial_stock_ataud
     * const Historial_stock_ataud = await prisma.historial_stock_ataud.delete({
     *   where: {
     *     // ... filter to delete one Historial_stock_ataud
     *   }
     * })
     * 
    **/
    delete<T extends historial_stock_ataudDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudDeleteArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpdateArgs} args - Arguments to update one Historial_stock_ataud.
     * @example
     * // Update one Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends historial_stock_ataudUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpdateArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Historial_stock_atauds.
     * @param {historial_stock_ataudDeleteManyArgs} args - Arguments to filter Historial_stock_atauds to delete.
     * @example
     * // Delete a few Historial_stock_atauds
     * const { count } = await prisma.historial_stock_ataud.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends historial_stock_ataudDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, historial_stock_ataudDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historial_stock_atauds
     * const historial_stock_ataud = await prisma.historial_stock_ataud.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends historial_stock_ataudUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historial_stock_ataud.
     * @param {historial_stock_ataudUpsertArgs} args - Arguments to update or create a Historial_stock_ataud.
     * @example
     * // Update or create a Historial_stock_ataud
     * const historial_stock_ataud = await prisma.historial_stock_ataud.upsert({
     *   create: {
     *     // ... data to create a Historial_stock_ataud
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historial_stock_ataud we want to update
     *   }
     * })
    **/
    upsert<T extends historial_stock_ataudUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, historial_stock_ataudUpsertArgs<ExtArgs>>
    ): Prisma__historial_stock_ataudClient<$Types.GetResult<historial_stock_ataudPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Historial_stock_atauds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudCountArgs} args - Arguments to filter Historial_stock_atauds to count.
     * @example
     * // Count the number of Historial_stock_atauds
     * const count = await prisma.historial_stock_ataud.count({
     *   where: {
     *     // ... the filter for the Historial_stock_atauds we want to count
     *   }
     * })
    **/
    count<T extends historial_stock_ataudCountArgs>(
      args?: Subset<T, historial_stock_ataudCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Historial_stock_ataudCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Historial_stock_ataudAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Historial_stock_ataudAggregateArgs>(args: Subset<T, Historial_stock_ataudAggregateArgs>): Prisma.PrismaPromise<GetHistorial_stock_ataudAggregateType<T>>

    /**
     * Group by Historial_stock_ataud.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historial_stock_ataudGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historial_stock_ataudGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historial_stock_ataudGroupByArgs['orderBy'] }
        : { orderBy?: historial_stock_ataudGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historial_stock_ataudGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorial_stock_ataudGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for historial_stock_ataud.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__historial_stock_ataudClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * historial_stock_ataud base type for findUnique actions
   */
  export type historial_stock_ataudFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }

  /**
   * historial_stock_ataud findUnique
   */
  export interface historial_stock_ataudFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_stock_ataudFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findUniqueOrThrow
   */
  export type historial_stock_ataudFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud base type for findFirst actions
   */
  export type historial_stock_ataudFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }

  /**
   * historial_stock_ataud findFirst
   */
  export interface historial_stock_ataudFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends historial_stock_ataudFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * historial_stock_ataud findFirstOrThrow
   */
  export type historial_stock_ataudFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_ataud to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historial_stock_atauds.
     */
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }


  /**
   * historial_stock_ataud findMany
   */
  export type historial_stock_ataudFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter, which historial_stock_atauds to fetch.
     */
    where?: historial_stock_ataudWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historial_stock_atauds to fetch.
     */
    orderBy?: historial_stock_ataudOrderByWithRelationInput | historial_stock_ataudOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historial_stock_atauds.
     */
    cursor?: historial_stock_ataudWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historial_stock_atauds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historial_stock_atauds.
     */
    skip?: number
    distinct?: Historial_stock_ataudScalarFieldEnum | Historial_stock_ataudScalarFieldEnum[]
  }


  /**
   * historial_stock_ataud create
   */
  export type historial_stock_ataudCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The data needed to create a historial_stock_ataud.
     */
    data?: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
  }


  /**
   * historial_stock_ataud createMany
   */
  export type historial_stock_ataudCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historial_stock_atauds.
     */
    data: historial_stock_ataudCreateManyInput | historial_stock_ataudCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * historial_stock_ataud update
   */
  export type historial_stock_ataudUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The data needed to update a historial_stock_ataud.
     */
    data: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
    /**
     * Choose, which historial_stock_ataud to update.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud updateMany
   */
  export type historial_stock_ataudUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historial_stock_atauds.
     */
    data: XOR<historial_stock_ataudUpdateManyMutationInput, historial_stock_ataudUncheckedUpdateManyInput>
    /**
     * Filter which historial_stock_atauds to update
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud upsert
   */
  export type historial_stock_ataudUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * The filter to search for the historial_stock_ataud to update in case it exists.
     */
    where: historial_stock_ataudWhereUniqueInput
    /**
     * In case the historial_stock_ataud found by the `where` argument doesn't exist, create a new historial_stock_ataud with this data.
     */
    create: XOR<historial_stock_ataudCreateInput, historial_stock_ataudUncheckedCreateInput>
    /**
     * In case the historial_stock_ataud was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historial_stock_ataudUpdateInput, historial_stock_ataudUncheckedUpdateInput>
  }


  /**
   * historial_stock_ataud delete
   */
  export type historial_stock_ataudDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
    /**
     * Filter which historial_stock_ataud to delete.
     */
    where: historial_stock_ataudWhereUniqueInput
  }


  /**
   * historial_stock_ataud deleteMany
   */
  export type historial_stock_ataudDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which historial_stock_atauds to delete
     */
    where?: historial_stock_ataudWhereInput
  }


  /**
   * historial_stock_ataud without action
   */
  export type historial_stock_ataudArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historial_stock_ataud
     */
    select?: historial_stock_ataudSelect<ExtArgs> | null
  }



  /**
   * Model honorarios
   */


  export type AggregateHonorarios = {
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  export type HonorariosAvgAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosSumAggregateOutputType = {
    idtrabajo: number | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMinAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosMaxAggregateOutputType = {
    idtrabajo: number | null
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
  }

  export type HonorariosCountAggregateOutputType = {
    idtrabajo: number
    trabajo: number
    dias_habiles: number
    finde: number
    feriado: number
    _all: number
  }


  export type HonorariosAvgAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosSumAggregateInputType = {
    idtrabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMinAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosMaxAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
  }

  export type HonorariosCountAggregateInputType = {
    idtrabajo?: true
    trabajo?: true
    dias_habiles?: true
    finde?: true
    feriado?: true
    _all?: true
  }

  export type HonorariosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which honorarios to aggregate.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned honorarios
    **/
    _count?: true | HonorariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HonorariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HonorariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HonorariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HonorariosMaxAggregateInputType
  }

  export type GetHonorariosAggregateType<T extends HonorariosAggregateArgs> = {
        [P in keyof T & keyof AggregateHonorarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHonorarios[P]>
      : GetScalarType<T[P], AggregateHonorarios[P]>
  }




  export type honorariosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: honorariosWhereInput
    orderBy?: honorariosOrderByWithAggregationInput | honorariosOrderByWithAggregationInput[]
    by: HonorariosScalarFieldEnum[] | HonorariosScalarFieldEnum
    having?: honorariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HonorariosCountAggregateInputType | true
    _avg?: HonorariosAvgAggregateInputType
    _sum?: HonorariosSumAggregateInputType
    _min?: HonorariosMinAggregateInputType
    _max?: HonorariosMaxAggregateInputType
  }


  export type HonorariosGroupByOutputType = {
    idtrabajo: number
    trabajo: string | null
    dias_habiles: number | null
    finde: number | null
    feriado: number | null
    _count: HonorariosCountAggregateOutputType | null
    _avg: HonorariosAvgAggregateOutputType | null
    _sum: HonorariosSumAggregateOutputType | null
    _min: HonorariosMinAggregateOutputType | null
    _max: HonorariosMaxAggregateOutputType | null
  }

  type GetHonorariosGroupByPayload<T extends honorariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HonorariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HonorariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
            : GetScalarType<T[P], HonorariosGroupByOutputType[P]>
        }
      >
    >


  export type honorariosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtrabajo?: boolean
    trabajo?: boolean
    dias_habiles?: boolean
    finde?: boolean
    feriado?: boolean
  }, ExtArgs["result"]["honorarios"]>

  export type honorariosSelectScalar = {
    idtrabajo?: boolean
    trabajo?: boolean
    dias_habiles?: boolean
    finde?: boolean
    feriado?: boolean
  }


  type honorariosGetPayload<S extends boolean | null | undefined | honorariosArgs> = $Types.GetResult<honorariosPayload, S>

  type honorariosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<honorariosFindManyArgs, 'select' | 'include'> & {
      select?: HonorariosCountAggregateInputType | true
    }

  export interface honorariosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['honorarios'], meta: { name: 'honorarios' } }
    /**
     * Find zero or one Honorarios that matches the filter.
     * @param {honorariosFindUniqueArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends honorariosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, honorariosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'honorarios'> extends True ? Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Honorarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {honorariosFindUniqueOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends honorariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends honorariosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, honorariosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'honorarios'> extends True ? Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Honorarios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindFirstOrThrowArgs} args - Arguments to find a Honorarios
     * @example
     * // Get one Honorarios
     * const honorarios = await prisma.honorarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends honorariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Honorarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Honorarios
     * const honorarios = await prisma.honorarios.findMany()
     * 
     * // Get first 10 Honorarios
     * const honorarios = await prisma.honorarios.findMany({ take: 10 })
     * 
     * // Only select the `idtrabajo`
     * const honorariosWithIdtrabajoOnly = await prisma.honorarios.findMany({ select: { idtrabajo: true } })
     * 
    **/
    findMany<T extends honorariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Honorarios.
     * @param {honorariosCreateArgs} args - Arguments to create a Honorarios.
     * @example
     * // Create one Honorarios
     * const Honorarios = await prisma.honorarios.create({
     *   data: {
     *     // ... data to create a Honorarios
     *   }
     * })
     * 
    **/
    create<T extends honorariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosCreateArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Honorarios.
     *     @param {honorariosCreateManyArgs} args - Arguments to create many Honorarios.
     *     @example
     *     // Create many Honorarios
     *     const honorarios = await prisma.honorarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends honorariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Honorarios.
     * @param {honorariosDeleteArgs} args - Arguments to delete one Honorarios.
     * @example
     * // Delete one Honorarios
     * const Honorarios = await prisma.honorarios.delete({
     *   where: {
     *     // ... filter to delete one Honorarios
     *   }
     * })
     * 
    **/
    delete<T extends honorariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosDeleteArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Honorarios.
     * @param {honorariosUpdateArgs} args - Arguments to update one Honorarios.
     * @example
     * // Update one Honorarios
     * const honorarios = await prisma.honorarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends honorariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpdateArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Honorarios.
     * @param {honorariosDeleteManyArgs} args - Arguments to filter Honorarios to delete.
     * @example
     * // Delete a few Honorarios
     * const { count } = await prisma.honorarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends honorariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, honorariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Honorarios
     * const honorarios = await prisma.honorarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends honorariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Honorarios.
     * @param {honorariosUpsertArgs} args - Arguments to update or create a Honorarios.
     * @example
     * // Update or create a Honorarios
     * const honorarios = await prisma.honorarios.upsert({
     *   create: {
     *     // ... data to create a Honorarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Honorarios we want to update
     *   }
     * })
    **/
    upsert<T extends honorariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, honorariosUpsertArgs<ExtArgs>>
    ): Prisma__honorariosClient<$Types.GetResult<honorariosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosCountArgs} args - Arguments to filter Honorarios to count.
     * @example
     * // Count the number of Honorarios
     * const count = await prisma.honorarios.count({
     *   where: {
     *     // ... the filter for the Honorarios we want to count
     *   }
     * })
    **/
    count<T extends honorariosCountArgs>(
      args?: Subset<T, honorariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HonorariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HonorariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HonorariosAggregateArgs>(args: Subset<T, HonorariosAggregateArgs>): Prisma.PrismaPromise<GetHonorariosAggregateType<T>>

    /**
     * Group by Honorarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {honorariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends honorariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: honorariosGroupByArgs['orderBy'] }
        : { orderBy?: honorariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, honorariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHonorariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for honorarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__honorariosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * honorarios base type for findUnique actions
   */
  export type honorariosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }

  /**
   * honorarios findUnique
   */
  export interface honorariosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends honorariosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findUniqueOrThrow
   */
  export type honorariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios base type for findFirst actions
   */
  export type honorariosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }

  /**
   * honorarios findFirst
   */
  export interface honorariosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends honorariosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * honorarios findFirstOrThrow
   */
  export type honorariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of honorarios.
     */
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }


  /**
   * honorarios findMany
   */
  export type honorariosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter, which honorarios to fetch.
     */
    where?: honorariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of honorarios to fetch.
     */
    orderBy?: honorariosOrderByWithRelationInput | honorariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing honorarios.
     */
    cursor?: honorariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` honorarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` honorarios.
     */
    skip?: number
    distinct?: HonorariosScalarFieldEnum | HonorariosScalarFieldEnum[]
  }


  /**
   * honorarios create
   */
  export type honorariosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The data needed to create a honorarios.
     */
    data?: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
  }


  /**
   * honorarios createMany
   */
  export type honorariosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many honorarios.
     */
    data: honorariosCreateManyInput | honorariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * honorarios update
   */
  export type honorariosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The data needed to update a honorarios.
     */
    data: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
    /**
     * Choose, which honorarios to update.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios updateMany
   */
  export type honorariosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update honorarios.
     */
    data: XOR<honorariosUpdateManyMutationInput, honorariosUncheckedUpdateManyInput>
    /**
     * Filter which honorarios to update
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios upsert
   */
  export type honorariosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * The filter to search for the honorarios to update in case it exists.
     */
    where: honorariosWhereUniqueInput
    /**
     * In case the honorarios found by the `where` argument doesn't exist, create a new honorarios with this data.
     */
    create: XOR<honorariosCreateInput, honorariosUncheckedCreateInput>
    /**
     * In case the honorarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<honorariosUpdateInput, honorariosUncheckedUpdateInput>
  }


  /**
   * honorarios delete
   */
  export type honorariosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
    /**
     * Filter which honorarios to delete.
     */
    where: honorariosWhereUniqueInput
  }


  /**
   * honorarios deleteMany
   */
  export type honorariosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which honorarios to delete
     */
    where?: honorariosWhereInput
  }


  /**
   * honorarios without action
   */
  export type honorariosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the honorarios
     */
    select?: honorariosSelect<ExtArgs> | null
  }



  /**
   * Model ingreso_caja
   */


  export type AggregateIngreso_caja = {
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  export type Ingreso_cajaAvgAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaSumAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    monto: number | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMinAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaMaxAggregateOutputType = {
    idingreso: number | null
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
  }

  export type Ingreso_cajaCountAggregateOutputType = {
    idingreso: number
    idcaja: number
    concepto: number
    monto: number
    operador: number
    fecha: number
    tipofactura: number
    nfactura: number
    empresa: number
    detalle: number
    ptoventa: number
    _all: number
  }


  export type Ingreso_cajaAvgAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    ptoventa?: true
  }

  export type Ingreso_cajaSumAggregateInputType = {
    idingreso?: true
    idcaja?: true
    monto?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMinAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaMaxAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
  }

  export type Ingreso_cajaCountAggregateInputType = {
    idingreso?: true
    idcaja?: true
    concepto?: true
    monto?: true
    operador?: true
    fecha?: true
    tipofactura?: true
    nfactura?: true
    empresa?: true
    detalle?: true
    ptoventa?: true
    _all?: true
  }

  export type Ingreso_cajaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ingreso_caja to aggregate.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ingreso_cajas
    **/
    _count?: true | Ingreso_cajaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ingreso_cajaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ingreso_cajaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ingreso_cajaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ingreso_cajaMaxAggregateInputType
  }

  export type GetIngreso_cajaAggregateType<T extends Ingreso_cajaAggregateArgs> = {
        [P in keyof T & keyof AggregateIngreso_caja]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngreso_caja[P]>
      : GetScalarType<T[P], AggregateIngreso_caja[P]>
  }




  export type ingreso_cajaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ingreso_cajaWhereInput
    orderBy?: ingreso_cajaOrderByWithAggregationInput | ingreso_cajaOrderByWithAggregationInput[]
    by: Ingreso_cajaScalarFieldEnum[] | Ingreso_cajaScalarFieldEnum
    having?: ingreso_cajaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ingreso_cajaCountAggregateInputType | true
    _avg?: Ingreso_cajaAvgAggregateInputType
    _sum?: Ingreso_cajaSumAggregateInputType
    _min?: Ingreso_cajaMinAggregateInputType
    _max?: Ingreso_cajaMaxAggregateInputType
  }


  export type Ingreso_cajaGroupByOutputType = {
    idingreso: number
    idcaja: number | null
    concepto: string | null
    monto: number | null
    operador: string | null
    fecha: Date | null
    tipofactura: string | null
    nfactura: string | null
    empresa: string | null
    detalle: string | null
    ptoventa: number | null
    _count: Ingreso_cajaCountAggregateOutputType | null
    _avg: Ingreso_cajaAvgAggregateOutputType | null
    _sum: Ingreso_cajaSumAggregateOutputType | null
    _min: Ingreso_cajaMinAggregateOutputType | null
    _max: Ingreso_cajaMaxAggregateOutputType | null
  }

  type GetIngreso_cajaGroupByPayload<T extends ingreso_cajaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ingreso_cajaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ingreso_cajaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
            : GetScalarType<T[P], Ingreso_cajaGroupByOutputType[P]>
        }
      >
    >


  export type ingreso_cajaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idingreso?: boolean
    idcaja?: boolean
    concepto?: boolean
    monto?: boolean
    operador?: boolean
    fecha?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    empresa?: boolean
    detalle?: boolean
    ptoventa?: boolean
  }, ExtArgs["result"]["ingreso_caja"]>

  export type ingreso_cajaSelectScalar = {
    idingreso?: boolean
    idcaja?: boolean
    concepto?: boolean
    monto?: boolean
    operador?: boolean
    fecha?: boolean
    tipofactura?: boolean
    nfactura?: boolean
    empresa?: boolean
    detalle?: boolean
    ptoventa?: boolean
  }


  type ingreso_cajaGetPayload<S extends boolean | null | undefined | ingreso_cajaArgs> = $Types.GetResult<ingreso_cajaPayload, S>

  type ingreso_cajaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ingreso_cajaFindManyArgs, 'select' | 'include'> & {
      select?: Ingreso_cajaCountAggregateInputType | true
    }

  export interface ingreso_cajaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ingreso_caja'], meta: { name: 'ingreso_caja' } }
    /**
     * Find zero or one Ingreso_caja that matches the filter.
     * @param {ingreso_cajaFindUniqueArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ingreso_cajaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ingreso_cajaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ingreso_caja that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ingreso_cajaFindUniqueOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ingreso_caja that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ingreso_cajaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ingreso_cajaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ingreso_caja'> extends True ? Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ingreso_caja that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindFirstOrThrowArgs} args - Arguments to find a Ingreso_caja
     * @example
     * // Get one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ingreso_cajaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ingreso_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany()
     * 
     * // Get first 10 Ingreso_cajas
     * const ingreso_cajas = await prisma.ingreso_caja.findMany({ take: 10 })
     * 
     * // Only select the `idingreso`
     * const ingreso_cajaWithIdingresoOnly = await prisma.ingreso_caja.findMany({ select: { idingreso: true } })
     * 
    **/
    findMany<T extends ingreso_cajaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ingreso_caja.
     * @param {ingreso_cajaCreateArgs} args - Arguments to create a Ingreso_caja.
     * @example
     * // Create one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.create({
     *   data: {
     *     // ... data to create a Ingreso_caja
     *   }
     * })
     * 
    **/
    create<T extends ingreso_cajaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaCreateArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ingreso_cajas.
     *     @param {ingreso_cajaCreateManyArgs} args - Arguments to create many Ingreso_cajas.
     *     @example
     *     // Create many Ingreso_cajas
     *     const ingreso_caja = await prisma.ingreso_caja.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ingreso_cajaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingreso_caja.
     * @param {ingreso_cajaDeleteArgs} args - Arguments to delete one Ingreso_caja.
     * @example
     * // Delete one Ingreso_caja
     * const Ingreso_caja = await prisma.ingreso_caja.delete({
     *   where: {
     *     // ... filter to delete one Ingreso_caja
     *   }
     * })
     * 
    **/
    delete<T extends ingreso_cajaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaDeleteArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ingreso_caja.
     * @param {ingreso_cajaUpdateArgs} args - Arguments to update one Ingreso_caja.
     * @example
     * // Update one Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ingreso_cajaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpdateArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ingreso_cajas.
     * @param {ingreso_cajaDeleteManyArgs} args - Arguments to filter Ingreso_cajas to delete.
     * @example
     * // Delete a few Ingreso_cajas
     * const { count } = await prisma.ingreso_caja.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ingreso_cajaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ingreso_cajaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingreso_cajas
     * const ingreso_caja = await prisma.ingreso_caja.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ingreso_cajaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingreso_caja.
     * @param {ingreso_cajaUpsertArgs} args - Arguments to update or create a Ingreso_caja.
     * @example
     * // Update or create a Ingreso_caja
     * const ingreso_caja = await prisma.ingreso_caja.upsert({
     *   create: {
     *     // ... data to create a Ingreso_caja
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingreso_caja we want to update
     *   }
     * })
    **/
    upsert<T extends ingreso_cajaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ingreso_cajaUpsertArgs<ExtArgs>>
    ): Prisma__ingreso_cajaClient<$Types.GetResult<ingreso_cajaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ingreso_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaCountArgs} args - Arguments to filter Ingreso_cajas to count.
     * @example
     * // Count the number of Ingreso_cajas
     * const count = await prisma.ingreso_caja.count({
     *   where: {
     *     // ... the filter for the Ingreso_cajas we want to count
     *   }
     * })
    **/
    count<T extends ingreso_cajaCountArgs>(
      args?: Subset<T, ingreso_cajaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ingreso_cajaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ingreso_cajaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ingreso_cajaAggregateArgs>(args: Subset<T, Ingreso_cajaAggregateArgs>): Prisma.PrismaPromise<GetIngreso_cajaAggregateType<T>>

    /**
     * Group by Ingreso_caja.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ingreso_cajaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ingreso_cajaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ingreso_cajaGroupByArgs['orderBy'] }
        : { orderBy?: ingreso_cajaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ingreso_cajaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngreso_cajaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ingreso_caja.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ingreso_cajaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ingreso_caja base type for findUnique actions
   */
  export type ingreso_cajaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }

  /**
   * ingreso_caja findUnique
   */
  export interface ingreso_cajaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ingreso_cajaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findUniqueOrThrow
   */
  export type ingreso_cajaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja base type for findFirst actions
   */
  export type ingreso_cajaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }

  /**
   * ingreso_caja findFirst
   */
  export interface ingreso_cajaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ingreso_cajaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ingreso_caja findFirstOrThrow
   */
  export type ingreso_cajaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_caja to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ingreso_cajas.
     */
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }


  /**
   * ingreso_caja findMany
   */
  export type ingreso_cajaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter, which ingreso_cajas to fetch.
     */
    where?: ingreso_cajaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ingreso_cajas to fetch.
     */
    orderBy?: ingreso_cajaOrderByWithRelationInput | ingreso_cajaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ingreso_cajas.
     */
    cursor?: ingreso_cajaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ingreso_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ingreso_cajas.
     */
    skip?: number
    distinct?: Ingreso_cajaScalarFieldEnum | Ingreso_cajaScalarFieldEnum[]
  }


  /**
   * ingreso_caja create
   */
  export type ingreso_cajaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The data needed to create a ingreso_caja.
     */
    data?: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
  }


  /**
   * ingreso_caja createMany
   */
  export type ingreso_cajaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ingreso_cajas.
     */
    data: ingreso_cajaCreateManyInput | ingreso_cajaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ingreso_caja update
   */
  export type ingreso_cajaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The data needed to update a ingreso_caja.
     */
    data: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
    /**
     * Choose, which ingreso_caja to update.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja updateMany
   */
  export type ingreso_cajaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ingreso_cajas.
     */
    data: XOR<ingreso_cajaUpdateManyMutationInput, ingreso_cajaUncheckedUpdateManyInput>
    /**
     * Filter which ingreso_cajas to update
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja upsert
   */
  export type ingreso_cajaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * The filter to search for the ingreso_caja to update in case it exists.
     */
    where: ingreso_cajaWhereUniqueInput
    /**
     * In case the ingreso_caja found by the `where` argument doesn't exist, create a new ingreso_caja with this data.
     */
    create: XOR<ingreso_cajaCreateInput, ingreso_cajaUncheckedCreateInput>
    /**
     * In case the ingreso_caja was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ingreso_cajaUpdateInput, ingreso_cajaUncheckedUpdateInput>
  }


  /**
   * ingreso_caja delete
   */
  export type ingreso_cajaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
    /**
     * Filter which ingreso_caja to delete.
     */
    where: ingreso_cajaWhereUniqueInput
  }


  /**
   * ingreso_caja deleteMany
   */
  export type ingreso_cajaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ingreso_cajas to delete
     */
    where?: ingreso_cajaWhereInput
  }


  /**
   * ingreso_caja without action
   */
  export type ingreso_cajaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ingreso_caja
     */
    select?: ingreso_cajaSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_autos
   */


  export type AggregateLegajo_virtual_autos = {
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_autosAvgAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosSumAggregateOutputType = {
    idlegajo: number | null
  }

  export type Legajo_virtual_autosMinAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosMaxAggregateOutputType = {
    idlegajo: number | null
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
  }

  export type Legajo_virtual_autosCountAggregateOutputType = {
    idlegajo: number
    patente: number
    archivo: number
    fecha_subida: number
    _all: number
  }


  export type Legajo_virtual_autosAvgAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosSumAggregateInputType = {
    idlegajo?: true
  }

  export type Legajo_virtual_autosMinAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosMaxAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
  }

  export type Legajo_virtual_autosCountAggregateInputType = {
    idlegajo?: true
    patente?: true
    archivo?: true
    fecha_subida?: true
    _all?: true
  }

  export type Legajo_virtual_autosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_autos to aggregate.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_autos
    **/
    _count?: true | Legajo_virtual_autosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_autosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_autosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }

  export type GetLegajo_virtual_autosAggregateType<T extends Legajo_virtual_autosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_autos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_autos[P]>
  }




  export type legajo_virtual_autosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_autosWhereInput
    orderBy?: legajo_virtual_autosOrderByWithAggregationInput | legajo_virtual_autosOrderByWithAggregationInput[]
    by: Legajo_virtual_autosScalarFieldEnum[] | Legajo_virtual_autosScalarFieldEnum
    having?: legajo_virtual_autosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_autosCountAggregateInputType | true
    _avg?: Legajo_virtual_autosAvgAggregateInputType
    _sum?: Legajo_virtual_autosSumAggregateInputType
    _min?: Legajo_virtual_autosMinAggregateInputType
    _max?: Legajo_virtual_autosMaxAggregateInputType
  }


  export type Legajo_virtual_autosGroupByOutputType = {
    idlegajo: number
    patente: string | null
    archivo: string | null
    fecha_subida: Date | null
    _count: Legajo_virtual_autosCountAggregateOutputType | null
    _avg: Legajo_virtual_autosAvgAggregateOutputType | null
    _sum: Legajo_virtual_autosSumAggregateOutputType | null
    _min: Legajo_virtual_autosMinAggregateOutputType | null
    _max: Legajo_virtual_autosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_autosGroupByPayload<T extends legajo_virtual_autosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_autosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_autosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_autosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_autosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    patente?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }, ExtArgs["result"]["legajo_virtual_autos"]>

  export type legajo_virtual_autosSelectScalar = {
    idlegajo?: boolean
    patente?: boolean
    archivo?: boolean
    fecha_subida?: boolean
  }


  type legajo_virtual_autosGetPayload<S extends boolean | null | undefined | legajo_virtual_autosArgs> = $Types.GetResult<legajo_virtual_autosPayload, S>

  type legajo_virtual_autosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_autosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_autosCountAggregateInputType | true
    }

  export interface legajo_virtual_autosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_autos'], meta: { name: 'legajo_virtual_autos' } }
    /**
     * Find zero or one Legajo_virtual_autos that matches the filter.
     * @param {legajo_virtual_autosFindUniqueArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_autosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_autosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_autos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_autosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_autosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_autos'> extends True ? Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_autos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_autos
     * @example
     * // Get one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_autos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany()
     * 
     * // Get first 10 Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_autosWithIdlegajoOnly = await prisma.legajo_virtual_autos.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_autosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_autos.
     * @param {legajo_virtual_autosCreateArgs} args - Arguments to create a Legajo_virtual_autos.
     * @example
     * // Create one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_autosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_autos.
     *     @param {legajo_virtual_autosCreateManyArgs} args - Arguments to create many Legajo_virtual_autos.
     *     @example
     *     // Create many Legajo_virtual_autos
     *     const legajo_virtual_autos = await prisma.legajo_virtual_autos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_autosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteArgs} args - Arguments to delete one Legajo_virtual_autos.
     * @example
     * // Delete one Legajo_virtual_autos
     * const Legajo_virtual_autos = await prisma.legajo_virtual_autos.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_autos
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_autosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpdateArgs} args - Arguments to update one Legajo_virtual_autos.
     * @example
     * // Update one Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_autosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_autos.
     * @param {legajo_virtual_autosDeleteManyArgs} args - Arguments to filter Legajo_virtual_autos to delete.
     * @example
     * // Delete a few Legajo_virtual_autos
     * const { count } = await prisma.legajo_virtual_autos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_autosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_autosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_autosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_autos.
     * @param {legajo_virtual_autosUpsertArgs} args - Arguments to update or create a Legajo_virtual_autos.
     * @example
     * // Update or create a Legajo_virtual_autos
     * const legajo_virtual_autos = await prisma.legajo_virtual_autos.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_autos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_autosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_autosUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_autosClient<$Types.GetResult<legajo_virtual_autosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosCountArgs} args - Arguments to filter Legajo_virtual_autos to count.
     * @example
     * // Count the number of Legajo_virtual_autos
     * const count = await prisma.legajo_virtual_autos.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_autos we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_autosCountArgs>(
      args?: Subset<T, legajo_virtual_autosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_autosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_autosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_autosAggregateArgs>(args: Subset<T, Legajo_virtual_autosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_autosAggregateType<T>>

    /**
     * Group by Legajo_virtual_autos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_autosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_autosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_autosGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_autosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_autosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_autosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_autos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_autosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_autos base type for findUnique actions
   */
  export type legajo_virtual_autosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }

  /**
   * legajo_virtual_autos findUnique
   */
  export interface legajo_virtual_autosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_autosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findUniqueOrThrow
   */
  export type legajo_virtual_autosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos base type for findFirst actions
   */
  export type legajo_virtual_autosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }

  /**
   * legajo_virtual_autos findFirst
   */
  export interface legajo_virtual_autosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_autosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_autos findFirstOrThrow
   */
  export type legajo_virtual_autosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_autos.
     */
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_autos findMany
   */
  export type legajo_virtual_autosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_autos to fetch.
     */
    where?: legajo_virtual_autosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_autos to fetch.
     */
    orderBy?: legajo_virtual_autosOrderByWithRelationInput | legajo_virtual_autosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_autos.
     */
    cursor?: legajo_virtual_autosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_autos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_autos.
     */
    skip?: number
    distinct?: Legajo_virtual_autosScalarFieldEnum | Legajo_virtual_autosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_autos create
   */
  export type legajo_virtual_autosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_autos.
     */
    data?: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_autos createMany
   */
  export type legajo_virtual_autosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_autos.
     */
    data: legajo_virtual_autosCreateManyInput | legajo_virtual_autosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_autos update
   */
  export type legajo_virtual_autosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_autos to update.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos updateMany
   */
  export type legajo_virtual_autosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_autos.
     */
    data: XOR<legajo_virtual_autosUpdateManyMutationInput, legajo_virtual_autosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_autos to update
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos upsert
   */
  export type legajo_virtual_autosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_autos to update in case it exists.
     */
    where: legajo_virtual_autosWhereUniqueInput
    /**
     * In case the legajo_virtual_autos found by the `where` argument doesn't exist, create a new legajo_virtual_autos with this data.
     */
    create: XOR<legajo_virtual_autosCreateInput, legajo_virtual_autosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_autos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_autosUpdateInput, legajo_virtual_autosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_autos delete
   */
  export type legajo_virtual_autosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_autos to delete.
     */
    where: legajo_virtual_autosWhereUniqueInput
  }


  /**
   * legajo_virtual_autos deleteMany
   */
  export type legajo_virtual_autosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_autos to delete
     */
    where?: legajo_virtual_autosWhereInput
  }


  /**
   * legajo_virtual_autos without action
   */
  export type legajo_virtual_autosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_autos
     */
    select?: legajo_virtual_autosSelect<ExtArgs> | null
  }



  /**
   * Model legajo_virtual_servicios
   */


  export type AggregateLegajo_virtual_servicios = {
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  export type Legajo_virtual_serviciosAvgAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
  }

  export type Legajo_virtual_serviciosSumAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
  }

  export type Legajo_virtual_serviciosMinAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosMaxAggregateOutputType = {
    idlegajo: number | null
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
  }

  export type Legajo_virtual_serviciosCountAggregateOutputType = {
    idlegajo: number
    servicio: number
    archivo: number
    fecha_subida: number
    empresa: number
    _all: number
  }


  export type Legajo_virtual_serviciosAvgAggregateInputType = {
    idlegajo?: true
    servicio?: true
  }

  export type Legajo_virtual_serviciosSumAggregateInputType = {
    idlegajo?: true
    servicio?: true
  }

  export type Legajo_virtual_serviciosMinAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosMaxAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
  }

  export type Legajo_virtual_serviciosCountAggregateInputType = {
    idlegajo?: true
    servicio?: true
    archivo?: true
    fecha_subida?: true
    empresa?: true
    _all?: true
  }

  export type Legajo_virtual_serviciosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_servicios to aggregate.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legajo_virtual_servicios
    **/
    _count?: true | Legajo_virtual_serviciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }

  export type GetLegajo_virtual_serviciosAggregateType<T extends Legajo_virtual_serviciosAggregateArgs> = {
        [P in keyof T & keyof AggregateLegajo_virtual_servicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
      : GetScalarType<T[P], AggregateLegajo_virtual_servicios[P]>
  }




  export type legajo_virtual_serviciosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: legajo_virtual_serviciosWhereInput
    orderBy?: legajo_virtual_serviciosOrderByWithAggregationInput | legajo_virtual_serviciosOrderByWithAggregationInput[]
    by: Legajo_virtual_serviciosScalarFieldEnum[] | Legajo_virtual_serviciosScalarFieldEnum
    having?: legajo_virtual_serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Legajo_virtual_serviciosCountAggregateInputType | true
    _avg?: Legajo_virtual_serviciosAvgAggregateInputType
    _sum?: Legajo_virtual_serviciosSumAggregateInputType
    _min?: Legajo_virtual_serviciosMinAggregateInputType
    _max?: Legajo_virtual_serviciosMaxAggregateInputType
  }


  export type Legajo_virtual_serviciosGroupByOutputType = {
    idlegajo: number
    servicio: number | null
    archivo: string | null
    fecha_subida: Date | null
    empresa: string | null
    _count: Legajo_virtual_serviciosCountAggregateOutputType | null
    _avg: Legajo_virtual_serviciosAvgAggregateOutputType | null
    _sum: Legajo_virtual_serviciosSumAggregateOutputType | null
    _min: Legajo_virtual_serviciosMinAggregateOutputType | null
    _max: Legajo_virtual_serviciosMaxAggregateOutputType | null
  }

  type GetLegajo_virtual_serviciosGroupByPayload<T extends legajo_virtual_serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Legajo_virtual_serviciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Legajo_virtual_serviciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
            : GetScalarType<T[P], Legajo_virtual_serviciosGroupByOutputType[P]>
        }
      >
    >


  export type legajo_virtual_serviciosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlegajo?: boolean
    servicio?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }, ExtArgs["result"]["legajo_virtual_servicios"]>

  export type legajo_virtual_serviciosSelectScalar = {
    idlegajo?: boolean
    servicio?: boolean
    archivo?: boolean
    fecha_subida?: boolean
    empresa?: boolean
  }


  type legajo_virtual_serviciosGetPayload<S extends boolean | null | undefined | legajo_virtual_serviciosArgs> = $Types.GetResult<legajo_virtual_serviciosPayload, S>

  type legajo_virtual_serviciosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<legajo_virtual_serviciosFindManyArgs, 'select' | 'include'> & {
      select?: Legajo_virtual_serviciosCountAggregateInputType | true
    }

  export interface legajo_virtual_serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legajo_virtual_servicios'], meta: { name: 'legajo_virtual_servicios' } }
    /**
     * Find zero or one Legajo_virtual_servicios that matches the filter.
     * @param {legajo_virtual_serviciosFindUniqueArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends legajo_virtual_serviciosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, legajo_virtual_serviciosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Legajo_virtual_servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {legajo_virtual_serviciosFindUniqueOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends legajo_virtual_serviciosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'legajo_virtual_servicios'> extends True ? Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Legajo_virtual_servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindFirstOrThrowArgs} args - Arguments to find a Legajo_virtual_servicios
     * @example
     * // Get one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Legajo_virtual_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany()
     * 
     * // Get first 10 Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.findMany({ take: 10 })
     * 
     * // Only select the `idlegajo`
     * const legajo_virtual_serviciosWithIdlegajoOnly = await prisma.legajo_virtual_servicios.findMany({ select: { idlegajo: true } })
     * 
    **/
    findMany<T extends legajo_virtual_serviciosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosCreateArgs} args - Arguments to create a Legajo_virtual_servicios.
     * @example
     * // Create one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.create({
     *   data: {
     *     // ... data to create a Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    create<T extends legajo_virtual_serviciosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosCreateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Legajo_virtual_servicios.
     *     @param {legajo_virtual_serviciosCreateManyArgs} args - Arguments to create many Legajo_virtual_servicios.
     *     @example
     *     // Create many Legajo_virtual_servicios
     *     const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends legajo_virtual_serviciosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteArgs} args - Arguments to delete one Legajo_virtual_servicios.
     * @example
     * // Delete one Legajo_virtual_servicios
     * const Legajo_virtual_servicios = await prisma.legajo_virtual_servicios.delete({
     *   where: {
     *     // ... filter to delete one Legajo_virtual_servicios
     *   }
     * })
     * 
    **/
    delete<T extends legajo_virtual_serviciosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosDeleteArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpdateArgs} args - Arguments to update one Legajo_virtual_servicios.
     * @example
     * // Update one Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends legajo_virtual_serviciosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosDeleteManyArgs} args - Arguments to filter Legajo_virtual_servicios to delete.
     * @example
     * // Delete a few Legajo_virtual_servicios
     * const { count } = await prisma.legajo_virtual_servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends legajo_virtual_serviciosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, legajo_virtual_serviciosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends legajo_virtual_serviciosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legajo_virtual_servicios.
     * @param {legajo_virtual_serviciosUpsertArgs} args - Arguments to update or create a Legajo_virtual_servicios.
     * @example
     * // Update or create a Legajo_virtual_servicios
     * const legajo_virtual_servicios = await prisma.legajo_virtual_servicios.upsert({
     *   create: {
     *     // ... data to create a Legajo_virtual_servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to update
     *   }
     * })
    **/
    upsert<T extends legajo_virtual_serviciosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, legajo_virtual_serviciosUpsertArgs<ExtArgs>>
    ): Prisma__legajo_virtual_serviciosClient<$Types.GetResult<legajo_virtual_serviciosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosCountArgs} args - Arguments to filter Legajo_virtual_servicios to count.
     * @example
     * // Count the number of Legajo_virtual_servicios
     * const count = await prisma.legajo_virtual_servicios.count({
     *   where: {
     *     // ... the filter for the Legajo_virtual_servicios we want to count
     *   }
     * })
    **/
    count<T extends legajo_virtual_serviciosCountArgs>(
      args?: Subset<T, legajo_virtual_serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Legajo_virtual_serviciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Legajo_virtual_serviciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Legajo_virtual_serviciosAggregateArgs>(args: Subset<T, Legajo_virtual_serviciosAggregateArgs>): Prisma.PrismaPromise<GetLegajo_virtual_serviciosAggregateType<T>>

    /**
     * Group by Legajo_virtual_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legajo_virtual_serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legajo_virtual_serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legajo_virtual_serviciosGroupByArgs['orderBy'] }
        : { orderBy?: legajo_virtual_serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legajo_virtual_serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegajo_virtual_serviciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for legajo_virtual_servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__legajo_virtual_serviciosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * legajo_virtual_servicios base type for findUnique actions
   */
  export type legajo_virtual_serviciosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }

  /**
   * legajo_virtual_servicios findUnique
   */
  export interface legajo_virtual_serviciosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_serviciosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findUniqueOrThrow
   */
  export type legajo_virtual_serviciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios base type for findFirst actions
   */
  export type legajo_virtual_serviciosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }

  /**
   * legajo_virtual_servicios findFirst
   */
  export interface legajo_virtual_serviciosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends legajo_virtual_serviciosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * legajo_virtual_servicios findFirstOrThrow
   */
  export type legajo_virtual_serviciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legajo_virtual_servicios.
     */
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_servicios findMany
   */
  export type legajo_virtual_serviciosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter, which legajo_virtual_servicios to fetch.
     */
    where?: legajo_virtual_serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legajo_virtual_servicios to fetch.
     */
    orderBy?: legajo_virtual_serviciosOrderByWithRelationInput | legajo_virtual_serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legajo_virtual_servicios.
     */
    cursor?: legajo_virtual_serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legajo_virtual_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legajo_virtual_servicios.
     */
    skip?: number
    distinct?: Legajo_virtual_serviciosScalarFieldEnum | Legajo_virtual_serviciosScalarFieldEnum[]
  }


  /**
   * legajo_virtual_servicios create
   */
  export type legajo_virtual_serviciosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The data needed to create a legajo_virtual_servicios.
     */
    data?: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
  }


  /**
   * legajo_virtual_servicios createMany
   */
  export type legajo_virtual_serviciosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legajo_virtual_servicios.
     */
    data: legajo_virtual_serviciosCreateManyInput | legajo_virtual_serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * legajo_virtual_servicios update
   */
  export type legajo_virtual_serviciosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The data needed to update a legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
    /**
     * Choose, which legajo_virtual_servicios to update.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios updateMany
   */
  export type legajo_virtual_serviciosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legajo_virtual_servicios.
     */
    data: XOR<legajo_virtual_serviciosUpdateManyMutationInput, legajo_virtual_serviciosUncheckedUpdateManyInput>
    /**
     * Filter which legajo_virtual_servicios to update
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios upsert
   */
  export type legajo_virtual_serviciosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * The filter to search for the legajo_virtual_servicios to update in case it exists.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
    /**
     * In case the legajo_virtual_servicios found by the `where` argument doesn't exist, create a new legajo_virtual_servicios with this data.
     */
    create: XOR<legajo_virtual_serviciosCreateInput, legajo_virtual_serviciosUncheckedCreateInput>
    /**
     * In case the legajo_virtual_servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legajo_virtual_serviciosUpdateInput, legajo_virtual_serviciosUncheckedUpdateInput>
  }


  /**
   * legajo_virtual_servicios delete
   */
  export type legajo_virtual_serviciosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
    /**
     * Filter which legajo_virtual_servicios to delete.
     */
    where: legajo_virtual_serviciosWhereUniqueInput
  }


  /**
   * legajo_virtual_servicios deleteMany
   */
  export type legajo_virtual_serviciosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which legajo_virtual_servicios to delete
     */
    where?: legajo_virtual_serviciosWhereInput
  }


  /**
   * legajo_virtual_servicios without action
   */
  export type legajo_virtual_serviciosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legajo_virtual_servicios
     */
    select?: legajo_virtual_serviciosSelect<ExtArgs> | null
  }



  /**
   * Model novedades
   */


  export type AggregateNovedades = {
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  export type NovedadesAvgAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesSumAggregateOutputType = {
    idnovedad: number | null
  }

  export type NovedadesMinAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesMaxAggregateOutputType = {
    idnovedad: number | null
    novedad: string | null
    fecha: Date | null
    operador: string | null
  }

  export type NovedadesCountAggregateOutputType = {
    idnovedad: number
    novedad: number
    fecha: number
    operador: number
    _all: number
  }


  export type NovedadesAvgAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesSumAggregateInputType = {
    idnovedad?: true
  }

  export type NovedadesMinAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesMaxAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
  }

  export type NovedadesCountAggregateInputType = {
    idnovedad?: true
    novedad?: true
    fecha?: true
    operador?: true
    _all?: true
  }

  export type NovedadesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to aggregate.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned novedades
    **/
    _count?: true | NovedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovedadesMaxAggregateInputType
  }

  export type GetNovedadesAggregateType<T extends NovedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateNovedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovedades[P]>
      : GetScalarType<T[P], AggregateNovedades[P]>
  }




  export type novedadesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: novedadesWhereInput
    orderBy?: novedadesOrderByWithAggregationInput | novedadesOrderByWithAggregationInput[]
    by: NovedadesScalarFieldEnum[] | NovedadesScalarFieldEnum
    having?: novedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovedadesCountAggregateInputType | true
    _avg?: NovedadesAvgAggregateInputType
    _sum?: NovedadesSumAggregateInputType
    _min?: NovedadesMinAggregateInputType
    _max?: NovedadesMaxAggregateInputType
  }


  export type NovedadesGroupByOutputType = {
    idnovedad: number
    novedad: string | null
    fecha: Date | null
    operador: string | null
    _count: NovedadesCountAggregateOutputType | null
    _avg: NovedadesAvgAggregateOutputType | null
    _sum: NovedadesSumAggregateOutputType | null
    _min: NovedadesMinAggregateOutputType | null
    _max: NovedadesMaxAggregateOutputType | null
  }

  type GetNovedadesGroupByPayload<T extends novedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
            : GetScalarType<T[P], NovedadesGroupByOutputType[P]>
        }
      >
    >


  export type novedadesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idnovedad?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
  }, ExtArgs["result"]["novedades"]>

  export type novedadesSelectScalar = {
    idnovedad?: boolean
    novedad?: boolean
    fecha?: boolean
    operador?: boolean
  }


  type novedadesGetPayload<S extends boolean | null | undefined | novedadesArgs> = $Types.GetResult<novedadesPayload, S>

  type novedadesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<novedadesFindManyArgs, 'select' | 'include'> & {
      select?: NovedadesCountAggregateInputType | true
    }

  export interface novedadesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['novedades'], meta: { name: 'novedades' } }
    /**
     * Find zero or one Novedades that matches the filter.
     * @param {novedadesFindUniqueArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends novedadesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, novedadesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Novedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {novedadesFindUniqueOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends novedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends novedadesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, novedadesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'novedades'> extends True ? Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Novedades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindFirstOrThrowArgs} args - Arguments to find a Novedades
     * @example
     * // Get one Novedades
     * const novedades = await prisma.novedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends novedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Novedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Novedades
     * const novedades = await prisma.novedades.findMany()
     * 
     * // Get first 10 Novedades
     * const novedades = await prisma.novedades.findMany({ take: 10 })
     * 
     * // Only select the `idnovedad`
     * const novedadesWithIdnovedadOnly = await prisma.novedades.findMany({ select: { idnovedad: true } })
     * 
    **/
    findMany<T extends novedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Novedades.
     * @param {novedadesCreateArgs} args - Arguments to create a Novedades.
     * @example
     * // Create one Novedades
     * const Novedades = await prisma.novedades.create({
     *   data: {
     *     // ... data to create a Novedades
     *   }
     * })
     * 
    **/
    create<T extends novedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesCreateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Novedades.
     *     @param {novedadesCreateManyArgs} args - Arguments to create many Novedades.
     *     @example
     *     // Create many Novedades
     *     const novedades = await prisma.novedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends novedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Novedades.
     * @param {novedadesDeleteArgs} args - Arguments to delete one Novedades.
     * @example
     * // Delete one Novedades
     * const Novedades = await prisma.novedades.delete({
     *   where: {
     *     // ... filter to delete one Novedades
     *   }
     * })
     * 
    **/
    delete<T extends novedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesDeleteArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Novedades.
     * @param {novedadesUpdateArgs} args - Arguments to update one Novedades.
     * @example
     * // Update one Novedades
     * const novedades = await prisma.novedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends novedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Novedades.
     * @param {novedadesDeleteManyArgs} args - Arguments to filter Novedades to delete.
     * @example
     * // Delete a few Novedades
     * const { count } = await prisma.novedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends novedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, novedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Novedades
     * const novedades = await prisma.novedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends novedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Novedades.
     * @param {novedadesUpsertArgs} args - Arguments to update or create a Novedades.
     * @example
     * // Update or create a Novedades
     * const novedades = await prisma.novedades.upsert({
     *   create: {
     *     // ... data to create a Novedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Novedades we want to update
     *   }
     * })
    **/
    upsert<T extends novedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, novedadesUpsertArgs<ExtArgs>>
    ): Prisma__novedadesClient<$Types.GetResult<novedadesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesCountArgs} args - Arguments to filter Novedades to count.
     * @example
     * // Count the number of Novedades
     * const count = await prisma.novedades.count({
     *   where: {
     *     // ... the filter for the Novedades we want to count
     *   }
     * })
    **/
    count<T extends novedadesCountArgs>(
      args?: Subset<T, novedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovedadesAggregateArgs>(args: Subset<T, NovedadesAggregateArgs>): Prisma.PrismaPromise<GetNovedadesAggregateType<T>>

    /**
     * Group by Novedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {novedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends novedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: novedadesGroupByArgs['orderBy'] }
        : { orderBy?: novedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, novedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for novedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__novedadesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * novedades base type for findUnique actions
   */
  export type novedadesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }

  /**
   * novedades findUnique
   */
  export interface novedadesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findUniqueOrThrow
   */
  export type novedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades base type for findFirst actions
   */
  export type novedadesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }

  /**
   * novedades findFirst
   */
  export interface novedadesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends novedadesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * novedades findFirstOrThrow
   */
  export type novedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of novedades.
     */
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades findMany
   */
  export type novedadesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter, which novedades to fetch.
     */
    where?: novedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of novedades to fetch.
     */
    orderBy?: novedadesOrderByWithRelationInput | novedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing novedades.
     */
    cursor?: novedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` novedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` novedades.
     */
    skip?: number
    distinct?: NovedadesScalarFieldEnum | NovedadesScalarFieldEnum[]
  }


  /**
   * novedades create
   */
  export type novedadesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a novedades.
     */
    data?: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
  }


  /**
   * novedades createMany
   */
  export type novedadesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many novedades.
     */
    data: novedadesCreateManyInput | novedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * novedades update
   */
  export type novedadesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a novedades.
     */
    data: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
    /**
     * Choose, which novedades to update.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades updateMany
   */
  export type novedadesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update novedades.
     */
    data: XOR<novedadesUpdateManyMutationInput, novedadesUncheckedUpdateManyInput>
    /**
     * Filter which novedades to update
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades upsert
   */
  export type novedadesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the novedades to update in case it exists.
     */
    where: novedadesWhereUniqueInput
    /**
     * In case the novedades found by the `where` argument doesn't exist, create a new novedades with this data.
     */
    create: XOR<novedadesCreateInput, novedadesUncheckedCreateInput>
    /**
     * In case the novedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<novedadesUpdateInput, novedadesUncheckedUpdateInput>
  }


  /**
   * novedades delete
   */
  export type novedadesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
    /**
     * Filter which novedades to delete.
     */
    where: novedadesWhereUniqueInput
  }


  /**
   * novedades deleteMany
   */
  export type novedadesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which novedades to delete
     */
    where?: novedadesWhereInput
  }


  /**
   * novedades without action
   */
  export type novedadesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the novedades
     */
    select?: novedadesSelect<ExtArgs> | null
  }



  /**
   * Model operadorsep
   */


  export type AggregateOperadorsep = {
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  export type OperadorsepAvgAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepSumAggregateOutputType = {
    idoperador: number | null
  }

  export type OperadorsepMinAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepMaxAggregateOutputType = {
    idoperador: number | null
    operador: string | null
  }

  export type OperadorsepCountAggregateOutputType = {
    idoperador: number
    operador: number
    _all: number
  }


  export type OperadorsepAvgAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepSumAggregateInputType = {
    idoperador?: true
  }

  export type OperadorsepMinAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepMaxAggregateInputType = {
    idoperador?: true
    operador?: true
  }

  export type OperadorsepCountAggregateInputType = {
    idoperador?: true
    operador?: true
    _all?: true
  }

  export type OperadorsepAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operadorsep to aggregate.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operadorseps
    **/
    _count?: true | OperadorsepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperadorsepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperadorsepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperadorsepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperadorsepMaxAggregateInputType
  }

  export type GetOperadorsepAggregateType<T extends OperadorsepAggregateArgs> = {
        [P in keyof T & keyof AggregateOperadorsep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperadorsep[P]>
      : GetScalarType<T[P], AggregateOperadorsep[P]>
  }




  export type operadorsepGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: operadorsepWhereInput
    orderBy?: operadorsepOrderByWithAggregationInput | operadorsepOrderByWithAggregationInput[]
    by: OperadorsepScalarFieldEnum[] | OperadorsepScalarFieldEnum
    having?: operadorsepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperadorsepCountAggregateInputType | true
    _avg?: OperadorsepAvgAggregateInputType
    _sum?: OperadorsepSumAggregateInputType
    _min?: OperadorsepMinAggregateInputType
    _max?: OperadorsepMaxAggregateInputType
  }


  export type OperadorsepGroupByOutputType = {
    idoperador: number
    operador: string | null
    _count: OperadorsepCountAggregateOutputType | null
    _avg: OperadorsepAvgAggregateOutputType | null
    _sum: OperadorsepSumAggregateOutputType | null
    _min: OperadorsepMinAggregateOutputType | null
    _max: OperadorsepMaxAggregateOutputType | null
  }

  type GetOperadorsepGroupByPayload<T extends operadorsepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperadorsepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperadorsepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
            : GetScalarType<T[P], OperadorsepGroupByOutputType[P]>
        }
      >
    >


  export type operadorsepSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idoperador?: boolean
    operador?: boolean
  }, ExtArgs["result"]["operadorsep"]>

  export type operadorsepSelectScalar = {
    idoperador?: boolean
    operador?: boolean
  }


  type operadorsepGetPayload<S extends boolean | null | undefined | operadorsepArgs> = $Types.GetResult<operadorsepPayload, S>

  type operadorsepCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<operadorsepFindManyArgs, 'select' | 'include'> & {
      select?: OperadorsepCountAggregateInputType | true
    }

  export interface operadorsepDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operadorsep'], meta: { name: 'operadorsep' } }
    /**
     * Find zero or one Operadorsep that matches the filter.
     * @param {operadorsepFindUniqueArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operadorsepFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operadorsepFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operadorsep'> extends True ? Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Operadorsep that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operadorsepFindUniqueOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operadorsepFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Operadorsep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operadorsepFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operadorsepFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operadorsep'> extends True ? Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Operadorsep that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindFirstOrThrowArgs} args - Arguments to find a Operadorsep
     * @example
     * // Get one Operadorsep
     * const operadorsep = await prisma.operadorsep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operadorsepFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Operadorseps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany()
     * 
     * // Get first 10 Operadorseps
     * const operadorseps = await prisma.operadorsep.findMany({ take: 10 })
     * 
     * // Only select the `idoperador`
     * const operadorsepWithIdoperadorOnly = await prisma.operadorsep.findMany({ select: { idoperador: true } })
     * 
    **/
    findMany<T extends operadorsepFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Operadorsep.
     * @param {operadorsepCreateArgs} args - Arguments to create a Operadorsep.
     * @example
     * // Create one Operadorsep
     * const Operadorsep = await prisma.operadorsep.create({
     *   data: {
     *     // ... data to create a Operadorsep
     *   }
     * })
     * 
    **/
    create<T extends operadorsepCreateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepCreateArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Operadorseps.
     *     @param {operadorsepCreateManyArgs} args - Arguments to create many Operadorseps.
     *     @example
     *     // Create many Operadorseps
     *     const operadorsep = await prisma.operadorsep.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operadorsepCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operadorsep.
     * @param {operadorsepDeleteArgs} args - Arguments to delete one Operadorsep.
     * @example
     * // Delete one Operadorsep
     * const Operadorsep = await prisma.operadorsep.delete({
     *   where: {
     *     // ... filter to delete one Operadorsep
     *   }
     * })
     * 
    **/
    delete<T extends operadorsepDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepDeleteArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Operadorsep.
     * @param {operadorsepUpdateArgs} args - Arguments to update one Operadorsep.
     * @example
     * // Update one Operadorsep
     * const operadorsep = await prisma.operadorsep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operadorsepUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpdateArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Operadorseps.
     * @param {operadorsepDeleteManyArgs} args - Arguments to filter Operadorseps to delete.
     * @example
     * // Delete a few Operadorseps
     * const { count } = await prisma.operadorsep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operadorsepDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, operadorsepDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operadorseps
     * const operadorsep = await prisma.operadorsep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operadorsepUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operadorsep.
     * @param {operadorsepUpsertArgs} args - Arguments to update or create a Operadorsep.
     * @example
     * // Update or create a Operadorsep
     * const operadorsep = await prisma.operadorsep.upsert({
     *   create: {
     *     // ... data to create a Operadorsep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operadorsep we want to update
     *   }
     * })
    **/
    upsert<T extends operadorsepUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, operadorsepUpsertArgs<ExtArgs>>
    ): Prisma__operadorsepClient<$Types.GetResult<operadorsepPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Operadorseps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepCountArgs} args - Arguments to filter Operadorseps to count.
     * @example
     * // Count the number of Operadorseps
     * const count = await prisma.operadorsep.count({
     *   where: {
     *     // ... the filter for the Operadorseps we want to count
     *   }
     * })
    **/
    count<T extends operadorsepCountArgs>(
      args?: Subset<T, operadorsepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperadorsepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperadorsepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperadorsepAggregateArgs>(args: Subset<T, OperadorsepAggregateArgs>): Prisma.PrismaPromise<GetOperadorsepAggregateType<T>>

    /**
     * Group by Operadorsep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operadorsepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operadorsepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operadorsepGroupByArgs['orderBy'] }
        : { orderBy?: operadorsepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operadorsepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperadorsepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operadorsep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operadorsepClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operadorsep base type for findUnique actions
   */
  export type operadorsepFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }

  /**
   * operadorsep findUnique
   */
  export interface operadorsepFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorsepFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findUniqueOrThrow
   */
  export type operadorsepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep base type for findFirst actions
   */
  export type operadorsepFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }

  /**
   * operadorsep findFirst
   */
  export interface operadorsepFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends operadorsepFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operadorsep findFirstOrThrow
   */
  export type operadorsepFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorsep to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operadorseps.
     */
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }


  /**
   * operadorsep findMany
   */
  export type operadorsepFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter, which operadorseps to fetch.
     */
    where?: operadorsepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operadorseps to fetch.
     */
    orderBy?: operadorsepOrderByWithRelationInput | operadorsepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operadorseps.
     */
    cursor?: operadorsepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operadorseps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operadorseps.
     */
    skip?: number
    distinct?: OperadorsepScalarFieldEnum | OperadorsepScalarFieldEnum[]
  }


  /**
   * operadorsep create
   */
  export type operadorsepCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The data needed to create a operadorsep.
     */
    data?: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
  }


  /**
   * operadorsep createMany
   */
  export type operadorsepCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operadorseps.
     */
    data: operadorsepCreateManyInput | operadorsepCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * operadorsep update
   */
  export type operadorsepUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The data needed to update a operadorsep.
     */
    data: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
    /**
     * Choose, which operadorsep to update.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep updateMany
   */
  export type operadorsepUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operadorseps.
     */
    data: XOR<operadorsepUpdateManyMutationInput, operadorsepUncheckedUpdateManyInput>
    /**
     * Filter which operadorseps to update
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep upsert
   */
  export type operadorsepUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * The filter to search for the operadorsep to update in case it exists.
     */
    where: operadorsepWhereUniqueInput
    /**
     * In case the operadorsep found by the `where` argument doesn't exist, create a new operadorsep with this data.
     */
    create: XOR<operadorsepCreateInput, operadorsepUncheckedCreateInput>
    /**
     * In case the operadorsep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operadorsepUpdateInput, operadorsepUncheckedUpdateInput>
  }


  /**
   * operadorsep delete
   */
  export type operadorsepDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
    /**
     * Filter which operadorsep to delete.
     */
    where: operadorsepWhereUniqueInput
  }


  /**
   * operadorsep deleteMany
   */
  export type operadorsepDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which operadorseps to delete
     */
    where?: operadorsepWhereInput
  }


  /**
   * operadorsep without action
   */
  export type operadorsepArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operadorsep
     */
    select?: operadorsepSelect<ExtArgs> | null
  }



  /**
   * Model parcelas
   */


  export type AggregateParcelas = {
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  export type ParcelasAvgAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasSumAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    mza: number | null
    lote: number | null
    lugares: number | null
  }

  export type ParcelasMinAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasMaxAggregateOutputType = {
    idparcela: number | null
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
  }

  export type ParcelasCountAggregateOutputType = {
    idparcela: number
    idservicio: number
    dni_extinto: number
    ficha: number
    parcela: number
    mza: number
    lote: number
    asignada: number
    fecha: number
    cementerio: number
    operador: number
    fecha_alta: number
    operador_asignacion: number
    fecha_asignacion: number
    lugares: number
    _all: number
  }


  export type ParcelasAvgAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasSumAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    mza?: true
    lote?: true
    lugares?: true
  }

  export type ParcelasMinAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasMaxAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
  }

  export type ParcelasCountAggregateInputType = {
    idparcela?: true
    idservicio?: true
    dni_extinto?: true
    ficha?: true
    parcela?: true
    mza?: true
    lote?: true
    asignada?: true
    fecha?: true
    cementerio?: true
    operador?: true
    fecha_alta?: true
    operador_asignacion?: true
    fecha_asignacion?: true
    lugares?: true
    _all?: true
  }

  export type ParcelasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas to aggregate.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parcelas
    **/
    _count?: true | ParcelasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParcelasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParcelasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParcelasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParcelasMaxAggregateInputType
  }

  export type GetParcelasAggregateType<T extends ParcelasAggregateArgs> = {
        [P in keyof T & keyof AggregateParcelas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcelas[P]>
      : GetScalarType<T[P], AggregateParcelas[P]>
  }




  export type parcelasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: parcelasWhereInput
    orderBy?: parcelasOrderByWithAggregationInput | parcelasOrderByWithAggregationInput[]
    by: ParcelasScalarFieldEnum[] | ParcelasScalarFieldEnum
    having?: parcelasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParcelasCountAggregateInputType | true
    _avg?: ParcelasAvgAggregateInputType
    _sum?: ParcelasSumAggregateInputType
    _min?: ParcelasMinAggregateInputType
    _max?: ParcelasMaxAggregateInputType
  }


  export type ParcelasGroupByOutputType = {
    idparcela: number
    idservicio: number | null
    dni_extinto: number | null
    ficha: number | null
    parcela: string | null
    mza: number | null
    lote: number | null
    asignada: boolean | null
    fecha: string | null
    cementerio: string | null
    operador: string | null
    fecha_alta: string | null
    operador_asignacion: string | null
    fecha_asignacion: string | null
    lugares: number | null
    _count: ParcelasCountAggregateOutputType | null
    _avg: ParcelasAvgAggregateOutputType | null
    _sum: ParcelasSumAggregateOutputType | null
    _min: ParcelasMinAggregateOutputType | null
    _max: ParcelasMaxAggregateOutputType | null
  }

  type GetParcelasGroupByPayload<T extends parcelasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParcelasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParcelasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
            : GetScalarType<T[P], ParcelasGroupByOutputType[P]>
        }
      >
    >


  export type parcelasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idparcela?: boolean
    idservicio?: boolean
    dni_extinto?: boolean
    ficha?: boolean
    parcela?: boolean
    mza?: boolean
    lote?: boolean
    asignada?: boolean
    fecha?: boolean
    cementerio?: boolean
    operador?: boolean
    fecha_alta?: boolean
    operador_asignacion?: boolean
    fecha_asignacion?: boolean
    lugares?: boolean
  }, ExtArgs["result"]["parcelas"]>

  export type parcelasSelectScalar = {
    idparcela?: boolean
    idservicio?: boolean
    dni_extinto?: boolean
    ficha?: boolean
    parcela?: boolean
    mza?: boolean
    lote?: boolean
    asignada?: boolean
    fecha?: boolean
    cementerio?: boolean
    operador?: boolean
    fecha_alta?: boolean
    operador_asignacion?: boolean
    fecha_asignacion?: boolean
    lugares?: boolean
  }


  type parcelasGetPayload<S extends boolean | null | undefined | parcelasArgs> = $Types.GetResult<parcelasPayload, S>

  type parcelasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<parcelasFindManyArgs, 'select' | 'include'> & {
      select?: ParcelasCountAggregateInputType | true
    }

  export interface parcelasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parcelas'], meta: { name: 'parcelas' } }
    /**
     * Find zero or one Parcelas that matches the filter.
     * @param {parcelasFindUniqueArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parcelasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parcelasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parcelas'> extends True ? Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parcelas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parcelasFindUniqueOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parcelasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parcelasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parcelasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parcelas'> extends True ? Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parcelas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindFirstOrThrowArgs} args - Arguments to find a Parcelas
     * @example
     * // Get one Parcelas
     * const parcelas = await prisma.parcelas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parcelasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parcelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas
     * const parcelas = await prisma.parcelas.findMany()
     * 
     * // Get first 10 Parcelas
     * const parcelas = await prisma.parcelas.findMany({ take: 10 })
     * 
     * // Only select the `idparcela`
     * const parcelasWithIdparcelaOnly = await prisma.parcelas.findMany({ select: { idparcela: true } })
     * 
    **/
    findMany<T extends parcelasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parcelas.
     * @param {parcelasCreateArgs} args - Arguments to create a Parcelas.
     * @example
     * // Create one Parcelas
     * const Parcelas = await prisma.parcelas.create({
     *   data: {
     *     // ... data to create a Parcelas
     *   }
     * })
     * 
    **/
    create<T extends parcelasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasCreateArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parcelas.
     *     @param {parcelasCreateManyArgs} args - Arguments to create many Parcelas.
     *     @example
     *     // Create many Parcelas
     *     const parcelas = await prisma.parcelas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends parcelasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcelas.
     * @param {parcelasDeleteArgs} args - Arguments to delete one Parcelas.
     * @example
     * // Delete one Parcelas
     * const Parcelas = await prisma.parcelas.delete({
     *   where: {
     *     // ... filter to delete one Parcelas
     *   }
     * })
     * 
    **/
    delete<T extends parcelasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasDeleteArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parcelas.
     * @param {parcelasUpdateArgs} args - Arguments to update one Parcelas.
     * @example
     * // Update one Parcelas
     * const parcelas = await prisma.parcelas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parcelasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpdateArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parcelas.
     * @param {parcelasDeleteManyArgs} args - Arguments to filter Parcelas to delete.
     * @example
     * // Delete a few Parcelas
     * const { count } = await prisma.parcelas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parcelasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas
     * const parcelas = await prisma.parcelas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parcelasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcelas.
     * @param {parcelasUpsertArgs} args - Arguments to update or create a Parcelas.
     * @example
     * // Update or create a Parcelas
     * const parcelas = await prisma.parcelas.upsert({
     *   create: {
     *     // ... data to create a Parcelas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcelas we want to update
     *   }
     * })
    **/
    upsert<T extends parcelasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, parcelasUpsertArgs<ExtArgs>>
    ): Prisma__parcelasClient<$Types.GetResult<parcelasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasCountArgs} args - Arguments to filter Parcelas to count.
     * @example
     * // Count the number of Parcelas
     * const count = await prisma.parcelas.count({
     *   where: {
     *     // ... the filter for the Parcelas we want to count
     *   }
     * })
    **/
    count<T extends parcelasCountArgs>(
      args?: Subset<T, parcelasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParcelasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParcelasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParcelasAggregateArgs>(args: Subset<T, ParcelasAggregateArgs>): Prisma.PrismaPromise<GetParcelasAggregateType<T>>

    /**
     * Group by Parcelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parcelasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parcelasGroupByArgs['orderBy'] }
        : { orderBy?: parcelasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parcelasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parcelas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parcelasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parcelas base type for findUnique actions
   */
  export type parcelasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }

  /**
   * parcelas findUnique
   */
  export interface parcelasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findUniqueOrThrow
   */
  export type parcelasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas base type for findFirst actions
   */
  export type parcelasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }

  /**
   * parcelas findFirst
   */
  export interface parcelasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas findFirstOrThrow
   */
  export type parcelasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas.
     */
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }


  /**
   * parcelas findMany
   */
  export type parcelasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter, which parcelas to fetch.
     */
    where?: parcelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas to fetch.
     */
    orderBy?: parcelasOrderByWithRelationInput | parcelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parcelas.
     */
    cursor?: parcelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas.
     */
    skip?: number
    distinct?: ParcelasScalarFieldEnum | ParcelasScalarFieldEnum[]
  }


  /**
   * parcelas create
   */
  export type parcelasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The data needed to create a parcelas.
     */
    data?: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
  }


  /**
   * parcelas createMany
   */
  export type parcelasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parcelas.
     */
    data: parcelasCreateManyInput | parcelasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * parcelas update
   */
  export type parcelasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The data needed to update a parcelas.
     */
    data: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
    /**
     * Choose, which parcelas to update.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas updateMany
   */
  export type parcelasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parcelas.
     */
    data: XOR<parcelasUpdateManyMutationInput, parcelasUncheckedUpdateManyInput>
    /**
     * Filter which parcelas to update
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas upsert
   */
  export type parcelasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * The filter to search for the parcelas to update in case it exists.
     */
    where: parcelasWhereUniqueInput
    /**
     * In case the parcelas found by the `where` argument doesn't exist, create a new parcelas with this data.
     */
    create: XOR<parcelasCreateInput, parcelasUncheckedCreateInput>
    /**
     * In case the parcelas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelasUpdateInput, parcelasUncheckedUpdateInput>
  }


  /**
   * parcelas delete
   */
  export type parcelasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
    /**
     * Filter which parcelas to delete.
     */
    where: parcelasWhereUniqueInput
  }


  /**
   * parcelas deleteMany
   */
  export type parcelasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas to delete
     */
    where?: parcelasWhereInput
  }


  /**
   * parcelas without action
   */
  export type parcelasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas
     */
    select?: parcelasSelect<ExtArgs> | null
  }



  /**
   * Model planificacion_guardias
   */


  export type AggregatePlanificacion_guardias = {
    _count: Planificacion_guardiasCountAggregateOutputType | null
    _avg: Planificacion_guardiasAvgAggregateOutputType | null
    _sum: Planificacion_guardiasSumAggregateOutputType | null
    _min: Planificacion_guardiasMinAggregateOutputType | null
    _max: Planificacion_guardiasMaxAggregateOutputType | null
  }

  export type Planificacion_guardiasAvgAggregateOutputType = {
    idturno: number | null
    horas: number | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasSumAggregateOutputType = {
    idturno: number | null
    horas: number | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasMinAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: number | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasMaxAggregateOutputType = {
    idturno: number | null
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: number | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
  }

  export type Planificacion_guardiasCountAggregateOutputType = {
    idturno: number
    lugar: number
    inicio: number
    fin: number
    horas: number
    operador: number
    mes_planificacion: number
    feriado: number
    tarea: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    aprobado: number
    fecha_aprobacion: number
    operadorap: number
    ano_planificacion: number
    _all: number
  }


  export type Planificacion_guardiasAvgAggregateInputType = {
    idturno?: true
    horas?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasSumAggregateInputType = {
    idturno?: true
    horas?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasMinAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasMaxAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
  }

  export type Planificacion_guardiasCountAggregateInputType = {
    idturno?: true
    lugar?: true
    inicio?: true
    fin?: true
    horas?: true
    operador?: true
    mes_planificacion?: true
    feriado?: true
    tarea?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    ano_planificacion?: true
    _all?: true
  }

  export type Planificacion_guardiasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planificacion_guardias to aggregate.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: planificacion_guardiasOrderByWithRelationInput | planificacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned planificacion_guardias
    **/
    _count?: true | Planificacion_guardiasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Planificacion_guardiasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Planificacion_guardiasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Planificacion_guardiasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Planificacion_guardiasMaxAggregateInputType
  }

  export type GetPlanificacion_guardiasAggregateType<T extends Planificacion_guardiasAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanificacion_guardias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanificacion_guardias[P]>
      : GetScalarType<T[P], AggregatePlanificacion_guardias[P]>
  }




  export type planificacion_guardiasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: planificacion_guardiasWhereInput
    orderBy?: planificacion_guardiasOrderByWithAggregationInput | planificacion_guardiasOrderByWithAggregationInput[]
    by: Planificacion_guardiasScalarFieldEnum[] | Planificacion_guardiasScalarFieldEnum
    having?: planificacion_guardiasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Planificacion_guardiasCountAggregateInputType | true
    _avg?: Planificacion_guardiasAvgAggregateInputType
    _sum?: Planificacion_guardiasSumAggregateInputType
    _min?: Planificacion_guardiasMinAggregateInputType
    _max?: Planificacion_guardiasMaxAggregateInputType
  }


  export type Planificacion_guardiasGroupByOutputType = {
    idturno: number
    lugar: string | null
    inicio: Date | null
    fin: Date | null
    horas: number | null
    operador: string | null
    mes_planificacion: string | null
    feriado: boolean | null
    tarea: string | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    ano_planificacion: number | null
    _count: Planificacion_guardiasCountAggregateOutputType | null
    _avg: Planificacion_guardiasAvgAggregateOutputType | null
    _sum: Planificacion_guardiasSumAggregateOutputType | null
    _min: Planificacion_guardiasMinAggregateOutputType | null
    _max: Planificacion_guardiasMaxAggregateOutputType | null
  }

  type GetPlanificacion_guardiasGroupByPayload<T extends planificacion_guardiasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Planificacion_guardiasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Planificacion_guardiasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Planificacion_guardiasGroupByOutputType[P]>
            : GetScalarType<T[P], Planificacion_guardiasGroupByOutputType[P]>
        }
      >
    >


  export type planificacion_guardiasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idturno?: boolean
    lugar?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    operador?: boolean
    mes_planificacion?: boolean
    feriado?: boolean
    tarea?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    ano_planificacion?: boolean
  }, ExtArgs["result"]["planificacion_guardias"]>

  export type planificacion_guardiasSelectScalar = {
    idturno?: boolean
    lugar?: boolean
    inicio?: boolean
    fin?: boolean
    horas?: boolean
    operador?: boolean
    mes_planificacion?: boolean
    feriado?: boolean
    tarea?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    ano_planificacion?: boolean
  }


  type planificacion_guardiasGetPayload<S extends boolean | null | undefined | planificacion_guardiasArgs> = $Types.GetResult<planificacion_guardiasPayload, S>

  type planificacion_guardiasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<planificacion_guardiasFindManyArgs, 'select' | 'include'> & {
      select?: Planificacion_guardiasCountAggregateInputType | true
    }

  export interface planificacion_guardiasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['planificacion_guardias'], meta: { name: 'planificacion_guardias' } }
    /**
     * Find zero or one Planificacion_guardias that matches the filter.
     * @param {planificacion_guardiasFindUniqueArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends planificacion_guardiasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, planificacion_guardiasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'planificacion_guardias'> extends True ? Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Planificacion_guardias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {planificacion_guardiasFindUniqueOrThrowArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends planificacion_guardiasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planificacion_guardiasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Planificacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindFirstArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends planificacion_guardiasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, planificacion_guardiasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'planificacion_guardias'> extends True ? Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Planificacion_guardias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindFirstOrThrowArgs} args - Arguments to find a Planificacion_guardias
     * @example
     * // Get one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends planificacion_guardiasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, planificacion_guardiasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Planificacion_guardias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findMany()
     * 
     * // Get first 10 Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.findMany({ take: 10 })
     * 
     * // Only select the `idturno`
     * const planificacion_guardiasWithIdturnoOnly = await prisma.planificacion_guardias.findMany({ select: { idturno: true } })
     * 
    **/
    findMany<T extends planificacion_guardiasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planificacion_guardiasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Planificacion_guardias.
     * @param {planificacion_guardiasCreateArgs} args - Arguments to create a Planificacion_guardias.
     * @example
     * // Create one Planificacion_guardias
     * const Planificacion_guardias = await prisma.planificacion_guardias.create({
     *   data: {
     *     // ... data to create a Planificacion_guardias
     *   }
     * })
     * 
    **/
    create<T extends planificacion_guardiasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, planificacion_guardiasCreateArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Planificacion_guardias.
     *     @param {planificacion_guardiasCreateManyArgs} args - Arguments to create many Planificacion_guardias.
     *     @example
     *     // Create many Planificacion_guardias
     *     const planificacion_guardias = await prisma.planificacion_guardias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends planificacion_guardiasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planificacion_guardiasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Planificacion_guardias.
     * @param {planificacion_guardiasDeleteArgs} args - Arguments to delete one Planificacion_guardias.
     * @example
     * // Delete one Planificacion_guardias
     * const Planificacion_guardias = await prisma.planificacion_guardias.delete({
     *   where: {
     *     // ... filter to delete one Planificacion_guardias
     *   }
     * })
     * 
    **/
    delete<T extends planificacion_guardiasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, planificacion_guardiasDeleteArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Planificacion_guardias.
     * @param {planificacion_guardiasUpdateArgs} args - Arguments to update one Planificacion_guardias.
     * @example
     * // Update one Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends planificacion_guardiasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, planificacion_guardiasUpdateArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Planificacion_guardias.
     * @param {planificacion_guardiasDeleteManyArgs} args - Arguments to filter Planificacion_guardias to delete.
     * @example
     * // Delete a few Planificacion_guardias
     * const { count } = await prisma.planificacion_guardias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends planificacion_guardiasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, planificacion_guardiasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends planificacion_guardiasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, planificacion_guardiasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planificacion_guardias.
     * @param {planificacion_guardiasUpsertArgs} args - Arguments to update or create a Planificacion_guardias.
     * @example
     * // Update or create a Planificacion_guardias
     * const planificacion_guardias = await prisma.planificacion_guardias.upsert({
     *   create: {
     *     // ... data to create a Planificacion_guardias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planificacion_guardias we want to update
     *   }
     * })
    **/
    upsert<T extends planificacion_guardiasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, planificacion_guardiasUpsertArgs<ExtArgs>>
    ): Prisma__planificacion_guardiasClient<$Types.GetResult<planificacion_guardiasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasCountArgs} args - Arguments to filter Planificacion_guardias to count.
     * @example
     * // Count the number of Planificacion_guardias
     * const count = await prisma.planificacion_guardias.count({
     *   where: {
     *     // ... the filter for the Planificacion_guardias we want to count
     *   }
     * })
    **/
    count<T extends planificacion_guardiasCountArgs>(
      args?: Subset<T, planificacion_guardiasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Planificacion_guardiasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Planificacion_guardiasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Planificacion_guardiasAggregateArgs>(args: Subset<T, Planificacion_guardiasAggregateArgs>): Prisma.PrismaPromise<GetPlanificacion_guardiasAggregateType<T>>

    /**
     * Group by Planificacion_guardias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planificacion_guardiasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planificacion_guardiasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planificacion_guardiasGroupByArgs['orderBy'] }
        : { orderBy?: planificacion_guardiasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planificacion_guardiasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanificacion_guardiasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for planificacion_guardias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__planificacion_guardiasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * planificacion_guardias base type for findUnique actions
   */
  export type planificacion_guardiasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where: planificacion_guardiasWhereUniqueInput
  }

  /**
   * planificacion_guardias findUnique
   */
  export interface planificacion_guardiasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends planificacion_guardiasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planificacion_guardias findUniqueOrThrow
   */
  export type planificacion_guardiasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias base type for findFirst actions
   */
  export type planificacion_guardiasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: planificacion_guardiasOrderByWithRelationInput | planificacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planificacion_guardias.
     */
    distinct?: Planificacion_guardiasScalarFieldEnum | Planificacion_guardiasScalarFieldEnum[]
  }

  /**
   * planificacion_guardias findFirst
   */
  export interface planificacion_guardiasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends planificacion_guardiasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * planificacion_guardias findFirstOrThrow
   */
  export type planificacion_guardiasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: planificacion_guardiasOrderByWithRelationInput | planificacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of planificacion_guardias.
     */
    distinct?: Planificacion_guardiasScalarFieldEnum | Planificacion_guardiasScalarFieldEnum[]
  }


  /**
   * planificacion_guardias findMany
   */
  export type planificacion_guardiasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter, which planificacion_guardias to fetch.
     */
    where?: planificacion_guardiasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of planificacion_guardias to fetch.
     */
    orderBy?: planificacion_guardiasOrderByWithRelationInput | planificacion_guardiasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing planificacion_guardias.
     */
    cursor?: planificacion_guardiasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` planificacion_guardias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` planificacion_guardias.
     */
    skip?: number
    distinct?: Planificacion_guardiasScalarFieldEnum | Planificacion_guardiasScalarFieldEnum[]
  }


  /**
   * planificacion_guardias create
   */
  export type planificacion_guardiasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * The data needed to create a planificacion_guardias.
     */
    data?: XOR<planificacion_guardiasCreateInput, planificacion_guardiasUncheckedCreateInput>
  }


  /**
   * planificacion_guardias createMany
   */
  export type planificacion_guardiasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many planificacion_guardias.
     */
    data: planificacion_guardiasCreateManyInput | planificacion_guardiasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * planificacion_guardias update
   */
  export type planificacion_guardiasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * The data needed to update a planificacion_guardias.
     */
    data: XOR<planificacion_guardiasUpdateInput, planificacion_guardiasUncheckedUpdateInput>
    /**
     * Choose, which planificacion_guardias to update.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias updateMany
   */
  export type planificacion_guardiasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update planificacion_guardias.
     */
    data: XOR<planificacion_guardiasUpdateManyMutationInput, planificacion_guardiasUncheckedUpdateManyInput>
    /**
     * Filter which planificacion_guardias to update
     */
    where?: planificacion_guardiasWhereInput
  }


  /**
   * planificacion_guardias upsert
   */
  export type planificacion_guardiasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * The filter to search for the planificacion_guardias to update in case it exists.
     */
    where: planificacion_guardiasWhereUniqueInput
    /**
     * In case the planificacion_guardias found by the `where` argument doesn't exist, create a new planificacion_guardias with this data.
     */
    create: XOR<planificacion_guardiasCreateInput, planificacion_guardiasUncheckedCreateInput>
    /**
     * In case the planificacion_guardias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planificacion_guardiasUpdateInput, planificacion_guardiasUncheckedUpdateInput>
  }


  /**
   * planificacion_guardias delete
   */
  export type planificacion_guardiasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
    /**
     * Filter which planificacion_guardias to delete.
     */
    where: planificacion_guardiasWhereUniqueInput
  }


  /**
   * planificacion_guardias deleteMany
   */
  export type planificacion_guardiasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which planificacion_guardias to delete
     */
    where?: planificacion_guardiasWhereInput
  }


  /**
   * planificacion_guardias without action
   */
  export type planificacion_guardiasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the planificacion_guardias
     */
    select?: planificacion_guardiasSelect<ExtArgs> | null
  }



  /**
   * Model precio_servicio
   */


  export type AggregatePrecio_servicio = {
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  export type Precio_servicioAvgAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioSumAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
  }

  export type Precio_servicioMinAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioMaxAggregateOutputType = {
    idprecio: number | null
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
  }

  export type Precio_servicioCountAggregateOutputType = {
    idprecio: number
    codigo: number
    contado: number
    contado_cremacion: number
    descuento1: number
    descuento1_cremacion: number
    descuento2: number
    descuento2_cremacion: number
    fecha_vigencia: number
    _all: number
  }


  export type Precio_servicioAvgAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioSumAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
  }

  export type Precio_servicioMinAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioMaxAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
  }

  export type Precio_servicioCountAggregateInputType = {
    idprecio?: true
    codigo?: true
    contado?: true
    contado_cremacion?: true
    descuento1?: true
    descuento1_cremacion?: true
    descuento2?: true
    descuento2_cremacion?: true
    fecha_vigencia?: true
    _all?: true
  }

  export type Precio_servicioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which precio_servicio to aggregate.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned precio_servicios
    **/
    _count?: true | Precio_servicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Precio_servicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Precio_servicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Precio_servicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Precio_servicioMaxAggregateInputType
  }

  export type GetPrecio_servicioAggregateType<T extends Precio_servicioAggregateArgs> = {
        [P in keyof T & keyof AggregatePrecio_servicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrecio_servicio[P]>
      : GetScalarType<T[P], AggregatePrecio_servicio[P]>
  }




  export type precio_servicioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: precio_servicioWhereInput
    orderBy?: precio_servicioOrderByWithAggregationInput | precio_servicioOrderByWithAggregationInput[]
    by: Precio_servicioScalarFieldEnum[] | Precio_servicioScalarFieldEnum
    having?: precio_servicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Precio_servicioCountAggregateInputType | true
    _avg?: Precio_servicioAvgAggregateInputType
    _sum?: Precio_servicioSumAggregateInputType
    _min?: Precio_servicioMinAggregateInputType
    _max?: Precio_servicioMaxAggregateInputType
  }


  export type Precio_servicioGroupByOutputType = {
    idprecio: number
    codigo: number | null
    contado: number | null
    contado_cremacion: number | null
    descuento1: number | null
    descuento1_cremacion: number | null
    descuento2: number | null
    descuento2_cremacion: number | null
    fecha_vigencia: Date | null
    _count: Precio_servicioCountAggregateOutputType | null
    _avg: Precio_servicioAvgAggregateOutputType | null
    _sum: Precio_servicioSumAggregateOutputType | null
    _min: Precio_servicioMinAggregateOutputType | null
    _max: Precio_servicioMaxAggregateOutputType | null
  }

  type GetPrecio_servicioGroupByPayload<T extends precio_servicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Precio_servicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Precio_servicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
            : GetScalarType<T[P], Precio_servicioGroupByOutputType[P]>
        }
      >
    >


  export type precio_servicioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprecio?: boolean
    codigo?: boolean
    contado?: boolean
    contado_cremacion?: boolean
    descuento1?: boolean
    descuento1_cremacion?: boolean
    descuento2?: boolean
    descuento2_cremacion?: boolean
    fecha_vigencia?: boolean
  }, ExtArgs["result"]["precio_servicio"]>

  export type precio_servicioSelectScalar = {
    idprecio?: boolean
    codigo?: boolean
    contado?: boolean
    contado_cremacion?: boolean
    descuento1?: boolean
    descuento1_cremacion?: boolean
    descuento2?: boolean
    descuento2_cremacion?: boolean
    fecha_vigencia?: boolean
  }


  type precio_servicioGetPayload<S extends boolean | null | undefined | precio_servicioArgs> = $Types.GetResult<precio_servicioPayload, S>

  type precio_servicioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<precio_servicioFindManyArgs, 'select' | 'include'> & {
      select?: Precio_servicioCountAggregateInputType | true
    }

  export interface precio_servicioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['precio_servicio'], meta: { name: 'precio_servicio' } }
    /**
     * Find zero or one Precio_servicio that matches the filter.
     * @param {precio_servicioFindUniqueArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends precio_servicioFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, precio_servicioFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Precio_servicio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {precio_servicioFindUniqueOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends precio_servicioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Precio_servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends precio_servicioFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, precio_servicioFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'precio_servicio'> extends True ? Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Precio_servicio that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindFirstOrThrowArgs} args - Arguments to find a Precio_servicio
     * @example
     * // Get one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends precio_servicioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Precio_servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany()
     * 
     * // Get first 10 Precio_servicios
     * const precio_servicios = await prisma.precio_servicio.findMany({ take: 10 })
     * 
     * // Only select the `idprecio`
     * const precio_servicioWithIdprecioOnly = await prisma.precio_servicio.findMany({ select: { idprecio: true } })
     * 
    **/
    findMany<T extends precio_servicioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Precio_servicio.
     * @param {precio_servicioCreateArgs} args - Arguments to create a Precio_servicio.
     * @example
     * // Create one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.create({
     *   data: {
     *     // ... data to create a Precio_servicio
     *   }
     * })
     * 
    **/
    create<T extends precio_servicioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioCreateArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Precio_servicios.
     *     @param {precio_servicioCreateManyArgs} args - Arguments to create many Precio_servicios.
     *     @example
     *     // Create many Precio_servicios
     *     const precio_servicio = await prisma.precio_servicio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends precio_servicioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Precio_servicio.
     * @param {precio_servicioDeleteArgs} args - Arguments to delete one Precio_servicio.
     * @example
     * // Delete one Precio_servicio
     * const Precio_servicio = await prisma.precio_servicio.delete({
     *   where: {
     *     // ... filter to delete one Precio_servicio
     *   }
     * })
     * 
    **/
    delete<T extends precio_servicioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioDeleteArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Precio_servicio.
     * @param {precio_servicioUpdateArgs} args - Arguments to update one Precio_servicio.
     * @example
     * // Update one Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends precio_servicioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpdateArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Precio_servicios.
     * @param {precio_servicioDeleteManyArgs} args - Arguments to filter Precio_servicios to delete.
     * @example
     * // Delete a few Precio_servicios
     * const { count } = await prisma.precio_servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends precio_servicioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, precio_servicioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Precio_servicios
     * const precio_servicio = await prisma.precio_servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends precio_servicioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Precio_servicio.
     * @param {precio_servicioUpsertArgs} args - Arguments to update or create a Precio_servicio.
     * @example
     * // Update or create a Precio_servicio
     * const precio_servicio = await prisma.precio_servicio.upsert({
     *   create: {
     *     // ... data to create a Precio_servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Precio_servicio we want to update
     *   }
     * })
    **/
    upsert<T extends precio_servicioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, precio_servicioUpsertArgs<ExtArgs>>
    ): Prisma__precio_servicioClient<$Types.GetResult<precio_servicioPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Precio_servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioCountArgs} args - Arguments to filter Precio_servicios to count.
     * @example
     * // Count the number of Precio_servicios
     * const count = await prisma.precio_servicio.count({
     *   where: {
     *     // ... the filter for the Precio_servicios we want to count
     *   }
     * })
    **/
    count<T extends precio_servicioCountArgs>(
      args?: Subset<T, precio_servicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Precio_servicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Precio_servicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Precio_servicioAggregateArgs>(args: Subset<T, Precio_servicioAggregateArgs>): Prisma.PrismaPromise<GetPrecio_servicioAggregateType<T>>

    /**
     * Group by Precio_servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {precio_servicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends precio_servicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: precio_servicioGroupByArgs['orderBy'] }
        : { orderBy?: precio_servicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, precio_servicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrecio_servicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for precio_servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__precio_servicioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * precio_servicio base type for findUnique actions
   */
  export type precio_servicioFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }

  /**
   * precio_servicio findUnique
   */
  export interface precio_servicioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends precio_servicioFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findUniqueOrThrow
   */
  export type precio_servicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio base type for findFirst actions
   */
  export type precio_servicioFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }

  /**
   * precio_servicio findFirst
   */
  export interface precio_servicioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends precio_servicioFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * precio_servicio findFirstOrThrow
   */
  export type precio_servicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicio to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of precio_servicios.
     */
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }


  /**
   * precio_servicio findMany
   */
  export type precio_servicioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter, which precio_servicios to fetch.
     */
    where?: precio_servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of precio_servicios to fetch.
     */
    orderBy?: precio_servicioOrderByWithRelationInput | precio_servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing precio_servicios.
     */
    cursor?: precio_servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` precio_servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` precio_servicios.
     */
    skip?: number
    distinct?: Precio_servicioScalarFieldEnum | Precio_servicioScalarFieldEnum[]
  }


  /**
   * precio_servicio create
   */
  export type precio_servicioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The data needed to create a precio_servicio.
     */
    data?: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
  }


  /**
   * precio_servicio createMany
   */
  export type precio_servicioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many precio_servicios.
     */
    data: precio_servicioCreateManyInput | precio_servicioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * precio_servicio update
   */
  export type precio_servicioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The data needed to update a precio_servicio.
     */
    data: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
    /**
     * Choose, which precio_servicio to update.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio updateMany
   */
  export type precio_servicioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update precio_servicios.
     */
    data: XOR<precio_servicioUpdateManyMutationInput, precio_servicioUncheckedUpdateManyInput>
    /**
     * Filter which precio_servicios to update
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio upsert
   */
  export type precio_servicioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * The filter to search for the precio_servicio to update in case it exists.
     */
    where: precio_servicioWhereUniqueInput
    /**
     * In case the precio_servicio found by the `where` argument doesn't exist, create a new precio_servicio with this data.
     */
    create: XOR<precio_servicioCreateInput, precio_servicioUncheckedCreateInput>
    /**
     * In case the precio_servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<precio_servicioUpdateInput, precio_servicioUncheckedUpdateInput>
  }


  /**
   * precio_servicio delete
   */
  export type precio_servicioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
    /**
     * Filter which precio_servicio to delete.
     */
    where: precio_servicioWhereUniqueInput
  }


  /**
   * precio_servicio deleteMany
   */
  export type precio_servicioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which precio_servicios to delete
     */
    where?: precio_servicioWhereInput
  }


  /**
   * precio_servicio without action
   */
  export type precio_servicioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the precio_servicio
     */
    select?: precio_servicioSelect<ExtArgs> | null
  }



  /**
   * Model proveedores
   */


  export type AggregateProveedores = {
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  export type ProveedoresAvgAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresSumAggregateOutputType = {
    idproveedor: number | null
    estado: number | null
  }

  export type ProveedoresMinAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresMaxAggregateOutputType = {
    idproveedor: number | null
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
  }

  export type ProveedoresCountAggregateOutputType = {
    idproveedor: number
    razon: number
    cuit: number
    domicilio: number
    telefonos: number
    estado: number
    operador: number
    _all: number
  }


  export type ProveedoresAvgAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresSumAggregateInputType = {
    idproveedor?: true
    estado?: true
  }

  export type ProveedoresMinAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresMaxAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
  }

  export type ProveedoresCountAggregateInputType = {
    idproveedor?: true
    razon?: true
    cuit?: true
    domicilio?: true
    telefonos?: true
    estado?: true
    operador?: true
    _all?: true
  }

  export type ProveedoresAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to aggregate.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedores
    **/
    _count?: true | ProveedoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedoresMaxAggregateInputType
  }

  export type GetProveedoresAggregateType<T extends ProveedoresAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedores[P]>
      : GetScalarType<T[P], AggregateProveedores[P]>
  }




  export type proveedoresGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: proveedoresWhereInput
    orderBy?: proveedoresOrderByWithAggregationInput | proveedoresOrderByWithAggregationInput[]
    by: ProveedoresScalarFieldEnum[] | ProveedoresScalarFieldEnum
    having?: proveedoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedoresCountAggregateInputType | true
    _avg?: ProveedoresAvgAggregateInputType
    _sum?: ProveedoresSumAggregateInputType
    _min?: ProveedoresMinAggregateInputType
    _max?: ProveedoresMaxAggregateInputType
  }


  export type ProveedoresGroupByOutputType = {
    idproveedor: number
    razon: string | null
    cuit: string | null
    domicilio: string | null
    telefonos: string | null
    estado: number | null
    operador: string | null
    _count: ProveedoresCountAggregateOutputType | null
    _avg: ProveedoresAvgAggregateOutputType | null
    _sum: ProveedoresSumAggregateOutputType | null
    _min: ProveedoresMinAggregateOutputType | null
    _max: ProveedoresMaxAggregateOutputType | null
  }

  type GetProveedoresGroupByPayload<T extends proveedoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedoresGroupByOutputType[P]>
        }
      >
    >


  export type proveedoresSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idproveedor?: boolean
    razon?: boolean
    cuit?: boolean
    domicilio?: boolean
    telefonos?: boolean
    estado?: boolean
    operador?: boolean
  }, ExtArgs["result"]["proveedores"]>

  export type proveedoresSelectScalar = {
    idproveedor?: boolean
    razon?: boolean
    cuit?: boolean
    domicilio?: boolean
    telefonos?: boolean
    estado?: boolean
    operador?: boolean
  }


  type proveedoresGetPayload<S extends boolean | null | undefined | proveedoresArgs> = $Types.GetResult<proveedoresPayload, S>

  type proveedoresCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<proveedoresFindManyArgs, 'select' | 'include'> & {
      select?: ProveedoresCountAggregateInputType | true
    }

  export interface proveedoresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedores'], meta: { name: 'proveedores' } }
    /**
     * Find zero or one Proveedores that matches the filter.
     * @param {proveedoresFindUniqueArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proveedoresFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, proveedoresFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'proveedores'> extends True ? Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Proveedores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {proveedoresFindUniqueOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends proveedoresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proveedoresFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, proveedoresFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'proveedores'> extends True ? Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Proveedores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindFirstOrThrowArgs} args - Arguments to find a Proveedores
     * @example
     * // Get one Proveedores
     * const proveedores = await prisma.proveedores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends proveedoresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Proveedores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedores
     * const proveedores = await prisma.proveedores.findMany()
     * 
     * // Get first 10 Proveedores
     * const proveedores = await prisma.proveedores.findMany({ take: 10 })
     * 
     * // Only select the `idproveedor`
     * const proveedoresWithIdproveedorOnly = await prisma.proveedores.findMany({ select: { idproveedor: true } })
     * 
    **/
    findMany<T extends proveedoresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Proveedores.
     * @param {proveedoresCreateArgs} args - Arguments to create a Proveedores.
     * @example
     * // Create one Proveedores
     * const Proveedores = await prisma.proveedores.create({
     *   data: {
     *     // ... data to create a Proveedores
     *   }
     * })
     * 
    **/
    create<T extends proveedoresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresCreateArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Proveedores.
     *     @param {proveedoresCreateManyArgs} args - Arguments to create many Proveedores.
     *     @example
     *     // Create many Proveedores
     *     const proveedores = await prisma.proveedores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proveedoresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedores.
     * @param {proveedoresDeleteArgs} args - Arguments to delete one Proveedores.
     * @example
     * // Delete one Proveedores
     * const Proveedores = await prisma.proveedores.delete({
     *   where: {
     *     // ... filter to delete one Proveedores
     *   }
     * })
     * 
    **/
    delete<T extends proveedoresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresDeleteArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Proveedores.
     * @param {proveedoresUpdateArgs} args - Arguments to update one Proveedores.
     * @example
     * // Update one Proveedores
     * const proveedores = await prisma.proveedores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proveedoresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpdateArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Proveedores.
     * @param {proveedoresDeleteManyArgs} args - Arguments to filter Proveedores to delete.
     * @example
     * // Delete a few Proveedores
     * const { count } = await prisma.proveedores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proveedoresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedoresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedores
     * const proveedores = await prisma.proveedores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proveedoresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedores.
     * @param {proveedoresUpsertArgs} args - Arguments to update or create a Proveedores.
     * @example
     * // Update or create a Proveedores
     * const proveedores = await prisma.proveedores.upsert({
     *   create: {
     *     // ... data to create a Proveedores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedores we want to update
     *   }
     * })
    **/
    upsert<T extends proveedoresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, proveedoresUpsertArgs<ExtArgs>>
    ): Prisma__proveedoresClient<$Types.GetResult<proveedoresPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresCountArgs} args - Arguments to filter Proveedores to count.
     * @example
     * // Count the number of Proveedores
     * const count = await prisma.proveedores.count({
     *   where: {
     *     // ... the filter for the Proveedores we want to count
     *   }
     * })
    **/
    count<T extends proveedoresCountArgs>(
      args?: Subset<T, proveedoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedoresAggregateArgs>(args: Subset<T, ProveedoresAggregateArgs>): Prisma.PrismaPromise<GetProveedoresAggregateType<T>>

    /**
     * Group by Proveedores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedoresGroupByArgs['orderBy'] }
        : { orderBy?: proveedoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__proveedoresClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * proveedores base type for findUnique actions
   */
  export type proveedoresFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }

  /**
   * proveedores findUnique
   */
  export interface proveedoresFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends proveedoresFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findUniqueOrThrow
   */
  export type proveedoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores base type for findFirst actions
   */
  export type proveedoresFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }

  /**
   * proveedores findFirst
   */
  export interface proveedoresFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends proveedoresFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * proveedores findFirstOrThrow
   */
  export type proveedoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedores.
     */
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }


  /**
   * proveedores findMany
   */
  export type proveedoresFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter, which proveedores to fetch.
     */
    where?: proveedoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedores to fetch.
     */
    orderBy?: proveedoresOrderByWithRelationInput | proveedoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedores.
     */
    cursor?: proveedoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedores.
     */
    skip?: number
    distinct?: ProveedoresScalarFieldEnum | ProveedoresScalarFieldEnum[]
  }


  /**
   * proveedores create
   */
  export type proveedoresCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The data needed to create a proveedores.
     */
    data?: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
  }


  /**
   * proveedores createMany
   */
  export type proveedoresCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedores.
     */
    data: proveedoresCreateManyInput | proveedoresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * proveedores update
   */
  export type proveedoresUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The data needed to update a proveedores.
     */
    data: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
    /**
     * Choose, which proveedores to update.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores updateMany
   */
  export type proveedoresUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedores.
     */
    data: XOR<proveedoresUpdateManyMutationInput, proveedoresUncheckedUpdateManyInput>
    /**
     * Filter which proveedores to update
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores upsert
   */
  export type proveedoresUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * The filter to search for the proveedores to update in case it exists.
     */
    where: proveedoresWhereUniqueInput
    /**
     * In case the proveedores found by the `where` argument doesn't exist, create a new proveedores with this data.
     */
    create: XOR<proveedoresCreateInput, proveedoresUncheckedCreateInput>
    /**
     * In case the proveedores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedoresUpdateInput, proveedoresUncheckedUpdateInput>
  }


  /**
   * proveedores delete
   */
  export type proveedoresDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
    /**
     * Filter which proveedores to delete.
     */
    where: proveedoresWhereUniqueInput
  }


  /**
   * proveedores deleteMany
   */
  export type proveedoresDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedores to delete
     */
    where?: proveedoresWhereInput
  }


  /**
   * proveedores without action
   */
  export type proveedoresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedores
     */
    select?: proveedoresSelect<ExtArgs> | null
  }



  /**
   * Model servicio_detalles
   */


  export type AggregateServicio_detalles = {
    _count: Servicio_detallesCountAggregateOutputType | null
    _avg: Servicio_detallesAvgAggregateOutputType | null
    _sum: Servicio_detallesSumAggregateOutputType | null
    _min: Servicio_detallesMinAggregateOutputType | null
    _max: Servicio_detallesMaxAggregateOutputType | null
  }

  export type Servicio_detallesAvgAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
  }

  export type Servicio_detallesSumAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
  }

  export type Servicio_detallesMinAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
  }

  export type Servicio_detallesMaxAggregateOutputType = {
    iddetalles: number | null
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
  }

  export type Servicio_detallesCountAggregateOutputType = {
    iddetalles: number
    idservicio: number
    detalle: number
    lugar: number
    monto: number
    patente: number
    operador: number
    fecha: number
    observacion: number
    _all: number
  }


  export type Servicio_detallesAvgAggregateInputType = {
    iddetalles?: true
    idservicio?: true
  }

  export type Servicio_detallesSumAggregateInputType = {
    iddetalles?: true
    idservicio?: true
  }

  export type Servicio_detallesMinAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
  }

  export type Servicio_detallesMaxAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
  }

  export type Servicio_detallesCountAggregateInputType = {
    iddetalles?: true
    idservicio?: true
    detalle?: true
    lugar?: true
    monto?: true
    patente?: true
    operador?: true
    fecha?: true
    observacion?: true
    _all?: true
  }

  export type Servicio_detallesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_detalles to aggregate.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: servicio_detallesOrderByWithRelationInput | servicio_detallesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_detalles
    **/
    _count?: true | Servicio_detallesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_detallesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_detallesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_detallesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_detallesMaxAggregateInputType
  }

  export type GetServicio_detallesAggregateType<T extends Servicio_detallesAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_detalles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_detalles[P]>
      : GetScalarType<T[P], AggregateServicio_detalles[P]>
  }




  export type servicio_detallesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_detallesWhereInput
    orderBy?: servicio_detallesOrderByWithAggregationInput | servicio_detallesOrderByWithAggregationInput[]
    by: Servicio_detallesScalarFieldEnum[] | Servicio_detallesScalarFieldEnum
    having?: servicio_detallesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_detallesCountAggregateInputType | true
    _avg?: Servicio_detallesAvgAggregateInputType
    _sum?: Servicio_detallesSumAggregateInputType
    _min?: Servicio_detallesMinAggregateInputType
    _max?: Servicio_detallesMaxAggregateInputType
  }


  export type Servicio_detallesGroupByOutputType = {
    iddetalles: number
    idservicio: number | null
    detalle: string | null
    lugar: string | null
    monto: string | null
    patente: string | null
    operador: string | null
    fecha: string | null
    observacion: string | null
    _count: Servicio_detallesCountAggregateOutputType | null
    _avg: Servicio_detallesAvgAggregateOutputType | null
    _sum: Servicio_detallesSumAggregateOutputType | null
    _min: Servicio_detallesMinAggregateOutputType | null
    _max: Servicio_detallesMaxAggregateOutputType | null
  }

  type GetServicio_detallesGroupByPayload<T extends servicio_detallesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_detallesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_detallesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_detallesGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_detallesGroupByOutputType[P]>
        }
      >
    >


  export type servicio_detallesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iddetalles?: boolean
    idservicio?: boolean
    detalle?: boolean
    lugar?: boolean
    monto?: boolean
    patente?: boolean
    operador?: boolean
    fecha?: boolean
    observacion?: boolean
  }, ExtArgs["result"]["servicio_detalles"]>

  export type servicio_detallesSelectScalar = {
    iddetalles?: boolean
    idservicio?: boolean
    detalle?: boolean
    lugar?: boolean
    monto?: boolean
    patente?: boolean
    operador?: boolean
    fecha?: boolean
    observacion?: boolean
  }


  type servicio_detallesGetPayload<S extends boolean | null | undefined | servicio_detallesArgs> = $Types.GetResult<servicio_detallesPayload, S>

  type servicio_detallesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_detallesFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_detallesCountAggregateInputType | true
    }

  export interface servicio_detallesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_detalles'], meta: { name: 'servicio_detalles' } }
    /**
     * Find zero or one Servicio_detalles that matches the filter.
     * @param {servicio_detallesFindUniqueArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_detallesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_detallesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_detalles'> extends True ? Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_detalles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_detallesFindUniqueOrThrowArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_detallesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_detallesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindFirstArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_detallesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_detallesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_detalles'> extends True ? Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_detalles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindFirstOrThrowArgs} args - Arguments to find a Servicio_detalles
     * @example
     * // Get one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_detallesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_detallesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findMany()
     * 
     * // Get first 10 Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.findMany({ take: 10 })
     * 
     * // Only select the `iddetalles`
     * const servicio_detallesWithIddetallesOnly = await prisma.servicio_detalles.findMany({ select: { iddetalles: true } })
     * 
    **/
    findMany<T extends servicio_detallesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_detallesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_detalles.
     * @param {servicio_detallesCreateArgs} args - Arguments to create a Servicio_detalles.
     * @example
     * // Create one Servicio_detalles
     * const Servicio_detalles = await prisma.servicio_detalles.create({
     *   data: {
     *     // ... data to create a Servicio_detalles
     *   }
     * })
     * 
    **/
    create<T extends servicio_detallesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_detallesCreateArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_detalles.
     *     @param {servicio_detallesCreateManyArgs} args - Arguments to create many Servicio_detalles.
     *     @example
     *     // Create many Servicio_detalles
     *     const servicio_detalles = await prisma.servicio_detalles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_detallesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_detallesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_detalles.
     * @param {servicio_detallesDeleteArgs} args - Arguments to delete one Servicio_detalles.
     * @example
     * // Delete one Servicio_detalles
     * const Servicio_detalles = await prisma.servicio_detalles.delete({
     *   where: {
     *     // ... filter to delete one Servicio_detalles
     *   }
     * })
     * 
    **/
    delete<T extends servicio_detallesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_detallesDeleteArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_detalles.
     * @param {servicio_detallesUpdateArgs} args - Arguments to update one Servicio_detalles.
     * @example
     * // Update one Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_detallesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_detallesUpdateArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_detalles.
     * @param {servicio_detallesDeleteManyArgs} args - Arguments to filter Servicio_detalles to delete.
     * @example
     * // Delete a few Servicio_detalles
     * const { count } = await prisma.servicio_detalles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_detallesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_detallesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_detallesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_detallesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_detalles.
     * @param {servicio_detallesUpsertArgs} args - Arguments to update or create a Servicio_detalles.
     * @example
     * // Update or create a Servicio_detalles
     * const servicio_detalles = await prisma.servicio_detalles.upsert({
     *   create: {
     *     // ... data to create a Servicio_detalles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_detalles we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_detallesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_detallesUpsertArgs<ExtArgs>>
    ): Prisma__servicio_detallesClient<$Types.GetResult<servicio_detallesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesCountArgs} args - Arguments to filter Servicio_detalles to count.
     * @example
     * // Count the number of Servicio_detalles
     * const count = await prisma.servicio_detalles.count({
     *   where: {
     *     // ... the filter for the Servicio_detalles we want to count
     *   }
     * })
    **/
    count<T extends servicio_detallesCountArgs>(
      args?: Subset<T, servicio_detallesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_detallesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_detallesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_detallesAggregateArgs>(args: Subset<T, Servicio_detallesAggregateArgs>): Prisma.PrismaPromise<GetServicio_detallesAggregateType<T>>

    /**
     * Group by Servicio_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_detallesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_detallesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_detallesGroupByArgs['orderBy'] }
        : { orderBy?: servicio_detallesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_detallesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_detallesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_detalles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_detallesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_detalles base type for findUnique actions
   */
  export type servicio_detallesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where: servicio_detallesWhereUniqueInput
  }

  /**
   * servicio_detalles findUnique
   */
  export interface servicio_detallesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_detallesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_detalles findUniqueOrThrow
   */
  export type servicio_detallesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles base type for findFirst actions
   */
  export type servicio_detallesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: servicio_detallesOrderByWithRelationInput | servicio_detallesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_detalles.
     */
    distinct?: Servicio_detallesScalarFieldEnum | Servicio_detallesScalarFieldEnum[]
  }

  /**
   * servicio_detalles findFirst
   */
  export interface servicio_detallesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_detallesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_detalles findFirstOrThrow
   */
  export type servicio_detallesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: servicio_detallesOrderByWithRelationInput | servicio_detallesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_detalles.
     */
    distinct?: Servicio_detallesScalarFieldEnum | Servicio_detallesScalarFieldEnum[]
  }


  /**
   * servicio_detalles findMany
   */
  export type servicio_detallesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter, which servicio_detalles to fetch.
     */
    where?: servicio_detallesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_detalles to fetch.
     */
    orderBy?: servicio_detallesOrderByWithRelationInput | servicio_detallesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_detalles.
     */
    cursor?: servicio_detallesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_detalles.
     */
    skip?: number
    distinct?: Servicio_detallesScalarFieldEnum | Servicio_detallesScalarFieldEnum[]
  }


  /**
   * servicio_detalles create
   */
  export type servicio_detallesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_detalles.
     */
    data?: XOR<servicio_detallesCreateInput, servicio_detallesUncheckedCreateInput>
  }


  /**
   * servicio_detalles createMany
   */
  export type servicio_detallesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_detalles.
     */
    data: servicio_detallesCreateManyInput | servicio_detallesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_detalles update
   */
  export type servicio_detallesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_detalles.
     */
    data: XOR<servicio_detallesUpdateInput, servicio_detallesUncheckedUpdateInput>
    /**
     * Choose, which servicio_detalles to update.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles updateMany
   */
  export type servicio_detallesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_detalles.
     */
    data: XOR<servicio_detallesUpdateManyMutationInput, servicio_detallesUncheckedUpdateManyInput>
    /**
     * Filter which servicio_detalles to update
     */
    where?: servicio_detallesWhereInput
  }


  /**
   * servicio_detalles upsert
   */
  export type servicio_detallesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_detalles to update in case it exists.
     */
    where: servicio_detallesWhereUniqueInput
    /**
     * In case the servicio_detalles found by the `where` argument doesn't exist, create a new servicio_detalles with this data.
     */
    create: XOR<servicio_detallesCreateInput, servicio_detallesUncheckedCreateInput>
    /**
     * In case the servicio_detalles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_detallesUpdateInput, servicio_detallesUncheckedUpdateInput>
  }


  /**
   * servicio_detalles delete
   */
  export type servicio_detallesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
    /**
     * Filter which servicio_detalles to delete.
     */
    where: servicio_detallesWhereUniqueInput
  }


  /**
   * servicio_detalles deleteMany
   */
  export type servicio_detallesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_detalles to delete
     */
    where?: servicio_detallesWhereInput
  }


  /**
   * servicio_detalles without action
   */
  export type servicio_detallesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_detalles
     */
    select?: servicio_detallesSelect<ExtArgs> | null
  }



  /**
   * Model servicio_gastos
   */


  export type AggregateServicio_gastos = {
    _count: Servicio_gastosCountAggregateOutputType | null
    _avg: Servicio_gastosAvgAggregateOutputType | null
    _sum: Servicio_gastosSumAggregateOutputType | null
    _min: Servicio_gastosMinAggregateOutputType | null
    _max: Servicio_gastosMaxAggregateOutputType | null
  }

  export type Servicio_gastosAvgAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
  }

  export type Servicio_gastosSumAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
  }

  export type Servicio_gastosMinAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
  }

  export type Servicio_gastosMaxAggregateOutputType = {
    idgastos: number | null
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
  }

  export type Servicio_gastosCountAggregateOutputType = {
    idgastos: number
    idservicio: number
    tipo_gasto: number
    horas: number
    operador: number
    observaciones: number
    inicio: number
    fin: number
    feriado: number
    liquidado: number
    operadorliq: number
    fecha_liquidacion: number
    aprobado: number
    operadorap: number
    fecha_aprobacion: number
    _all: number
  }


  export type Servicio_gastosAvgAggregateInputType = {
    idgastos?: true
    idservicio?: true
  }

  export type Servicio_gastosSumAggregateInputType = {
    idgastos?: true
    idservicio?: true
  }

  export type Servicio_gastosMinAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
  }

  export type Servicio_gastosMaxAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
  }

  export type Servicio_gastosCountAggregateInputType = {
    idgastos?: true
    idservicio?: true
    tipo_gasto?: true
    horas?: true
    operador?: true
    observaciones?: true
    inicio?: true
    fin?: true
    feriado?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    _all?: true
  }

  export type Servicio_gastosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_gastos to aggregate.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: servicio_gastosOrderByWithRelationInput | servicio_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_gastos
    **/
    _count?: true | Servicio_gastosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_gastosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_gastosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_gastosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_gastosMaxAggregateInputType
  }

  export type GetServicio_gastosAggregateType<T extends Servicio_gastosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_gastos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_gastos[P]>
      : GetScalarType<T[P], AggregateServicio_gastos[P]>
  }




  export type servicio_gastosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_gastosWhereInput
    orderBy?: servicio_gastosOrderByWithAggregationInput | servicio_gastosOrderByWithAggregationInput[]
    by: Servicio_gastosScalarFieldEnum[] | Servicio_gastosScalarFieldEnum
    having?: servicio_gastosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_gastosCountAggregateInputType | true
    _avg?: Servicio_gastosAvgAggregateInputType
    _sum?: Servicio_gastosSumAggregateInputType
    _min?: Servicio_gastosMinAggregateInputType
    _max?: Servicio_gastosMaxAggregateInputType
  }


  export type Servicio_gastosGroupByOutputType = {
    idgastos: number
    idservicio: number | null
    tipo_gasto: string | null
    horas: Date | null
    operador: string | null
    observaciones: string | null
    inicio: string | null
    fin: string | null
    feriado: boolean | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    _count: Servicio_gastosCountAggregateOutputType | null
    _avg: Servicio_gastosAvgAggregateOutputType | null
    _sum: Servicio_gastosSumAggregateOutputType | null
    _min: Servicio_gastosMinAggregateOutputType | null
    _max: Servicio_gastosMaxAggregateOutputType | null
  }

  type GetServicio_gastosGroupByPayload<T extends servicio_gastosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_gastosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_gastosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_gastosGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_gastosGroupByOutputType[P]>
        }
      >
    >


  export type servicio_gastosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgastos?: boolean
    idservicio?: boolean
    tipo_gasto?: boolean
    horas?: boolean
    operador?: boolean
    observaciones?: boolean
    inicio?: boolean
    fin?: boolean
    feriado?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
  }, ExtArgs["result"]["servicio_gastos"]>

  export type servicio_gastosSelectScalar = {
    idgastos?: boolean
    idservicio?: boolean
    tipo_gasto?: boolean
    horas?: boolean
    operador?: boolean
    observaciones?: boolean
    inicio?: boolean
    fin?: boolean
    feriado?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
  }


  type servicio_gastosGetPayload<S extends boolean | null | undefined | servicio_gastosArgs> = $Types.GetResult<servicio_gastosPayload, S>

  type servicio_gastosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_gastosFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_gastosCountAggregateInputType | true
    }

  export interface servicio_gastosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_gastos'], meta: { name: 'servicio_gastos' } }
    /**
     * Find zero or one Servicio_gastos that matches the filter.
     * @param {servicio_gastosFindUniqueArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_gastosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_gastosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_gastos'> extends True ? Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_gastos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_gastosFindUniqueOrThrowArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_gastosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_gastosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindFirstArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_gastosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_gastosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_gastos'> extends True ? Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_gastos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindFirstOrThrowArgs} args - Arguments to find a Servicio_gastos
     * @example
     * // Get one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_gastosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_gastosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_gastos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findMany()
     * 
     * // Get first 10 Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.findMany({ take: 10 })
     * 
     * // Only select the `idgastos`
     * const servicio_gastosWithIdgastosOnly = await prisma.servicio_gastos.findMany({ select: { idgastos: true } })
     * 
    **/
    findMany<T extends servicio_gastosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_gastosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_gastos.
     * @param {servicio_gastosCreateArgs} args - Arguments to create a Servicio_gastos.
     * @example
     * // Create one Servicio_gastos
     * const Servicio_gastos = await prisma.servicio_gastos.create({
     *   data: {
     *     // ... data to create a Servicio_gastos
     *   }
     * })
     * 
    **/
    create<T extends servicio_gastosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_gastosCreateArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_gastos.
     *     @param {servicio_gastosCreateManyArgs} args - Arguments to create many Servicio_gastos.
     *     @example
     *     // Create many Servicio_gastos
     *     const servicio_gastos = await prisma.servicio_gastos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_gastosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_gastosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_gastos.
     * @param {servicio_gastosDeleteArgs} args - Arguments to delete one Servicio_gastos.
     * @example
     * // Delete one Servicio_gastos
     * const Servicio_gastos = await prisma.servicio_gastos.delete({
     *   where: {
     *     // ... filter to delete one Servicio_gastos
     *   }
     * })
     * 
    **/
    delete<T extends servicio_gastosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_gastosDeleteArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_gastos.
     * @param {servicio_gastosUpdateArgs} args - Arguments to update one Servicio_gastos.
     * @example
     * // Update one Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_gastosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_gastosUpdateArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_gastos.
     * @param {servicio_gastosDeleteManyArgs} args - Arguments to filter Servicio_gastos to delete.
     * @example
     * // Delete a few Servicio_gastos
     * const { count } = await prisma.servicio_gastos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_gastosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_gastosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_gastosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_gastosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_gastos.
     * @param {servicio_gastosUpsertArgs} args - Arguments to update or create a Servicio_gastos.
     * @example
     * // Update or create a Servicio_gastos
     * const servicio_gastos = await prisma.servicio_gastos.upsert({
     *   create: {
     *     // ... data to create a Servicio_gastos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_gastos we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_gastosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_gastosUpsertArgs<ExtArgs>>
    ): Prisma__servicio_gastosClient<$Types.GetResult<servicio_gastosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosCountArgs} args - Arguments to filter Servicio_gastos to count.
     * @example
     * // Count the number of Servicio_gastos
     * const count = await prisma.servicio_gastos.count({
     *   where: {
     *     // ... the filter for the Servicio_gastos we want to count
     *   }
     * })
    **/
    count<T extends servicio_gastosCountArgs>(
      args?: Subset<T, servicio_gastosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_gastosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_gastosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_gastosAggregateArgs>(args: Subset<T, Servicio_gastosAggregateArgs>): Prisma.PrismaPromise<GetServicio_gastosAggregateType<T>>

    /**
     * Group by Servicio_gastos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_gastosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_gastosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_gastosGroupByArgs['orderBy'] }
        : { orderBy?: servicio_gastosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_gastosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_gastosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_gastos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_gastosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_gastos base type for findUnique actions
   */
  export type servicio_gastosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where: servicio_gastosWhereUniqueInput
  }

  /**
   * servicio_gastos findUnique
   */
  export interface servicio_gastosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_gastosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_gastos findUniqueOrThrow
   */
  export type servicio_gastosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos base type for findFirst actions
   */
  export type servicio_gastosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: servicio_gastosOrderByWithRelationInput | servicio_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_gastos.
     */
    distinct?: Servicio_gastosScalarFieldEnum | Servicio_gastosScalarFieldEnum[]
  }

  /**
   * servicio_gastos findFirst
   */
  export interface servicio_gastosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_gastosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_gastos findFirstOrThrow
   */
  export type servicio_gastosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: servicio_gastosOrderByWithRelationInput | servicio_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_gastos.
     */
    distinct?: Servicio_gastosScalarFieldEnum | Servicio_gastosScalarFieldEnum[]
  }


  /**
   * servicio_gastos findMany
   */
  export type servicio_gastosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter, which servicio_gastos to fetch.
     */
    where?: servicio_gastosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_gastos to fetch.
     */
    orderBy?: servicio_gastosOrderByWithRelationInput | servicio_gastosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_gastos.
     */
    cursor?: servicio_gastosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_gastos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_gastos.
     */
    skip?: number
    distinct?: Servicio_gastosScalarFieldEnum | Servicio_gastosScalarFieldEnum[]
  }


  /**
   * servicio_gastos create
   */
  export type servicio_gastosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_gastos.
     */
    data?: XOR<servicio_gastosCreateInput, servicio_gastosUncheckedCreateInput>
  }


  /**
   * servicio_gastos createMany
   */
  export type servicio_gastosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_gastos.
     */
    data: servicio_gastosCreateManyInput | servicio_gastosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_gastos update
   */
  export type servicio_gastosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_gastos.
     */
    data: XOR<servicio_gastosUpdateInput, servicio_gastosUncheckedUpdateInput>
    /**
     * Choose, which servicio_gastos to update.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos updateMany
   */
  export type servicio_gastosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_gastos.
     */
    data: XOR<servicio_gastosUpdateManyMutationInput, servicio_gastosUncheckedUpdateManyInput>
    /**
     * Filter which servicio_gastos to update
     */
    where?: servicio_gastosWhereInput
  }


  /**
   * servicio_gastos upsert
   */
  export type servicio_gastosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_gastos to update in case it exists.
     */
    where: servicio_gastosWhereUniqueInput
    /**
     * In case the servicio_gastos found by the `where` argument doesn't exist, create a new servicio_gastos with this data.
     */
    create: XOR<servicio_gastosCreateInput, servicio_gastosUncheckedCreateInput>
    /**
     * In case the servicio_gastos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_gastosUpdateInput, servicio_gastosUncheckedUpdateInput>
  }


  /**
   * servicio_gastos delete
   */
  export type servicio_gastosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
    /**
     * Filter which servicio_gastos to delete.
     */
    where: servicio_gastosWhereUniqueInput
  }


  /**
   * servicio_gastos deleteMany
   */
  export type servicio_gastosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_gastos to delete
     */
    where?: servicio_gastosWhereInput
  }


  /**
   * servicio_gastos without action
   */
  export type servicio_gastosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_gastos
     */
    select?: servicio_gastosSelect<ExtArgs> | null
  }



  /**
   * Model servicio_venta
   */


  export type AggregateServicio_venta = {
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  export type Servicio_ventaAvgAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaSumAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    dni_sol: number | null
    comision: number | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    efectivo: number | null
  }

  export type Servicio_ventaMinAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaMaxAggregateOutputType = {
    idventa: number | null
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
  }

  export type Servicio_ventaCountAggregateOutputType = {
    idventa: number
    idservicio: number
    monto: number
    operador: number
    fecha_venta: number
    apellido_sol: number
    nombre_sol: number
    dni_sol: number
    parentesco: number
    operador_venta: number
    liquidado: number
    operadorliq: number
    fecha_liquidacion: number
    aprobado: number
    operadorap: number
    fecha_aprobacion: number
    comision: number
    fecha_carga: number
    valor_cuota: number
    plan_cuota: number
    monto_financiacion: number
    financiacion: number
    efectivo: number
    _all: number
  }


  export type Servicio_ventaAvgAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaSumAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    dni_sol?: true
    comision?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMinAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaMaxAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
  }

  export type Servicio_ventaCountAggregateInputType = {
    idventa?: true
    idservicio?: true
    monto?: true
    operador?: true
    fecha_venta?: true
    apellido_sol?: true
    nombre_sol?: true
    dni_sol?: true
    parentesco?: true
    operador_venta?: true
    liquidado?: true
    operadorliq?: true
    fecha_liquidacion?: true
    aprobado?: true
    operadorap?: true
    fecha_aprobacion?: true
    comision?: true
    fecha_carga?: true
    valor_cuota?: true
    plan_cuota?: true
    monto_financiacion?: true
    financiacion?: true
    efectivo?: true
    _all?: true
  }

  export type Servicio_ventaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_venta to aggregate.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicio_ventas
    **/
    _count?: true | Servicio_ventaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicio_ventaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicio_ventaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicio_ventaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicio_ventaMaxAggregateInputType
  }

  export type GetServicio_ventaAggregateType<T extends Servicio_ventaAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio_venta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio_venta[P]>
      : GetScalarType<T[P], AggregateServicio_venta[P]>
  }




  export type servicio_ventaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicio_ventaWhereInput
    orderBy?: servicio_ventaOrderByWithAggregationInput | servicio_ventaOrderByWithAggregationInput[]
    by: Servicio_ventaScalarFieldEnum[] | Servicio_ventaScalarFieldEnum
    having?: servicio_ventaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicio_ventaCountAggregateInputType | true
    _avg?: Servicio_ventaAvgAggregateInputType
    _sum?: Servicio_ventaSumAggregateInputType
    _min?: Servicio_ventaMinAggregateInputType
    _max?: Servicio_ventaMaxAggregateInputType
  }


  export type Servicio_ventaGroupByOutputType = {
    idventa: number
    idservicio: number | null
    monto: number | null
    operador: string | null
    fecha_venta: Date | null
    apellido_sol: string | null
    nombre_sol: string | null
    dni_sol: number | null
    parentesco: string | null
    operador_venta: string | null
    liquidado: boolean | null
    operadorliq: string | null
    fecha_liquidacion: string | null
    aprobado: boolean | null
    operadorap: string | null
    fecha_aprobacion: string | null
    comision: number | null
    fecha_carga: Date | null
    valor_cuota: number | null
    plan_cuota: number | null
    monto_financiacion: number | null
    financiacion: boolean | null
    efectivo: number | null
    _count: Servicio_ventaCountAggregateOutputType | null
    _avg: Servicio_ventaAvgAggregateOutputType | null
    _sum: Servicio_ventaSumAggregateOutputType | null
    _min: Servicio_ventaMinAggregateOutputType | null
    _max: Servicio_ventaMaxAggregateOutputType | null
  }

  type GetServicio_ventaGroupByPayload<T extends servicio_ventaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicio_ventaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicio_ventaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
            : GetScalarType<T[P], Servicio_ventaGroupByOutputType[P]>
        }
      >
    >


  export type servicio_ventaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idventa?: boolean
    idservicio?: boolean
    monto?: boolean
    operador?: boolean
    fecha_venta?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    parentesco?: boolean
    operador_venta?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
    comision?: boolean
    fecha_carga?: boolean
    valor_cuota?: boolean
    plan_cuota?: boolean
    monto_financiacion?: boolean
    financiacion?: boolean
    efectivo?: boolean
  }, ExtArgs["result"]["servicio_venta"]>

  export type servicio_ventaSelectScalar = {
    idventa?: boolean
    idservicio?: boolean
    monto?: boolean
    operador?: boolean
    fecha_venta?: boolean
    apellido_sol?: boolean
    nombre_sol?: boolean
    dni_sol?: boolean
    parentesco?: boolean
    operador_venta?: boolean
    liquidado?: boolean
    operadorliq?: boolean
    fecha_liquidacion?: boolean
    aprobado?: boolean
    operadorap?: boolean
    fecha_aprobacion?: boolean
    comision?: boolean
    fecha_carga?: boolean
    valor_cuota?: boolean
    plan_cuota?: boolean
    monto_financiacion?: boolean
    financiacion?: boolean
    efectivo?: boolean
  }


  type servicio_ventaGetPayload<S extends boolean | null | undefined | servicio_ventaArgs> = $Types.GetResult<servicio_ventaPayload, S>

  type servicio_ventaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicio_ventaFindManyArgs, 'select' | 'include'> & {
      select?: Servicio_ventaCountAggregateInputType | true
    }

  export interface servicio_ventaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio_venta'], meta: { name: 'servicio_venta' } }
    /**
     * Find zero or one Servicio_venta that matches the filter.
     * @param {servicio_ventaFindUniqueArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicio_ventaFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicio_ventaFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicio_venta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicio_ventaFindUniqueOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicio_ventaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicio_venta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicio_ventaFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicio_ventaFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicio_venta'> extends True ? Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicio_venta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindFirstOrThrowArgs} args - Arguments to find a Servicio_venta
     * @example
     * // Get one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicio_ventaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicio_ventas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany()
     * 
     * // Get first 10 Servicio_ventas
     * const servicio_ventas = await prisma.servicio_venta.findMany({ take: 10 })
     * 
     * // Only select the `idventa`
     * const servicio_ventaWithIdventaOnly = await prisma.servicio_venta.findMany({ select: { idventa: true } })
     * 
    **/
    findMany<T extends servicio_ventaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicio_venta.
     * @param {servicio_ventaCreateArgs} args - Arguments to create a Servicio_venta.
     * @example
     * // Create one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.create({
     *   data: {
     *     // ... data to create a Servicio_venta
     *   }
     * })
     * 
    **/
    create<T extends servicio_ventaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaCreateArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicio_ventas.
     *     @param {servicio_ventaCreateManyArgs} args - Arguments to create many Servicio_ventas.
     *     @example
     *     // Create many Servicio_ventas
     *     const servicio_venta = await prisma.servicio_venta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicio_ventaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicio_venta.
     * @param {servicio_ventaDeleteArgs} args - Arguments to delete one Servicio_venta.
     * @example
     * // Delete one Servicio_venta
     * const Servicio_venta = await prisma.servicio_venta.delete({
     *   where: {
     *     // ... filter to delete one Servicio_venta
     *   }
     * })
     * 
    **/
    delete<T extends servicio_ventaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaDeleteArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicio_venta.
     * @param {servicio_ventaUpdateArgs} args - Arguments to update one Servicio_venta.
     * @example
     * // Update one Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicio_ventaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpdateArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicio_ventas.
     * @param {servicio_ventaDeleteManyArgs} args - Arguments to filter Servicio_ventas to delete.
     * @example
     * // Delete a few Servicio_ventas
     * const { count } = await prisma.servicio_venta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicio_ventaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicio_ventaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicio_ventas
     * const servicio_venta = await prisma.servicio_venta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicio_ventaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicio_venta.
     * @param {servicio_ventaUpsertArgs} args - Arguments to update or create a Servicio_venta.
     * @example
     * // Update or create a Servicio_venta
     * const servicio_venta = await prisma.servicio_venta.upsert({
     *   create: {
     *     // ... data to create a Servicio_venta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio_venta we want to update
     *   }
     * })
    **/
    upsert<T extends servicio_ventaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicio_ventaUpsertArgs<ExtArgs>>
    ): Prisma__servicio_ventaClient<$Types.GetResult<servicio_ventaPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicio_ventas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaCountArgs} args - Arguments to filter Servicio_ventas to count.
     * @example
     * // Count the number of Servicio_ventas
     * const count = await prisma.servicio_venta.count({
     *   where: {
     *     // ... the filter for the Servicio_ventas we want to count
     *   }
     * })
    **/
    count<T extends servicio_ventaCountArgs>(
      args?: Subset<T, servicio_ventaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicio_ventaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicio_ventaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicio_ventaAggregateArgs>(args: Subset<T, Servicio_ventaAggregateArgs>): Prisma.PrismaPromise<GetServicio_ventaAggregateType<T>>

    /**
     * Group by Servicio_venta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicio_ventaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicio_ventaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicio_ventaGroupByArgs['orderBy'] }
        : { orderBy?: servicio_ventaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicio_ventaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicio_ventaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio_venta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicio_ventaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicio_venta base type for findUnique actions
   */
  export type servicio_ventaFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }

  /**
   * servicio_venta findUnique
   */
  export interface servicio_ventaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_ventaFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findUniqueOrThrow
   */
  export type servicio_ventaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta base type for findFirst actions
   */
  export type servicio_ventaFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }

  /**
   * servicio_venta findFirst
   */
  export interface servicio_ventaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicio_ventaFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicio_venta findFirstOrThrow
   */
  export type servicio_ventaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_venta to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicio_ventas.
     */
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }


  /**
   * servicio_venta findMany
   */
  export type servicio_ventaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter, which servicio_ventas to fetch.
     */
    where?: servicio_ventaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicio_ventas to fetch.
     */
    orderBy?: servicio_ventaOrderByWithRelationInput | servicio_ventaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicio_ventas.
     */
    cursor?: servicio_ventaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicio_ventas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicio_ventas.
     */
    skip?: number
    distinct?: Servicio_ventaScalarFieldEnum | Servicio_ventaScalarFieldEnum[]
  }


  /**
   * servicio_venta create
   */
  export type servicio_ventaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The data needed to create a servicio_venta.
     */
    data?: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
  }


  /**
   * servicio_venta createMany
   */
  export type servicio_ventaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicio_ventas.
     */
    data: servicio_ventaCreateManyInput | servicio_ventaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicio_venta update
   */
  export type servicio_ventaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The data needed to update a servicio_venta.
     */
    data: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
    /**
     * Choose, which servicio_venta to update.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta updateMany
   */
  export type servicio_ventaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicio_ventas.
     */
    data: XOR<servicio_ventaUpdateManyMutationInput, servicio_ventaUncheckedUpdateManyInput>
    /**
     * Filter which servicio_ventas to update
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta upsert
   */
  export type servicio_ventaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * The filter to search for the servicio_venta to update in case it exists.
     */
    where: servicio_ventaWhereUniqueInput
    /**
     * In case the servicio_venta found by the `where` argument doesn't exist, create a new servicio_venta with this data.
     */
    create: XOR<servicio_ventaCreateInput, servicio_ventaUncheckedCreateInput>
    /**
     * In case the servicio_venta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicio_ventaUpdateInput, servicio_ventaUncheckedUpdateInput>
  }


  /**
   * servicio_venta delete
   */
  export type servicio_ventaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
    /**
     * Filter which servicio_venta to delete.
     */
    where: servicio_ventaWhereUniqueInput
  }


  /**
   * servicio_venta deleteMany
   */
  export type servicio_ventaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio_ventas to delete
     */
    where?: servicio_ventaWhereInput
  }


  /**
   * servicio_venta without action
   */
  export type servicio_ventaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio_venta
     */
    select?: servicio_ventaSelect<ExtArgs> | null
  }



  /**
   * Model servicios
   */


  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosAvgAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
  }

  export type ServiciosSumAggregateOutputType = {
    idservicio: number | null
    dni: number | null
    edad: number | null
    contrato: number | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    idataud: number | null
    dni_solicitante: number | null
    idparcela: number | null
    gastos_cargados: number | null
    importe: number | null
  }

  export type ServiciosMinAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    idservicio: number | null
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    idservicio: number
    empresa: number
    dni: number
    apellido: number
    nombre: number
    edad: number
    fecha_fallecimiento: number
    lugar_fallecimiento: number
    tipo_servicio: number
    casa_mortuaria: number
    fecha_inhumacion: number
    hora_inhumacion: number
    cementerio: number
    estado: number
    contrato: number
    fecha_recepcion: number
    sucursal: number
    motivo: number
    retiro: number
    solicitado: number
    parentesco: number
    altura: number
    peso: number
    dni_nuevotitular: number
    operador: number
    idataud: number
    dni_solicitante: number
    impactado: number
    cremacion: number
    idparcela: number
    liquidado: number
    fecha_liquidacion: number
    gastos_cargados: number
    obra_soc: number
    importe: number
    donacion: number
    domicilio_solicitante: number
    _all: number
  }


  export type ServiciosAvgAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
  }

  export type ServiciosSumAggregateInputType = {
    idservicio?: true
    dni?: true
    edad?: true
    contrato?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    idataud?: true
    dni_solicitante?: true
    idparcela?: true
    gastos_cargados?: true
    importe?: true
  }

  export type ServiciosMinAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
  }

  export type ServiciosMaxAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
  }

  export type ServiciosCountAggregateInputType = {
    idservicio?: true
    empresa?: true
    dni?: true
    apellido?: true
    nombre?: true
    edad?: true
    fecha_fallecimiento?: true
    lugar_fallecimiento?: true
    tipo_servicio?: true
    casa_mortuaria?: true
    fecha_inhumacion?: true
    hora_inhumacion?: true
    cementerio?: true
    estado?: true
    contrato?: true
    fecha_recepcion?: true
    sucursal?: true
    motivo?: true
    retiro?: true
    solicitado?: true
    parentesco?: true
    altura?: true
    peso?: true
    dni_nuevotitular?: true
    operador?: true
    idataud?: true
    dni_solicitante?: true
    impactado?: true
    cremacion?: true
    idparcela?: true
    liquidado?: true
    fecha_liquidacion?: true
    gastos_cargados?: true
    obra_soc?: true
    importe?: true
    donacion?: true
    domicilio_solicitante?: true
    _all?: true
  }

  export type ServiciosAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to aggregate.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiciosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiciosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type serviciosGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: serviciosWhereInput
    orderBy?: serviciosOrderByWithAggregationInput | serviciosOrderByWithAggregationInput[]
    by: ServiciosScalarFieldEnum[] | ServiciosScalarFieldEnum
    having?: serviciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _avg?: ServiciosAvgAggregateInputType
    _sum?: ServiciosSumAggregateInputType
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }


  export type ServiciosGroupByOutputType = {
    idservicio: number
    empresa: string | null
    dni: number | null
    apellido: string | null
    nombre: string | null
    edad: number | null
    fecha_fallecimiento: Date | null
    lugar_fallecimiento: string | null
    tipo_servicio: string | null
    casa_mortuaria: string | null
    fecha_inhumacion: Date | null
    hora_inhumacion: string | null
    cementerio: string | null
    estado: boolean | null
    contrato: number | null
    fecha_recepcion: string | null
    sucursal: string | null
    motivo: string | null
    retiro: string | null
    solicitado: string | null
    parentesco: string | null
    altura: number | null
    peso: number | null
    dni_nuevotitular: number | null
    operador: string | null
    idataud: number | null
    dni_solicitante: number | null
    impactado: boolean | null
    cremacion: boolean | null
    idparcela: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    gastos_cargados: number | null
    obra_soc: string | null
    importe: number | null
    donacion: boolean | null
    domicilio_solicitante: string | null
    _count: ServiciosCountAggregateOutputType | null
    _avg: ServiciosAvgAggregateOutputType | null
    _sum: ServiciosSumAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends serviciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type serviciosSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idservicio?: boolean
    empresa?: boolean
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    fecha_fallecimiento?: boolean
    lugar_fallecimiento?: boolean
    tipo_servicio?: boolean
    casa_mortuaria?: boolean
    fecha_inhumacion?: boolean
    hora_inhumacion?: boolean
    cementerio?: boolean
    estado?: boolean
    contrato?: boolean
    fecha_recepcion?: boolean
    sucursal?: boolean
    motivo?: boolean
    retiro?: boolean
    solicitado?: boolean
    parentesco?: boolean
    altura?: boolean
    peso?: boolean
    dni_nuevotitular?: boolean
    operador?: boolean
    idataud?: boolean
    dni_solicitante?: boolean
    impactado?: boolean
    cremacion?: boolean
    idparcela?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    gastos_cargados?: boolean
    obra_soc?: boolean
    importe?: boolean
    donacion?: boolean
    domicilio_solicitante?: boolean
  }, ExtArgs["result"]["servicios"]>

  export type serviciosSelectScalar = {
    idservicio?: boolean
    empresa?: boolean
    dni?: boolean
    apellido?: boolean
    nombre?: boolean
    edad?: boolean
    fecha_fallecimiento?: boolean
    lugar_fallecimiento?: boolean
    tipo_servicio?: boolean
    casa_mortuaria?: boolean
    fecha_inhumacion?: boolean
    hora_inhumacion?: boolean
    cementerio?: boolean
    estado?: boolean
    contrato?: boolean
    fecha_recepcion?: boolean
    sucursal?: boolean
    motivo?: boolean
    retiro?: boolean
    solicitado?: boolean
    parentesco?: boolean
    altura?: boolean
    peso?: boolean
    dni_nuevotitular?: boolean
    operador?: boolean
    idataud?: boolean
    dni_solicitante?: boolean
    impactado?: boolean
    cremacion?: boolean
    idparcela?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    gastos_cargados?: boolean
    obra_soc?: boolean
    importe?: boolean
    donacion?: boolean
    domicilio_solicitante?: boolean
  }


  type serviciosGetPayload<S extends boolean | null | undefined | serviciosArgs> = $Types.GetResult<serviciosPayload, S>

  type serviciosCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<serviciosFindManyArgs, 'select' | 'include'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface serviciosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios'], meta: { name: 'servicios' } }
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {serviciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serviciosFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, serviciosFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios'> extends True ? Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serviciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serviciosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serviciosFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, serviciosFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios'> extends True ? Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicios that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serviciosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `idservicio`
     * const serviciosWithIdservicioOnly = await prisma.servicios.findMany({ select: { idservicio: true } })
     * 
    **/
    findMany<T extends serviciosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicios.
     * @param {serviciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
    **/
    create<T extends serviciosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosCreateArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios.
     *     @param {serviciosCreateManyArgs} args - Arguments to create many Servicios.
     *     @example
     *     // Create many Servicios
     *     const servicios = await prisma.servicios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serviciosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {serviciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
    **/
    delete<T extends serviciosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosDeleteArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicios.
     * @param {serviciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serviciosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpdateArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {serviciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serviciosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serviciosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serviciosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {serviciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
    **/
    upsert<T extends serviciosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, serviciosUpsertArgs<ExtArgs>>
    ): Prisma__serviciosClient<$Types.GetResult<serviciosPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends serviciosCountArgs>(
      args?: Subset<T, serviciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviciosGroupByArgs['orderBy'] }
        : { orderBy?: serviciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__serviciosClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios base type for findUnique actions
   */
  export type serviciosFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }

  /**
   * servicios findUnique
   */
  export interface serviciosFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviciosFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findUniqueOrThrow
   */
  export type serviciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios base type for findFirst actions
   */
  export type serviciosFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * servicios findFirst
   */
  export interface serviciosFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends serviciosFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios findFirstOrThrow
   */
  export type serviciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * servicios findMany
   */
  export type serviciosFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: serviciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: serviciosOrderByWithRelationInput | serviciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     */
    cursor?: serviciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }


  /**
   * servicios create
   */
  export type serviciosCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The data needed to create a servicios.
     */
    data?: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
  }


  /**
   * servicios createMany
   */
  export type serviciosCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios.
     */
    data: serviciosCreateManyInput | serviciosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicios update
   */
  export type serviciosUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The data needed to update a servicios.
     */
    data: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
    /**
     * Choose, which servicios to update.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios updateMany
   */
  export type serviciosUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios.
     */
    data: XOR<serviciosUpdateManyMutationInput, serviciosUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios upsert
   */
  export type serviciosUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * The filter to search for the servicios to update in case it exists.
     */
    where: serviciosWhereUniqueInput
    /**
     * In case the servicios found by the `where` argument doesn't exist, create a new servicios with this data.
     */
    create: XOR<serviciosCreateInput, serviciosUncheckedCreateInput>
    /**
     * In case the servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviciosUpdateInput, serviciosUncheckedUpdateInput>
  }


  /**
   * servicios delete
   */
  export type serviciosDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
    /**
     * Filter which servicios to delete.
     */
    where: serviciosWhereUniqueInput
  }


  /**
   * servicios deleteMany
   */
  export type serviciosDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to delete
     */
    where?: serviciosWhereInput
  }


  /**
   * servicios without action
   */
  export type serviciosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios
     */
    select?: serviciosSelect<ExtArgs> | null
  }



  /**
   * Model servicios_liquidacion
   */


  export type AggregateServicios_liquidacion = {
    _count: Servicios_liquidacionCountAggregateOutputType | null
    _avg: Servicios_liquidacionAvgAggregateOutputType | null
    _sum: Servicios_liquidacionSumAggregateOutputType | null
    _min: Servicios_liquidacionMinAggregateOutputType | null
    _max: Servicios_liquidacionMaxAggregateOutputType | null
  }

  export type Servicios_liquidacionAvgAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
  }

  export type Servicios_liquidacionSumAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
  }

  export type Servicios_liquidacionMinAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
  }

  export type Servicios_liquidacionMaxAggregateOutputType = {
    idliquidacion: number | null
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
  }

  export type Servicios_liquidacionCountAggregateOutputType = {
    idliquidacion: number
    idservicio: number
    total_liquidacion: number
    fecha_liquidacion: number
    operador: number
    _all: number
  }


  export type Servicios_liquidacionAvgAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
  }

  export type Servicios_liquidacionSumAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
  }

  export type Servicios_liquidacionMinAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
  }

  export type Servicios_liquidacionMaxAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
  }

  export type Servicios_liquidacionCountAggregateInputType = {
    idliquidacion?: true
    idservicio?: true
    total_liquidacion?: true
    fecha_liquidacion?: true
    operador?: true
    _all?: true
  }

  export type Servicios_liquidacionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_liquidacion to aggregate.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: servicios_liquidacionOrderByWithRelationInput | servicios_liquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios_liquidacions
    **/
    _count?: true | Servicios_liquidacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Servicios_liquidacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Servicios_liquidacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Servicios_liquidacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Servicios_liquidacionMaxAggregateInputType
  }

  export type GetServicios_liquidacionAggregateType<T extends Servicios_liquidacionAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios_liquidacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios_liquidacion[P]>
      : GetScalarType<T[P], AggregateServicios_liquidacion[P]>
  }




  export type servicios_liquidacionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: servicios_liquidacionWhereInput
    orderBy?: servicios_liquidacionOrderByWithAggregationInput | servicios_liquidacionOrderByWithAggregationInput[]
    by: Servicios_liquidacionScalarFieldEnum[] | Servicios_liquidacionScalarFieldEnum
    having?: servicios_liquidacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Servicios_liquidacionCountAggregateInputType | true
    _avg?: Servicios_liquidacionAvgAggregateInputType
    _sum?: Servicios_liquidacionSumAggregateInputType
    _min?: Servicios_liquidacionMinAggregateInputType
    _max?: Servicios_liquidacionMaxAggregateInputType
  }


  export type Servicios_liquidacionGroupByOutputType = {
    idliquidacion: number
    idservicio: number | null
    total_liquidacion: number | null
    fecha_liquidacion: Date | null
    operador: string | null
    _count: Servicios_liquidacionCountAggregateOutputType | null
    _avg: Servicios_liquidacionAvgAggregateOutputType | null
    _sum: Servicios_liquidacionSumAggregateOutputType | null
    _min: Servicios_liquidacionMinAggregateOutputType | null
    _max: Servicios_liquidacionMaxAggregateOutputType | null
  }

  type GetServicios_liquidacionGroupByPayload<T extends servicios_liquidacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Servicios_liquidacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Servicios_liquidacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Servicios_liquidacionGroupByOutputType[P]>
            : GetScalarType<T[P], Servicios_liquidacionGroupByOutputType[P]>
        }
      >
    >


  export type servicios_liquidacionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idliquidacion?: boolean
    idservicio?: boolean
    total_liquidacion?: boolean
    fecha_liquidacion?: boolean
    operador?: boolean
  }, ExtArgs["result"]["servicios_liquidacion"]>

  export type servicios_liquidacionSelectScalar = {
    idliquidacion?: boolean
    idservicio?: boolean
    total_liquidacion?: boolean
    fecha_liquidacion?: boolean
    operador?: boolean
  }


  type servicios_liquidacionGetPayload<S extends boolean | null | undefined | servicios_liquidacionArgs> = $Types.GetResult<servicios_liquidacionPayload, S>

  type servicios_liquidacionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<servicios_liquidacionFindManyArgs, 'select' | 'include'> & {
      select?: Servicios_liquidacionCountAggregateInputType | true
    }

  export interface servicios_liquidacionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicios_liquidacion'], meta: { name: 'servicios_liquidacion' } }
    /**
     * Find zero or one Servicios_liquidacion that matches the filter.
     * @param {servicios_liquidacionFindUniqueArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicios_liquidacionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicios_liquidacionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'servicios_liquidacion'> extends True ? Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Servicios_liquidacion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {servicios_liquidacionFindUniqueOrThrowArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicios_liquidacionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_liquidacionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Servicios_liquidacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindFirstArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicios_liquidacionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicios_liquidacionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'servicios_liquidacion'> extends True ? Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Servicios_liquidacion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindFirstOrThrowArgs} args - Arguments to find a Servicios_liquidacion
     * @example
     * // Get one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicios_liquidacionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_liquidacionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Servicios_liquidacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios_liquidacions
     * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany()
     * 
     * // Get first 10 Servicios_liquidacions
     * const servicios_liquidacions = await prisma.servicios_liquidacion.findMany({ take: 10 })
     * 
     * // Only select the `idliquidacion`
     * const servicios_liquidacionWithIdliquidacionOnly = await prisma.servicios_liquidacion.findMany({ select: { idliquidacion: true } })
     * 
    **/
    findMany<T extends servicios_liquidacionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_liquidacionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Servicios_liquidacion.
     * @param {servicios_liquidacionCreateArgs} args - Arguments to create a Servicios_liquidacion.
     * @example
     * // Create one Servicios_liquidacion
     * const Servicios_liquidacion = await prisma.servicios_liquidacion.create({
     *   data: {
     *     // ... data to create a Servicios_liquidacion
     *   }
     * })
     * 
    **/
    create<T extends servicios_liquidacionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_liquidacionCreateArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Servicios_liquidacions.
     *     @param {servicios_liquidacionCreateManyArgs} args - Arguments to create many Servicios_liquidacions.
     *     @example
     *     // Create many Servicios_liquidacions
     *     const servicios_liquidacion = await prisma.servicios_liquidacion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicios_liquidacionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_liquidacionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios_liquidacion.
     * @param {servicios_liquidacionDeleteArgs} args - Arguments to delete one Servicios_liquidacion.
     * @example
     * // Delete one Servicios_liquidacion
     * const Servicios_liquidacion = await prisma.servicios_liquidacion.delete({
     *   where: {
     *     // ... filter to delete one Servicios_liquidacion
     *   }
     * })
     * 
    **/
    delete<T extends servicios_liquidacionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_liquidacionDeleteArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Servicios_liquidacion.
     * @param {servicios_liquidacionUpdateArgs} args - Arguments to update one Servicios_liquidacion.
     * @example
     * // Update one Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicios_liquidacionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_liquidacionUpdateArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Servicios_liquidacions.
     * @param {servicios_liquidacionDeleteManyArgs} args - Arguments to filter Servicios_liquidacions to delete.
     * @example
     * // Delete a few Servicios_liquidacions
     * const { count } = await prisma.servicios_liquidacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicios_liquidacionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, servicios_liquidacionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios_liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios_liquidacions
     * const servicios_liquidacion = await prisma.servicios_liquidacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicios_liquidacionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_liquidacionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios_liquidacion.
     * @param {servicios_liquidacionUpsertArgs} args - Arguments to update or create a Servicios_liquidacion.
     * @example
     * // Update or create a Servicios_liquidacion
     * const servicios_liquidacion = await prisma.servicios_liquidacion.upsert({
     *   create: {
     *     // ... data to create a Servicios_liquidacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios_liquidacion we want to update
     *   }
     * })
    **/
    upsert<T extends servicios_liquidacionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, servicios_liquidacionUpsertArgs<ExtArgs>>
    ): Prisma__servicios_liquidacionClient<$Types.GetResult<servicios_liquidacionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Servicios_liquidacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionCountArgs} args - Arguments to filter Servicios_liquidacions to count.
     * @example
     * // Count the number of Servicios_liquidacions
     * const count = await prisma.servicios_liquidacion.count({
     *   where: {
     *     // ... the filter for the Servicios_liquidacions we want to count
     *   }
     * })
    **/
    count<T extends servicios_liquidacionCountArgs>(
      args?: Subset<T, servicios_liquidacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Servicios_liquidacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios_liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Servicios_liquidacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Servicios_liquidacionAggregateArgs>(args: Subset<T, Servicios_liquidacionAggregateArgs>): Prisma.PrismaPromise<GetServicios_liquidacionAggregateType<T>>

    /**
     * Group by Servicios_liquidacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicios_liquidacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicios_liquidacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicios_liquidacionGroupByArgs['orderBy'] }
        : { orderBy?: servicios_liquidacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicios_liquidacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicios_liquidacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for servicios_liquidacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicios_liquidacionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * servicios_liquidacion base type for findUnique actions
   */
  export type servicios_liquidacionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where: servicios_liquidacionWhereUniqueInput
  }

  /**
   * servicios_liquidacion findUnique
   */
  export interface servicios_liquidacionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_liquidacionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_liquidacion findUniqueOrThrow
   */
  export type servicios_liquidacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion base type for findFirst actions
   */
  export type servicios_liquidacionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: servicios_liquidacionOrderByWithRelationInput | servicios_liquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_liquidacions.
     */
    distinct?: Servicios_liquidacionScalarFieldEnum | Servicios_liquidacionScalarFieldEnum[]
  }

  /**
   * servicios_liquidacion findFirst
   */
  export interface servicios_liquidacionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends servicios_liquidacionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * servicios_liquidacion findFirstOrThrow
   */
  export type servicios_liquidacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter, which servicios_liquidacion to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: servicios_liquidacionOrderByWithRelationInput | servicios_liquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios_liquidacions.
     */
    distinct?: Servicios_liquidacionScalarFieldEnum | Servicios_liquidacionScalarFieldEnum[]
  }


  /**
   * servicios_liquidacion findMany
   */
  export type servicios_liquidacionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter, which servicios_liquidacions to fetch.
     */
    where?: servicios_liquidacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios_liquidacions to fetch.
     */
    orderBy?: servicios_liquidacionOrderByWithRelationInput | servicios_liquidacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios_liquidacions.
     */
    cursor?: servicios_liquidacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios_liquidacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios_liquidacions.
     */
    skip?: number
    distinct?: Servicios_liquidacionScalarFieldEnum | Servicios_liquidacionScalarFieldEnum[]
  }


  /**
   * servicios_liquidacion create
   */
  export type servicios_liquidacionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * The data needed to create a servicios_liquidacion.
     */
    data?: XOR<servicios_liquidacionCreateInput, servicios_liquidacionUncheckedCreateInput>
  }


  /**
   * servicios_liquidacion createMany
   */
  export type servicios_liquidacionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios_liquidacions.
     */
    data: servicios_liquidacionCreateManyInput | servicios_liquidacionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servicios_liquidacion update
   */
  export type servicios_liquidacionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * The data needed to update a servicios_liquidacion.
     */
    data: XOR<servicios_liquidacionUpdateInput, servicios_liquidacionUncheckedUpdateInput>
    /**
     * Choose, which servicios_liquidacion to update.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion updateMany
   */
  export type servicios_liquidacionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios_liquidacions.
     */
    data: XOR<servicios_liquidacionUpdateManyMutationInput, servicios_liquidacionUncheckedUpdateManyInput>
    /**
     * Filter which servicios_liquidacions to update
     */
    where?: servicios_liquidacionWhereInput
  }


  /**
   * servicios_liquidacion upsert
   */
  export type servicios_liquidacionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * The filter to search for the servicios_liquidacion to update in case it exists.
     */
    where: servicios_liquidacionWhereUniqueInput
    /**
     * In case the servicios_liquidacion found by the `where` argument doesn't exist, create a new servicios_liquidacion with this data.
     */
    create: XOR<servicios_liquidacionCreateInput, servicios_liquidacionUncheckedCreateInput>
    /**
     * In case the servicios_liquidacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicios_liquidacionUpdateInput, servicios_liquidacionUncheckedUpdateInput>
  }


  /**
   * servicios_liquidacion delete
   */
  export type servicios_liquidacionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
    /**
     * Filter which servicios_liquidacion to delete.
     */
    where: servicios_liquidacionWhereUniqueInput
  }


  /**
   * servicios_liquidacion deleteMany
   */
  export type servicios_liquidacionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios_liquidacions to delete
     */
    where?: servicios_liquidacionWhereInput
  }


  /**
   * servicios_liquidacion without action
   */
  export type servicios_liquidacionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicios_liquidacion
     */
    select?: servicios_liquidacionSelect<ExtArgs> | null
  }



  /**
   * Model tareas
   */


  export type AggregateTareas = {
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  export type TareasAvgAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type TareasSumAggregateOutputType = {
    idevents: number | null
    allDay: number | null
    priority: number | null
  }

  export type TareasMinAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }

  export type TareasMaxAggregateOutputType = {
    idevents: number | null
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
  }

  export type TareasCountAggregateOutputType = {
    idevents: number
    title: number
    allDay: number
    start: number
    end: number
    priority: number
    _all: number
  }


  export type TareasAvgAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type TareasSumAggregateInputType = {
    idevents?: true
    allDay?: true
    priority?: true
  }

  export type TareasMinAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasMaxAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
  }

  export type TareasCountAggregateInputType = {
    idevents?: true
    title?: true
    allDay?: true
    start?: true
    end?: true
    priority?: true
    _all?: true
  }

  export type TareasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas to aggregate.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas
    **/
    _count?: true | TareasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TareasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TareasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TareasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TareasMaxAggregateInputType
  }

  export type GetTareasAggregateType<T extends TareasAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas[P]>
      : GetScalarType<T[P], AggregateTareas[P]>
  }




  export type tareasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tareasWhereInput
    orderBy?: tareasOrderByWithAggregationInput | tareasOrderByWithAggregationInput[]
    by: TareasScalarFieldEnum[] | TareasScalarFieldEnum
    having?: tareasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TareasCountAggregateInputType | true
    _avg?: TareasAvgAggregateInputType
    _sum?: TareasSumAggregateInputType
    _min?: TareasMinAggregateInputType
    _max?: TareasMaxAggregateInputType
  }


  export type TareasGroupByOutputType = {
    idevents: number
    title: string | null
    allDay: number | null
    start: string | null
    end: string | null
    priority: number | null
    _count: TareasCountAggregateOutputType | null
    _avg: TareasAvgAggregateOutputType | null
    _sum: TareasSumAggregateOutputType | null
    _min: TareasMinAggregateOutputType | null
    _max: TareasMaxAggregateOutputType | null
  }

  type GetTareasGroupByPayload<T extends tareasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TareasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TareasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TareasGroupByOutputType[P]>
            : GetScalarType<T[P], TareasGroupByOutputType[P]>
        }
      >
    >


  export type tareasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
  }, ExtArgs["result"]["tareas"]>

  export type tareasSelectScalar = {
    idevents?: boolean
    title?: boolean
    allDay?: boolean
    start?: boolean
    end?: boolean
    priority?: boolean
  }


  type tareasGetPayload<S extends boolean | null | undefined | tareasArgs> = $Types.GetResult<tareasPayload, S>

  type tareasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tareasFindManyArgs, 'select' | 'include'> & {
      select?: TareasCountAggregateInputType | true
    }

  export interface tareasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tareas'], meta: { name: 'tareas' } }
    /**
     * Find zero or one Tareas that matches the filter.
     * @param {tareasFindUniqueArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas'> extends True ? Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tareas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareasFindUniqueOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas'> extends True ? Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tareas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindFirstOrThrowArgs} args - Arguments to find a Tareas
     * @example
     * // Get one Tareas
     * const tareas = await prisma.tareas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tareas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas
     * const tareas = await prisma.tareas.findMany()
     * 
     * // Get first 10 Tareas
     * const tareas = await prisma.tareas.findMany({ take: 10 })
     * 
     * // Only select the `idevents`
     * const tareasWithIdeventsOnly = await prisma.tareas.findMany({ select: { idevents: true } })
     * 
    **/
    findMany<T extends tareasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tareasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tareas.
     * @param {tareasCreateArgs} args - Arguments to create a Tareas.
     * @example
     * // Create one Tareas
     * const Tareas = await prisma.tareas.create({
     *   data: {
     *     // ... data to create a Tareas
     *   }
     * })
     * 
    **/
    create<T extends tareasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tareasCreateArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tareas.
     *     @param {tareasCreateManyArgs} args - Arguments to create many Tareas.
     *     @example
     *     // Create many Tareas
     *     const tareas = await prisma.tareas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas.
     * @param {tareasDeleteArgs} args - Arguments to delete one Tareas.
     * @example
     * // Delete one Tareas
     * const Tareas = await prisma.tareas.delete({
     *   where: {
     *     // ... filter to delete one Tareas
     *   }
     * })
     * 
    **/
    delete<T extends tareasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tareasDeleteArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tareas.
     * @param {tareasUpdateArgs} args - Arguments to update one Tareas.
     * @example
     * // Update one Tareas
     * const tareas = await prisma.tareas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpdateArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tareas.
     * @param {tareasDeleteManyArgs} args - Arguments to filter Tareas to delete.
     * @example
     * // Delete a few Tareas
     * const { count } = await prisma.tareas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas
     * const tareas = await prisma.tareas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas.
     * @param {tareasUpsertArgs} args - Arguments to update or create a Tareas.
     * @example
     * // Update or create a Tareas
     * const tareas = await prisma.tareas.upsert({
     *   create: {
     *     // ... data to create a Tareas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas we want to update
     *   }
     * })
    **/
    upsert<T extends tareasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tareasUpsertArgs<ExtArgs>>
    ): Prisma__tareasClient<$Types.GetResult<tareasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasCountArgs} args - Arguments to filter Tareas to count.
     * @example
     * // Count the number of Tareas
     * const count = await prisma.tareas.count({
     *   where: {
     *     // ... the filter for the Tareas we want to count
     *   }
     * })
    **/
    count<T extends tareasCountArgs>(
      args?: Subset<T, tareasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TareasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TareasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TareasAggregateArgs>(args: Subset<T, TareasAggregateArgs>): Prisma.PrismaPromise<GetTareasAggregateType<T>>

    /**
     * Group by Tareas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tareasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tareasGroupByArgs['orderBy'] }
        : { orderBy?: tareasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tareasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas base type for findUnique actions
   */
  export type tareasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }

  /**
   * tareas findUnique
   */
  export interface tareasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findUniqueOrThrow
   */
  export type tareasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas base type for findFirst actions
   */
  export type tareasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }

  /**
   * tareas findFirst
   */
  export interface tareasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas findFirstOrThrow
   */
  export type tareasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas.
     */
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }


  /**
   * tareas findMany
   */
  export type tareasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter, which tareas to fetch.
     */
    where?: tareasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas to fetch.
     */
    orderBy?: tareasOrderByWithRelationInput | tareasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas.
     */
    cursor?: tareasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas.
     */
    skip?: number
    distinct?: TareasScalarFieldEnum | TareasScalarFieldEnum[]
  }


  /**
   * tareas create
   */
  export type tareasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The data needed to create a tareas.
     */
    data?: XOR<tareasCreateInput, tareasUncheckedCreateInput>
  }


  /**
   * tareas createMany
   */
  export type tareasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tareas.
     */
    data: tareasCreateManyInput | tareasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tareas update
   */
  export type tareasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The data needed to update a tareas.
     */
    data: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
    /**
     * Choose, which tareas to update.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas updateMany
   */
  export type tareasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tareas.
     */
    data: XOR<tareasUpdateManyMutationInput, tareasUncheckedUpdateManyInput>
    /**
     * Filter which tareas to update
     */
    where?: tareasWhereInput
  }


  /**
   * tareas upsert
   */
  export type tareasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * The filter to search for the tareas to update in case it exists.
     */
    where: tareasWhereUniqueInput
    /**
     * In case the tareas found by the `where` argument doesn't exist, create a new tareas with this data.
     */
    create: XOR<tareasCreateInput, tareasUncheckedCreateInput>
    /**
     * In case the tareas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareasUpdateInput, tareasUncheckedUpdateInput>
  }


  /**
   * tareas delete
   */
  export type tareasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
    /**
     * Filter which tareas to delete.
     */
    where: tareasWhereUniqueInput
  }


  /**
   * tareas deleteMany
   */
  export type tareasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas to delete
     */
    where?: tareasWhereInput
  }


  /**
   * tareas without action
   */
  export type tareasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas
     */
    select?: tareasSelect<ExtArgs> | null
  }



  /**
   * Model tareas_adicionales
   */


  export type AggregateTareas_adicionales = {
    _count: Tareas_adicionalesCountAggregateOutputType | null
    _avg: Tareas_adicionalesAvgAggregateOutputType | null
    _sum: Tareas_adicionalesSumAggregateOutputType | null
    _min: Tareas_adicionalesMinAggregateOutputType | null
    _max: Tareas_adicionalesMaxAggregateOutputType | null
  }

  export type Tareas_adicionalesAvgAggregateOutputType = {
    idtarea: number | null
    feriado: number | null
  }

  export type Tareas_adicionalesSumAggregateOutputType = {
    idtarea: number | null
    feriado: number | null
  }

  export type Tareas_adicionalesMinAggregateOutputType = {
    idtarea: number | null
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
  }

  export type Tareas_adicionalesMaxAggregateOutputType = {
    idtarea: number | null
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
  }

  export type Tareas_adicionalesCountAggregateOutputType = {
    idtarea: number
    inicio: number
    fin: number
    tarea: number
    operador: number
    observaciones: number
    horas: number
    feriado: number
    liquidado: number
    fecha_liquidacion: number
    operadorliq: number
    aprobado: number
    fecha_aprobacion: number
    operadorap: number
    mes_planificacion: number
    _all: number
  }


  export type Tareas_adicionalesAvgAggregateInputType = {
    idtarea?: true
    feriado?: true
  }

  export type Tareas_adicionalesSumAggregateInputType = {
    idtarea?: true
    feriado?: true
  }

  export type Tareas_adicionalesMinAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
  }

  export type Tareas_adicionalesMaxAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
  }

  export type Tareas_adicionalesCountAggregateInputType = {
    idtarea?: true
    inicio?: true
    fin?: true
    tarea?: true
    operador?: true
    observaciones?: true
    horas?: true
    feriado?: true
    liquidado?: true
    fecha_liquidacion?: true
    operadorliq?: true
    aprobado?: true
    fecha_aprobacion?: true
    operadorap?: true
    mes_planificacion?: true
    _all?: true
  }

  export type Tareas_adicionalesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas_adicionales to aggregate.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: tareas_adicionalesOrderByWithRelationInput | tareas_adicionalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tareas_adicionales
    **/
    _count?: true | Tareas_adicionalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tareas_adicionalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tareas_adicionalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tareas_adicionalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tareas_adicionalesMaxAggregateInputType
  }

  export type GetTareas_adicionalesAggregateType<T extends Tareas_adicionalesAggregateArgs> = {
        [P in keyof T & keyof AggregateTareas_adicionales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTareas_adicionales[P]>
      : GetScalarType<T[P], AggregateTareas_adicionales[P]>
  }




  export type tareas_adicionalesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tareas_adicionalesWhereInput
    orderBy?: tareas_adicionalesOrderByWithAggregationInput | tareas_adicionalesOrderByWithAggregationInput[]
    by: Tareas_adicionalesScalarFieldEnum[] | Tareas_adicionalesScalarFieldEnum
    having?: tareas_adicionalesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tareas_adicionalesCountAggregateInputType | true
    _avg?: Tareas_adicionalesAvgAggregateInputType
    _sum?: Tareas_adicionalesSumAggregateInputType
    _min?: Tareas_adicionalesMinAggregateInputType
    _max?: Tareas_adicionalesMaxAggregateInputType
  }


  export type Tareas_adicionalesGroupByOutputType = {
    idtarea: number
    inicio: Date | null
    fin: Date | null
    tarea: string | null
    operador: string | null
    observaciones: string | null
    horas: Date | null
    feriado: number | null
    liquidado: boolean | null
    fecha_liquidacion: string | null
    operadorliq: string | null
    aprobado: boolean | null
    fecha_aprobacion: string | null
    operadorap: string | null
    mes_planificacion: string | null
    _count: Tareas_adicionalesCountAggregateOutputType | null
    _avg: Tareas_adicionalesAvgAggregateOutputType | null
    _sum: Tareas_adicionalesSumAggregateOutputType | null
    _min: Tareas_adicionalesMinAggregateOutputType | null
    _max: Tareas_adicionalesMaxAggregateOutputType | null
  }

  type GetTareas_adicionalesGroupByPayload<T extends tareas_adicionalesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tareas_adicionalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tareas_adicionalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tareas_adicionalesGroupByOutputType[P]>
            : GetScalarType<T[P], Tareas_adicionalesGroupByOutputType[P]>
        }
      >
    >


  export type tareas_adicionalesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtarea?: boolean
    inicio?: boolean
    fin?: boolean
    tarea?: boolean
    operador?: boolean
    observaciones?: boolean
    horas?: boolean
    feriado?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    mes_planificacion?: boolean
  }, ExtArgs["result"]["tareas_adicionales"]>

  export type tareas_adicionalesSelectScalar = {
    idtarea?: boolean
    inicio?: boolean
    fin?: boolean
    tarea?: boolean
    operador?: boolean
    observaciones?: boolean
    horas?: boolean
    feriado?: boolean
    liquidado?: boolean
    fecha_liquidacion?: boolean
    operadorliq?: boolean
    aprobado?: boolean
    fecha_aprobacion?: boolean
    operadorap?: boolean
    mes_planificacion?: boolean
  }


  type tareas_adicionalesGetPayload<S extends boolean | null | undefined | tareas_adicionalesArgs> = $Types.GetResult<tareas_adicionalesPayload, S>

  type tareas_adicionalesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tareas_adicionalesFindManyArgs, 'select' | 'include'> & {
      select?: Tareas_adicionalesCountAggregateInputType | true
    }

  export interface tareas_adicionalesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tareas_adicionales'], meta: { name: 'tareas_adicionales' } }
    /**
     * Find zero or one Tareas_adicionales that matches the filter.
     * @param {tareas_adicionalesFindUniqueArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tareas_adicionalesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tareas_adicionalesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tareas_adicionales'> extends True ? Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tareas_adicionales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tareas_adicionalesFindUniqueOrThrowArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tareas_adicionalesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_adicionalesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tareas_adicionales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindFirstArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tareas_adicionalesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tareas_adicionalesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tareas_adicionales'> extends True ? Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tareas_adicionales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindFirstOrThrowArgs} args - Arguments to find a Tareas_adicionales
     * @example
     * // Get one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tareas_adicionalesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_adicionalesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tareas_adicionales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findMany()
     * 
     * // Get first 10 Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.findMany({ take: 10 })
     * 
     * // Only select the `idtarea`
     * const tareas_adicionalesWithIdtareaOnly = await prisma.tareas_adicionales.findMany({ select: { idtarea: true } })
     * 
    **/
    findMany<T extends tareas_adicionalesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_adicionalesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tareas_adicionales.
     * @param {tareas_adicionalesCreateArgs} args - Arguments to create a Tareas_adicionales.
     * @example
     * // Create one Tareas_adicionales
     * const Tareas_adicionales = await prisma.tareas_adicionales.create({
     *   data: {
     *     // ... data to create a Tareas_adicionales
     *   }
     * })
     * 
    **/
    create<T extends tareas_adicionalesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_adicionalesCreateArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tareas_adicionales.
     *     @param {tareas_adicionalesCreateManyArgs} args - Arguments to create many Tareas_adicionales.
     *     @example
     *     // Create many Tareas_adicionales
     *     const tareas_adicionales = await prisma.tareas_adicionales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tareas_adicionalesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_adicionalesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tareas_adicionales.
     * @param {tareas_adicionalesDeleteArgs} args - Arguments to delete one Tareas_adicionales.
     * @example
     * // Delete one Tareas_adicionales
     * const Tareas_adicionales = await prisma.tareas_adicionales.delete({
     *   where: {
     *     // ... filter to delete one Tareas_adicionales
     *   }
     * })
     * 
    **/
    delete<T extends tareas_adicionalesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_adicionalesDeleteArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tareas_adicionales.
     * @param {tareas_adicionalesUpdateArgs} args - Arguments to update one Tareas_adicionales.
     * @example
     * // Update one Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tareas_adicionalesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_adicionalesUpdateArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tareas_adicionales.
     * @param {tareas_adicionalesDeleteManyArgs} args - Arguments to filter Tareas_adicionales to delete.
     * @example
     * // Delete a few Tareas_adicionales
     * const { count } = await prisma.tareas_adicionales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tareas_adicionalesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tareas_adicionalesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tareas_adicionalesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_adicionalesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tareas_adicionales.
     * @param {tareas_adicionalesUpsertArgs} args - Arguments to update or create a Tareas_adicionales.
     * @example
     * // Update or create a Tareas_adicionales
     * const tareas_adicionales = await prisma.tareas_adicionales.upsert({
     *   create: {
     *     // ... data to create a Tareas_adicionales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tareas_adicionales we want to update
     *   }
     * })
    **/
    upsert<T extends tareas_adicionalesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tareas_adicionalesUpsertArgs<ExtArgs>>
    ): Prisma__tareas_adicionalesClient<$Types.GetResult<tareas_adicionalesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesCountArgs} args - Arguments to filter Tareas_adicionales to count.
     * @example
     * // Count the number of Tareas_adicionales
     * const count = await prisma.tareas_adicionales.count({
     *   where: {
     *     // ... the filter for the Tareas_adicionales we want to count
     *   }
     * })
    **/
    count<T extends tareas_adicionalesCountArgs>(
      args?: Subset<T, tareas_adicionalesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tareas_adicionalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tareas_adicionalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tareas_adicionalesAggregateArgs>(args: Subset<T, Tareas_adicionalesAggregateArgs>): Prisma.PrismaPromise<GetTareas_adicionalesAggregateType<T>>

    /**
     * Group by Tareas_adicionales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tareas_adicionalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tareas_adicionalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tareas_adicionalesGroupByArgs['orderBy'] }
        : { orderBy?: tareas_adicionalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tareas_adicionalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTareas_adicionalesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tareas_adicionales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tareas_adicionalesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tareas_adicionales base type for findUnique actions
   */
  export type tareas_adicionalesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where: tareas_adicionalesWhereUniqueInput
  }

  /**
   * tareas_adicionales findUnique
   */
  export interface tareas_adicionalesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareas_adicionalesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_adicionales findUniqueOrThrow
   */
  export type tareas_adicionalesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales base type for findFirst actions
   */
  export type tareas_adicionalesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: tareas_adicionalesOrderByWithRelationInput | tareas_adicionalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_adicionales.
     */
    distinct?: Tareas_adicionalesScalarFieldEnum | Tareas_adicionalesScalarFieldEnum[]
  }

  /**
   * tareas_adicionales findFirst
   */
  export interface tareas_adicionalesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tareas_adicionalesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tareas_adicionales findFirstOrThrow
   */
  export type tareas_adicionalesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: tareas_adicionalesOrderByWithRelationInput | tareas_adicionalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tareas_adicionales.
     */
    distinct?: Tareas_adicionalesScalarFieldEnum | Tareas_adicionalesScalarFieldEnum[]
  }


  /**
   * tareas_adicionales findMany
   */
  export type tareas_adicionalesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter, which tareas_adicionales to fetch.
     */
    where?: tareas_adicionalesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tareas_adicionales to fetch.
     */
    orderBy?: tareas_adicionalesOrderByWithRelationInput | tareas_adicionalesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tareas_adicionales.
     */
    cursor?: tareas_adicionalesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tareas_adicionales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tareas_adicionales.
     */
    skip?: number
    distinct?: Tareas_adicionalesScalarFieldEnum | Tareas_adicionalesScalarFieldEnum[]
  }


  /**
   * tareas_adicionales create
   */
  export type tareas_adicionalesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * The data needed to create a tareas_adicionales.
     */
    data?: XOR<tareas_adicionalesCreateInput, tareas_adicionalesUncheckedCreateInput>
  }


  /**
   * tareas_adicionales createMany
   */
  export type tareas_adicionalesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tareas_adicionales.
     */
    data: tareas_adicionalesCreateManyInput | tareas_adicionalesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tareas_adicionales update
   */
  export type tareas_adicionalesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * The data needed to update a tareas_adicionales.
     */
    data: XOR<tareas_adicionalesUpdateInput, tareas_adicionalesUncheckedUpdateInput>
    /**
     * Choose, which tareas_adicionales to update.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales updateMany
   */
  export type tareas_adicionalesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tareas_adicionales.
     */
    data: XOR<tareas_adicionalesUpdateManyMutationInput, tareas_adicionalesUncheckedUpdateManyInput>
    /**
     * Filter which tareas_adicionales to update
     */
    where?: tareas_adicionalesWhereInput
  }


  /**
   * tareas_adicionales upsert
   */
  export type tareas_adicionalesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * The filter to search for the tareas_adicionales to update in case it exists.
     */
    where: tareas_adicionalesWhereUniqueInput
    /**
     * In case the tareas_adicionales found by the `where` argument doesn't exist, create a new tareas_adicionales with this data.
     */
    create: XOR<tareas_adicionalesCreateInput, tareas_adicionalesUncheckedCreateInput>
    /**
     * In case the tareas_adicionales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tareas_adicionalesUpdateInput, tareas_adicionalesUncheckedUpdateInput>
  }


  /**
   * tareas_adicionales delete
   */
  export type tareas_adicionalesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
    /**
     * Filter which tareas_adicionales to delete.
     */
    where: tareas_adicionalesWhereUniqueInput
  }


  /**
   * tareas_adicionales deleteMany
   */
  export type tareas_adicionalesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tareas_adicionales to delete
     */
    where?: tareas_adicionalesWhereInput
  }


  /**
   * tareas_adicionales without action
   */
  export type tareas_adicionalesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tareas_adicionales
     */
    select?: tareas_adicionalesSelect<ExtArgs> | null
  }



  /**
   * Model tipo_detalle
   */


  export type AggregateTipo_detalle = {
    _count: Tipo_detalleCountAggregateOutputType | null
    _avg: Tipo_detalleAvgAggregateOutputType | null
    _sum: Tipo_detalleSumAggregateOutputType | null
    _min: Tipo_detalleMinAggregateOutputType | null
    _max: Tipo_detalleMaxAggregateOutputType | null
  }

  export type Tipo_detalleAvgAggregateOutputType = {
    idtipodetalle: number | null
  }

  export type Tipo_detalleSumAggregateOutputType = {
    idtipodetalle: number | null
  }

  export type Tipo_detalleMinAggregateOutputType = {
    idtipodetalle: number | null
    tipo_detalle: string | null
    observacion: string | null
  }

  export type Tipo_detalleMaxAggregateOutputType = {
    idtipodetalle: number | null
    tipo_detalle: string | null
    observacion: string | null
  }

  export type Tipo_detalleCountAggregateOutputType = {
    idtipodetalle: number
    tipo_detalle: number
    observacion: number
    _all: number
  }


  export type Tipo_detalleAvgAggregateInputType = {
    idtipodetalle?: true
  }

  export type Tipo_detalleSumAggregateInputType = {
    idtipodetalle?: true
  }

  export type Tipo_detalleMinAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
  }

  export type Tipo_detalleMaxAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
  }

  export type Tipo_detalleCountAggregateInputType = {
    idtipodetalle?: true
    tipo_detalle?: true
    observacion?: true
    _all?: true
  }

  export type Tipo_detalleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_detalle to aggregate.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: tipo_detalleOrderByWithRelationInput | tipo_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_detalles
    **/
    _count?: true | Tipo_detalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_detalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_detalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_detalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_detalleMaxAggregateInputType
  }

  export type GetTipo_detalleAggregateType<T extends Tipo_detalleAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_detalle[P]>
      : GetScalarType<T[P], AggregateTipo_detalle[P]>
  }




  export type tipo_detalleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tipo_detalleWhereInput
    orderBy?: tipo_detalleOrderByWithAggregationInput | tipo_detalleOrderByWithAggregationInput[]
    by: Tipo_detalleScalarFieldEnum[] | Tipo_detalleScalarFieldEnum
    having?: tipo_detalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_detalleCountAggregateInputType | true
    _avg?: Tipo_detalleAvgAggregateInputType
    _sum?: Tipo_detalleSumAggregateInputType
    _min?: Tipo_detalleMinAggregateInputType
    _max?: Tipo_detalleMaxAggregateInputType
  }


  export type Tipo_detalleGroupByOutputType = {
    idtipodetalle: number
    tipo_detalle: string | null
    observacion: string | null
    _count: Tipo_detalleCountAggregateOutputType | null
    _avg: Tipo_detalleAvgAggregateOutputType | null
    _sum: Tipo_detalleSumAggregateOutputType | null
    _min: Tipo_detalleMinAggregateOutputType | null
    _max: Tipo_detalleMaxAggregateOutputType | null
  }

  type GetTipo_detalleGroupByPayload<T extends tipo_detalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tipo_detalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_detalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_detalleGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_detalleGroupByOutputType[P]>
        }
      >
    >


  export type tipo_detalleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtipodetalle?: boolean
    tipo_detalle?: boolean
    observacion?: boolean
  }, ExtArgs["result"]["tipo_detalle"]>

  export type tipo_detalleSelectScalar = {
    idtipodetalle?: boolean
    tipo_detalle?: boolean
    observacion?: boolean
  }


  type tipo_detalleGetPayload<S extends boolean | null | undefined | tipo_detalleArgs> = $Types.GetResult<tipo_detallePayload, S>

  type tipo_detalleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tipo_detalleFindManyArgs, 'select' | 'include'> & {
      select?: Tipo_detalleCountAggregateInputType | true
    }

  export interface tipo_detalleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipo_detalle'], meta: { name: 'tipo_detalle' } }
    /**
     * Find zero or one Tipo_detalle that matches the filter.
     * @param {tipo_detalleFindUniqueArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipo_detalleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tipo_detalleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tipo_detalle'> extends True ? Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Tipo_detalle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipo_detalleFindUniqueOrThrowArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipo_detalleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_detalleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Tipo_detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindFirstArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipo_detalleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tipo_detalleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tipo_detalle'> extends True ? Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Tipo_detalle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindFirstOrThrowArgs} args - Arguments to find a Tipo_detalle
     * @example
     * // Get one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipo_detalleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_detalleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Tipo_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_detalles
     * const tipo_detalles = await prisma.tipo_detalle.findMany()
     * 
     * // Get first 10 Tipo_detalles
     * const tipo_detalles = await prisma.tipo_detalle.findMany({ take: 10 })
     * 
     * // Only select the `idtipodetalle`
     * const tipo_detalleWithIdtipodetalleOnly = await prisma.tipo_detalle.findMany({ select: { idtipodetalle: true } })
     * 
    **/
    findMany<T extends tipo_detalleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_detalleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Tipo_detalle.
     * @param {tipo_detalleCreateArgs} args - Arguments to create a Tipo_detalle.
     * @example
     * // Create one Tipo_detalle
     * const Tipo_detalle = await prisma.tipo_detalle.create({
     *   data: {
     *     // ... data to create a Tipo_detalle
     *   }
     * })
     * 
    **/
    create<T extends tipo_detalleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_detalleCreateArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Tipo_detalles.
     *     @param {tipo_detalleCreateManyArgs} args - Arguments to create many Tipo_detalles.
     *     @example
     *     // Create many Tipo_detalles
     *     const tipo_detalle = await prisma.tipo_detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipo_detalleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_detalleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_detalle.
     * @param {tipo_detalleDeleteArgs} args - Arguments to delete one Tipo_detalle.
     * @example
     * // Delete one Tipo_detalle
     * const Tipo_detalle = await prisma.tipo_detalle.delete({
     *   where: {
     *     // ... filter to delete one Tipo_detalle
     *   }
     * })
     * 
    **/
    delete<T extends tipo_detalleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_detalleDeleteArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Tipo_detalle.
     * @param {tipo_detalleUpdateArgs} args - Arguments to update one Tipo_detalle.
     * @example
     * // Update one Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipo_detalleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_detalleUpdateArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Tipo_detalles.
     * @param {tipo_detalleDeleteManyArgs} args - Arguments to filter Tipo_detalles to delete.
     * @example
     * // Delete a few Tipo_detalles
     * const { count } = await prisma.tipo_detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipo_detalleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipo_detalleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_detalles
     * const tipo_detalle = await prisma.tipo_detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipo_detalleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_detalleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_detalle.
     * @param {tipo_detalleUpsertArgs} args - Arguments to update or create a Tipo_detalle.
     * @example
     * // Update or create a Tipo_detalle
     * const tipo_detalle = await prisma.tipo_detalle.upsert({
     *   create: {
     *     // ... data to create a Tipo_detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_detalle we want to update
     *   }
     * })
    **/
    upsert<T extends tipo_detalleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tipo_detalleUpsertArgs<ExtArgs>>
    ): Prisma__tipo_detalleClient<$Types.GetResult<tipo_detallePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Tipo_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleCountArgs} args - Arguments to filter Tipo_detalles to count.
     * @example
     * // Count the number of Tipo_detalles
     * const count = await prisma.tipo_detalle.count({
     *   where: {
     *     // ... the filter for the Tipo_detalles we want to count
     *   }
     * })
    **/
    count<T extends tipo_detalleCountArgs>(
      args?: Subset<T, tipo_detalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_detalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_detalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_detalleAggregateArgs>(args: Subset<T, Tipo_detalleAggregateArgs>): Prisma.PrismaPromise<GetTipo_detalleAggregateType<T>>

    /**
     * Group by Tipo_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_detalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipo_detalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipo_detalleGroupByArgs['orderBy'] }
        : { orderBy?: tipo_detalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipo_detalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_detalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tipo_detalleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tipo_detalle base type for findUnique actions
   */
  export type tipo_detalleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where: tipo_detalleWhereUniqueInput
  }

  /**
   * tipo_detalle findUnique
   */
  export interface tipo_detalleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_detalleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_detalle findUniqueOrThrow
   */
  export type tipo_detalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle base type for findFirst actions
   */
  export type tipo_detalleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: tipo_detalleOrderByWithRelationInput | tipo_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_detalles.
     */
    distinct?: Tipo_detalleScalarFieldEnum | Tipo_detalleScalarFieldEnum[]
  }

  /**
   * tipo_detalle findFirst
   */
  export interface tipo_detalleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends tipo_detalleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_detalle findFirstOrThrow
   */
  export type tipo_detalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter, which tipo_detalle to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: tipo_detalleOrderByWithRelationInput | tipo_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_detalles.
     */
    distinct?: Tipo_detalleScalarFieldEnum | Tipo_detalleScalarFieldEnum[]
  }


  /**
   * tipo_detalle findMany
   */
  export type tipo_detalleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter, which tipo_detalles to fetch.
     */
    where?: tipo_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_detalles to fetch.
     */
    orderBy?: tipo_detalleOrderByWithRelationInput | tipo_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_detalles.
     */
    cursor?: tipo_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_detalles.
     */
    skip?: number
    distinct?: Tipo_detalleScalarFieldEnum | Tipo_detalleScalarFieldEnum[]
  }


  /**
   * tipo_detalle create
   */
  export type tipo_detalleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * The data needed to create a tipo_detalle.
     */
    data?: XOR<tipo_detalleCreateInput, tipo_detalleUncheckedCreateInput>
  }


  /**
   * tipo_detalle createMany
   */
  export type tipo_detalleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipo_detalles.
     */
    data: tipo_detalleCreateManyInput | tipo_detalleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tipo_detalle update
   */
  export type tipo_detalleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * The data needed to update a tipo_detalle.
     */
    data: XOR<tipo_detalleUpdateInput, tipo_detalleUncheckedUpdateInput>
    /**
     * Choose, which tipo_detalle to update.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle updateMany
   */
  export type tipo_detalleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipo_detalles.
     */
    data: XOR<tipo_detalleUpdateManyMutationInput, tipo_detalleUncheckedUpdateManyInput>
    /**
     * Filter which tipo_detalles to update
     */
    where?: tipo_detalleWhereInput
  }


  /**
   * tipo_detalle upsert
   */
  export type tipo_detalleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * The filter to search for the tipo_detalle to update in case it exists.
     */
    where: tipo_detalleWhereUniqueInput
    /**
     * In case the tipo_detalle found by the `where` argument doesn't exist, create a new tipo_detalle with this data.
     */
    create: XOR<tipo_detalleCreateInput, tipo_detalleUncheckedCreateInput>
    /**
     * In case the tipo_detalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_detalleUpdateInput, tipo_detalleUncheckedUpdateInput>
  }


  /**
   * tipo_detalle delete
   */
  export type tipo_detalleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
    /**
     * Filter which tipo_detalle to delete.
     */
    where: tipo_detalleWhereUniqueInput
  }


  /**
   * tipo_detalle deleteMany
   */
  export type tipo_detalleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipo_detalles to delete
     */
    where?: tipo_detalleWhereInput
  }


  /**
   * tipo_detalle without action
   */
  export type tipo_detalleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipo_detalle
     */
    select?: tipo_detalleSelect<ExtArgs> | null
  }



  /**
   * Model visitantes
   */


  export type AggregateVisitantes = {
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  export type VisitantesAvgAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesSumAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    dni: number | null
    telefono: number | null
  }

  export type VisitantesMinAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesMaxAggregateOutputType = {
    idvisitante: number | null
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
  }

  export type VisitantesCountAggregateOutputType = {
    idvisitante: number
    idservicio: number
    nombre: number
    apellido: number
    dni: number
    telefono: number
    parentezco: number
    operador: number
    fecha: number
    temperatura: number
    _all: number
  }


  export type VisitantesAvgAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesSumAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    dni?: true
    telefono?: true
  }

  export type VisitantesMinAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesMaxAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
  }

  export type VisitantesCountAggregateInputType = {
    idvisitante?: true
    idservicio?: true
    nombre?: true
    apellido?: true
    dni?: true
    telefono?: true
    parentezco?: true
    operador?: true
    fecha?: true
    temperatura?: true
    _all?: true
  }

  export type VisitantesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitantes to aggregate.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned visitantes
    **/
    _count?: true | VisitantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitantesMaxAggregateInputType
  }

  export type GetVisitantesAggregateType<T extends VisitantesAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitantes[P]>
      : GetScalarType<T[P], AggregateVisitantes[P]>
  }




  export type visitantesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: visitantesWhereInput
    orderBy?: visitantesOrderByWithAggregationInput | visitantesOrderByWithAggregationInput[]
    by: VisitantesScalarFieldEnum[] | VisitantesScalarFieldEnum
    having?: visitantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitantesCountAggregateInputType | true
    _avg?: VisitantesAvgAggregateInputType
    _sum?: VisitantesSumAggregateInputType
    _min?: VisitantesMinAggregateInputType
    _max?: VisitantesMaxAggregateInputType
  }


  export type VisitantesGroupByOutputType = {
    idvisitante: number
    idservicio: number | null
    nombre: string | null
    apellido: string | null
    dni: number | null
    telefono: number | null
    parentezco: string | null
    operador: string | null
    fecha: Date | null
    temperatura: string | null
    _count: VisitantesCountAggregateOutputType | null
    _avg: VisitantesAvgAggregateOutputType | null
    _sum: VisitantesSumAggregateOutputType | null
    _min: VisitantesMinAggregateOutputType | null
    _max: VisitantesMaxAggregateOutputType | null
  }

  type GetVisitantesGroupByPayload<T extends visitantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
            : GetScalarType<T[P], VisitantesGroupByOutputType[P]>
        }
      >
    >


  export type visitantesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idvisitante?: boolean
    idservicio?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    operador?: boolean
    fecha?: boolean
    temperatura?: boolean
  }, ExtArgs["result"]["visitantes"]>

  export type visitantesSelectScalar = {
    idvisitante?: boolean
    idservicio?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    telefono?: boolean
    parentezco?: boolean
    operador?: boolean
    fecha?: boolean
    temperatura?: boolean
  }


  type visitantesGetPayload<S extends boolean | null | undefined | visitantesArgs> = $Types.GetResult<visitantesPayload, S>

  type visitantesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<visitantesFindManyArgs, 'select' | 'include'> & {
      select?: VisitantesCountAggregateInputType | true
    }

  export interface visitantesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['visitantes'], meta: { name: 'visitantes' } }
    /**
     * Find zero or one Visitantes that matches the filter.
     * @param {visitantesFindUniqueArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends visitantesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, visitantesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'visitantes'> extends True ? Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Visitantes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {visitantesFindUniqueOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends visitantesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends visitantesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, visitantesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'visitantes'> extends True ? Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Visitantes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindFirstOrThrowArgs} args - Arguments to find a Visitantes
     * @example
     * // Get one Visitantes
     * const visitantes = await prisma.visitantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends visitantesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Visitantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitantes
     * const visitantes = await prisma.visitantes.findMany()
     * 
     * // Get first 10 Visitantes
     * const visitantes = await prisma.visitantes.findMany({ take: 10 })
     * 
     * // Only select the `idvisitante`
     * const visitantesWithIdvisitanteOnly = await prisma.visitantes.findMany({ select: { idvisitante: true } })
     * 
    **/
    findMany<T extends visitantesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Visitantes.
     * @param {visitantesCreateArgs} args - Arguments to create a Visitantes.
     * @example
     * // Create one Visitantes
     * const Visitantes = await prisma.visitantes.create({
     *   data: {
     *     // ... data to create a Visitantes
     *   }
     * })
     * 
    **/
    create<T extends visitantesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesCreateArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Visitantes.
     *     @param {visitantesCreateManyArgs} args - Arguments to create many Visitantes.
     *     @example
     *     // Create many Visitantes
     *     const visitantes = await prisma.visitantes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends visitantesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitantes.
     * @param {visitantesDeleteArgs} args - Arguments to delete one Visitantes.
     * @example
     * // Delete one Visitantes
     * const Visitantes = await prisma.visitantes.delete({
     *   where: {
     *     // ... filter to delete one Visitantes
     *   }
     * })
     * 
    **/
    delete<T extends visitantesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesDeleteArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Visitantes.
     * @param {visitantesUpdateArgs} args - Arguments to update one Visitantes.
     * @example
     * // Update one Visitantes
     * const visitantes = await prisma.visitantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends visitantesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpdateArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Visitantes.
     * @param {visitantesDeleteManyArgs} args - Arguments to filter Visitantes to delete.
     * @example
     * // Delete a few Visitantes
     * const { count } = await prisma.visitantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends visitantesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, visitantesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitantes
     * const visitantes = await prisma.visitantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends visitantesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitantes.
     * @param {visitantesUpsertArgs} args - Arguments to update or create a Visitantes.
     * @example
     * // Update or create a Visitantes
     * const visitantes = await prisma.visitantes.upsert({
     *   create: {
     *     // ... data to create a Visitantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitantes we want to update
     *   }
     * })
    **/
    upsert<T extends visitantesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, visitantesUpsertArgs<ExtArgs>>
    ): Prisma__visitantesClient<$Types.GetResult<visitantesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesCountArgs} args - Arguments to filter Visitantes to count.
     * @example
     * // Count the number of Visitantes
     * const count = await prisma.visitantes.count({
     *   where: {
     *     // ... the filter for the Visitantes we want to count
     *   }
     * })
    **/
    count<T extends visitantesCountArgs>(
      args?: Subset<T, visitantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitantesAggregateArgs>(args: Subset<T, VisitantesAggregateArgs>): Prisma.PrismaPromise<GetVisitantesAggregateType<T>>

    /**
     * Group by Visitantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {visitantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends visitantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: visitantesGroupByArgs['orderBy'] }
        : { orderBy?: visitantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, visitantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for visitantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__visitantesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * visitantes base type for findUnique actions
   */
  export type visitantesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }

  /**
   * visitantes findUnique
   */
  export interface visitantesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends visitantesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findUniqueOrThrow
   */
  export type visitantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes base type for findFirst actions
   */
  export type visitantesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }

  /**
   * visitantes findFirst
   */
  export interface visitantesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends visitantesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * visitantes findFirstOrThrow
   */
  export type visitantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of visitantes.
     */
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }


  /**
   * visitantes findMany
   */
  export type visitantesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter, which visitantes to fetch.
     */
    where?: visitantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of visitantes to fetch.
     */
    orderBy?: visitantesOrderByWithRelationInput | visitantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing visitantes.
     */
    cursor?: visitantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` visitantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` visitantes.
     */
    skip?: number
    distinct?: VisitantesScalarFieldEnum | VisitantesScalarFieldEnum[]
  }


  /**
   * visitantes create
   */
  export type visitantesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The data needed to create a visitantes.
     */
    data?: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
  }


  /**
   * visitantes createMany
   */
  export type visitantesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many visitantes.
     */
    data: visitantesCreateManyInput | visitantesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * visitantes update
   */
  export type visitantesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The data needed to update a visitantes.
     */
    data: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
    /**
     * Choose, which visitantes to update.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes updateMany
   */
  export type visitantesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update visitantes.
     */
    data: XOR<visitantesUpdateManyMutationInput, visitantesUncheckedUpdateManyInput>
    /**
     * Filter which visitantes to update
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes upsert
   */
  export type visitantesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * The filter to search for the visitantes to update in case it exists.
     */
    where: visitantesWhereUniqueInput
    /**
     * In case the visitantes found by the `where` argument doesn't exist, create a new visitantes with this data.
     */
    create: XOR<visitantesCreateInput, visitantesUncheckedCreateInput>
    /**
     * In case the visitantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<visitantesUpdateInput, visitantesUncheckedUpdateInput>
  }


  /**
   * visitantes delete
   */
  export type visitantesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
    /**
     * Filter which visitantes to delete.
     */
    where: visitantesWhereUniqueInput
  }


  /**
   * visitantes deleteMany
   */
  export type visitantesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which visitantes to delete
     */
    where?: visitantesWhereInput
  }


  /**
   * visitantes without action
   */
  export type visitantesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the visitantes
     */
    select?: visitantesSelect<ExtArgs> | null
  }



  /**
   * Model parcelas_lugares
   */


  export type AggregateParcelas_lugares = {
    _count: Parcelas_lugaresCountAggregateOutputType | null
    _avg: Parcelas_lugaresAvgAggregateOutputType | null
    _sum: Parcelas_lugaresSumAggregateOutputType | null
    _min: Parcelas_lugaresMinAggregateOutputType | null
    _max: Parcelas_lugaresMaxAggregateOutputType | null
  }

  export type Parcelas_lugaresAvgAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
  }

  export type Parcelas_lugaresSumAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
  }

  export type Parcelas_lugaresMinAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }

  export type Parcelas_lugaresMaxAggregateOutputType = {
    idlugar: number | null
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
  }

  export type Parcelas_lugaresCountAggregateOutputType = {
    idlugar: number
    idparcela: number
    idservicio: number
    lugar: number
    contrato: number
    dni: number
    fecha: number
    operador: number
    _all: number
  }


  export type Parcelas_lugaresAvgAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
  }

  export type Parcelas_lugaresSumAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
  }

  export type Parcelas_lugaresMinAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
  }

  export type Parcelas_lugaresMaxAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
  }

  export type Parcelas_lugaresCountAggregateInputType = {
    idlugar?: true
    idparcela?: true
    idservicio?: true
    lugar?: true
    contrato?: true
    dni?: true
    fecha?: true
    operador?: true
    _all?: true
  }

  export type Parcelas_lugaresAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas_lugares to aggregate.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parcelas_lugares
    **/
    _count?: true | Parcelas_lugaresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parcelas_lugaresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parcelas_lugaresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parcelas_lugaresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parcelas_lugaresMaxAggregateInputType
  }

  export type GetParcelas_lugaresAggregateType<T extends Parcelas_lugaresAggregateArgs> = {
        [P in keyof T & keyof AggregateParcelas_lugares]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParcelas_lugares[P]>
      : GetScalarType<T[P], AggregateParcelas_lugares[P]>
  }




  export type parcelas_lugaresGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: parcelas_lugaresWhereInput
    orderBy?: parcelas_lugaresOrderByWithAggregationInput | parcelas_lugaresOrderByWithAggregationInput[]
    by: Parcelas_lugaresScalarFieldEnum[] | Parcelas_lugaresScalarFieldEnum
    having?: parcelas_lugaresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parcelas_lugaresCountAggregateInputType | true
    _avg?: Parcelas_lugaresAvgAggregateInputType
    _sum?: Parcelas_lugaresSumAggregateInputType
    _min?: Parcelas_lugaresMinAggregateInputType
    _max?: Parcelas_lugaresMaxAggregateInputType
  }


  export type Parcelas_lugaresGroupByOutputType = {
    idlugar: number
    idparcela: number | null
    idservicio: number | null
    lugar: number | null
    contrato: number | null
    dni: number | null
    fecha: Date | null
    operador: string | null
    _count: Parcelas_lugaresCountAggregateOutputType | null
    _avg: Parcelas_lugaresAvgAggregateOutputType | null
    _sum: Parcelas_lugaresSumAggregateOutputType | null
    _min: Parcelas_lugaresMinAggregateOutputType | null
    _max: Parcelas_lugaresMaxAggregateOutputType | null
  }

  type GetParcelas_lugaresGroupByPayload<T extends parcelas_lugaresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parcelas_lugaresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parcelas_lugaresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parcelas_lugaresGroupByOutputType[P]>
            : GetScalarType<T[P], Parcelas_lugaresGroupByOutputType[P]>
        }
      >
    >


  export type parcelas_lugaresSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idlugar?: boolean
    idparcela?: boolean
    idservicio?: boolean
    lugar?: boolean
    contrato?: boolean
    dni?: boolean
    fecha?: boolean
    operador?: boolean
  }, ExtArgs["result"]["parcelas_lugares"]>

  export type parcelas_lugaresSelectScalar = {
    idlugar?: boolean
    idparcela?: boolean
    idservicio?: boolean
    lugar?: boolean
    contrato?: boolean
    dni?: boolean
    fecha?: boolean
    operador?: boolean
  }


  type parcelas_lugaresGetPayload<S extends boolean | null | undefined | parcelas_lugaresArgs> = $Types.GetResult<parcelas_lugaresPayload, S>

  type parcelas_lugaresCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<parcelas_lugaresFindManyArgs, 'select' | 'include'> & {
      select?: Parcelas_lugaresCountAggregateInputType | true
    }

  export interface parcelas_lugaresDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parcelas_lugares'], meta: { name: 'parcelas_lugares' } }
    /**
     * Find zero or one Parcelas_lugares that matches the filter.
     * @param {parcelas_lugaresFindUniqueArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parcelas_lugaresFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parcelas_lugaresFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parcelas_lugares'> extends True ? Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Parcelas_lugares that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parcelas_lugaresFindUniqueOrThrowArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Parcelas_lugares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindFirstArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parcelas_lugaresFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parcelas_lugaresFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parcelas_lugares'> extends True ? Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Parcelas_lugares that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindFirstOrThrowArgs} args - Arguments to find a Parcelas_lugares
     * @example
     * // Get one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Parcelas_lugares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findMany()
     * 
     * // Get first 10 Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.findMany({ take: 10 })
     * 
     * // Only select the `idlugar`
     * const parcelas_lugaresWithIdlugarOnly = await prisma.parcelas_lugares.findMany({ select: { idlugar: true } })
     * 
    **/
    findMany<T extends parcelas_lugaresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Parcelas_lugares.
     * @param {parcelas_lugaresCreateArgs} args - Arguments to create a Parcelas_lugares.
     * @example
     * // Create one Parcelas_lugares
     * const Parcelas_lugares = await prisma.parcelas_lugares.create({
     *   data: {
     *     // ... data to create a Parcelas_lugares
     *   }
     * })
     * 
    **/
    create<T extends parcelas_lugaresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresCreateArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Parcelas_lugares.
     *     @param {parcelas_lugaresCreateManyArgs} args - Arguments to create many Parcelas_lugares.
     *     @example
     *     // Create many Parcelas_lugares
     *     const parcelas_lugares = await prisma.parcelas_lugares.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends parcelas_lugaresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parcelas_lugares.
     * @param {parcelas_lugaresDeleteArgs} args - Arguments to delete one Parcelas_lugares.
     * @example
     * // Delete one Parcelas_lugares
     * const Parcelas_lugares = await prisma.parcelas_lugares.delete({
     *   where: {
     *     // ... filter to delete one Parcelas_lugares
     *   }
     * })
     * 
    **/
    delete<T extends parcelas_lugaresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresDeleteArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Parcelas_lugares.
     * @param {parcelas_lugaresUpdateArgs} args - Arguments to update one Parcelas_lugares.
     * @example
     * // Update one Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parcelas_lugaresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpdateArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Parcelas_lugares.
     * @param {parcelas_lugaresDeleteManyArgs} args - Arguments to filter Parcelas_lugares to delete.
     * @example
     * // Delete a few Parcelas_lugares
     * const { count } = await prisma.parcelas_lugares.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parcelas_lugaresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, parcelas_lugaresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parcelas_lugaresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parcelas_lugares.
     * @param {parcelas_lugaresUpsertArgs} args - Arguments to update or create a Parcelas_lugares.
     * @example
     * // Update or create a Parcelas_lugares
     * const parcelas_lugares = await prisma.parcelas_lugares.upsert({
     *   create: {
     *     // ... data to create a Parcelas_lugares
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parcelas_lugares we want to update
     *   }
     * })
    **/
    upsert<T extends parcelas_lugaresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, parcelas_lugaresUpsertArgs<ExtArgs>>
    ): Prisma__parcelas_lugaresClient<$Types.GetResult<parcelas_lugaresPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresCountArgs} args - Arguments to filter Parcelas_lugares to count.
     * @example
     * // Count the number of Parcelas_lugares
     * const count = await prisma.parcelas_lugares.count({
     *   where: {
     *     // ... the filter for the Parcelas_lugares we want to count
     *   }
     * })
    **/
    count<T extends parcelas_lugaresCountArgs>(
      args?: Subset<T, parcelas_lugaresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parcelas_lugaresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parcelas_lugaresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parcelas_lugaresAggregateArgs>(args: Subset<T, Parcelas_lugaresAggregateArgs>): Prisma.PrismaPromise<GetParcelas_lugaresAggregateType<T>>

    /**
     * Group by Parcelas_lugares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parcelas_lugaresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parcelas_lugaresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parcelas_lugaresGroupByArgs['orderBy'] }
        : { orderBy?: parcelas_lugaresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parcelas_lugaresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParcelas_lugaresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parcelas_lugares.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parcelas_lugaresClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parcelas_lugares base type for findUnique actions
   */
  export type parcelas_lugaresFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where: parcelas_lugaresWhereUniqueInput
  }

  /**
   * parcelas_lugares findUnique
   */
  export interface parcelas_lugaresFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelas_lugaresFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas_lugares findUniqueOrThrow
   */
  export type parcelas_lugaresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares base type for findFirst actions
   */
  export type parcelas_lugaresFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas_lugares.
     */
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }

  /**
   * parcelas_lugares findFirst
   */
  export interface parcelas_lugaresFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends parcelas_lugaresFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parcelas_lugares findFirstOrThrow
   */
  export type parcelas_lugaresFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parcelas_lugares.
     */
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }


  /**
   * parcelas_lugares findMany
   */
  export type parcelas_lugaresFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter, which parcelas_lugares to fetch.
     */
    where?: parcelas_lugaresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parcelas_lugares to fetch.
     */
    orderBy?: parcelas_lugaresOrderByWithRelationInput | parcelas_lugaresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parcelas_lugares.
     */
    cursor?: parcelas_lugaresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parcelas_lugares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parcelas_lugares.
     */
    skip?: number
    distinct?: Parcelas_lugaresScalarFieldEnum | Parcelas_lugaresScalarFieldEnum[]
  }


  /**
   * parcelas_lugares create
   */
  export type parcelas_lugaresCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The data needed to create a parcelas_lugares.
     */
    data?: XOR<parcelas_lugaresCreateInput, parcelas_lugaresUncheckedCreateInput>
  }


  /**
   * parcelas_lugares createMany
   */
  export type parcelas_lugaresCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parcelas_lugares.
     */
    data: parcelas_lugaresCreateManyInput | parcelas_lugaresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * parcelas_lugares update
   */
  export type parcelas_lugaresUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The data needed to update a parcelas_lugares.
     */
    data: XOR<parcelas_lugaresUpdateInput, parcelas_lugaresUncheckedUpdateInput>
    /**
     * Choose, which parcelas_lugares to update.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares updateMany
   */
  export type parcelas_lugaresUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parcelas_lugares.
     */
    data: XOR<parcelas_lugaresUpdateManyMutationInput, parcelas_lugaresUncheckedUpdateManyInput>
    /**
     * Filter which parcelas_lugares to update
     */
    where?: parcelas_lugaresWhereInput
  }


  /**
   * parcelas_lugares upsert
   */
  export type parcelas_lugaresUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * The filter to search for the parcelas_lugares to update in case it exists.
     */
    where: parcelas_lugaresWhereUniqueInput
    /**
     * In case the parcelas_lugares found by the `where` argument doesn't exist, create a new parcelas_lugares with this data.
     */
    create: XOR<parcelas_lugaresCreateInput, parcelas_lugaresUncheckedCreateInput>
    /**
     * In case the parcelas_lugares was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parcelas_lugaresUpdateInput, parcelas_lugaresUncheckedUpdateInput>
  }


  /**
   * parcelas_lugares delete
   */
  export type parcelas_lugaresDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
    /**
     * Filter which parcelas_lugares to delete.
     */
    where: parcelas_lugaresWhereUniqueInput
  }


  /**
   * parcelas_lugares deleteMany
   */
  export type parcelas_lugaresDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which parcelas_lugares to delete
     */
    where?: parcelas_lugaresWhereInput
  }


  /**
   * parcelas_lugares without action
   */
  export type parcelas_lugaresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parcelas_lugares
     */
    select?: parcelas_lugaresSelect<ExtArgs> | null
  }



  /**
   * Model caja_sa
   */


  export type AggregateCaja_sa = {
    _count: Caja_saCountAggregateOutputType | null
    _avg: Caja_saAvgAggregateOutputType | null
    _sum: Caja_saSumAggregateOutputType | null
    _min: Caja_saMinAggregateOutputType | null
    _max: Caja_saMaxAggregateOutputType | null
  }

  export type Caja_saAvgAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_saSumAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_saMinAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_saMaxAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_saCountAggregateOutputType = {
    idcaja: number
    codigo: number
    cuenta: number
    tipo: number
    serie: number
    factura: number
    importe: number
    comentarios: number
    nro_caja: number
    movim: number
    fecha: number
    puesto: number
    operador: number
    cuit: number
    proveedor: number
    sucursal: number
    _all: number
  }


  export type Caja_saAvgAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_saSumAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_saMinAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_saMaxAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_saCountAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
    _all?: true
  }

  export type Caja_saAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sa to aggregate.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_sas
    **/
    _count?: true | Caja_saCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_saAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_saSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_saMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_saMaxAggregateInputType
  }

  export type GetCaja_saAggregateType<T extends Caja_saAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_sa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_sa[P]>
      : GetScalarType<T[P], AggregateCaja_sa[P]>
  }




  export type caja_saGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_saWhereInput
    orderBy?: caja_saOrderByWithAggregationInput | caja_saOrderByWithAggregationInput[]
    by: Caja_saScalarFieldEnum[] | Caja_saScalarFieldEnum
    having?: caja_saScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_saCountAggregateInputType | true
    _avg?: Caja_saAvgAggregateInputType
    _sum?: Caja_saSumAggregateInputType
    _min?: Caja_saMinAggregateInputType
    _max?: Caja_saMaxAggregateInputType
  }


  export type Caja_saGroupByOutputType = {
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
    _count: Caja_saCountAggregateOutputType | null
    _avg: Caja_saAvgAggregateOutputType | null
    _sum: Caja_saSumAggregateOutputType | null
    _min: Caja_saMinAggregateOutputType | null
    _max: Caja_saMaxAggregateOutputType | null
  }

  type GetCaja_saGroupByPayload<T extends caja_saGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_saGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_saGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_saGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_saGroupByOutputType[P]>
        }
      >
    >


  export type caja_saSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["caja_sa"]>

  export type caja_saSelectScalar = {
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }


  type caja_saGetPayload<S extends boolean | null | undefined | caja_saArgs> = $Types.GetResult<caja_saPayload, S>

  type caja_saCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_saFindManyArgs, 'select' | 'include'> & {
      select?: Caja_saCountAggregateInputType | true
    }

  export interface caja_saDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_sa'], meta: { name: 'caja_sa' } }
    /**
     * Find zero or one Caja_sa that matches the filter.
     * @param {caja_saFindUniqueArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_saFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_saFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_sa'> extends True ? Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_sa that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_saFindUniqueOrThrowArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_saFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_sa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindFirstArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_saFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_saFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_sa'> extends True ? Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_sa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindFirstOrThrowArgs} args - Arguments to find a Caja_sa
     * @example
     * // Get one Caja_sa
     * const caja_sa = await prisma.caja_sa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_saFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_sas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_sas
     * const caja_sas = await prisma.caja_sa.findMany()
     * 
     * // Get first 10 Caja_sas
     * const caja_sas = await prisma.caja_sa.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_saWithIdcajaOnly = await prisma.caja_sa.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_saFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_sa.
     * @param {caja_saCreateArgs} args - Arguments to create a Caja_sa.
     * @example
     * // Create one Caja_sa
     * const Caja_sa = await prisma.caja_sa.create({
     *   data: {
     *     // ... data to create a Caja_sa
     *   }
     * })
     * 
    **/
    create<T extends caja_saCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saCreateArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_sas.
     *     @param {caja_saCreateManyArgs} args - Arguments to create many Caja_sas.
     *     @example
     *     // Create many Caja_sas
     *     const caja_sa = await prisma.caja_sa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_saCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_sa.
     * @param {caja_saDeleteArgs} args - Arguments to delete one Caja_sa.
     * @example
     * // Delete one Caja_sa
     * const Caja_sa = await prisma.caja_sa.delete({
     *   where: {
     *     // ... filter to delete one Caja_sa
     *   }
     * })
     * 
    **/
    delete<T extends caja_saDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saDeleteArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_sa.
     * @param {caja_saUpdateArgs} args - Arguments to update one Caja_sa.
     * @example
     * // Update one Caja_sa
     * const caja_sa = await prisma.caja_sa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_saUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpdateArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_sas.
     * @param {caja_saDeleteManyArgs} args - Arguments to filter Caja_sas to delete.
     * @example
     * // Delete a few Caja_sas
     * const { count } = await prisma.caja_sa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_saDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_saDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_sas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_sas
     * const caja_sa = await prisma.caja_sa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_saUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_sa.
     * @param {caja_saUpsertArgs} args - Arguments to update or create a Caja_sa.
     * @example
     * // Update or create a Caja_sa
     * const caja_sa = await prisma.caja_sa.upsert({
     *   create: {
     *     // ... data to create a Caja_sa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_sa we want to update
     *   }
     * })
    **/
    upsert<T extends caja_saUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_saUpsertArgs<ExtArgs>>
    ): Prisma__caja_saClient<$Types.GetResult<caja_saPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_sas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saCountArgs} args - Arguments to filter Caja_sas to count.
     * @example
     * // Count the number of Caja_sas
     * const count = await prisma.caja_sa.count({
     *   where: {
     *     // ... the filter for the Caja_sas we want to count
     *   }
     * })
    **/
    count<T extends caja_saCountArgs>(
      args?: Subset<T, caja_saCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_saCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_sa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_saAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_saAggregateArgs>(args: Subset<T, Caja_saAggregateArgs>): Prisma.PrismaPromise<GetCaja_saAggregateType<T>>

    /**
     * Group by Caja_sa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_saGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_saGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_saGroupByArgs['orderBy'] }
        : { orderBy?: caja_saGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_saGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_saGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_sa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_saClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_sa base type for findUnique actions
   */
  export type caja_saFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where: caja_saWhereUniqueInput
  }

  /**
   * caja_sa findUnique
   */
  export interface caja_saFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_saFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sa findUniqueOrThrow
   */
  export type caja_saFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa base type for findFirst actions
   */
  export type caja_saFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sas.
     */
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }

  /**
   * caja_sa findFirst
   */
  export interface caja_saFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_saFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_sa findFirstOrThrow
   */
  export type caja_saFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sa to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_sas.
     */
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }


  /**
   * caja_sa findMany
   */
  export type caja_saFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter, which caja_sas to fetch.
     */
    where?: caja_saWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_sas to fetch.
     */
    orderBy?: caja_saOrderByWithRelationInput | caja_saOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_sas.
     */
    cursor?: caja_saWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_sas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_sas.
     */
    skip?: number
    distinct?: Caja_saScalarFieldEnum | Caja_saScalarFieldEnum[]
  }


  /**
   * caja_sa create
   */
  export type caja_saCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_sa.
     */
    data?: XOR<caja_saCreateInput, caja_saUncheckedCreateInput>
  }


  /**
   * caja_sa createMany
   */
  export type caja_saCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_sas.
     */
    data: caja_saCreateManyInput | caja_saCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_sa update
   */
  export type caja_saUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_sa.
     */
    data: XOR<caja_saUpdateInput, caja_saUncheckedUpdateInput>
    /**
     * Choose, which caja_sa to update.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa updateMany
   */
  export type caja_saUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_sas.
     */
    data: XOR<caja_saUpdateManyMutationInput, caja_saUncheckedUpdateManyInput>
    /**
     * Filter which caja_sas to update
     */
    where?: caja_saWhereInput
  }


  /**
   * caja_sa upsert
   */
  export type caja_saUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_sa to update in case it exists.
     */
    where: caja_saWhereUniqueInput
    /**
     * In case the caja_sa found by the `where` argument doesn't exist, create a new caja_sa with this data.
     */
    create: XOR<caja_saCreateInput, caja_saUncheckedCreateInput>
    /**
     * In case the caja_sa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_saUpdateInput, caja_saUncheckedUpdateInput>
  }


  /**
   * caja_sa delete
   */
  export type caja_saDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
    /**
     * Filter which caja_sa to delete.
     */
    where: caja_saWhereUniqueInput
  }


  /**
   * caja_sa deleteMany
   */
  export type caja_saDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_sas to delete
     */
    where?: caja_saWhereInput
  }


  /**
   * caja_sa without action
   */
  export type caja_saArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_sa
     */
    select?: caja_saSelect<ExtArgs> | null
  }



  /**
   * Model caja_srl
   */


  export type AggregateCaja_srl = {
    _count: Caja_srlCountAggregateOutputType | null
    _avg: Caja_srlAvgAggregateOutputType | null
    _sum: Caja_srlSumAggregateOutputType | null
    _min: Caja_srlMinAggregateOutputType | null
    _max: Caja_srlMaxAggregateOutputType | null
  }

  export type Caja_srlAvgAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_srlSumAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    serie: number | null
    factura: number | null
    importe: number | null
    nro_caja: number | null
    puesto: number | null
    operador: number | null
  }

  export type Caja_srlMinAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_srlMaxAggregateOutputType = {
    idcaja: number | null
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
  }

  export type Caja_srlCountAggregateOutputType = {
    idcaja: number
    codigo: number
    cuenta: number
    tipo: number
    serie: number
    factura: number
    importe: number
    comentarios: number
    nro_caja: number
    movim: number
    fecha: number
    puesto: number
    operador: number
    cuit: number
    proveedor: number
    sucursal: number
    _all: number
  }


  export type Caja_srlAvgAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_srlSumAggregateInputType = {
    idcaja?: true
    codigo?: true
    serie?: true
    factura?: true
    importe?: true
    nro_caja?: true
    puesto?: true
    operador?: true
  }

  export type Caja_srlMinAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_srlMaxAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
  }

  export type Caja_srlCountAggregateInputType = {
    idcaja?: true
    codigo?: true
    cuenta?: true
    tipo?: true
    serie?: true
    factura?: true
    importe?: true
    comentarios?: true
    nro_caja?: true
    movim?: true
    fecha?: true
    puesto?: true
    operador?: true
    cuit?: true
    proveedor?: true
    sucursal?: true
    _all?: true
  }

  export type Caja_srlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_srl to aggregate.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caja_srls
    **/
    _count?: true | Caja_srlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Caja_srlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Caja_srlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Caja_srlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Caja_srlMaxAggregateInputType
  }

  export type GetCaja_srlAggregateType<T extends Caja_srlAggregateArgs> = {
        [P in keyof T & keyof AggregateCaja_srl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaja_srl[P]>
      : GetScalarType<T[P], AggregateCaja_srl[P]>
  }




  export type caja_srlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: caja_srlWhereInput
    orderBy?: caja_srlOrderByWithAggregationInput | caja_srlOrderByWithAggregationInput[]
    by: Caja_srlScalarFieldEnum[] | Caja_srlScalarFieldEnum
    having?: caja_srlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Caja_srlCountAggregateInputType | true
    _avg?: Caja_srlAvgAggregateInputType
    _sum?: Caja_srlSumAggregateInputType
    _min?: Caja_srlMinAggregateInputType
    _max?: Caja_srlMaxAggregateInputType
  }


  export type Caja_srlGroupByOutputType = {
    idcaja: number
    codigo: number | null
    cuenta: string | null
    tipo: string | null
    serie: number | null
    factura: number | null
    importe: number | null
    comentarios: string | null
    nro_caja: number | null
    movim: string | null
    fecha: Date | null
    puesto: number | null
    operador: number | null
    cuit: string | null
    proveedor: string | null
    sucursal: string | null
    _count: Caja_srlCountAggregateOutputType | null
    _avg: Caja_srlAvgAggregateOutputType | null
    _sum: Caja_srlSumAggregateOutputType | null
    _min: Caja_srlMinAggregateOutputType | null
    _max: Caja_srlMaxAggregateOutputType | null
  }

  type GetCaja_srlGroupByPayload<T extends caja_srlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Caja_srlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Caja_srlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Caja_srlGroupByOutputType[P]>
            : GetScalarType<T[P], Caja_srlGroupByOutputType[P]>
        }
      >
    >


  export type caja_srlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }, ExtArgs["result"]["caja_srl"]>

  export type caja_srlSelectScalar = {
    idcaja?: boolean
    codigo?: boolean
    cuenta?: boolean
    tipo?: boolean
    serie?: boolean
    factura?: boolean
    importe?: boolean
    comentarios?: boolean
    nro_caja?: boolean
    movim?: boolean
    fecha?: boolean
    puesto?: boolean
    operador?: boolean
    cuit?: boolean
    proveedor?: boolean
    sucursal?: boolean
  }


  type caja_srlGetPayload<S extends boolean | null | undefined | caja_srlArgs> = $Types.GetResult<caja_srlPayload, S>

  type caja_srlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<caja_srlFindManyArgs, 'select' | 'include'> & {
      select?: Caja_srlCountAggregateInputType | true
    }

  export interface caja_srlDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caja_srl'], meta: { name: 'caja_srl' } }
    /**
     * Find zero or one Caja_srl that matches the filter.
     * @param {caja_srlFindUniqueArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends caja_srlFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, caja_srlFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'caja_srl'> extends True ? Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Caja_srl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {caja_srlFindUniqueOrThrowArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends caja_srlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Caja_srl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindFirstArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends caja_srlFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, caja_srlFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'caja_srl'> extends True ? Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Caja_srl that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindFirstOrThrowArgs} args - Arguments to find a Caja_srl
     * @example
     * // Get one Caja_srl
     * const caja_srl = await prisma.caja_srl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends caja_srlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Caja_srls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caja_srls
     * const caja_srls = await prisma.caja_srl.findMany()
     * 
     * // Get first 10 Caja_srls
     * const caja_srls = await prisma.caja_srl.findMany({ take: 10 })
     * 
     * // Only select the `idcaja`
     * const caja_srlWithIdcajaOnly = await prisma.caja_srl.findMany({ select: { idcaja: true } })
     * 
    **/
    findMany<T extends caja_srlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Caja_srl.
     * @param {caja_srlCreateArgs} args - Arguments to create a Caja_srl.
     * @example
     * // Create one Caja_srl
     * const Caja_srl = await prisma.caja_srl.create({
     *   data: {
     *     // ... data to create a Caja_srl
     *   }
     * })
     * 
    **/
    create<T extends caja_srlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlCreateArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Caja_srls.
     *     @param {caja_srlCreateManyArgs} args - Arguments to create many Caja_srls.
     *     @example
     *     // Create many Caja_srls
     *     const caja_srl = await prisma.caja_srl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends caja_srlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Caja_srl.
     * @param {caja_srlDeleteArgs} args - Arguments to delete one Caja_srl.
     * @example
     * // Delete one Caja_srl
     * const Caja_srl = await prisma.caja_srl.delete({
     *   where: {
     *     // ... filter to delete one Caja_srl
     *   }
     * })
     * 
    **/
    delete<T extends caja_srlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlDeleteArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Caja_srl.
     * @param {caja_srlUpdateArgs} args - Arguments to update one Caja_srl.
     * @example
     * // Update one Caja_srl
     * const caja_srl = await prisma.caja_srl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends caja_srlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpdateArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Caja_srls.
     * @param {caja_srlDeleteManyArgs} args - Arguments to filter Caja_srls to delete.
     * @example
     * // Delete a few Caja_srls
     * const { count } = await prisma.caja_srl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends caja_srlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, caja_srlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caja_srls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caja_srls
     * const caja_srl = await prisma.caja_srl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends caja_srlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Caja_srl.
     * @param {caja_srlUpsertArgs} args - Arguments to update or create a Caja_srl.
     * @example
     * // Update or create a Caja_srl
     * const caja_srl = await prisma.caja_srl.upsert({
     *   create: {
     *     // ... data to create a Caja_srl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caja_srl we want to update
     *   }
     * })
    **/
    upsert<T extends caja_srlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, caja_srlUpsertArgs<ExtArgs>>
    ): Prisma__caja_srlClient<$Types.GetResult<caja_srlPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Caja_srls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlCountArgs} args - Arguments to filter Caja_srls to count.
     * @example
     * // Count the number of Caja_srls
     * const count = await prisma.caja_srl.count({
     *   where: {
     *     // ... the filter for the Caja_srls we want to count
     *   }
     * })
    **/
    count<T extends caja_srlCountArgs>(
      args?: Subset<T, caja_srlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Caja_srlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caja_srl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Caja_srlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Caja_srlAggregateArgs>(args: Subset<T, Caja_srlAggregateArgs>): Prisma.PrismaPromise<GetCaja_srlAggregateType<T>>

    /**
     * Group by Caja_srl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caja_srlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caja_srlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caja_srlGroupByArgs['orderBy'] }
        : { orderBy?: caja_srlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caja_srlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaja_srlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for caja_srl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__caja_srlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * caja_srl base type for findUnique actions
   */
  export type caja_srlFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where: caja_srlWhereUniqueInput
  }

  /**
   * caja_srl findUnique
   */
  export interface caja_srlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_srlFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_srl findUniqueOrThrow
   */
  export type caja_srlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl base type for findFirst actions
   */
  export type caja_srlFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_srls.
     */
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }

  /**
   * caja_srl findFirst
   */
  export interface caja_srlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends caja_srlFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * caja_srl findFirstOrThrow
   */
  export type caja_srlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srl to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caja_srls.
     */
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }


  /**
   * caja_srl findMany
   */
  export type caja_srlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter, which caja_srls to fetch.
     */
    where?: caja_srlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caja_srls to fetch.
     */
    orderBy?: caja_srlOrderByWithRelationInput | caja_srlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caja_srls.
     */
    cursor?: caja_srlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caja_srls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caja_srls.
     */
    skip?: number
    distinct?: Caja_srlScalarFieldEnum | Caja_srlScalarFieldEnum[]
  }


  /**
   * caja_srl create
   */
  export type caja_srlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The data needed to create a caja_srl.
     */
    data?: XOR<caja_srlCreateInput, caja_srlUncheckedCreateInput>
  }


  /**
   * caja_srl createMany
   */
  export type caja_srlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caja_srls.
     */
    data: caja_srlCreateManyInput | caja_srlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * caja_srl update
   */
  export type caja_srlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The data needed to update a caja_srl.
     */
    data: XOR<caja_srlUpdateInput, caja_srlUncheckedUpdateInput>
    /**
     * Choose, which caja_srl to update.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl updateMany
   */
  export type caja_srlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caja_srls.
     */
    data: XOR<caja_srlUpdateManyMutationInput, caja_srlUncheckedUpdateManyInput>
    /**
     * Filter which caja_srls to update
     */
    where?: caja_srlWhereInput
  }


  /**
   * caja_srl upsert
   */
  export type caja_srlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * The filter to search for the caja_srl to update in case it exists.
     */
    where: caja_srlWhereUniqueInput
    /**
     * In case the caja_srl found by the `where` argument doesn't exist, create a new caja_srl with this data.
     */
    create: XOR<caja_srlCreateInput, caja_srlUncheckedCreateInput>
    /**
     * In case the caja_srl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caja_srlUpdateInput, caja_srlUncheckedUpdateInput>
  }


  /**
   * caja_srl delete
   */
  export type caja_srlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
    /**
     * Filter which caja_srl to delete.
     */
    where: caja_srlWhereUniqueInput
  }


  /**
   * caja_srl deleteMany
   */
  export type caja_srlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which caja_srls to delete
     */
    where?: caja_srlWhereInput
  }


  /**
   * caja_srl without action
   */
  export type caja_srlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caja_srl
     */
    select?: caja_srlSelect<ExtArgs> | null
  }



  /**
   * Model generacion_cajas
   */


  export type AggregateGeneracion_cajas = {
    _count: Generacion_cajasCountAggregateOutputType | null
    _avg: Generacion_cajasAvgAggregateOutputType | null
    _sum: Generacion_cajasSumAggregateOutputType | null
    _min: Generacion_cajasMinAggregateOutputType | null
    _max: Generacion_cajasMaxAggregateOutputType | null
  }

  export type Generacion_cajasAvgAggregateOutputType = {
    idgeneracion: number | null
  }

  export type Generacion_cajasSumAggregateOutputType = {
    idgeneracion: number | null
  }

  export type Generacion_cajasMinAggregateOutputType = {
    idgeneracion: number | null
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }

  export type Generacion_cajasMaxAggregateOutputType = {
    idgeneracion: number | null
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
  }

  export type Generacion_cajasCountAggregateOutputType = {
    idgeneracion: number
    desde: number
    hasta: number
    empresa: number
    operador: number
    fecha: number
    _all: number
  }


  export type Generacion_cajasAvgAggregateInputType = {
    idgeneracion?: true
  }

  export type Generacion_cajasSumAggregateInputType = {
    idgeneracion?: true
  }

  export type Generacion_cajasMinAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
  }

  export type Generacion_cajasMaxAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
  }

  export type Generacion_cajasCountAggregateInputType = {
    idgeneracion?: true
    desde?: true
    hasta?: true
    empresa?: true
    operador?: true
    fecha?: true
    _all?: true
  }

  export type Generacion_cajasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which generacion_cajas to aggregate.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned generacion_cajas
    **/
    _count?: true | Generacion_cajasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Generacion_cajasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Generacion_cajasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Generacion_cajasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Generacion_cajasMaxAggregateInputType
  }

  export type GetGeneracion_cajasAggregateType<T extends Generacion_cajasAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneracion_cajas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneracion_cajas[P]>
      : GetScalarType<T[P], AggregateGeneracion_cajas[P]>
  }




  export type generacion_cajasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: generacion_cajasWhereInput
    orderBy?: generacion_cajasOrderByWithAggregationInput | generacion_cajasOrderByWithAggregationInput[]
    by: Generacion_cajasScalarFieldEnum[] | Generacion_cajasScalarFieldEnum
    having?: generacion_cajasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Generacion_cajasCountAggregateInputType | true
    _avg?: Generacion_cajasAvgAggregateInputType
    _sum?: Generacion_cajasSumAggregateInputType
    _min?: Generacion_cajasMinAggregateInputType
    _max?: Generacion_cajasMaxAggregateInputType
  }


  export type Generacion_cajasGroupByOutputType = {
    idgeneracion: number
    desde: Date | null
    hasta: Date | null
    empresa: string | null
    operador: string | null
    fecha: Date | null
    _count: Generacion_cajasCountAggregateOutputType | null
    _avg: Generacion_cajasAvgAggregateOutputType | null
    _sum: Generacion_cajasSumAggregateOutputType | null
    _min: Generacion_cajasMinAggregateOutputType | null
    _max: Generacion_cajasMaxAggregateOutputType | null
  }

  type GetGeneracion_cajasGroupByPayload<T extends generacion_cajasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Generacion_cajasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Generacion_cajasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Generacion_cajasGroupByOutputType[P]>
            : GetScalarType<T[P], Generacion_cajasGroupByOutputType[P]>
        }
      >
    >


  export type generacion_cajasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idgeneracion?: boolean
    desde?: boolean
    hasta?: boolean
    empresa?: boolean
    operador?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["generacion_cajas"]>

  export type generacion_cajasSelectScalar = {
    idgeneracion?: boolean
    desde?: boolean
    hasta?: boolean
    empresa?: boolean
    operador?: boolean
    fecha?: boolean
  }


  type generacion_cajasGetPayload<S extends boolean | null | undefined | generacion_cajasArgs> = $Types.GetResult<generacion_cajasPayload, S>

  type generacion_cajasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<generacion_cajasFindManyArgs, 'select' | 'include'> & {
      select?: Generacion_cajasCountAggregateInputType | true
    }

  export interface generacion_cajasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['generacion_cajas'], meta: { name: 'generacion_cajas' } }
    /**
     * Find zero or one Generacion_cajas that matches the filter.
     * @param {generacion_cajasFindUniqueArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends generacion_cajasFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, generacion_cajasFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'generacion_cajas'> extends True ? Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Generacion_cajas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {generacion_cajasFindUniqueOrThrowArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends generacion_cajasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Generacion_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindFirstArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends generacion_cajasFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, generacion_cajasFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'generacion_cajas'> extends True ? Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Generacion_cajas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindFirstOrThrowArgs} args - Arguments to find a Generacion_cajas
     * @example
     * // Get one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends generacion_cajasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Generacion_cajas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findMany()
     * 
     * // Get first 10 Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.findMany({ take: 10 })
     * 
     * // Only select the `idgeneracion`
     * const generacion_cajasWithIdgeneracionOnly = await prisma.generacion_cajas.findMany({ select: { idgeneracion: true } })
     * 
    **/
    findMany<T extends generacion_cajasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Generacion_cajas.
     * @param {generacion_cajasCreateArgs} args - Arguments to create a Generacion_cajas.
     * @example
     * // Create one Generacion_cajas
     * const Generacion_cajas = await prisma.generacion_cajas.create({
     *   data: {
     *     // ... data to create a Generacion_cajas
     *   }
     * })
     * 
    **/
    create<T extends generacion_cajasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasCreateArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Generacion_cajas.
     *     @param {generacion_cajasCreateManyArgs} args - Arguments to create many Generacion_cajas.
     *     @example
     *     // Create many Generacion_cajas
     *     const generacion_cajas = await prisma.generacion_cajas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends generacion_cajasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Generacion_cajas.
     * @param {generacion_cajasDeleteArgs} args - Arguments to delete one Generacion_cajas.
     * @example
     * // Delete one Generacion_cajas
     * const Generacion_cajas = await prisma.generacion_cajas.delete({
     *   where: {
     *     // ... filter to delete one Generacion_cajas
     *   }
     * })
     * 
    **/
    delete<T extends generacion_cajasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasDeleteArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Generacion_cajas.
     * @param {generacion_cajasUpdateArgs} args - Arguments to update one Generacion_cajas.
     * @example
     * // Update one Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends generacion_cajasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpdateArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Generacion_cajas.
     * @param {generacion_cajasDeleteManyArgs} args - Arguments to filter Generacion_cajas to delete.
     * @example
     * // Delete a few Generacion_cajas
     * const { count } = await prisma.generacion_cajas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends generacion_cajasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, generacion_cajasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends generacion_cajasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Generacion_cajas.
     * @param {generacion_cajasUpsertArgs} args - Arguments to update or create a Generacion_cajas.
     * @example
     * // Update or create a Generacion_cajas
     * const generacion_cajas = await prisma.generacion_cajas.upsert({
     *   create: {
     *     // ... data to create a Generacion_cajas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generacion_cajas we want to update
     *   }
     * })
    **/
    upsert<T extends generacion_cajasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, generacion_cajasUpsertArgs<ExtArgs>>
    ): Prisma__generacion_cajasClient<$Types.GetResult<generacion_cajasPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasCountArgs} args - Arguments to filter Generacion_cajas to count.
     * @example
     * // Count the number of Generacion_cajas
     * const count = await prisma.generacion_cajas.count({
     *   where: {
     *     // ... the filter for the Generacion_cajas we want to count
     *   }
     * })
    **/
    count<T extends generacion_cajasCountArgs>(
      args?: Subset<T, generacion_cajasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Generacion_cajasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Generacion_cajasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Generacion_cajasAggregateArgs>(args: Subset<T, Generacion_cajasAggregateArgs>): Prisma.PrismaPromise<GetGeneracion_cajasAggregateType<T>>

    /**
     * Group by Generacion_cajas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generacion_cajasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends generacion_cajasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: generacion_cajasGroupByArgs['orderBy'] }
        : { orderBy?: generacion_cajasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, generacion_cajasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneracion_cajasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for generacion_cajas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__generacion_cajasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * generacion_cajas base type for findUnique actions
   */
  export type generacion_cajasFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where: generacion_cajasWhereUniqueInput
  }

  /**
   * generacion_cajas findUnique
   */
  export interface generacion_cajasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends generacion_cajasFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * generacion_cajas findUniqueOrThrow
   */
  export type generacion_cajasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas base type for findFirst actions
   */
  export type generacion_cajasFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generacion_cajas.
     */
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }

  /**
   * generacion_cajas findFirst
   */
  export interface generacion_cajasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends generacion_cajasFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * generacion_cajas findFirstOrThrow
   */
  export type generacion_cajasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generacion_cajas.
     */
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }


  /**
   * generacion_cajas findMany
   */
  export type generacion_cajasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter, which generacion_cajas to fetch.
     */
    where?: generacion_cajasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generacion_cajas to fetch.
     */
    orderBy?: generacion_cajasOrderByWithRelationInput | generacion_cajasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing generacion_cajas.
     */
    cursor?: generacion_cajasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generacion_cajas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generacion_cajas.
     */
    skip?: number
    distinct?: Generacion_cajasScalarFieldEnum | Generacion_cajasScalarFieldEnum[]
  }


  /**
   * generacion_cajas create
   */
  export type generacion_cajasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The data needed to create a generacion_cajas.
     */
    data?: XOR<generacion_cajasCreateInput, generacion_cajasUncheckedCreateInput>
  }


  /**
   * generacion_cajas createMany
   */
  export type generacion_cajasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many generacion_cajas.
     */
    data: generacion_cajasCreateManyInput | generacion_cajasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * generacion_cajas update
   */
  export type generacion_cajasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The data needed to update a generacion_cajas.
     */
    data: XOR<generacion_cajasUpdateInput, generacion_cajasUncheckedUpdateInput>
    /**
     * Choose, which generacion_cajas to update.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas updateMany
   */
  export type generacion_cajasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update generacion_cajas.
     */
    data: XOR<generacion_cajasUpdateManyMutationInput, generacion_cajasUncheckedUpdateManyInput>
    /**
     * Filter which generacion_cajas to update
     */
    where?: generacion_cajasWhereInput
  }


  /**
   * generacion_cajas upsert
   */
  export type generacion_cajasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * The filter to search for the generacion_cajas to update in case it exists.
     */
    where: generacion_cajasWhereUniqueInput
    /**
     * In case the generacion_cajas found by the `where` argument doesn't exist, create a new generacion_cajas with this data.
     */
    create: XOR<generacion_cajasCreateInput, generacion_cajasUncheckedCreateInput>
    /**
     * In case the generacion_cajas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<generacion_cajasUpdateInput, generacion_cajasUncheckedUpdateInput>
  }


  /**
   * generacion_cajas delete
   */
  export type generacion_cajasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
    /**
     * Filter which generacion_cajas to delete.
     */
    where: generacion_cajasWhereUniqueInput
  }


  /**
   * generacion_cajas deleteMany
   */
  export type generacion_cajasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which generacion_cajas to delete
     */
    where?: generacion_cajasWhereInput
  }


  /**
   * generacion_cajas without action
   */
  export type generacion_cajasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generacion_cajas
     */
    select?: generacion_cajasSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Ataud_precioScalarFieldEnum: {
    idprecio: 'idprecio',
    idataud: 'idataud',
    codigo: 'codigo',
    ataud: 'ataud',
    precio: 'precio',
    pri_desc: 'pri_desc',
    sec_desc: 'sec_desc',
    fecha: 'fecha',
    operador: 'operador',
    estado: 'estado'
  };

  export type Ataud_precioScalarFieldEnum = (typeof Ataud_precioScalarFieldEnum)[keyof typeof Ataud_precioScalarFieldEnum]


  export const Ataud_ventaScalarFieldEnum: {
    idataudventa: 'idataudventa',
    idataud: 'idataud',
    contrato: 'contrato',
    apellido_fall: 'apellido_fall',
    nombre_fall: 'nombre_fall',
    dni_fall: 'dni_fall',
    dom_fall: 'dom_fall',
    ndom_fall: 'ndom_fall',
    barrio_fall: 'barrio_fall',
    telefono_fall: 'telefono_fall',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    telefono_sol: 'telefono_sol',
    fecha: 'fecha',
    operador: 'operador',
    ataud: 'ataud'
  };

  export type Ataud_ventaScalarFieldEnum = (typeof Ataud_ventaScalarFieldEnum)[keyof typeof Ataud_ventaScalarFieldEnum]


  export const AtaudesScalarFieldEnum: {
    idataud: 'idataud',
    nombre: 'nombre',
    tipo: 'tipo',
    medidas: 'medidas',
    uso: 'uso',
    fabricante: 'fabricante',
    codigo: 'codigo',
    fecha_alta: 'fecha_alta',
    stock: 'stock',
    fecha_reposicion: 'fecha_reposicion',
    fecha_baja: 'fecha_baja',
    observaciones: 'observaciones',
    estado: 'estado',
    operador: 'operador'
  };

  export type AtaudesScalarFieldEnum = (typeof AtaudesScalarFieldEnum)[keyof typeof AtaudesScalarFieldEnum]


  export const AutosScalarFieldEnum: {
    patente: 'patente',
    auto: 'auto',
    kilometros: 'kilometros',
    responsable: 'responsable',
    nro_poliza: 'nro_poliza',
    empresa: 'empresa',
    vencimiento: 'vencimiento',
    motor: 'motor',
    chasis: 'chasis',
    modelo: 'modelo',
    cobertura: 'cobertura',
    idauto: 'idauto',
    estado: 'estado',
    operador: 'operador'
  };

  export type AutosScalarFieldEnum = (typeof AutosScalarFieldEnum)[keyof typeof AutosScalarFieldEnum]


  export const Autos_hoja_rutaScalarFieldEnum: {
    idhojaruta: 'idhojaruta',
    patente: 'patente',
    auto: 'auto',
    conductor: 'conductor',
    idservicio: 'idservicio',
    fecha_salida: 'fecha_salida',
    km_salida: 'km_salida',
    fecha_llegada: 'fecha_llegada',
    km_llegada: 'km_llegada',
    fecha_registro: 'fecha_registro',
    operador: 'operador'
  };

  export type Autos_hoja_rutaScalarFieldEnum = (typeof Autos_hoja_rutaScalarFieldEnum)[keyof typeof Autos_hoja_rutaScalarFieldEnum]


  export const Autos_novedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    patente: 'patente',
    fecha: 'fecha',
    novedad: 'novedad',
    operador: 'operador',
    auto: 'auto'
  };

  export type Autos_novedadesScalarFieldEnum = (typeof Autos_novedadesScalarFieldEnum)[keyof typeof Autos_novedadesScalarFieldEnum]


  export const Autos_pago_patenteScalarFieldEnum: {
    idpago: 'idpago',
    patente: 'patente',
    mes: 'mes',
    ano: 'ano',
    importe: 'importe',
    cod_pago: 'cod_pago',
    idauto: 'idauto',
    operador: 'operador'
  };

  export type Autos_pago_patenteScalarFieldEnum = (typeof Autos_pago_patenteScalarFieldEnum)[keyof typeof Autos_pago_patenteScalarFieldEnum]


  export const Caja_sepelioScalarFieldEnum: {
    idcaja: 'idcaja',
    operador: 'operador',
    detalle: 'detalle',
    monto: 'monto',
    estado: 'estado',
    fecha: 'fecha',
    gastos: 'gastos',
    totalcaja: 'totalcaja',
    empresa: 'empresa',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    ptoventa: 'ptoventa',
    concepto: 'concepto',
    cierre: 'cierre',
    ultimacarga: 'ultimacarga'
  };

  export type Caja_sepelioScalarFieldEnum = (typeof Caja_sepelioScalarFieldEnum)[keyof typeof Caja_sepelioScalarFieldEnum]


  export const ConceptosScalarFieldEnum: {
    idconcepto: 'idconcepto',
    concepto: 'concepto',
    tipo: 'tipo'
  };

  export type ConceptosScalarFieldEnum = (typeof ConceptosScalarFieldEnum)[keyof typeof ConceptosScalarFieldEnum]


  export const Fabricante_ataudScalarFieldEnum: {
    idfabricante: 'idfabricante',
    fabricante: 'fabricante'
  };

  export type Fabricante_ataudScalarFieldEnum = (typeof Fabricante_ataudScalarFieldEnum)[keyof typeof Fabricante_ataudScalarFieldEnum]


  export const Gasto_lutoScalarFieldEnum: {
    idgastoluto: 'idgastoluto',
    idservicio: 'idservicio',
    contrato: 'contrato',
    dni_extinto: 'dni_extinto',
    extinto: 'extinto',
    gasto_luto: 'gasto_luto',
    idataud: 'idataud',
    apellido_ben: 'apellido_ben',
    nombre_ben: 'nombre_ben',
    telefono_ben: 'telefono_ben',
    fecha: 'fecha',
    operador: 'operador',
    parentezco: 'parentezco'
  };

  export type Gasto_lutoScalarFieldEnum = (typeof Gasto_lutoScalarFieldEnum)[keyof typeof Gasto_lutoScalarFieldEnum]


  export const Gastos_cajaScalarFieldEnum: {
    idgastos: 'idgastos',
    idcaja: 'idcaja',
    concepto: 'concepto',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    fecha: 'fecha',
    operadorgestion: 'operadorgestion',
    operadortramite: 'operadortramite',
    ptoventa: 'ptoventa',
    porciva: 'porciva',
    montoiva: 'montoiva',
    retiibb: 'retiibb',
    retggcias: 'retggcias',
    perciva: 'perciva',
    detalle: 'detalle',
    mediopago: 'mediopago',
    proveedor: 'proveedor',
    empresa: 'empresa',
    total: 'total',
    idservicio: 'idservicio'
  };

  export type Gastos_cajaScalarFieldEnum = (typeof Gastos_cajaScalarFieldEnum)[keyof typeof Gastos_cajaScalarFieldEnum]


  export const Historial_autosScalarFieldEnum: {
    idhistorial: 'idhistorial',
    patente: 'patente',
    idauto: 'idauto',
    operador: 'operador',
    fecha: 'fecha',
    accion: 'accion'
  };

  export type Historial_autosScalarFieldEnum = (typeof Historial_autosScalarFieldEnum)[keyof typeof Historial_autosScalarFieldEnum]


  export const Historial_stock_ataudScalarFieldEnum: {
    idhistorial: 'idhistorial',
    idataud: 'idataud',
    fecha_carga: 'fecha_carga',
    stock_anterior: 'stock_anterior',
    stock_nuevo: 'stock_nuevo',
    remito: 'remito',
    operador: 'operador',
    fecha_recepcion: 'fecha_recepcion'
  };

  export type Historial_stock_ataudScalarFieldEnum = (typeof Historial_stock_ataudScalarFieldEnum)[keyof typeof Historial_stock_ataudScalarFieldEnum]


  export const HonorariosScalarFieldEnum: {
    idtrabajo: 'idtrabajo',
    trabajo: 'trabajo',
    dias_habiles: 'dias_habiles',
    finde: 'finde',
    feriado: 'feriado'
  };

  export type HonorariosScalarFieldEnum = (typeof HonorariosScalarFieldEnum)[keyof typeof HonorariosScalarFieldEnum]


  export const Ingreso_cajaScalarFieldEnum: {
    idingreso: 'idingreso',
    idcaja: 'idcaja',
    concepto: 'concepto',
    monto: 'monto',
    operador: 'operador',
    fecha: 'fecha',
    tipofactura: 'tipofactura',
    nfactura: 'nfactura',
    empresa: 'empresa',
    detalle: 'detalle',
    ptoventa: 'ptoventa'
  };

  export type Ingreso_cajaScalarFieldEnum = (typeof Ingreso_cajaScalarFieldEnum)[keyof typeof Ingreso_cajaScalarFieldEnum]


  export const Legajo_virtual_autosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    patente: 'patente',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida'
  };

  export type Legajo_virtual_autosScalarFieldEnum = (typeof Legajo_virtual_autosScalarFieldEnum)[keyof typeof Legajo_virtual_autosScalarFieldEnum]


  export const Legajo_virtual_serviciosScalarFieldEnum: {
    idlegajo: 'idlegajo',
    servicio: 'servicio',
    archivo: 'archivo',
    fecha_subida: 'fecha_subida',
    empresa: 'empresa'
  };

  export type Legajo_virtual_serviciosScalarFieldEnum = (typeof Legajo_virtual_serviciosScalarFieldEnum)[keyof typeof Legajo_virtual_serviciosScalarFieldEnum]


  export const NovedadesScalarFieldEnum: {
    idnovedad: 'idnovedad',
    novedad: 'novedad',
    fecha: 'fecha',
    operador: 'operador'
  };

  export type NovedadesScalarFieldEnum = (typeof NovedadesScalarFieldEnum)[keyof typeof NovedadesScalarFieldEnum]


  export const OperadorsepScalarFieldEnum: {
    idoperador: 'idoperador',
    operador: 'operador'
  };

  export type OperadorsepScalarFieldEnum = (typeof OperadorsepScalarFieldEnum)[keyof typeof OperadorsepScalarFieldEnum]


  export const ParcelasScalarFieldEnum: {
    idparcela: 'idparcela',
    idservicio: 'idservicio',
    dni_extinto: 'dni_extinto',
    ficha: 'ficha',
    parcela: 'parcela',
    mza: 'mza',
    lote: 'lote',
    asignada: 'asignada',
    fecha: 'fecha',
    cementerio: 'cementerio',
    operador: 'operador',
    fecha_alta: 'fecha_alta',
    operador_asignacion: 'operador_asignacion',
    fecha_asignacion: 'fecha_asignacion',
    lugares: 'lugares'
  };

  export type ParcelasScalarFieldEnum = (typeof ParcelasScalarFieldEnum)[keyof typeof ParcelasScalarFieldEnum]


  export const Planificacion_guardiasScalarFieldEnum: {
    idturno: 'idturno',
    lugar: 'lugar',
    inicio: 'inicio',
    fin: 'fin',
    horas: 'horas',
    operador: 'operador',
    mes_planificacion: 'mes_planificacion',
    feriado: 'feriado',
    tarea: 'tarea',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    operadorap: 'operadorap',
    ano_planificacion: 'ano_planificacion'
  };

  export type Planificacion_guardiasScalarFieldEnum = (typeof Planificacion_guardiasScalarFieldEnum)[keyof typeof Planificacion_guardiasScalarFieldEnum]


  export const Precio_servicioScalarFieldEnum: {
    idprecio: 'idprecio',
    codigo: 'codigo',
    contado: 'contado',
    contado_cremacion: 'contado_cremacion',
    descuento1: 'descuento1',
    descuento1_cremacion: 'descuento1_cremacion',
    descuento2: 'descuento2',
    descuento2_cremacion: 'descuento2_cremacion',
    fecha_vigencia: 'fecha_vigencia'
  };

  export type Precio_servicioScalarFieldEnum = (typeof Precio_servicioScalarFieldEnum)[keyof typeof Precio_servicioScalarFieldEnum]


  export const ProveedoresScalarFieldEnum: {
    idproveedor: 'idproveedor',
    razon: 'razon',
    cuit: 'cuit',
    domicilio: 'domicilio',
    telefonos: 'telefonos',
    estado: 'estado',
    operador: 'operador'
  };

  export type ProveedoresScalarFieldEnum = (typeof ProveedoresScalarFieldEnum)[keyof typeof ProveedoresScalarFieldEnum]


  export const Servicio_detallesScalarFieldEnum: {
    iddetalles: 'iddetalles',
    idservicio: 'idservicio',
    detalle: 'detalle',
    lugar: 'lugar',
    monto: 'monto',
    patente: 'patente',
    operador: 'operador',
    fecha: 'fecha',
    observacion: 'observacion'
  };

  export type Servicio_detallesScalarFieldEnum = (typeof Servicio_detallesScalarFieldEnum)[keyof typeof Servicio_detallesScalarFieldEnum]


  export const Servicio_gastosScalarFieldEnum: {
    idgastos: 'idgastos',
    idservicio: 'idservicio',
    tipo_gasto: 'tipo_gasto',
    horas: 'horas',
    operador: 'operador',
    observaciones: 'observaciones',
    inicio: 'inicio',
    fin: 'fin',
    feriado: 'feriado',
    liquidado: 'liquidado',
    operadorliq: 'operadorliq',
    fecha_liquidacion: 'fecha_liquidacion',
    aprobado: 'aprobado',
    operadorap: 'operadorap',
    fecha_aprobacion: 'fecha_aprobacion'
  };

  export type Servicio_gastosScalarFieldEnum = (typeof Servicio_gastosScalarFieldEnum)[keyof typeof Servicio_gastosScalarFieldEnum]


  export const Servicio_ventaScalarFieldEnum: {
    idventa: 'idventa',
    idservicio: 'idservicio',
    monto: 'monto',
    operador: 'operador',
    fecha_venta: 'fecha_venta',
    apellido_sol: 'apellido_sol',
    nombre_sol: 'nombre_sol',
    dni_sol: 'dni_sol',
    parentesco: 'parentesco',
    operador_venta: 'operador_venta',
    liquidado: 'liquidado',
    operadorliq: 'operadorliq',
    fecha_liquidacion: 'fecha_liquidacion',
    aprobado: 'aprobado',
    operadorap: 'operadorap',
    fecha_aprobacion: 'fecha_aprobacion',
    comision: 'comision',
    fecha_carga: 'fecha_carga',
    valor_cuota: 'valor_cuota',
    plan_cuota: 'plan_cuota',
    monto_financiacion: 'monto_financiacion',
    financiacion: 'financiacion',
    efectivo: 'efectivo'
  };

  export type Servicio_ventaScalarFieldEnum = (typeof Servicio_ventaScalarFieldEnum)[keyof typeof Servicio_ventaScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    idservicio: 'idservicio',
    empresa: 'empresa',
    dni: 'dni',
    apellido: 'apellido',
    nombre: 'nombre',
    edad: 'edad',
    fecha_fallecimiento: 'fecha_fallecimiento',
    lugar_fallecimiento: 'lugar_fallecimiento',
    tipo_servicio: 'tipo_servicio',
    casa_mortuaria: 'casa_mortuaria',
    fecha_inhumacion: 'fecha_inhumacion',
    hora_inhumacion: 'hora_inhumacion',
    cementerio: 'cementerio',
    estado: 'estado',
    contrato: 'contrato',
    fecha_recepcion: 'fecha_recepcion',
    sucursal: 'sucursal',
    motivo: 'motivo',
    retiro: 'retiro',
    solicitado: 'solicitado',
    parentesco: 'parentesco',
    altura: 'altura',
    peso: 'peso',
    dni_nuevotitular: 'dni_nuevotitular',
    operador: 'operador',
    idataud: 'idataud',
    dni_solicitante: 'dni_solicitante',
    impactado: 'impactado',
    cremacion: 'cremacion',
    idparcela: 'idparcela',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    gastos_cargados: 'gastos_cargados',
    obra_soc: 'obra_soc',
    importe: 'importe',
    donacion: 'donacion',
    domicilio_solicitante: 'domicilio_solicitante'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const Servicios_liquidacionScalarFieldEnum: {
    idliquidacion: 'idliquidacion',
    idservicio: 'idservicio',
    total_liquidacion: 'total_liquidacion',
    fecha_liquidacion: 'fecha_liquidacion',
    operador: 'operador'
  };

  export type Servicios_liquidacionScalarFieldEnum = (typeof Servicios_liquidacionScalarFieldEnum)[keyof typeof Servicios_liquidacionScalarFieldEnum]


  export const TareasScalarFieldEnum: {
    idevents: 'idevents',
    title: 'title',
    allDay: 'allDay',
    start: 'start',
    end: 'end',
    priority: 'priority'
  };

  export type TareasScalarFieldEnum = (typeof TareasScalarFieldEnum)[keyof typeof TareasScalarFieldEnum]


  export const Tareas_adicionalesScalarFieldEnum: {
    idtarea: 'idtarea',
    inicio: 'inicio',
    fin: 'fin',
    tarea: 'tarea',
    operador: 'operador',
    observaciones: 'observaciones',
    horas: 'horas',
    feriado: 'feriado',
    liquidado: 'liquidado',
    fecha_liquidacion: 'fecha_liquidacion',
    operadorliq: 'operadorliq',
    aprobado: 'aprobado',
    fecha_aprobacion: 'fecha_aprobacion',
    operadorap: 'operadorap',
    mes_planificacion: 'mes_planificacion'
  };

  export type Tareas_adicionalesScalarFieldEnum = (typeof Tareas_adicionalesScalarFieldEnum)[keyof typeof Tareas_adicionalesScalarFieldEnum]


  export const Tipo_detalleScalarFieldEnum: {
    idtipodetalle: 'idtipodetalle',
    tipo_detalle: 'tipo_detalle',
    observacion: 'observacion'
  };

  export type Tipo_detalleScalarFieldEnum = (typeof Tipo_detalleScalarFieldEnum)[keyof typeof Tipo_detalleScalarFieldEnum]


  export const VisitantesScalarFieldEnum: {
    idvisitante: 'idvisitante',
    idservicio: 'idservicio',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    telefono: 'telefono',
    parentezco: 'parentezco',
    operador: 'operador',
    fecha: 'fecha',
    temperatura: 'temperatura'
  };

  export type VisitantesScalarFieldEnum = (typeof VisitantesScalarFieldEnum)[keyof typeof VisitantesScalarFieldEnum]


  export const Parcelas_lugaresScalarFieldEnum: {
    idlugar: 'idlugar',
    idparcela: 'idparcela',
    idservicio: 'idservicio',
    lugar: 'lugar',
    contrato: 'contrato',
    dni: 'dni',
    fecha: 'fecha',
    operador: 'operador'
  };

  export type Parcelas_lugaresScalarFieldEnum = (typeof Parcelas_lugaresScalarFieldEnum)[keyof typeof Parcelas_lugaresScalarFieldEnum]


  export const Caja_saScalarFieldEnum: {
    idcaja: 'idcaja',
    codigo: 'codigo',
    cuenta: 'cuenta',
    tipo: 'tipo',
    serie: 'serie',
    factura: 'factura',
    importe: 'importe',
    comentarios: 'comentarios',
    nro_caja: 'nro_caja',
    movim: 'movim',
    fecha: 'fecha',
    puesto: 'puesto',
    operador: 'operador',
    cuit: 'cuit',
    proveedor: 'proveedor',
    sucursal: 'sucursal'
  };

  export type Caja_saScalarFieldEnum = (typeof Caja_saScalarFieldEnum)[keyof typeof Caja_saScalarFieldEnum]


  export const Caja_srlScalarFieldEnum: {
    idcaja: 'idcaja',
    codigo: 'codigo',
    cuenta: 'cuenta',
    tipo: 'tipo',
    serie: 'serie',
    factura: 'factura',
    importe: 'importe',
    comentarios: 'comentarios',
    nro_caja: 'nro_caja',
    movim: 'movim',
    fecha: 'fecha',
    puesto: 'puesto',
    operador: 'operador',
    cuit: 'cuit',
    proveedor: 'proveedor',
    sucursal: 'sucursal'
  };

  export type Caja_srlScalarFieldEnum = (typeof Caja_srlScalarFieldEnum)[keyof typeof Caja_srlScalarFieldEnum]


  export const Generacion_cajasScalarFieldEnum: {
    idgeneracion: 'idgeneracion',
    desde: 'desde',
    hasta: 'hasta',
    empresa: 'empresa',
    operador: 'operador',
    fecha: 'fecha'
  };

  export type Generacion_cajasScalarFieldEnum = (typeof Generacion_cajasScalarFieldEnum)[keyof typeof Generacion_cajasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type ataud_precioWhereInput = {
    AND?: ataud_precioWhereInput | ataud_precioWhereInput[]
    OR?: ataud_precioWhereInput[]
    NOT?: ataud_precioWhereInput | ataud_precioWhereInput[]
    idprecio?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    codigo?: IntNullableFilter | number | null
    ataud?: StringNullableFilter | string | null
    precio?: FloatNullableFilter | number | null
    pri_desc?: FloatNullableFilter | number | null
    sec_desc?: FloatNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
  }

  export type ataud_precioOrderByWithRelationInput = {
    idprecio?: SortOrder
    idataud?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    pri_desc?: SortOrderInput | SortOrder
    sec_desc?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
  }

  export type ataud_precioWhereUniqueInput = {
    idprecio?: number
  }

  export type ataud_precioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    idataud?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    pri_desc?: SortOrderInput | SortOrder
    sec_desc?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: ataud_precioCountOrderByAggregateInput
    _avg?: ataud_precioAvgOrderByAggregateInput
    _max?: ataud_precioMaxOrderByAggregateInput
    _min?: ataud_precioMinOrderByAggregateInput
    _sum?: ataud_precioSumOrderByAggregateInput
  }

  export type ataud_precioScalarWhereWithAggregatesInput = {
    AND?: ataud_precioScalarWhereWithAggregatesInput | ataud_precioScalarWhereWithAggregatesInput[]
    OR?: ataud_precioScalarWhereWithAggregatesInput[]
    NOT?: ataud_precioScalarWhereWithAggregatesInput | ataud_precioScalarWhereWithAggregatesInput[]
    idprecio?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    ataud?: StringNullableWithAggregatesFilter | string | null
    precio?: FloatNullableWithAggregatesFilter | number | null
    pri_desc?: FloatNullableWithAggregatesFilter | number | null
    sec_desc?: FloatNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type ataud_ventaWhereInput = {
    AND?: ataud_ventaWhereInput | ataud_ventaWhereInput[]
    OR?: ataud_ventaWhereInput[]
    NOT?: ataud_ventaWhereInput | ataud_ventaWhereInput[]
    idataudventa?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    apellido_fall?: StringNullableFilter | string | null
    nombre_fall?: StringNullableFilter | string | null
    dni_fall?: IntNullableFilter | number | null
    dom_fall?: StringNullableFilter | string | null
    ndom_fall?: IntNullableFilter | number | null
    barrio_fall?: StringNullableFilter | string | null
    telefono_fall?: StringNullableFilter | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    telefono_sol?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    ataud?: StringNullableFilter | string | null
  }

  export type ataud_ventaOrderByWithRelationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido_fall?: SortOrderInput | SortOrder
    nombre_fall?: SortOrderInput | SortOrder
    dni_fall?: SortOrderInput | SortOrder
    dom_fall?: SortOrderInput | SortOrder
    ndom_fall?: SortOrderInput | SortOrder
    barrio_fall?: SortOrderInput | SortOrder
    telefono_fall?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
  }

  export type ataud_ventaWhereUniqueInput = {
    idataudventa?: number
  }

  export type ataud_ventaOrderByWithAggregationInput = {
    idataudventa?: SortOrder
    idataud?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    apellido_fall?: SortOrderInput | SortOrder
    nombre_fall?: SortOrderInput | SortOrder
    dni_fall?: SortOrderInput | SortOrder
    dom_fall?: SortOrderInput | SortOrder
    ndom_fall?: SortOrderInput | SortOrder
    barrio_fall?: SortOrderInput | SortOrder
    telefono_fall?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    telefono_sol?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    ataud?: SortOrderInput | SortOrder
    _count?: ataud_ventaCountOrderByAggregateInput
    _avg?: ataud_ventaAvgOrderByAggregateInput
    _max?: ataud_ventaMaxOrderByAggregateInput
    _min?: ataud_ventaMinOrderByAggregateInput
    _sum?: ataud_ventaSumOrderByAggregateInput
  }

  export type ataud_ventaScalarWhereWithAggregatesInput = {
    AND?: ataud_ventaScalarWhereWithAggregatesInput | ataud_ventaScalarWhereWithAggregatesInput[]
    OR?: ataud_ventaScalarWhereWithAggregatesInput[]
    NOT?: ataud_ventaScalarWhereWithAggregatesInput | ataud_ventaScalarWhereWithAggregatesInput[]
    idataudventa?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    apellido_fall?: StringNullableWithAggregatesFilter | string | null
    nombre_fall?: StringNullableWithAggregatesFilter | string | null
    dni_fall?: IntNullableWithAggregatesFilter | number | null
    dom_fall?: StringNullableWithAggregatesFilter | string | null
    ndom_fall?: IntNullableWithAggregatesFilter | number | null
    barrio_fall?: StringNullableWithAggregatesFilter | string | null
    telefono_fall?: StringNullableWithAggregatesFilter | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    telefono_sol?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    ataud?: StringNullableWithAggregatesFilter | string | null
  }

  export type ataudesWhereInput = {
    AND?: ataudesWhereInput | ataudesWhereInput[]
    OR?: ataudesWhereInput[]
    NOT?: ataudesWhereInput | ataudesWhereInput[]
    idataud?: IntFilter | number
    nombre?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    medidas?: StringNullableFilter | string | null
    uso?: StringNullableFilter | string | null
    fabricante?: StringNullableFilter | string | null
    codigo?: IntNullableFilter | number | null
    fecha_alta?: DateTimeNullableFilter | Date | string | null
    stock?: IntNullableFilter | number | null
    fecha_reposicion?: DateTimeNullableFilter | Date | string | null
    fecha_baja?: DateTimeNullableFilter | Date | string | null
    observaciones?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type ataudesOrderByWithRelationInput = {
    idataud?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    medidas?: SortOrderInput | SortOrder
    uso?: SortOrderInput | SortOrder
    fabricante?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    fecha_baja?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type ataudesWhereUniqueInput = {
    idataud?: number
  }

  export type ataudesOrderByWithAggregationInput = {
    idataud?: SortOrder
    nombre?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    medidas?: SortOrderInput | SortOrder
    uso?: SortOrderInput | SortOrder
    fabricante?: SortOrderInput | SortOrder
    codigo?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    fecha_reposicion?: SortOrderInput | SortOrder
    fecha_baja?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: ataudesCountOrderByAggregateInput
    _avg?: ataudesAvgOrderByAggregateInput
    _max?: ataudesMaxOrderByAggregateInput
    _min?: ataudesMinOrderByAggregateInput
    _sum?: ataudesSumOrderByAggregateInput
  }

  export type ataudesScalarWhereWithAggregatesInput = {
    AND?: ataudesScalarWhereWithAggregatesInput | ataudesScalarWhereWithAggregatesInput[]
    OR?: ataudesScalarWhereWithAggregatesInput[]
    NOT?: ataudesScalarWhereWithAggregatesInput | ataudesScalarWhereWithAggregatesInput[]
    idataud?: IntWithAggregatesFilter | number
    nombre?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    medidas?: StringNullableWithAggregatesFilter | string | null
    uso?: StringNullableWithAggregatesFilter | string | null
    fabricante?: StringNullableWithAggregatesFilter | string | null
    codigo?: IntNullableWithAggregatesFilter | number | null
    fecha_alta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock?: IntNullableWithAggregatesFilter | number | null
    fecha_reposicion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fecha_baja?: DateTimeNullableWithAggregatesFilter | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autosWhereInput = {
    AND?: autosWhereInput | autosWhereInput[]
    OR?: autosWhereInput[]
    NOT?: autosWhereInput | autosWhereInput[]
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    kilometros?: FloatNullableFilter | number | null
    responsable?: StringNullableFilter | string | null
    nro_poliza?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    vencimiento?: DateTimeNullableFilter | Date | string | null
    motor?: StringNullableFilter | string | null
    chasis?: StringNullableFilter | string | null
    modelo?: IntNullableFilter | number | null
    cobertura?: StringNullableFilter | string | null
    idauto?: IntFilter | number
    estado?: BoolNullableFilter | boolean | null
    operador?: StringNullableFilter | string | null
  }

  export type autosOrderByWithRelationInput = {
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    kilometros?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    nro_poliza?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    vencimiento?: SortOrderInput | SortOrder
    motor?: SortOrderInput | SortOrder
    chasis?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    idauto?: SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autosWhereUniqueInput = {
    idauto?: number
  }

  export type autosOrderByWithAggregationInput = {
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    kilometros?: SortOrderInput | SortOrder
    responsable?: SortOrderInput | SortOrder
    nro_poliza?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    vencimiento?: SortOrderInput | SortOrder
    motor?: SortOrderInput | SortOrder
    chasis?: SortOrderInput | SortOrder
    modelo?: SortOrderInput | SortOrder
    cobertura?: SortOrderInput | SortOrder
    idauto?: SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autosCountOrderByAggregateInput
    _avg?: autosAvgOrderByAggregateInput
    _max?: autosMaxOrderByAggregateInput
    _min?: autosMinOrderByAggregateInput
    _sum?: autosSumOrderByAggregateInput
  }

  export type autosScalarWhereWithAggregatesInput = {
    AND?: autosScalarWhereWithAggregatesInput | autosScalarWhereWithAggregatesInput[]
    OR?: autosScalarWhereWithAggregatesInput[]
    NOT?: autosScalarWhereWithAggregatesInput | autosScalarWhereWithAggregatesInput[]
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    kilometros?: FloatNullableWithAggregatesFilter | number | null
    responsable?: StringNullableWithAggregatesFilter | string | null
    nro_poliza?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    vencimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    motor?: StringNullableWithAggregatesFilter | string | null
    chasis?: StringNullableWithAggregatesFilter | string | null
    modelo?: IntNullableWithAggregatesFilter | number | null
    cobertura?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntWithAggregatesFilter | number
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_hoja_rutaWhereInput = {
    AND?: autos_hoja_rutaWhereInput | autos_hoja_rutaWhereInput[]
    OR?: autos_hoja_rutaWhereInput[]
    NOT?: autos_hoja_rutaWhereInput | autos_hoja_rutaWhereInput[]
    idhojaruta?: IntFilter | number
    patente?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
    conductor?: StringNullableFilter | string | null
    idservicio?: IntNullableFilter | number | null
    fecha_salida?: DateTimeNullableFilter | Date | string | null
    km_salida?: IntNullableFilter | number | null
    fecha_llegada?: DateTimeNullableFilter | Date | string | null
    km_llegada?: IntNullableFilter | number | null
    fecha_registro?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_hoja_rutaOrderByWithRelationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    conductor?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    km_salida?: SortOrderInput | SortOrder
    fecha_llegada?: SortOrderInput | SortOrder
    km_llegada?: SortOrderInput | SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autos_hoja_rutaWhereUniqueInput = {
    idhojaruta?: number
  }

  export type autos_hoja_rutaOrderByWithAggregationInput = {
    idhojaruta?: SortOrder
    patente?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    conductor?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    fecha_salida?: SortOrderInput | SortOrder
    km_salida?: SortOrderInput | SortOrder
    fecha_llegada?: SortOrderInput | SortOrder
    km_llegada?: SortOrderInput | SortOrder
    fecha_registro?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autos_hoja_rutaCountOrderByAggregateInput
    _avg?: autos_hoja_rutaAvgOrderByAggregateInput
    _max?: autos_hoja_rutaMaxOrderByAggregateInput
    _min?: autos_hoja_rutaMinOrderByAggregateInput
    _sum?: autos_hoja_rutaSumOrderByAggregateInput
  }

  export type autos_hoja_rutaScalarWhereWithAggregatesInput = {
    AND?: autos_hoja_rutaScalarWhereWithAggregatesInput | autos_hoja_rutaScalarWhereWithAggregatesInput[]
    OR?: autos_hoja_rutaScalarWhereWithAggregatesInput[]
    NOT?: autos_hoja_rutaScalarWhereWithAggregatesInput | autos_hoja_rutaScalarWhereWithAggregatesInput[]
    idhojaruta?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
    conductor?: StringNullableWithAggregatesFilter | string | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    fecha_salida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_salida?: IntNullableWithAggregatesFilter | number | null
    fecha_llegada?: DateTimeNullableWithAggregatesFilter | Date | string | null
    km_llegada?: IntNullableWithAggregatesFilter | number | null
    fecha_registro?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_novedadesWhereInput = {
    AND?: autos_novedadesWhereInput | autos_novedadesWhereInput[]
    OR?: autos_novedadesWhereInput[]
    NOT?: autos_novedadesWhereInput | autos_novedadesWhereInput[]
    idnovedad?: IntFilter | number
    patente?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    novedad?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    auto?: StringNullableFilter | string | null
  }

  export type autos_novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    patente?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    novedad?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
  }

  export type autos_novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type autos_novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    patente?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    novedad?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    auto?: SortOrderInput | SortOrder
    _count?: autos_novedadesCountOrderByAggregateInput
    _avg?: autos_novedadesAvgOrderByAggregateInput
    _max?: autos_novedadesMaxOrderByAggregateInput
    _min?: autos_novedadesMinOrderByAggregateInput
    _sum?: autos_novedadesSumOrderByAggregateInput
  }

  export type autos_novedadesScalarWhereWithAggregatesInput = {
    AND?: autos_novedadesScalarWhereWithAggregatesInput | autos_novedadesScalarWhereWithAggregatesInput[]
    OR?: autos_novedadesScalarWhereWithAggregatesInput[]
    NOT?: autos_novedadesScalarWhereWithAggregatesInput | autos_novedadesScalarWhereWithAggregatesInput[]
    idnovedad?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    novedad?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    auto?: StringNullableWithAggregatesFilter | string | null
  }

  export type autos_pago_patenteWhereInput = {
    AND?: autos_pago_patenteWhereInput | autos_pago_patenteWhereInput[]
    OR?: autos_pago_patenteWhereInput[]
    NOT?: autos_pago_patenteWhereInput | autos_pago_patenteWhereInput[]
    idpago?: IntFilter | number
    patente?: StringNullableFilter | string | null
    mes?: IntNullableFilter | number | null
    ano?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    cod_pago?: IntNullableFilter | number | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type autos_pago_patenteOrderByWithRelationInput = {
    idpago?: SortOrder
    patente?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    cod_pago?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type autos_pago_patenteWhereUniqueInput = {
    idpago?: number
  }

  export type autos_pago_patenteOrderByWithAggregationInput = {
    idpago?: SortOrder
    patente?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    ano?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    cod_pago?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: autos_pago_patenteCountOrderByAggregateInput
    _avg?: autos_pago_patenteAvgOrderByAggregateInput
    _max?: autos_pago_patenteMaxOrderByAggregateInput
    _min?: autos_pago_patenteMinOrderByAggregateInput
    _sum?: autos_pago_patenteSumOrderByAggregateInput
  }

  export type autos_pago_patenteScalarWhereWithAggregatesInput = {
    AND?: autos_pago_patenteScalarWhereWithAggregatesInput | autos_pago_patenteScalarWhereWithAggregatesInput[]
    OR?: autos_pago_patenteScalarWhereWithAggregatesInput[]
    NOT?: autos_pago_patenteScalarWhereWithAggregatesInput | autos_pago_patenteScalarWhereWithAggregatesInput[]
    idpago?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    mes?: IntNullableWithAggregatesFilter | number | null
    ano?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    cod_pago?: IntNullableWithAggregatesFilter | number | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_sepelioWhereInput = {
    AND?: caja_sepelioWhereInput | caja_sepelioWhereInput[]
    OR?: caja_sepelioWhereInput[]
    NOT?: caja_sepelioWhereInput | caja_sepelioWhereInput[]
    idcaja?: IntFilter | number
    operador?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    estado?: BoolNullableFilter | boolean | null
    fecha?: DateTimeNullableFilter | Date | string | null
    gastos?: FloatNullableFilter | number | null
    totalcaja?: FloatNullableFilter | number | null
    empresa?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: IntNullableFilter | number | null
    ptoventa?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    cierre?: DateTimeNullableFilter | Date | string | null
    ultimacarga?: DateTimeNullableFilter | Date | string | null
  }

  export type caja_sepelioOrderByWithRelationInput = {
    idcaja?: SortOrder
    operador?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    gastos?: SortOrderInput | SortOrder
    totalcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    cierre?: SortOrderInput | SortOrder
    ultimacarga?: SortOrderInput | SortOrder
  }

  export type caja_sepelioWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_sepelioOrderByWithAggregationInput = {
    idcaja?: SortOrder
    operador?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    gastos?: SortOrderInput | SortOrder
    totalcaja?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    cierre?: SortOrderInput | SortOrder
    ultimacarga?: SortOrderInput | SortOrder
    _count?: caja_sepelioCountOrderByAggregateInput
    _avg?: caja_sepelioAvgOrderByAggregateInput
    _max?: caja_sepelioMaxOrderByAggregateInput
    _min?: caja_sepelioMinOrderByAggregateInput
    _sum?: caja_sepelioSumOrderByAggregateInput
  }

  export type caja_sepelioScalarWhereWithAggregatesInput = {
    AND?: caja_sepelioScalarWhereWithAggregatesInput | caja_sepelioScalarWhereWithAggregatesInput[]
    OR?: caja_sepelioScalarWhereWithAggregatesInput[]
    NOT?: caja_sepelioScalarWhereWithAggregatesInput | caja_sepelioScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gastos?: FloatNullableWithAggregatesFilter | number | null
    totalcaja?: FloatNullableWithAggregatesFilter | number | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: IntNullableWithAggregatesFilter | number | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    cierre?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ultimacarga?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type conceptosWhereInput = {
    AND?: conceptosWhereInput | conceptosWhereInput[]
    OR?: conceptosWhereInput[]
    NOT?: conceptosWhereInput | conceptosWhereInput[]
    idconcepto?: IntFilter | number
    concepto?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
  }

  export type conceptosOrderByWithRelationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
  }

  export type conceptosWhereUniqueInput = {
    idconcepto?: number
  }

  export type conceptosOrderByWithAggregationInput = {
    idconcepto?: SortOrder
    concepto?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    _count?: conceptosCountOrderByAggregateInput
    _avg?: conceptosAvgOrderByAggregateInput
    _max?: conceptosMaxOrderByAggregateInput
    _min?: conceptosMinOrderByAggregateInput
    _sum?: conceptosSumOrderByAggregateInput
  }

  export type conceptosScalarWhereWithAggregatesInput = {
    AND?: conceptosScalarWhereWithAggregatesInput | conceptosScalarWhereWithAggregatesInput[]
    OR?: conceptosScalarWhereWithAggregatesInput[]
    NOT?: conceptosScalarWhereWithAggregatesInput | conceptosScalarWhereWithAggregatesInput[]
    idconcepto?: IntWithAggregatesFilter | number
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
  }

  export type fabricante_ataudWhereInput = {
    AND?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    OR?: fabricante_ataudWhereInput[]
    NOT?: fabricante_ataudWhereInput | fabricante_ataudWhereInput[]
    idfabricante?: IntFilter | number
    fabricante?: StringNullableFilter | string | null
  }

  export type fabricante_ataudOrderByWithRelationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
  }

  export type fabricante_ataudWhereUniqueInput = {
    idfabricante?: number
  }

  export type fabricante_ataudOrderByWithAggregationInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrderInput | SortOrder
    _count?: fabricante_ataudCountOrderByAggregateInput
    _avg?: fabricante_ataudAvgOrderByAggregateInput
    _max?: fabricante_ataudMaxOrderByAggregateInput
    _min?: fabricante_ataudMinOrderByAggregateInput
    _sum?: fabricante_ataudSumOrderByAggregateInput
  }

  export type fabricante_ataudScalarWhereWithAggregatesInput = {
    AND?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    OR?: fabricante_ataudScalarWhereWithAggregatesInput[]
    NOT?: fabricante_ataudScalarWhereWithAggregatesInput | fabricante_ataudScalarWhereWithAggregatesInput[]
    idfabricante?: IntWithAggregatesFilter | number
    fabricante?: StringNullableWithAggregatesFilter | string | null
  }

  export type gasto_lutoWhereInput = {
    AND?: gasto_lutoWhereInput | gasto_lutoWhereInput[]
    OR?: gasto_lutoWhereInput[]
    NOT?: gasto_lutoWhereInput | gasto_lutoWhereInput[]
    idgastoluto?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    extinto?: StringNullableFilter | string | null
    gasto_luto?: FloatNullableFilter | number | null
    idataud?: IntNullableFilter | number | null
    apellido_ben?: StringNullableFilter | string | null
    nombre_ben?: StringNullableFilter | string | null
    telefono_ben?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    parentezco?: StringNullableFilter | string | null
  }

  export type gasto_lutoOrderByWithRelationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    extinto?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
  }

  export type gasto_lutoWhereUniqueInput = {
    idgastoluto?: number
  }

  export type gasto_lutoOrderByWithAggregationInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    extinto?: SortOrderInput | SortOrder
    gasto_luto?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    apellido_ben?: SortOrderInput | SortOrder
    nombre_ben?: SortOrderInput | SortOrder
    telefono_ben?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    _count?: gasto_lutoCountOrderByAggregateInput
    _avg?: gasto_lutoAvgOrderByAggregateInput
    _max?: gasto_lutoMaxOrderByAggregateInput
    _min?: gasto_lutoMinOrderByAggregateInput
    _sum?: gasto_lutoSumOrderByAggregateInput
  }

  export type gasto_lutoScalarWhereWithAggregatesInput = {
    AND?: gasto_lutoScalarWhereWithAggregatesInput | gasto_lutoScalarWhereWithAggregatesInput[]
    OR?: gasto_lutoScalarWhereWithAggregatesInput[]
    NOT?: gasto_lutoScalarWhereWithAggregatesInput | gasto_lutoScalarWhereWithAggregatesInput[]
    idgastoluto?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    extinto?: StringNullableWithAggregatesFilter | string | null
    gasto_luto?: FloatNullableWithAggregatesFilter | number | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    apellido_ben?: StringNullableWithAggregatesFilter | string | null
    nombre_ben?: StringNullableWithAggregatesFilter | string | null
    telefono_ben?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
  }

  export type gastos_cajaWhereInput = {
    AND?: gastos_cajaWhereInput | gastos_cajaWhereInput[]
    OR?: gastos_cajaWhereInput[]
    NOT?: gastos_cajaWhereInput | gastos_cajaWhereInput[]
    idgastos?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operadorgestion?: StringNullableFilter | string | null
    operadortramite?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
    porciva?: StringNullableFilter | string | null
    montoiva?: IntNullableFilter | number | null
    retiibb?: FloatNullableFilter | number | null
    retggcias?: FloatNullableFilter | number | null
    perciva?: FloatNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    mediopago?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    total?: FloatNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
  }

  export type gastos_cajaOrderByWithRelationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
  }

  export type gastos_cajaWhereUniqueInput = {
    idgastos?: number
  }

  export type gastos_cajaOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operadorgestion?: SortOrderInput | SortOrder
    operadortramite?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    porciva?: SortOrderInput | SortOrder
    montoiva?: SortOrderInput | SortOrder
    retiibb?: SortOrderInput | SortOrder
    retggcias?: SortOrderInput | SortOrder
    perciva?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    mediopago?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    _count?: gastos_cajaCountOrderByAggregateInput
    _avg?: gastos_cajaAvgOrderByAggregateInput
    _max?: gastos_cajaMaxOrderByAggregateInput
    _min?: gastos_cajaMinOrderByAggregateInput
    _sum?: gastos_cajaSumOrderByAggregateInput
  }

  export type gastos_cajaScalarWhereWithAggregatesInput = {
    AND?: gastos_cajaScalarWhereWithAggregatesInput | gastos_cajaScalarWhereWithAggregatesInput[]
    OR?: gastos_cajaScalarWhereWithAggregatesInput[]
    NOT?: gastos_cajaScalarWhereWithAggregatesInput | gastos_cajaScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operadorgestion?: StringNullableWithAggregatesFilter | string | null
    operadortramite?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
    porciva?: StringNullableWithAggregatesFilter | string | null
    montoiva?: IntNullableWithAggregatesFilter | number | null
    retiibb?: FloatNullableWithAggregatesFilter | number | null
    retggcias?: FloatNullableWithAggregatesFilter | number | null
    perciva?: FloatNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    mediopago?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    total?: FloatNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
  }

  export type historial_autosWhereInput = {
    AND?: historial_autosWhereInput | historial_autosWhereInput[]
    OR?: historial_autosWhereInput[]
    NOT?: historial_autosWhereInput | historial_autosWhereInput[]
    idhistorial?: IntFilter | number
    patente?: StringNullableFilter | string | null
    idauto?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    accion?: StringNullableFilter | string | null
  }

  export type historial_autosOrderByWithRelationInput = {
    idhistorial?: SortOrder
    patente?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
  }

  export type historial_autosWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_autosOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    patente?: SortOrderInput | SortOrder
    idauto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    accion?: SortOrderInput | SortOrder
    _count?: historial_autosCountOrderByAggregateInput
    _avg?: historial_autosAvgOrderByAggregateInput
    _max?: historial_autosMaxOrderByAggregateInput
    _min?: historial_autosMinOrderByAggregateInput
    _sum?: historial_autosSumOrderByAggregateInput
  }

  export type historial_autosScalarWhereWithAggregatesInput = {
    AND?: historial_autosScalarWhereWithAggregatesInput | historial_autosScalarWhereWithAggregatesInput[]
    OR?: historial_autosScalarWhereWithAggregatesInput[]
    NOT?: historial_autosScalarWhereWithAggregatesInput | historial_autosScalarWhereWithAggregatesInput[]
    idhistorial?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    idauto?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    accion?: StringNullableWithAggregatesFilter | string | null
  }

  export type historial_stock_ataudWhereInput = {
    AND?: historial_stock_ataudWhereInput | historial_stock_ataudWhereInput[]
    OR?: historial_stock_ataudWhereInput[]
    NOT?: historial_stock_ataudWhereInput | historial_stock_ataudWhereInput[]
    idhistorial?: IntFilter | number
    idataud?: IntNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    stock_anterior?: IntNullableFilter | number | null
    stock_nuevo?: IntNullableFilter | number | null
    remito?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_recepcion?: DateTimeNullableFilter | Date | string | null
  }

  export type historial_stock_ataudOrderByWithRelationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    stock_anterior?: SortOrderInput | SortOrder
    stock_nuevo?: SortOrderInput | SortOrder
    remito?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
  }

  export type historial_stock_ataudWhereUniqueInput = {
    idhistorial?: number
  }

  export type historial_stock_ataudOrderByWithAggregationInput = {
    idhistorial?: SortOrder
    idataud?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    stock_anterior?: SortOrderInput | SortOrder
    stock_nuevo?: SortOrderInput | SortOrder
    remito?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    _count?: historial_stock_ataudCountOrderByAggregateInput
    _avg?: historial_stock_ataudAvgOrderByAggregateInput
    _max?: historial_stock_ataudMaxOrderByAggregateInput
    _min?: historial_stock_ataudMinOrderByAggregateInput
    _sum?: historial_stock_ataudSumOrderByAggregateInput
  }

  export type historial_stock_ataudScalarWhereWithAggregatesInput = {
    AND?: historial_stock_ataudScalarWhereWithAggregatesInput | historial_stock_ataudScalarWhereWithAggregatesInput[]
    OR?: historial_stock_ataudScalarWhereWithAggregatesInput[]
    NOT?: historial_stock_ataudScalarWhereWithAggregatesInput | historial_stock_ataudScalarWhereWithAggregatesInput[]
    idhistorial?: IntWithAggregatesFilter | number
    idataud?: IntNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stock_anterior?: IntNullableWithAggregatesFilter | number | null
    stock_nuevo?: IntNullableWithAggregatesFilter | number | null
    remito?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_recepcion?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type honorariosWhereInput = {
    AND?: honorariosWhereInput | honorariosWhereInput[]
    OR?: honorariosWhereInput[]
    NOT?: honorariosWhereInput | honorariosWhereInput[]
    idtrabajo?: IntFilter | number
    trabajo?: StringNullableFilter | string | null
    dias_habiles?: IntNullableFilter | number | null
    finde?: IntNullableFilter | number | null
    feriado?: IntNullableFilter | number | null
  }

  export type honorariosOrderByWithRelationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrderInput | SortOrder
    dias_habiles?: SortOrderInput | SortOrder
    finde?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
  }

  export type honorariosWhereUniqueInput = {
    idtrabajo?: number
  }

  export type honorariosOrderByWithAggregationInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrderInput | SortOrder
    dias_habiles?: SortOrderInput | SortOrder
    finde?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    _count?: honorariosCountOrderByAggregateInput
    _avg?: honorariosAvgOrderByAggregateInput
    _max?: honorariosMaxOrderByAggregateInput
    _min?: honorariosMinOrderByAggregateInput
    _sum?: honorariosSumOrderByAggregateInput
  }

  export type honorariosScalarWhereWithAggregatesInput = {
    AND?: honorariosScalarWhereWithAggregatesInput | honorariosScalarWhereWithAggregatesInput[]
    OR?: honorariosScalarWhereWithAggregatesInput[]
    NOT?: honorariosScalarWhereWithAggregatesInput | honorariosScalarWhereWithAggregatesInput[]
    idtrabajo?: IntWithAggregatesFilter | number
    trabajo?: StringNullableWithAggregatesFilter | string | null
    dias_habiles?: IntNullableWithAggregatesFilter | number | null
    finde?: IntNullableWithAggregatesFilter | number | null
    feriado?: IntNullableWithAggregatesFilter | number | null
  }

  export type ingreso_cajaWhereInput = {
    AND?: ingreso_cajaWhereInput | ingreso_cajaWhereInput[]
    OR?: ingreso_cajaWhereInput[]
    NOT?: ingreso_cajaWhereInput | ingreso_cajaWhereInput[]
    idingreso?: IntFilter | number
    idcaja?: IntNullableFilter | number | null
    concepto?: StringNullableFilter | string | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    tipofactura?: StringNullableFilter | string | null
    nfactura?: StringNullableFilter | string | null
    empresa?: StringNullableFilter | string | null
    detalle?: StringNullableFilter | string | null
    ptoventa?: IntNullableFilter | number | null
  }

  export type ingreso_cajaOrderByWithRelationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
  }

  export type ingreso_cajaWhereUniqueInput = {
    idingreso?: number
  }

  export type ingreso_cajaOrderByWithAggregationInput = {
    idingreso?: SortOrder
    idcaja?: SortOrderInput | SortOrder
    concepto?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    tipofactura?: SortOrderInput | SortOrder
    nfactura?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    ptoventa?: SortOrderInput | SortOrder
    _count?: ingreso_cajaCountOrderByAggregateInput
    _avg?: ingreso_cajaAvgOrderByAggregateInput
    _max?: ingreso_cajaMaxOrderByAggregateInput
    _min?: ingreso_cajaMinOrderByAggregateInput
    _sum?: ingreso_cajaSumOrderByAggregateInput
  }

  export type ingreso_cajaScalarWhereWithAggregatesInput = {
    AND?: ingreso_cajaScalarWhereWithAggregatesInput | ingreso_cajaScalarWhereWithAggregatesInput[]
    OR?: ingreso_cajaScalarWhereWithAggregatesInput[]
    NOT?: ingreso_cajaScalarWhereWithAggregatesInput | ingreso_cajaScalarWhereWithAggregatesInput[]
    idingreso?: IntWithAggregatesFilter | number
    idcaja?: IntNullableWithAggregatesFilter | number | null
    concepto?: StringNullableWithAggregatesFilter | string | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tipofactura?: StringNullableWithAggregatesFilter | string | null
    nfactura?: StringNullableWithAggregatesFilter | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    ptoventa?: IntNullableWithAggregatesFilter | number | null
  }

  export type legajo_virtual_autosWhereInput = {
    AND?: legajo_virtual_autosWhereInput | legajo_virtual_autosWhereInput[]
    OR?: legajo_virtual_autosWhereInput[]
    NOT?: legajo_virtual_autosWhereInput | legajo_virtual_autosWhereInput[]
    idlegajo?: IntFilter | number
    patente?: StringNullableFilter | string | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
  }

  export type legajo_virtual_autosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    patente?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_autosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_autosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    patente?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    _count?: legajo_virtual_autosCountOrderByAggregateInput
    _avg?: legajo_virtual_autosAvgOrderByAggregateInput
    _max?: legajo_virtual_autosMaxOrderByAggregateInput
    _min?: legajo_virtual_autosMinOrderByAggregateInput
    _sum?: legajo_virtual_autosSumOrderByAggregateInput
  }

  export type legajo_virtual_autosScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_autosScalarWhereWithAggregatesInput | legajo_virtual_autosScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_autosScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_autosScalarWhereWithAggregatesInput | legajo_virtual_autosScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    patente?: StringNullableWithAggregatesFilter | string | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type legajo_virtual_serviciosWhereInput = {
    AND?: legajo_virtual_serviciosWhereInput | legajo_virtual_serviciosWhereInput[]
    OR?: legajo_virtual_serviciosWhereInput[]
    NOT?: legajo_virtual_serviciosWhereInput | legajo_virtual_serviciosWhereInput[]
    idlegajo?: IntFilter | number
    servicio?: IntNullableFilter | number | null
    archivo?: StringNullableFilter | string | null
    fecha_subida?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
  }

  export type legajo_virtual_serviciosOrderByWithRelationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
  }

  export type legajo_virtual_serviciosWhereUniqueInput = {
    idlegajo?: number
  }

  export type legajo_virtual_serviciosOrderByWithAggregationInput = {
    idlegajo?: SortOrder
    servicio?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    fecha_subida?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    _count?: legajo_virtual_serviciosCountOrderByAggregateInput
    _avg?: legajo_virtual_serviciosAvgOrderByAggregateInput
    _max?: legajo_virtual_serviciosMaxOrderByAggregateInput
    _min?: legajo_virtual_serviciosMinOrderByAggregateInput
    _sum?: legajo_virtual_serviciosSumOrderByAggregateInput
  }

  export type legajo_virtual_serviciosScalarWhereWithAggregatesInput = {
    AND?: legajo_virtual_serviciosScalarWhereWithAggregatesInput | legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    OR?: legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    NOT?: legajo_virtual_serviciosScalarWhereWithAggregatesInput | legajo_virtual_serviciosScalarWhereWithAggregatesInput[]
    idlegajo?: IntWithAggregatesFilter | number
    servicio?: IntNullableWithAggregatesFilter | number | null
    archivo?: StringNullableWithAggregatesFilter | string | null
    fecha_subida?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
  }

  export type novedadesWhereInput = {
    AND?: novedadesWhereInput | novedadesWhereInput[]
    OR?: novedadesWhereInput[]
    NOT?: novedadesWhereInput | novedadesWhereInput[]
    idnovedad?: IntFilter | number
    novedad?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type novedadesOrderByWithRelationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type novedadesWhereUniqueInput = {
    idnovedad?: number
  }

  export type novedadesOrderByWithAggregationInput = {
    idnovedad?: SortOrder
    novedad?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: novedadesCountOrderByAggregateInput
    _avg?: novedadesAvgOrderByAggregateInput
    _max?: novedadesMaxOrderByAggregateInput
    _min?: novedadesMinOrderByAggregateInput
    _sum?: novedadesSumOrderByAggregateInput
  }

  export type novedadesScalarWhereWithAggregatesInput = {
    AND?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    OR?: novedadesScalarWhereWithAggregatesInput[]
    NOT?: novedadesScalarWhereWithAggregatesInput | novedadesScalarWhereWithAggregatesInput[]
    idnovedad?: IntWithAggregatesFilter | number
    novedad?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type operadorsepWhereInput = {
    AND?: operadorsepWhereInput | operadorsepWhereInput[]
    OR?: operadorsepWhereInput[]
    NOT?: operadorsepWhereInput | operadorsepWhereInput[]
    idoperador?: IntFilter | number
    operador?: StringNullableFilter | string | null
  }

  export type operadorsepOrderByWithRelationInput = {
    idoperador?: SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type operadorsepWhereUniqueInput = {
    idoperador?: number
  }

  export type operadorsepOrderByWithAggregationInput = {
    idoperador?: SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: operadorsepCountOrderByAggregateInput
    _avg?: operadorsepAvgOrderByAggregateInput
    _max?: operadorsepMaxOrderByAggregateInput
    _min?: operadorsepMinOrderByAggregateInput
    _sum?: operadorsepSumOrderByAggregateInput
  }

  export type operadorsepScalarWhereWithAggregatesInput = {
    AND?: operadorsepScalarWhereWithAggregatesInput | operadorsepScalarWhereWithAggregatesInput[]
    OR?: operadorsepScalarWhereWithAggregatesInput[]
    NOT?: operadorsepScalarWhereWithAggregatesInput | operadorsepScalarWhereWithAggregatesInput[]
    idoperador?: IntWithAggregatesFilter | number
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type parcelasWhereInput = {
    AND?: parcelasWhereInput | parcelasWhereInput[]
    OR?: parcelasWhereInput[]
    NOT?: parcelasWhereInput | parcelasWhereInput[]
    idparcela?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    dni_extinto?: IntNullableFilter | number | null
    ficha?: IntNullableFilter | number | null
    parcela?: StringNullableFilter | string | null
    mza?: IntNullableFilter | number | null
    lote?: IntNullableFilter | number | null
    asignada?: BoolNullableFilter | boolean | null
    fecha?: StringNullableFilter | string | null
    cementerio?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha_alta?: StringNullableFilter | string | null
    operador_asignacion?: StringNullableFilter | string | null
    fecha_asignacion?: StringNullableFilter | string | null
    lugares?: IntNullableFilter | number | null
  }

  export type parcelasOrderByWithRelationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    ficha?: SortOrderInput | SortOrder
    parcela?: SortOrderInput | SortOrder
    mza?: SortOrderInput | SortOrder
    lote?: SortOrderInput | SortOrder
    asignada?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    operador_asignacion?: SortOrderInput | SortOrder
    fecha_asignacion?: SortOrderInput | SortOrder
    lugares?: SortOrderInput | SortOrder
  }

  export type parcelasWhereUniqueInput = {
    idparcela?: number
  }

  export type parcelasOrderByWithAggregationInput = {
    idparcela?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    dni_extinto?: SortOrderInput | SortOrder
    ficha?: SortOrderInput | SortOrder
    parcela?: SortOrderInput | SortOrder
    mza?: SortOrderInput | SortOrder
    lote?: SortOrderInput | SortOrder
    asignada?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_alta?: SortOrderInput | SortOrder
    operador_asignacion?: SortOrderInput | SortOrder
    fecha_asignacion?: SortOrderInput | SortOrder
    lugares?: SortOrderInput | SortOrder
    _count?: parcelasCountOrderByAggregateInput
    _avg?: parcelasAvgOrderByAggregateInput
    _max?: parcelasMaxOrderByAggregateInput
    _min?: parcelasMinOrderByAggregateInput
    _sum?: parcelasSumOrderByAggregateInput
  }

  export type parcelasScalarWhereWithAggregatesInput = {
    AND?: parcelasScalarWhereWithAggregatesInput | parcelasScalarWhereWithAggregatesInput[]
    OR?: parcelasScalarWhereWithAggregatesInput[]
    NOT?: parcelasScalarWhereWithAggregatesInput | parcelasScalarWhereWithAggregatesInput[]
    idparcela?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    dni_extinto?: IntNullableWithAggregatesFilter | number | null
    ficha?: IntNullableWithAggregatesFilter | number | null
    parcela?: StringNullableWithAggregatesFilter | string | null
    mza?: IntNullableWithAggregatesFilter | number | null
    lote?: IntNullableWithAggregatesFilter | number | null
    asignada?: BoolNullableWithAggregatesFilter | boolean | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_alta?: StringNullableWithAggregatesFilter | string | null
    operador_asignacion?: StringNullableWithAggregatesFilter | string | null
    fecha_asignacion?: StringNullableWithAggregatesFilter | string | null
    lugares?: IntNullableWithAggregatesFilter | number | null
  }

  export type planificacion_guardiasWhereInput = {
    AND?: planificacion_guardiasWhereInput | planificacion_guardiasWhereInput[]
    OR?: planificacion_guardiasWhereInput[]
    NOT?: planificacion_guardiasWhereInput | planificacion_guardiasWhereInput[]
    idturno?: IntFilter | number
    lugar?: StringNullableFilter | string | null
    inicio?: DateTimeNullableFilter | Date | string | null
    fin?: DateTimeNullableFilter | Date | string | null
    horas?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    mes_planificacion?: StringNullableFilter | string | null
    feriado?: BoolNullableFilter | boolean | null
    tarea?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    operadorliq?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    fecha_aprobacion?: StringNullableFilter | string | null
    operadorap?: StringNullableFilter | string | null
    ano_planificacion?: IntNullableFilter | number | null
  }

  export type planificacion_guardiasOrderByWithRelationInput = {
    idturno?: SortOrder
    lugar?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    mes_planificacion?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    ano_planificacion?: SortOrderInput | SortOrder
  }

  export type planificacion_guardiasWhereUniqueInput = {
    idturno?: number
  }

  export type planificacion_guardiasOrderByWithAggregationInput = {
    idturno?: SortOrder
    lugar?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    mes_planificacion?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    ano_planificacion?: SortOrderInput | SortOrder
    _count?: planificacion_guardiasCountOrderByAggregateInput
    _avg?: planificacion_guardiasAvgOrderByAggregateInput
    _max?: planificacion_guardiasMaxOrderByAggregateInput
    _min?: planificacion_guardiasMinOrderByAggregateInput
    _sum?: planificacion_guardiasSumOrderByAggregateInput
  }

  export type planificacion_guardiasScalarWhereWithAggregatesInput = {
    AND?: planificacion_guardiasScalarWhereWithAggregatesInput | planificacion_guardiasScalarWhereWithAggregatesInput[]
    OR?: planificacion_guardiasScalarWhereWithAggregatesInput[]
    NOT?: planificacion_guardiasScalarWhereWithAggregatesInput | planificacion_guardiasScalarWhereWithAggregatesInput[]
    idturno?: IntWithAggregatesFilter | number
    lugar?: StringNullableWithAggregatesFilter | string | null
    inicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    horas?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    mes_planificacion?: StringNullableWithAggregatesFilter | string | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
    tarea?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    ano_planificacion?: IntNullableWithAggregatesFilter | number | null
  }

  export type precio_servicioWhereInput = {
    AND?: precio_servicioWhereInput | precio_servicioWhereInput[]
    OR?: precio_servicioWhereInput[]
    NOT?: precio_servicioWhereInput | precio_servicioWhereInput[]
    idprecio?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    contado?: IntNullableFilter | number | null
    contado_cremacion?: IntNullableFilter | number | null
    descuento1?: IntNullableFilter | number | null
    descuento1_cremacion?: IntNullableFilter | number | null
    descuento2?: IntNullableFilter | number | null
    descuento2_cremacion?: IntNullableFilter | number | null
    fecha_vigencia?: DateTimeNullableFilter | Date | string | null
  }

  export type precio_servicioOrderByWithRelationInput = {
    idprecio?: SortOrder
    codigo?: SortOrderInput | SortOrder
    contado?: SortOrderInput | SortOrder
    contado_cremacion?: SortOrderInput | SortOrder
    descuento1?: SortOrderInput | SortOrder
    descuento1_cremacion?: SortOrderInput | SortOrder
    descuento2?: SortOrderInput | SortOrder
    descuento2_cremacion?: SortOrderInput | SortOrder
    fecha_vigencia?: SortOrderInput | SortOrder
  }

  export type precio_servicioWhereUniqueInput = {
    idprecio?: number
  }

  export type precio_servicioOrderByWithAggregationInput = {
    idprecio?: SortOrder
    codigo?: SortOrderInput | SortOrder
    contado?: SortOrderInput | SortOrder
    contado_cremacion?: SortOrderInput | SortOrder
    descuento1?: SortOrderInput | SortOrder
    descuento1_cremacion?: SortOrderInput | SortOrder
    descuento2?: SortOrderInput | SortOrder
    descuento2_cremacion?: SortOrderInput | SortOrder
    fecha_vigencia?: SortOrderInput | SortOrder
    _count?: precio_servicioCountOrderByAggregateInput
    _avg?: precio_servicioAvgOrderByAggregateInput
    _max?: precio_servicioMaxOrderByAggregateInput
    _min?: precio_servicioMinOrderByAggregateInput
    _sum?: precio_servicioSumOrderByAggregateInput
  }

  export type precio_servicioScalarWhereWithAggregatesInput = {
    AND?: precio_servicioScalarWhereWithAggregatesInput | precio_servicioScalarWhereWithAggregatesInput[]
    OR?: precio_servicioScalarWhereWithAggregatesInput[]
    NOT?: precio_servicioScalarWhereWithAggregatesInput | precio_servicioScalarWhereWithAggregatesInput[]
    idprecio?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    contado?: IntNullableWithAggregatesFilter | number | null
    contado_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento1?: IntNullableWithAggregatesFilter | number | null
    descuento1_cremacion?: IntNullableWithAggregatesFilter | number | null
    descuento2?: IntNullableWithAggregatesFilter | number | null
    descuento2_cremacion?: IntNullableWithAggregatesFilter | number | null
    fecha_vigencia?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type proveedoresWhereInput = {
    AND?: proveedoresWhereInput | proveedoresWhereInput[]
    OR?: proveedoresWhereInput[]
    NOT?: proveedoresWhereInput | proveedoresWhereInput[]
    idproveedor?: IntFilter | number
    razon?: StringNullableFilter | string | null
    cuit?: StringNullableFilter | string | null
    domicilio?: StringNullableFilter | string | null
    telefonos?: StringNullableFilter | string | null
    estado?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
  }

  export type proveedoresOrderByWithRelationInput = {
    idproveedor?: SortOrder
    razon?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefonos?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type proveedoresWhereUniqueInput = {
    idproveedor?: number
  }

  export type proveedoresOrderByWithAggregationInput = {
    idproveedor?: SortOrder
    razon?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefonos?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: proveedoresCountOrderByAggregateInput
    _avg?: proveedoresAvgOrderByAggregateInput
    _max?: proveedoresMaxOrderByAggregateInput
    _min?: proveedoresMinOrderByAggregateInput
    _sum?: proveedoresSumOrderByAggregateInput
  }

  export type proveedoresScalarWhereWithAggregatesInput = {
    AND?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    OR?: proveedoresScalarWhereWithAggregatesInput[]
    NOT?: proveedoresScalarWhereWithAggregatesInput | proveedoresScalarWhereWithAggregatesInput[]
    idproveedor?: IntWithAggregatesFilter | number
    razon?: StringNullableWithAggregatesFilter | string | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    domicilio?: StringNullableWithAggregatesFilter | string | null
    telefonos?: StringNullableWithAggregatesFilter | string | null
    estado?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_detallesWhereInput = {
    AND?: servicio_detallesWhereInput | servicio_detallesWhereInput[]
    OR?: servicio_detallesWhereInput[]
    NOT?: servicio_detallesWhereInput | servicio_detallesWhereInput[]
    iddetalles?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    detalle?: StringNullableFilter | string | null
    lugar?: StringNullableFilter | string | null
    monto?: StringNullableFilter | string | null
    patente?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type servicio_detallesOrderByWithRelationInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    patente?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
  }

  export type servicio_detallesWhereUniqueInput = {
    iddetalles?: number
  }

  export type servicio_detallesOrderByWithAggregationInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    detalle?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    patente?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    _count?: servicio_detallesCountOrderByAggregateInput
    _avg?: servicio_detallesAvgOrderByAggregateInput
    _max?: servicio_detallesMaxOrderByAggregateInput
    _min?: servicio_detallesMinOrderByAggregateInput
    _sum?: servicio_detallesSumOrderByAggregateInput
  }

  export type servicio_detallesScalarWhereWithAggregatesInput = {
    AND?: servicio_detallesScalarWhereWithAggregatesInput | servicio_detallesScalarWhereWithAggregatesInput[]
    OR?: servicio_detallesScalarWhereWithAggregatesInput[]
    NOT?: servicio_detallesScalarWhereWithAggregatesInput | servicio_detallesScalarWhereWithAggregatesInput[]
    iddetalles?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    detalle?: StringNullableWithAggregatesFilter | string | null
    lugar?: StringNullableWithAggregatesFilter | string | null
    monto?: StringNullableWithAggregatesFilter | string | null
    patente?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_gastosWhereInput = {
    AND?: servicio_gastosWhereInput | servicio_gastosWhereInput[]
    OR?: servicio_gastosWhereInput[]
    NOT?: servicio_gastosWhereInput | servicio_gastosWhereInput[]
    idgastos?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    tipo_gasto?: StringNullableFilter | string | null
    horas?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
    observaciones?: StringNullableFilter | string | null
    inicio?: StringNullableFilter | string | null
    fin?: StringNullableFilter | string | null
    feriado?: BoolNullableFilter | boolean | null
    liquidado?: BoolNullableFilter | boolean | null
    operadorliq?: StringNullableFilter | string | null
    fecha_liquidacion?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    operadorap?: StringNullableFilter | string | null
    fecha_aprobacion?: StringNullableFilter | string | null
  }

  export type servicio_gastosOrderByWithRelationInput = {
    idgastos?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    tipo_gasto?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
  }

  export type servicio_gastosWhereUniqueInput = {
    idgastos?: number
  }

  export type servicio_gastosOrderByWithAggregationInput = {
    idgastos?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    tipo_gasto?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    _count?: servicio_gastosCountOrderByAggregateInput
    _avg?: servicio_gastosAvgOrderByAggregateInput
    _max?: servicio_gastosMaxOrderByAggregateInput
    _min?: servicio_gastosMinOrderByAggregateInput
    _sum?: servicio_gastosSumOrderByAggregateInput
  }

  export type servicio_gastosScalarWhereWithAggregatesInput = {
    AND?: servicio_gastosScalarWhereWithAggregatesInput | servicio_gastosScalarWhereWithAggregatesInput[]
    OR?: servicio_gastosScalarWhereWithAggregatesInput[]
    NOT?: servicio_gastosScalarWhereWithAggregatesInput | servicio_gastosScalarWhereWithAggregatesInput[]
    idgastos?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    tipo_gasto?: StringNullableWithAggregatesFilter | string | null
    horas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    inicio?: StringNullableWithAggregatesFilter | string | null
    fin?: StringNullableWithAggregatesFilter | string | null
    feriado?: BoolNullableWithAggregatesFilter | boolean | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicio_ventaWhereInput = {
    AND?: servicio_ventaWhereInput | servicio_ventaWhereInput[]
    OR?: servicio_ventaWhereInput[]
    NOT?: servicio_ventaWhereInput | servicio_ventaWhereInput[]
    idventa?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    monto?: FloatNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    fecha_venta?: DateTimeNullableFilter | Date | string | null
    apellido_sol?: StringNullableFilter | string | null
    nombre_sol?: StringNullableFilter | string | null
    dni_sol?: IntNullableFilter | number | null
    parentesco?: StringNullableFilter | string | null
    operador_venta?: StringNullableFilter | string | null
    liquidado?: BoolNullableFilter | boolean | null
    operadorliq?: StringNullableFilter | string | null
    fecha_liquidacion?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    operadorap?: StringNullableFilter | string | null
    fecha_aprobacion?: StringNullableFilter | string | null
    comision?: FloatNullableFilter | number | null
    fecha_carga?: DateTimeNullableFilter | Date | string | null
    valor_cuota?: FloatNullableFilter | number | null
    plan_cuota?: IntNullableFilter | number | null
    monto_financiacion?: FloatNullableFilter | number | null
    financiacion?: BoolNullableFilter | boolean | null
    efectivo?: FloatNullableFilter | number | null
  }

  export type servicio_ventaOrderByWithRelationInput = {
    idventa?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_venta?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    operador_venta?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    valor_cuota?: SortOrderInput | SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    monto_financiacion?: SortOrderInput | SortOrder
    financiacion?: SortOrderInput | SortOrder
    efectivo?: SortOrderInput | SortOrder
  }

  export type servicio_ventaWhereUniqueInput = {
    idventa?: number
  }

  export type servicio_ventaOrderByWithAggregationInput = {
    idventa?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    monto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha_venta?: SortOrderInput | SortOrder
    apellido_sol?: SortOrderInput | SortOrder
    nombre_sol?: SortOrderInput | SortOrder
    dni_sol?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    operador_venta?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    comision?: SortOrderInput | SortOrder
    fecha_carga?: SortOrderInput | SortOrder
    valor_cuota?: SortOrderInput | SortOrder
    plan_cuota?: SortOrderInput | SortOrder
    monto_financiacion?: SortOrderInput | SortOrder
    financiacion?: SortOrderInput | SortOrder
    efectivo?: SortOrderInput | SortOrder
    _count?: servicio_ventaCountOrderByAggregateInput
    _avg?: servicio_ventaAvgOrderByAggregateInput
    _max?: servicio_ventaMaxOrderByAggregateInput
    _min?: servicio_ventaMinOrderByAggregateInput
    _sum?: servicio_ventaSumOrderByAggregateInput
  }

  export type servicio_ventaScalarWhereWithAggregatesInput = {
    AND?: servicio_ventaScalarWhereWithAggregatesInput | servicio_ventaScalarWhereWithAggregatesInput[]
    OR?: servicio_ventaScalarWhereWithAggregatesInput[]
    NOT?: servicio_ventaScalarWhereWithAggregatesInput | servicio_ventaScalarWhereWithAggregatesInput[]
    idventa?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    monto?: FloatNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha_venta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    apellido_sol?: StringNullableWithAggregatesFilter | string | null
    nombre_sol?: StringNullableWithAggregatesFilter | string | null
    dni_sol?: IntNullableWithAggregatesFilter | number | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    operador_venta?: StringNullableWithAggregatesFilter | string | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    comision?: FloatNullableWithAggregatesFilter | number | null
    fecha_carga?: DateTimeNullableWithAggregatesFilter | Date | string | null
    valor_cuota?: FloatNullableWithAggregatesFilter | number | null
    plan_cuota?: IntNullableWithAggregatesFilter | number | null
    monto_financiacion?: FloatNullableWithAggregatesFilter | number | null
    financiacion?: BoolNullableWithAggregatesFilter | boolean | null
    efectivo?: FloatNullableWithAggregatesFilter | number | null
  }

  export type serviciosWhereInput = {
    AND?: serviciosWhereInput | serviciosWhereInput[]
    OR?: serviciosWhereInput[]
    NOT?: serviciosWhereInput | serviciosWhereInput[]
    idservicio?: IntFilter | number
    empresa?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    apellido?: StringNullableFilter | string | null
    nombre?: StringNullableFilter | string | null
    edad?: IntNullableFilter | number | null
    fecha_fallecimiento?: DateTimeNullableFilter | Date | string | null
    lugar_fallecimiento?: StringNullableFilter | string | null
    tipo_servicio?: StringNullableFilter | string | null
    casa_mortuaria?: StringNullableFilter | string | null
    fecha_inhumacion?: DateTimeNullableFilter | Date | string | null
    hora_inhumacion?: StringNullableFilter | string | null
    cementerio?: StringNullableFilter | string | null
    estado?: BoolNullableFilter | boolean | null
    contrato?: IntNullableFilter | number | null
    fecha_recepcion?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
    motivo?: StringNullableFilter | string | null
    retiro?: StringNullableFilter | string | null
    solicitado?: StringNullableFilter | string | null
    parentesco?: StringNullableFilter | string | null
    altura?: FloatNullableFilter | number | null
    peso?: FloatNullableFilter | number | null
    dni_nuevotitular?: IntNullableFilter | number | null
    operador?: StringNullableFilter | string | null
    idataud?: IntNullableFilter | number | null
    dni_solicitante?: IntNullableFilter | number | null
    impactado?: BoolNullableFilter | boolean | null
    cremacion?: BoolNullableFilter | boolean | null
    idparcela?: IntNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    gastos_cargados?: IntNullableFilter | number | null
    obra_soc?: StringNullableFilter | string | null
    importe?: FloatNullableFilter | number | null
    donacion?: BoolNullableFilter | boolean | null
    domicilio_solicitante?: StringNullableFilter | string | null
  }

  export type serviciosOrderByWithRelationInput = {
    idservicio?: SortOrder
    empresa?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_fallecimiento?: SortOrderInput | SortOrder
    lugar_fallecimiento?: SortOrderInput | SortOrder
    tipo_servicio?: SortOrderInput | SortOrder
    casa_mortuaria?: SortOrderInput | SortOrder
    fecha_inhumacion?: SortOrderInput | SortOrder
    hora_inhumacion?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    retiro?: SortOrderInput | SortOrder
    solicitado?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    dni_nuevotitular?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    dni_solicitante?: SortOrderInput | SortOrder
    impactado?: SortOrderInput | SortOrder
    cremacion?: SortOrderInput | SortOrder
    idparcela?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    gastos_cargados?: SortOrderInput | SortOrder
    obra_soc?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    donacion?: SortOrderInput | SortOrder
    domicilio_solicitante?: SortOrderInput | SortOrder
  }

  export type serviciosWhereUniqueInput = {
    idservicio?: number
  }

  export type serviciosOrderByWithAggregationInput = {
    idservicio?: SortOrder
    empresa?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_fallecimiento?: SortOrderInput | SortOrder
    lugar_fallecimiento?: SortOrderInput | SortOrder
    tipo_servicio?: SortOrderInput | SortOrder
    casa_mortuaria?: SortOrderInput | SortOrder
    fecha_inhumacion?: SortOrderInput | SortOrder
    hora_inhumacion?: SortOrderInput | SortOrder
    cementerio?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    fecha_recepcion?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    retiro?: SortOrderInput | SortOrder
    solicitado?: SortOrderInput | SortOrder
    parentesco?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    dni_nuevotitular?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    idataud?: SortOrderInput | SortOrder
    dni_solicitante?: SortOrderInput | SortOrder
    impactado?: SortOrderInput | SortOrder
    cremacion?: SortOrderInput | SortOrder
    idparcela?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    gastos_cargados?: SortOrderInput | SortOrder
    obra_soc?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    donacion?: SortOrderInput | SortOrder
    domicilio_solicitante?: SortOrderInput | SortOrder
    _count?: serviciosCountOrderByAggregateInput
    _avg?: serviciosAvgOrderByAggregateInput
    _max?: serviciosMaxOrderByAggregateInput
    _min?: serviciosMinOrderByAggregateInput
    _sum?: serviciosSumOrderByAggregateInput
  }

  export type serviciosScalarWhereWithAggregatesInput = {
    AND?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    OR?: serviciosScalarWhereWithAggregatesInput[]
    NOT?: serviciosScalarWhereWithAggregatesInput | serviciosScalarWhereWithAggregatesInput[]
    idservicio?: IntWithAggregatesFilter | number
    empresa?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    edad?: IntNullableWithAggregatesFilter | number | null
    fecha_fallecimiento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    lugar_fallecimiento?: StringNullableWithAggregatesFilter | string | null
    tipo_servicio?: StringNullableWithAggregatesFilter | string | null
    casa_mortuaria?: StringNullableWithAggregatesFilter | string | null
    fecha_inhumacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hora_inhumacion?: StringNullableWithAggregatesFilter | string | null
    cementerio?: StringNullableWithAggregatesFilter | string | null
    estado?: BoolNullableWithAggregatesFilter | boolean | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    fecha_recepcion?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
    motivo?: StringNullableWithAggregatesFilter | string | null
    retiro?: StringNullableWithAggregatesFilter | string | null
    solicitado?: StringNullableWithAggregatesFilter | string | null
    parentesco?: StringNullableWithAggregatesFilter | string | null
    altura?: FloatNullableWithAggregatesFilter | number | null
    peso?: FloatNullableWithAggregatesFilter | number | null
    dni_nuevotitular?: IntNullableWithAggregatesFilter | number | null
    operador?: StringNullableWithAggregatesFilter | string | null
    idataud?: IntNullableWithAggregatesFilter | number | null
    dni_solicitante?: IntNullableWithAggregatesFilter | number | null
    impactado?: BoolNullableWithAggregatesFilter | boolean | null
    cremacion?: BoolNullableWithAggregatesFilter | boolean | null
    idparcela?: IntNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    gastos_cargados?: IntNullableWithAggregatesFilter | number | null
    obra_soc?: StringNullableWithAggregatesFilter | string | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    donacion?: BoolNullableWithAggregatesFilter | boolean | null
    domicilio_solicitante?: StringNullableWithAggregatesFilter | string | null
  }

  export type servicios_liquidacionWhereInput = {
    AND?: servicios_liquidacionWhereInput | servicios_liquidacionWhereInput[]
    OR?: servicios_liquidacionWhereInput[]
    NOT?: servicios_liquidacionWhereInput | servicios_liquidacionWhereInput[]
    idliquidacion?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    total_liquidacion?: IntNullableFilter | number | null
    fecha_liquidacion?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type servicios_liquidacionOrderByWithRelationInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    total_liquidacion?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type servicios_liquidacionWhereUniqueInput = {
    idliquidacion?: number
  }

  export type servicios_liquidacionOrderByWithAggregationInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    total_liquidacion?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: servicios_liquidacionCountOrderByAggregateInput
    _avg?: servicios_liquidacionAvgOrderByAggregateInput
    _max?: servicios_liquidacionMaxOrderByAggregateInput
    _min?: servicios_liquidacionMinOrderByAggregateInput
    _sum?: servicios_liquidacionSumOrderByAggregateInput
  }

  export type servicios_liquidacionScalarWhereWithAggregatesInput = {
    AND?: servicios_liquidacionScalarWhereWithAggregatesInput | servicios_liquidacionScalarWhereWithAggregatesInput[]
    OR?: servicios_liquidacionScalarWhereWithAggregatesInput[]
    NOT?: servicios_liquidacionScalarWhereWithAggregatesInput | servicios_liquidacionScalarWhereWithAggregatesInput[]
    idliquidacion?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    total_liquidacion?: IntNullableWithAggregatesFilter | number | null
    fecha_liquidacion?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type tareasWhereInput = {
    AND?: tareasWhereInput | tareasWhereInput[]
    OR?: tareasWhereInput[]
    NOT?: tareasWhereInput | tareasWhereInput[]
    idevents?: IntFilter | number
    title?: StringNullableFilter | string | null
    allDay?: IntNullableFilter | number | null
    start?: StringNullableFilter | string | null
    end?: StringNullableFilter | string | null
    priority?: IntNullableFilter | number | null
  }

  export type tareasOrderByWithRelationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
  }

  export type tareasWhereUniqueInput = {
    idevents?: number
  }

  export type tareasOrderByWithAggregationInput = {
    idevents?: SortOrder
    title?: SortOrderInput | SortOrder
    allDay?: SortOrderInput | SortOrder
    start?: SortOrderInput | SortOrder
    end?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    _count?: tareasCountOrderByAggregateInput
    _avg?: tareasAvgOrderByAggregateInput
    _max?: tareasMaxOrderByAggregateInput
    _min?: tareasMinOrderByAggregateInput
    _sum?: tareasSumOrderByAggregateInput
  }

  export type tareasScalarWhereWithAggregatesInput = {
    AND?: tareasScalarWhereWithAggregatesInput | tareasScalarWhereWithAggregatesInput[]
    OR?: tareasScalarWhereWithAggregatesInput[]
    NOT?: tareasScalarWhereWithAggregatesInput | tareasScalarWhereWithAggregatesInput[]
    idevents?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    allDay?: IntNullableWithAggregatesFilter | number | null
    start?: StringNullableWithAggregatesFilter | string | null
    end?: StringNullableWithAggregatesFilter | string | null
    priority?: IntNullableWithAggregatesFilter | number | null
  }

  export type tareas_adicionalesWhereInput = {
    AND?: tareas_adicionalesWhereInput | tareas_adicionalesWhereInput[]
    OR?: tareas_adicionalesWhereInput[]
    NOT?: tareas_adicionalesWhereInput | tareas_adicionalesWhereInput[]
    idtarea?: IntFilter | number
    inicio?: DateTimeNullableFilter | Date | string | null
    fin?: DateTimeNullableFilter | Date | string | null
    tarea?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    observaciones?: StringNullableFilter | string | null
    horas?: DateTimeNullableFilter | Date | string | null
    feriado?: IntNullableFilter | number | null
    liquidado?: BoolNullableFilter | boolean | null
    fecha_liquidacion?: StringNullableFilter | string | null
    operadorliq?: StringNullableFilter | string | null
    aprobado?: BoolNullableFilter | boolean | null
    fecha_aprobacion?: StringNullableFilter | string | null
    operadorap?: StringNullableFilter | string | null
    mes_planificacion?: StringNullableFilter | string | null
  }

  export type tareas_adicionalesOrderByWithRelationInput = {
    idtarea?: SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    mes_planificacion?: SortOrderInput | SortOrder
  }

  export type tareas_adicionalesWhereUniqueInput = {
    idtarea?: number
  }

  export type tareas_adicionalesOrderByWithAggregationInput = {
    idtarea?: SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    tarea?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    horas?: SortOrderInput | SortOrder
    feriado?: SortOrderInput | SortOrder
    liquidado?: SortOrderInput | SortOrder
    fecha_liquidacion?: SortOrderInput | SortOrder
    operadorliq?: SortOrderInput | SortOrder
    aprobado?: SortOrderInput | SortOrder
    fecha_aprobacion?: SortOrderInput | SortOrder
    operadorap?: SortOrderInput | SortOrder
    mes_planificacion?: SortOrderInput | SortOrder
    _count?: tareas_adicionalesCountOrderByAggregateInput
    _avg?: tareas_adicionalesAvgOrderByAggregateInput
    _max?: tareas_adicionalesMaxOrderByAggregateInput
    _min?: tareas_adicionalesMinOrderByAggregateInput
    _sum?: tareas_adicionalesSumOrderByAggregateInput
  }

  export type tareas_adicionalesScalarWhereWithAggregatesInput = {
    AND?: tareas_adicionalesScalarWhereWithAggregatesInput | tareas_adicionalesScalarWhereWithAggregatesInput[]
    OR?: tareas_adicionalesScalarWhereWithAggregatesInput[]
    NOT?: tareas_adicionalesScalarWhereWithAggregatesInput | tareas_adicionalesScalarWhereWithAggregatesInput[]
    idtarea?: IntWithAggregatesFilter | number
    inicio?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fin?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tarea?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    observaciones?: StringNullableWithAggregatesFilter | string | null
    horas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    feriado?: IntNullableWithAggregatesFilter | number | null
    liquidado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_liquidacion?: StringNullableWithAggregatesFilter | string | null
    operadorliq?: StringNullableWithAggregatesFilter | string | null
    aprobado?: BoolNullableWithAggregatesFilter | boolean | null
    fecha_aprobacion?: StringNullableWithAggregatesFilter | string | null
    operadorap?: StringNullableWithAggregatesFilter | string | null
    mes_planificacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type tipo_detalleWhereInput = {
    AND?: tipo_detalleWhereInput | tipo_detalleWhereInput[]
    OR?: tipo_detalleWhereInput[]
    NOT?: tipo_detalleWhereInput | tipo_detalleWhereInput[]
    idtipodetalle?: IntFilter | number
    tipo_detalle?: StringNullableFilter | string | null
    observacion?: StringNullableFilter | string | null
  }

  export type tipo_detalleOrderByWithRelationInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
  }

  export type tipo_detalleWhereUniqueInput = {
    idtipodetalle?: number
  }

  export type tipo_detalleOrderByWithAggregationInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrderInput | SortOrder
    observacion?: SortOrderInput | SortOrder
    _count?: tipo_detalleCountOrderByAggregateInput
    _avg?: tipo_detalleAvgOrderByAggregateInput
    _max?: tipo_detalleMaxOrderByAggregateInput
    _min?: tipo_detalleMinOrderByAggregateInput
    _sum?: tipo_detalleSumOrderByAggregateInput
  }

  export type tipo_detalleScalarWhereWithAggregatesInput = {
    AND?: tipo_detalleScalarWhereWithAggregatesInput | tipo_detalleScalarWhereWithAggregatesInput[]
    OR?: tipo_detalleScalarWhereWithAggregatesInput[]
    NOT?: tipo_detalleScalarWhereWithAggregatesInput | tipo_detalleScalarWhereWithAggregatesInput[]
    idtipodetalle?: IntWithAggregatesFilter | number
    tipo_detalle?: StringNullableWithAggregatesFilter | string | null
    observacion?: StringNullableWithAggregatesFilter | string | null
  }

  export type visitantesWhereInput = {
    AND?: visitantesWhereInput | visitantesWhereInput[]
    OR?: visitantesWhereInput[]
    NOT?: visitantesWhereInput | visitantesWhereInput[]
    idvisitante?: IntFilter | number
    idservicio?: IntNullableFilter | number | null
    nombre?: StringNullableFilter | string | null
    apellido?: StringNullableFilter | string | null
    dni?: IntNullableFilter | number | null
    telefono?: IntNullableFilter | number | null
    parentezco?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    temperatura?: StringNullableFilter | string | null
  }

  export type visitantesOrderByWithRelationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
  }

  export type visitantesWhereUniqueInput = {
    idvisitante?: number
  }

  export type visitantesOrderByWithAggregationInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrderInput | SortOrder
    nombre?: SortOrderInput | SortOrder
    apellido?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    parentezco?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
    _count?: visitantesCountOrderByAggregateInput
    _avg?: visitantesAvgOrderByAggregateInput
    _max?: visitantesMaxOrderByAggregateInput
    _min?: visitantesMinOrderByAggregateInput
    _sum?: visitantesSumOrderByAggregateInput
  }

  export type visitantesScalarWhereWithAggregatesInput = {
    AND?: visitantesScalarWhereWithAggregatesInput | visitantesScalarWhereWithAggregatesInput[]
    OR?: visitantesScalarWhereWithAggregatesInput[]
    NOT?: visitantesScalarWhereWithAggregatesInput | visitantesScalarWhereWithAggregatesInput[]
    idvisitante?: IntWithAggregatesFilter | number
    idservicio?: IntNullableWithAggregatesFilter | number | null
    nombre?: StringNullableWithAggregatesFilter | string | null
    apellido?: StringNullableWithAggregatesFilter | string | null
    dni?: IntNullableWithAggregatesFilter | number | null
    telefono?: IntNullableWithAggregatesFilter | number | null
    parentezco?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    temperatura?: StringNullableWithAggregatesFilter | string | null
  }

  export type parcelas_lugaresWhereInput = {
    AND?: parcelas_lugaresWhereInput | parcelas_lugaresWhereInput[]
    OR?: parcelas_lugaresWhereInput[]
    NOT?: parcelas_lugaresWhereInput | parcelas_lugaresWhereInput[]
    idlugar?: IntFilter | number
    idparcela?: IntNullableFilter | number | null
    idservicio?: IntNullableFilter | number | null
    lugar?: IntNullableFilter | number | null
    contrato?: IntNullableFilter | number | null
    dni?: IntNullableFilter | number | null
    fecha?: DateTimeNullableFilter | Date | string | null
    operador?: StringNullableFilter | string | null
  }

  export type parcelas_lugaresOrderByWithRelationInput = {
    idlugar?: SortOrder
    idparcela?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
  }

  export type parcelas_lugaresWhereUniqueInput = {
    idlugar?: number
  }

  export type parcelas_lugaresOrderByWithAggregationInput = {
    idlugar?: SortOrder
    idparcela?: SortOrderInput | SortOrder
    idservicio?: SortOrderInput | SortOrder
    lugar?: SortOrderInput | SortOrder
    contrato?: SortOrderInput | SortOrder
    dni?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    _count?: parcelas_lugaresCountOrderByAggregateInput
    _avg?: parcelas_lugaresAvgOrderByAggregateInput
    _max?: parcelas_lugaresMaxOrderByAggregateInput
    _min?: parcelas_lugaresMinOrderByAggregateInput
    _sum?: parcelas_lugaresSumOrderByAggregateInput
  }

  export type parcelas_lugaresScalarWhereWithAggregatesInput = {
    AND?: parcelas_lugaresScalarWhereWithAggregatesInput | parcelas_lugaresScalarWhereWithAggregatesInput[]
    OR?: parcelas_lugaresScalarWhereWithAggregatesInput[]
    NOT?: parcelas_lugaresScalarWhereWithAggregatesInput | parcelas_lugaresScalarWhereWithAggregatesInput[]
    idlugar?: IntWithAggregatesFilter | number
    idparcela?: IntNullableWithAggregatesFilter | number | null
    idservicio?: IntNullableWithAggregatesFilter | number | null
    lugar?: IntNullableWithAggregatesFilter | number | null
    contrato?: IntNullableWithAggregatesFilter | number | null
    dni?: IntNullableWithAggregatesFilter | number | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_saWhereInput = {
    AND?: caja_saWhereInput | caja_saWhereInput[]
    OR?: caja_saWhereInput[]
    NOT?: caja_saWhereInput | caja_saWhereInput[]
    idcaja?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    cuenta?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    serie?: IntNullableFilter | number | null
    factura?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    comentarios?: StringNullableFilter | string | null
    nro_caja?: IntNullableFilter | number | null
    movim?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    puesto?: IntNullableFilter | number | null
    operador?: IntNullableFilter | number | null
    cuit?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
  }

  export type caja_saOrderByWithRelationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
  }

  export type caja_saWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_saOrderByWithAggregationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    _count?: caja_saCountOrderByAggregateInput
    _avg?: caja_saAvgOrderByAggregateInput
    _max?: caja_saMaxOrderByAggregateInput
    _min?: caja_saMinOrderByAggregateInput
    _sum?: caja_saSumOrderByAggregateInput
  }

  export type caja_saScalarWhereWithAggregatesInput = {
    AND?: caja_saScalarWhereWithAggregatesInput | caja_saScalarWhereWithAggregatesInput[]
    OR?: caja_saScalarWhereWithAggregatesInput[]
    NOT?: caja_saScalarWhereWithAggregatesInput | caja_saScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    cuenta?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    serie?: IntNullableWithAggregatesFilter | number | null
    factura?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    comentarios?: StringNullableWithAggregatesFilter | string | null
    nro_caja?: IntNullableWithAggregatesFilter | number | null
    movim?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    puesto?: IntNullableWithAggregatesFilter | number | null
    operador?: IntNullableWithAggregatesFilter | number | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
  }

  export type caja_srlWhereInput = {
    AND?: caja_srlWhereInput | caja_srlWhereInput[]
    OR?: caja_srlWhereInput[]
    NOT?: caja_srlWhereInput | caja_srlWhereInput[]
    idcaja?: IntFilter | number
    codigo?: IntNullableFilter | number | null
    cuenta?: StringNullableFilter | string | null
    tipo?: StringNullableFilter | string | null
    serie?: IntNullableFilter | number | null
    factura?: IntNullableFilter | number | null
    importe?: FloatNullableFilter | number | null
    comentarios?: StringNullableFilter | string | null
    nro_caja?: IntNullableFilter | number | null
    movim?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
    puesto?: IntNullableFilter | number | null
    operador?: IntNullableFilter | number | null
    cuit?: StringNullableFilter | string | null
    proveedor?: StringNullableFilter | string | null
    sucursal?: StringNullableFilter | string | null
  }

  export type caja_srlOrderByWithRelationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
  }

  export type caja_srlWhereUniqueInput = {
    idcaja?: number
  }

  export type caja_srlOrderByWithAggregationInput = {
    idcaja?: SortOrder
    codigo?: SortOrderInput | SortOrder
    cuenta?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    factura?: SortOrderInput | SortOrder
    importe?: SortOrderInput | SortOrder
    comentarios?: SortOrderInput | SortOrder
    nro_caja?: SortOrderInput | SortOrder
    movim?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    cuit?: SortOrderInput | SortOrder
    proveedor?: SortOrderInput | SortOrder
    sucursal?: SortOrderInput | SortOrder
    _count?: caja_srlCountOrderByAggregateInput
    _avg?: caja_srlAvgOrderByAggregateInput
    _max?: caja_srlMaxOrderByAggregateInput
    _min?: caja_srlMinOrderByAggregateInput
    _sum?: caja_srlSumOrderByAggregateInput
  }

  export type caja_srlScalarWhereWithAggregatesInput = {
    AND?: caja_srlScalarWhereWithAggregatesInput | caja_srlScalarWhereWithAggregatesInput[]
    OR?: caja_srlScalarWhereWithAggregatesInput[]
    NOT?: caja_srlScalarWhereWithAggregatesInput | caja_srlScalarWhereWithAggregatesInput[]
    idcaja?: IntWithAggregatesFilter | number
    codigo?: IntNullableWithAggregatesFilter | number | null
    cuenta?: StringNullableWithAggregatesFilter | string | null
    tipo?: StringNullableWithAggregatesFilter | string | null
    serie?: IntNullableWithAggregatesFilter | number | null
    factura?: IntNullableWithAggregatesFilter | number | null
    importe?: FloatNullableWithAggregatesFilter | number | null
    comentarios?: StringNullableWithAggregatesFilter | string | null
    nro_caja?: IntNullableWithAggregatesFilter | number | null
    movim?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
    puesto?: IntNullableWithAggregatesFilter | number | null
    operador?: IntNullableWithAggregatesFilter | number | null
    cuit?: StringNullableWithAggregatesFilter | string | null
    proveedor?: StringNullableWithAggregatesFilter | string | null
    sucursal?: StringNullableWithAggregatesFilter | string | null
  }

  export type generacion_cajasWhereInput = {
    AND?: generacion_cajasWhereInput | generacion_cajasWhereInput[]
    OR?: generacion_cajasWhereInput[]
    NOT?: generacion_cajasWhereInput | generacion_cajasWhereInput[]
    idgeneracion?: IntFilter | number
    desde?: DateTimeNullableFilter | Date | string | null
    hasta?: DateTimeNullableFilter | Date | string | null
    empresa?: StringNullableFilter | string | null
    operador?: StringNullableFilter | string | null
    fecha?: DateTimeNullableFilter | Date | string | null
  }

  export type generacion_cajasOrderByWithRelationInput = {
    idgeneracion?: SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type generacion_cajasWhereUniqueInput = {
    idgeneracion?: number
  }

  export type generacion_cajasOrderByWithAggregationInput = {
    idgeneracion?: SortOrder
    desde?: SortOrderInput | SortOrder
    hasta?: SortOrderInput | SortOrder
    empresa?: SortOrderInput | SortOrder
    operador?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: generacion_cajasCountOrderByAggregateInput
    _avg?: generacion_cajasAvgOrderByAggregateInput
    _max?: generacion_cajasMaxOrderByAggregateInput
    _min?: generacion_cajasMinOrderByAggregateInput
    _sum?: generacion_cajasSumOrderByAggregateInput
  }

  export type generacion_cajasScalarWhereWithAggregatesInput = {
    AND?: generacion_cajasScalarWhereWithAggregatesInput | generacion_cajasScalarWhereWithAggregatesInput[]
    OR?: generacion_cajasScalarWhereWithAggregatesInput[]
    NOT?: generacion_cajasScalarWhereWithAggregatesInput | generacion_cajasScalarWhereWithAggregatesInput[]
    idgeneracion?: IntWithAggregatesFilter | number
    desde?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hasta?: DateTimeNullableWithAggregatesFilter | Date | string | null
    empresa?: StringNullableWithAggregatesFilter | string | null
    operador?: StringNullableWithAggregatesFilter | string | null
    fecha?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ataud_precioCreateInput = {
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUncheckedCreateInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioCreateManyInput = {
    idprecio?: number
    idataud?: number | null
    codigo?: number | null
    ataud?: string | null
    precio?: number | null
    pri_desc?: number | null
    sec_desc?: number | null
    fecha?: Date | string | null
    operador?: string | null
    estado?: boolean | null
  }

  export type ataud_precioUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_precioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableFloatFieldUpdateOperationsInput | number | null
    pri_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    sec_desc?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ataud_ventaCreateInput = {
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUncheckedCreateInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaCreateManyInput = {
    idataudventa?: number
    idataud?: number | null
    contrato?: number | null
    apellido_fall?: string | null
    nombre_fall?: string | null
    dni_fall?: number | null
    dom_fall?: string | null
    ndom_fall?: number | null
    barrio_fall?: string | null
    telefono_fall?: string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    telefono_sol?: string | null
    fecha?: Date | string | null
    operador?: string | null
    ataud?: string | null
  }

  export type ataud_ventaUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataud_ventaUncheckedUpdateManyInput = {
    idataudventa?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_fall?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_fall?: NullableStringFieldUpdateOperationsInput | string | null
    dni_fall?: NullableIntFieldUpdateOperationsInput | number | null
    dom_fall?: NullableStringFieldUpdateOperationsInput | string | null
    ndom_fall?: NullableIntFieldUpdateOperationsInput | number | null
    barrio_fall?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_fall?: NullableStringFieldUpdateOperationsInput | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    telefono_sol?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    ataud?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateInput = {
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUncheckedCreateInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesCreateManyInput = {
    idataud?: number
    nombre?: string | null
    tipo?: string | null
    medidas?: string | null
    uso?: string | null
    fabricante?: string | null
    codigo?: number | null
    fecha_alta?: Date | string | null
    stock?: number | null
    fecha_reposicion?: Date | string | null
    fecha_baja?: Date | string | null
    observaciones?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type ataudesUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ataudesUncheckedUpdateManyInput = {
    idataud?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    medidas?: NullableStringFieldUpdateOperationsInput | string | null
    uso?: NullableStringFieldUpdateOperationsInput | string | null
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_alta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_reposicion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_baja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUncheckedCreateInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosCreateManyInput = {
    patente?: string | null
    auto?: string | null
    kilometros?: number | null
    responsable?: string | null
    nro_poliza?: string | null
    empresa?: string | null
    vencimiento?: Date | string | null
    motor?: string | null
    chasis?: string | null
    modelo?: number | null
    cobertura?: string | null
    idauto?: number
    estado?: boolean | null
    operador?: string | null
  }

  export type autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autosUncheckedUpdateManyInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    kilometros?: NullableFloatFieldUpdateOperationsInput | number | null
    responsable?: NullableStringFieldUpdateOperationsInput | string | null
    nro_poliza?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    vencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motor?: NullableStringFieldUpdateOperationsInput | string | null
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: NullableIntFieldUpdateOperationsInput | number | null
    cobertura?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: IntFieldUpdateOperationsInput | number
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateInput = {
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUncheckedCreateInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaCreateManyInput = {
    idhojaruta?: number
    patente?: string | null
    auto?: string | null
    conductor?: string | null
    idservicio?: number | null
    fecha_salida?: Date | string | null
    km_salida?: number | null
    fecha_llegada?: Date | string | null
    km_llegada?: number | null
    fecha_registro?: Date | string | null
    operador?: string | null
  }

  export type autos_hoja_rutaUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_hoja_rutaUncheckedUpdateManyInput = {
    idhojaruta?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
    conductor?: NullableStringFieldUpdateOperationsInput | string | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_salida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_salida?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_llegada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    km_llegada?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_registro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateInput = {
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUncheckedCreateInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesCreateManyInput = {
    idnovedad?: number
    patente?: string | null
    fecha?: Date | string | null
    novedad?: string | null
    operador?: string | null
    auto?: string | null
  }

  export type autos_novedadesUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    auto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateInput = {
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUncheckedCreateInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteCreateManyInput = {
    idpago?: number
    patente?: string | null
    mes?: number | null
    ano?: number | null
    importe?: number | null
    cod_pago?: number | null
    idauto?: number | null
    operador?: string | null
  }

  export type autos_pago_patenteUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type autos_pago_patenteUncheckedUpdateManyInput = {
    idpago?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    ano?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    cod_pago?: NullableIntFieldUpdateOperationsInput | number | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_sepelioCreateInput = {
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUncheckedCreateInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioCreateManyInput = {
    idcaja?: number
    operador?: string | null
    detalle?: string | null
    monto?: number | null
    estado?: boolean | null
    fecha?: Date | string | null
    gastos?: number | null
    totalcaja?: number | null
    empresa?: string | null
    tipofactura?: string | null
    nfactura?: number | null
    ptoventa?: number | null
    concepto?: string | null
    cierre?: Date | string | null
    ultimacarga?: Date | string | null
  }

  export type caja_sepelioUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type caja_sepelioUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gastos?: NullableFloatFieldUpdateOperationsInput | number | null
    totalcaja?: NullableFloatFieldUpdateOperationsInput | number | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableIntFieldUpdateOperationsInput | number | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    cierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimacarga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conceptosCreateInput = {
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUncheckedCreateInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosCreateManyInput = {
    idconcepto?: number
    concepto?: string | null
    tipo?: string | null
  }

  export type conceptosUpdateManyMutationInput = {
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conceptosUncheckedUpdateManyInput = {
    idconcepto?: IntFieldUpdateOperationsInput | number
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateInput = {
    fabricante?: string | null
  }

  export type fabricante_ataudUncheckedCreateInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudCreateManyInput = {
    idfabricante?: number
    fabricante?: string | null
  }

  export type fabricante_ataudUpdateManyMutationInput = {
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fabricante_ataudUncheckedUpdateManyInput = {
    idfabricante?: IntFieldUpdateOperationsInput | number
    fabricante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateInput = {
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUncheckedCreateInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoCreateManyInput = {
    idgastoluto?: number
    idservicio?: number | null
    contrato?: number | null
    dni_extinto?: number | null
    extinto?: string | null
    gasto_luto?: number | null
    idataud?: number | null
    apellido_ben?: string | null
    nombre_ben?: string | null
    telefono_ben?: string | null
    fecha?: string | null
    operador?: string | null
    parentezco?: string | null
  }

  export type gasto_lutoUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gasto_lutoUncheckedUpdateManyInput = {
    idgastoluto?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    extinto?: NullableStringFieldUpdateOperationsInput | string | null
    gasto_luto?: NullableFloatFieldUpdateOperationsInput | number | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    apellido_ben?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_ben?: NullableStringFieldUpdateOperationsInput | string | null
    telefono_ben?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gastos_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUncheckedCreateInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaCreateManyInput = {
    idgastos?: number
    idcaja?: number | null
    concepto?: string | null
    tipofactura?: string | null
    nfactura?: string | null
    fecha?: Date | string | null
    operadorgestion?: string | null
    operadortramite?: string | null
    ptoventa?: number | null
    porciva?: string | null
    montoiva?: number | null
    retiibb?: number | null
    retggcias?: number | null
    perciva?: number | null
    detalle?: string | null
    mediopago?: string | null
    proveedor?: string | null
    empresa?: string | null
    total?: number | null
    idservicio?: number | null
  }

  export type gastos_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gastos_cajaUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operadorgestion?: NullableStringFieldUpdateOperationsInput | string | null
    operadortramite?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
    porciva?: NullableStringFieldUpdateOperationsInput | string | null
    montoiva?: NullableIntFieldUpdateOperationsInput | number | null
    retiibb?: NullableFloatFieldUpdateOperationsInput | number | null
    retggcias?: NullableFloatFieldUpdateOperationsInput | number | null
    perciva?: NullableFloatFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    mediopago?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historial_autosCreateInput = {
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUncheckedCreateInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosCreateManyInput = {
    idhistorial?: number
    patente?: string | null
    idauto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    accion?: string | null
  }

  export type historial_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_autosUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    idauto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historial_stock_ataudCreateInput = {
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUncheckedCreateInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudCreateManyInput = {
    idhistorial?: number
    idataud?: number | null
    fecha_carga?: Date | string | null
    stock_anterior?: number | null
    stock_nuevo?: number | null
    remito?: string | null
    operador?: string | null
    fecha_recepcion?: Date | string | null
  }

  export type historial_stock_ataudUpdateManyMutationInput = {
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historial_stock_ataudUncheckedUpdateManyInput = {
    idhistorial?: IntFieldUpdateOperationsInput | number
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock_anterior?: NullableIntFieldUpdateOperationsInput | number | null
    stock_nuevo?: NullableIntFieldUpdateOperationsInput | number | null
    remito?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_recepcion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type honorariosCreateInput = {
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUncheckedCreateInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosCreateManyInput = {
    idtrabajo?: number
    trabajo?: string | null
    dias_habiles?: number | null
    finde?: number | null
    feriado?: number | null
  }

  export type honorariosUpdateManyMutationInput = {
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type honorariosUncheckedUpdateManyInput = {
    idtrabajo?: IntFieldUpdateOperationsInput | number
    trabajo?: NullableStringFieldUpdateOperationsInput | string | null
    dias_habiles?: NullableIntFieldUpdateOperationsInput | number | null
    finde?: NullableIntFieldUpdateOperationsInput | number | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaCreateInput = {
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUncheckedCreateInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaCreateManyInput = {
    idingreso?: number
    idcaja?: number | null
    concepto?: string | null
    monto?: number | null
    operador?: string | null
    fecha?: Date | string | null
    tipofactura?: string | null
    nfactura?: string | null
    empresa?: string | null
    detalle?: string | null
    ptoventa?: number | null
  }

  export type ingreso_cajaUpdateManyMutationInput = {
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ingreso_cajaUncheckedUpdateManyInput = {
    idingreso?: IntFieldUpdateOperationsInput | number
    idcaja?: NullableIntFieldUpdateOperationsInput | number | null
    concepto?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipofactura?: NullableStringFieldUpdateOperationsInput | string | null
    nfactura?: NullableStringFieldUpdateOperationsInput | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    ptoventa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type legajo_virtual_autosCreateInput = {
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUncheckedCreateInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosCreateManyInput = {
    idlegajo?: number
    patente?: string | null
    archivo?: string | null
    fecha_subida?: Date | string | null
  }

  export type legajo_virtual_autosUpdateManyMutationInput = {
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_autosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type legajo_virtual_serviciosCreateInput = {
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUncheckedCreateInput = {
    idlegajo?: number
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateInput = {
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosCreateManyInput = {
    idlegajo?: number
    servicio?: number | null
    archivo?: string | null
    fecha_subida?: Date | string | null
    empresa?: string | null
  }

  export type legajo_virtual_serviciosUpdateManyMutationInput = {
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type legajo_virtual_serviciosUncheckedUpdateManyInput = {
    idlegajo?: IntFieldUpdateOperationsInput | number
    servicio?: NullableIntFieldUpdateOperationsInput | number | null
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_subida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesCreateInput = {
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUncheckedCreateInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesCreateManyInput = {
    idnovedad?: number
    novedad?: string | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type novedadesUpdateManyMutationInput = {
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type novedadesUncheckedUpdateManyInput = {
    idnovedad?: IntFieldUpdateOperationsInput | number
    novedad?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateInput = {
    operador?: string | null
  }

  export type operadorsepUncheckedCreateInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepCreateManyInput = {
    idoperador?: number
    operador?: string | null
  }

  export type operadorsepUpdateManyMutationInput = {
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type operadorsepUncheckedUpdateManyInput = {
    idoperador?: IntFieldUpdateOperationsInput | number
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelasCreateInput = {
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUncheckedCreateInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasCreateManyInput = {
    idparcela?: number
    idservicio?: number | null
    dni_extinto?: number | null
    ficha?: number | null
    parcela?: string | null
    mza?: number | null
    lote?: number | null
    asignada?: boolean | null
    fecha?: string | null
    cementerio?: string | null
    operador?: string | null
    fecha_alta?: string | null
    operador_asignacion?: string | null
    fecha_asignacion?: string | null
    lugares?: number | null
  }

  export type parcelasUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parcelasUncheckedUpdateManyInput = {
    idparcela?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    dni_extinto?: NullableIntFieldUpdateOperationsInput | number | null
    ficha?: NullableIntFieldUpdateOperationsInput | number | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    mza?: NullableIntFieldUpdateOperationsInput | number | null
    lote?: NullableIntFieldUpdateOperationsInput | number | null
    asignada?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_alta?: NullableStringFieldUpdateOperationsInput | string | null
    operador_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_asignacion?: NullableStringFieldUpdateOperationsInput | string | null
    lugares?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasCreateInput = {
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: number | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUncheckedCreateInput = {
    idturno?: number
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: number | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUpdateInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasUncheckedUpdateInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasCreateManyInput = {
    idturno?: number
    lugar?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    horas?: number | null
    operador?: string | null
    mes_planificacion?: string | null
    feriado?: boolean | null
    tarea?: string | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    ano_planificacion?: number | null
  }

  export type planificacion_guardiasUpdateManyMutationInput = {
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type planificacion_guardiasUncheckedUpdateManyInput = {
    idturno?: IntFieldUpdateOperationsInput | number
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horas?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    ano_planificacion?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type precio_servicioCreateInput = {
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUncheckedCreateInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioCreateManyInput = {
    idprecio?: number
    codigo?: number | null
    contado?: number | null
    contado_cremacion?: number | null
    descuento1?: number | null
    descuento1_cremacion?: number | null
    descuento2?: number | null
    descuento2_cremacion?: number | null
    fecha_vigencia?: Date | string | null
  }

  export type precio_servicioUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type precio_servicioUncheckedUpdateManyInput = {
    idprecio?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    contado?: NullableIntFieldUpdateOperationsInput | number | null
    contado_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1?: NullableIntFieldUpdateOperationsInput | number | null
    descuento1_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2?: NullableIntFieldUpdateOperationsInput | number | null
    descuento2_cremacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_vigencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type proveedoresCreateInput = {
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUncheckedCreateInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresCreateManyInput = {
    idproveedor?: number
    razon?: string | null
    cuit?: string | null
    domicilio?: string | null
    telefonos?: string | null
    estado?: number | null
    operador?: string | null
  }

  export type proveedoresUpdateManyMutationInput = {
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedoresUncheckedUpdateManyInput = {
    idproveedor?: IntFieldUpdateOperationsInput | number
    razon?: NullableStringFieldUpdateOperationsInput | string | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefonos?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesCreateInput = {
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUncheckedCreateInput = {
    iddetalles?: number
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesUncheckedUpdateInput = {
    iddetalles?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesCreateManyInput = {
    iddetalles?: number
    idservicio?: number | null
    detalle?: string | null
    lugar?: string | null
    monto?: string | null
    patente?: string | null
    operador?: string | null
    fecha?: string | null
    observacion?: string | null
  }

  export type servicio_detallesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_detallesUncheckedUpdateManyInput = {
    iddetalles?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    lugar?: NullableStringFieldUpdateOperationsInput | string | null
    monto?: NullableStringFieldUpdateOperationsInput | string | null
    patente?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosCreateInput = {
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUncheckedCreateInput = {
    idgastos?: number
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosUncheckedUpdateInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosCreateManyInput = {
    idgastos?: number
    idservicio?: number | null
    tipo_gasto?: string | null
    horas?: Date | string | null
    operador?: string | null
    observaciones?: string | null
    inicio?: string | null
    fin?: string | null
    feriado?: boolean | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
  }

  export type servicio_gastosUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_gastosUncheckedUpdateManyInput = {
    idgastos?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    tipo_gasto?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableStringFieldUpdateOperationsInput | string | null
    fin?: NullableStringFieldUpdateOperationsInput | string | null
    feriado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicio_ventaCreateInput = {
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUncheckedCreateInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaCreateManyInput = {
    idventa?: number
    idservicio?: number | null
    monto?: number | null
    operador?: string | null
    fecha_venta?: Date | string | null
    apellido_sol?: string | null
    nombre_sol?: string | null
    dni_sol?: number | null
    parentesco?: string | null
    operador_venta?: string | null
    liquidado?: boolean | null
    operadorliq?: string | null
    fecha_liquidacion?: string | null
    aprobado?: boolean | null
    operadorap?: string | null
    fecha_aprobacion?: string | null
    comision?: number | null
    fecha_carga?: Date | string | null
    valor_cuota?: number | null
    plan_cuota?: number | null
    monto_financiacion?: number | null
    financiacion?: boolean | null
    efectivo?: number | null
  }

  export type servicio_ventaUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type servicio_ventaUncheckedUpdateManyInput = {
    idventa?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    monto?: NullableFloatFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_venta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apellido_sol?: NullableStringFieldUpdateOperationsInput | string | null
    nombre_sol?: NullableStringFieldUpdateOperationsInput | string | null
    dni_sol?: NullableIntFieldUpdateOperationsInput | number | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    operador_venta?: NullableStringFieldUpdateOperationsInput | string | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    comision?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_carga?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valor_cuota?: NullableFloatFieldUpdateOperationsInput | number | null
    plan_cuota?: NullableIntFieldUpdateOperationsInput | number | null
    monto_financiacion?: NullableFloatFieldUpdateOperationsInput | number | null
    financiacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    efectivo?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type serviciosCreateInput = {
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUncheckedCreateInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUpdateInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosCreateManyInput = {
    idservicio?: number
    empresa?: string | null
    dni?: number | null
    apellido?: string | null
    nombre?: string | null
    edad?: number | null
    fecha_fallecimiento?: Date | string | null
    lugar_fallecimiento?: string | null
    tipo_servicio?: string | null
    casa_mortuaria?: string | null
    fecha_inhumacion?: Date | string | null
    hora_inhumacion?: string | null
    cementerio?: string | null
    estado?: boolean | null
    contrato?: number | null
    fecha_recepcion?: string | null
    sucursal?: string | null
    motivo?: string | null
    retiro?: string | null
    solicitado?: string | null
    parentesco?: string | null
    altura?: number | null
    peso?: number | null
    dni_nuevotitular?: number | null
    operador?: string | null
    idataud?: number | null
    dni_solicitante?: number | null
    impactado?: boolean | null
    cremacion?: boolean | null
    idparcela?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    gastos_cargados?: number | null
    obra_soc?: string | null
    importe?: number | null
    donacion?: boolean | null
    domicilio_solicitante?: string | null
  }

  export type serviciosUpdateManyMutationInput = {
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviciosUncheckedUpdateManyInput = {
    idservicio?: IntFieldUpdateOperationsInput | number
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_fallecimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugar_fallecimiento?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_servicio?: NullableStringFieldUpdateOperationsInput | string | null
    casa_mortuaria?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inhumacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hora_inhumacion?: NullableStringFieldUpdateOperationsInput | string | null
    cementerio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_recepcion?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    retiro?: NullableStringFieldUpdateOperationsInput | string | null
    solicitado?: NullableStringFieldUpdateOperationsInput | string | null
    parentesco?: NullableStringFieldUpdateOperationsInput | string | null
    altura?: NullableFloatFieldUpdateOperationsInput | number | null
    peso?: NullableFloatFieldUpdateOperationsInput | number | null
    dni_nuevotitular?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    idataud?: NullableIntFieldUpdateOperationsInput | number | null
    dni_solicitante?: NullableIntFieldUpdateOperationsInput | number | null
    impactado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cremacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    gastos_cargados?: NullableIntFieldUpdateOperationsInput | number | null
    obra_soc?: NullableStringFieldUpdateOperationsInput | string | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    donacion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    domicilio_solicitante?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionCreateInput = {
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUncheckedCreateInput = {
    idliquidacion?: number
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionUncheckedUpdateInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionCreateManyInput = {
    idliquidacion?: number
    idservicio?: number | null
    total_liquidacion?: number | null
    fecha_liquidacion?: Date | string | null
    operador?: string | null
  }

  export type servicios_liquidacionUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicios_liquidacionUncheckedUpdateManyInput = {
    idliquidacion?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    total_liquidacion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_liquidacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareasCreateInput = {
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUncheckedCreateInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasUncheckedUpdateInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasCreateManyInput = {
    idevents?: number
    title?: string | null
    allDay?: number | null
    start?: string | null
    end?: string | null
    priority?: number | null
  }

  export type tareasUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareasUncheckedUpdateManyInput = {
    idevents?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    allDay?: NullableIntFieldUpdateOperationsInput | number | null
    start?: NullableStringFieldUpdateOperationsInput | string | null
    end?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tareas_adicionalesCreateInput = {
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUncheckedCreateInput = {
    idtarea?: number
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUpdateInput = {
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesUncheckedUpdateInput = {
    idtarea?: IntFieldUpdateOperationsInput | number
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesCreateManyInput = {
    idtarea?: number
    inicio?: Date | string | null
    fin?: Date | string | null
    tarea?: string | null
    operador?: string | null
    observaciones?: string | null
    horas?: Date | string | null
    feriado?: number | null
    liquidado?: boolean | null
    fecha_liquidacion?: string | null
    operadorliq?: string | null
    aprobado?: boolean | null
    fecha_aprobacion?: string | null
    operadorap?: string | null
    mes_planificacion?: string | null
  }

  export type tareas_adicionalesUpdateManyMutationInput = {
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tareas_adicionalesUncheckedUpdateManyInput = {
    idtarea?: IntFieldUpdateOperationsInput | number
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarea?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    horas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feriado?: NullableIntFieldUpdateOperationsInput | number | null
    liquidado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_liquidacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorliq?: NullableStringFieldUpdateOperationsInput | string | null
    aprobado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fecha_aprobacion?: NullableStringFieldUpdateOperationsInput | string | null
    operadorap?: NullableStringFieldUpdateOperationsInput | string | null
    mes_planificacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleCreateInput = {
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUncheckedCreateInput = {
    idtipodetalle?: number
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUpdateInput = {
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleUncheckedUpdateInput = {
    idtipodetalle?: IntFieldUpdateOperationsInput | number
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleCreateManyInput = {
    idtipodetalle?: number
    tipo_detalle?: string | null
    observacion?: string | null
  }

  export type tipo_detalleUpdateManyMutationInput = {
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipo_detalleUncheckedUpdateManyInput = {
    idtipodetalle?: IntFieldUpdateOperationsInput | number
    tipo_detalle?: NullableStringFieldUpdateOperationsInput | string | null
    observacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesCreateInput = {
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUncheckedCreateInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesCreateManyInput = {
    idvisitante?: number
    idservicio?: number | null
    nombre?: string | null
    apellido?: string | null
    dni?: number | null
    telefono?: number | null
    parentezco?: string | null
    operador?: string | null
    fecha?: Date | string | null
    temperatura?: string | null
  }

  export type visitantesUpdateManyMutationInput = {
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type visitantesUncheckedUpdateManyInput = {
    idvisitante?: IntFieldUpdateOperationsInput | number
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    telefono?: NullableIntFieldUpdateOperationsInput | number | null
    parentezco?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    temperatura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresCreateInput = {
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUncheckedCreateInput = {
    idlugar?: number
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUpdateInput = {
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresUncheckedUpdateInput = {
    idlugar?: IntFieldUpdateOperationsInput | number
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresCreateManyInput = {
    idlugar?: number
    idparcela?: number | null
    idservicio?: number | null
    lugar?: number | null
    contrato?: number | null
    dni?: number | null
    fecha?: Date | string | null
    operador?: string | null
  }

  export type parcelas_lugaresUpdateManyMutationInput = {
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parcelas_lugaresUncheckedUpdateManyInput = {
    idlugar?: IntFieldUpdateOperationsInput | number
    idparcela?: NullableIntFieldUpdateOperationsInput | number | null
    idservicio?: NullableIntFieldUpdateOperationsInput | number | null
    lugar?: NullableIntFieldUpdateOperationsInput | number | null
    contrato?: NullableIntFieldUpdateOperationsInput | number | null
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saCreateInput = {
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUncheckedCreateInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saCreateManyInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_saUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_saUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlCreateInput = {
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUncheckedCreateInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUpdateInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlUncheckedUpdateInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlCreateManyInput = {
    idcaja?: number
    codigo?: number | null
    cuenta?: string | null
    tipo?: string | null
    serie?: number | null
    factura?: number | null
    importe?: number | null
    comentarios?: string | null
    nro_caja?: number | null
    movim?: string | null
    fecha?: Date | string | null
    puesto?: number | null
    operador?: number | null
    cuit?: string | null
    proveedor?: string | null
    sucursal?: string | null
  }

  export type caja_srlUpdateManyMutationInput = {
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type caja_srlUncheckedUpdateManyInput = {
    idcaja?: IntFieldUpdateOperationsInput | number
    codigo?: NullableIntFieldUpdateOperationsInput | number | null
    cuenta?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableIntFieldUpdateOperationsInput | number | null
    factura?: NullableIntFieldUpdateOperationsInput | number | null
    importe?: NullableFloatFieldUpdateOperationsInput | number | null
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nro_caja?: NullableIntFieldUpdateOperationsInput | number | null
    movim?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    puesto?: NullableIntFieldUpdateOperationsInput | number | null
    operador?: NullableIntFieldUpdateOperationsInput | number | null
    cuit?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: NullableStringFieldUpdateOperationsInput | string | null
    sucursal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type generacion_cajasCreateInput = {
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUncheckedCreateInput = {
    idgeneracion?: number
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUpdateInput = {
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasUncheckedUpdateInput = {
    idgeneracion?: IntFieldUpdateOperationsInput | number
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasCreateManyInput = {
    idgeneracion?: number
    desde?: Date | string | null
    hasta?: Date | string | null
    empresa?: string | null
    operador?: string | null
    fecha?: Date | string | null
  }

  export type generacion_cajasUpdateManyMutationInput = {
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type generacion_cajasUncheckedUpdateManyInput = {
    idgeneracion?: IntFieldUpdateOperationsInput | number
    desde?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    empresa?: NullableStringFieldUpdateOperationsInput | string | null
    operador?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ataud_precioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type ataud_precioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    ataud?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    estado?: SortOrder
  }

  export type ataud_precioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    idataud?: SortOrder
    codigo?: SortOrder
    precio?: SortOrder
    pri_desc?: SortOrder
    sec_desc?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type ataud_ventaCountOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaAvgOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataud_ventaMaxOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaMinOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    apellido_fall?: SortOrder
    nombre_fall?: SortOrder
    dni_fall?: SortOrder
    dom_fall?: SortOrder
    ndom_fall?: SortOrder
    barrio_fall?: SortOrder
    telefono_fall?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    telefono_sol?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    ataud?: SortOrder
  }

  export type ataud_ventaSumOrderByAggregateInput = {
    idataudventa?: SortOrder
    idataud?: SortOrder
    contrato?: SortOrder
    dni_fall?: SortOrder
    ndom_fall?: SortOrder
    dni_sol?: SortOrder
  }

  export type ataudesCountOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesAvgOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type ataudesMaxOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesMinOrderByAggregateInput = {
    idataud?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    medidas?: SortOrder
    uso?: SortOrder
    fabricante?: SortOrder
    codigo?: SortOrder
    fecha_alta?: SortOrder
    stock?: SortOrder
    fecha_reposicion?: SortOrder
    fecha_baja?: SortOrder
    observaciones?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type ataudesSumOrderByAggregateInput = {
    idataud?: SortOrder
    codigo?: SortOrder
    stock?: SortOrder
  }

  export type autosCountOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosAvgOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autosMaxOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosMinOrderByAggregateInput = {
    patente?: SortOrder
    auto?: SortOrder
    kilometros?: SortOrder
    responsable?: SortOrder
    nro_poliza?: SortOrder
    empresa?: SortOrder
    vencimiento?: SortOrder
    motor?: SortOrder
    chasis?: SortOrder
    modelo?: SortOrder
    cobertura?: SortOrder
    idauto?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type autosSumOrderByAggregateInput = {
    kilometros?: SortOrder
    modelo?: SortOrder
    idauto?: SortOrder
  }

  export type autos_hoja_rutaCountOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaAvgOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_hoja_rutaMaxOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaMinOrderByAggregateInput = {
    idhojaruta?: SortOrder
    patente?: SortOrder
    auto?: SortOrder
    conductor?: SortOrder
    idservicio?: SortOrder
    fecha_salida?: SortOrder
    km_salida?: SortOrder
    fecha_llegada?: SortOrder
    km_llegada?: SortOrder
    fecha_registro?: SortOrder
    operador?: SortOrder
  }

  export type autos_hoja_rutaSumOrderByAggregateInput = {
    idhojaruta?: SortOrder
    idservicio?: SortOrder
    km_salida?: SortOrder
    km_llegada?: SortOrder
  }

  export type autos_novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    patente?: SortOrder
    fecha?: SortOrder
    novedad?: SortOrder
    operador?: SortOrder
    auto?: SortOrder
  }

  export type autos_novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type autos_pago_patenteCountOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteAvgOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type autos_pago_patenteMaxOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteMinOrderByAggregateInput = {
    idpago?: SortOrder
    patente?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
  }

  export type autos_pago_patenteSumOrderByAggregateInput = {
    idpago?: SortOrder
    mes?: SortOrder
    ano?: SortOrder
    importe?: SortOrder
    cod_pago?: SortOrder
    idauto?: SortOrder
  }

  export type caja_sepelioCountOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type caja_sepelioMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioMinOrderByAggregateInput = {
    idcaja?: SortOrder
    operador?: SortOrder
    detalle?: SortOrder
    monto?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    empresa?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
    concepto?: SortOrder
    cierre?: SortOrder
    ultimacarga?: SortOrder
  }

  export type caja_sepelioSumOrderByAggregateInput = {
    idcaja?: SortOrder
    monto?: SortOrder
    gastos?: SortOrder
    totalcaja?: SortOrder
    nfactura?: SortOrder
    ptoventa?: SortOrder
  }

  export type conceptosCountOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosAvgOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type conceptosMaxOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosMinOrderByAggregateInput = {
    idconcepto?: SortOrder
    concepto?: SortOrder
    tipo?: SortOrder
  }

  export type conceptosSumOrderByAggregateInput = {
    idconcepto?: SortOrder
  }

  export type fabricante_ataudCountOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudAvgOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type fabricante_ataudMaxOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudMinOrderByAggregateInput = {
    idfabricante?: SortOrder
    fabricante?: SortOrder
  }

  export type fabricante_ataudSumOrderByAggregateInput = {
    idfabricante?: SortOrder
  }

  export type gasto_lutoCountOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoAvgOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gasto_lutoMaxOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoMinOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
    apellido_ben?: SortOrder
    nombre_ben?: SortOrder
    telefono_ben?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
    parentezco?: SortOrder
  }

  export type gasto_lutoSumOrderByAggregateInput = {
    idgastoluto?: SortOrder
    idservicio?: SortOrder
    contrato?: SortOrder
    dni_extinto?: SortOrder
    gasto_luto?: SortOrder
    idataud?: SortOrder
  }

  export type gastos_cajaCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    fecha?: SortOrder
    operadorgestion?: SortOrder
    operadortramite?: SortOrder
    ptoventa?: SortOrder
    porciva?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    detalle?: SortOrder
    mediopago?: SortOrder
    proveedor?: SortOrder
    empresa?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type gastos_cajaSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idcaja?: SortOrder
    ptoventa?: SortOrder
    montoiva?: SortOrder
    retiibb?: SortOrder
    retggcias?: SortOrder
    perciva?: SortOrder
    total?: SortOrder
    idservicio?: SortOrder
  }

  export type historial_autosCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_autosMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    patente?: SortOrder
    idauto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    accion?: SortOrder
  }

  export type historial_autosSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idauto?: SortOrder
  }

  export type historial_stock_ataudCountOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudAvgOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type historial_stock_ataudMaxOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudMinOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    fecha_carga?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
    remito?: SortOrder
    operador?: SortOrder
    fecha_recepcion?: SortOrder
  }

  export type historial_stock_ataudSumOrderByAggregateInput = {
    idhistorial?: SortOrder
    idataud?: SortOrder
    stock_anterior?: SortOrder
    stock_nuevo?: SortOrder
  }

  export type honorariosCountOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosAvgOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMaxOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosMinOrderByAggregateInput = {
    idtrabajo?: SortOrder
    trabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type honorariosSumOrderByAggregateInput = {
    idtrabajo?: SortOrder
    dias_habiles?: SortOrder
    finde?: SortOrder
    feriado?: SortOrder
  }

  export type ingreso_cajaCountOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaAvgOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMaxOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaMinOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    tipofactura?: SortOrder
    nfactura?: SortOrder
    empresa?: SortOrder
    detalle?: SortOrder
    ptoventa?: SortOrder
  }

  export type ingreso_cajaSumOrderByAggregateInput = {
    idingreso?: SortOrder
    idcaja?: SortOrder
    monto?: SortOrder
    ptoventa?: SortOrder
  }

  export type legajo_virtual_autosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_autosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    patente?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
  }

  export type legajo_virtual_autosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
  }

  export type legajo_virtual_serviciosCountOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosAvgOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
  }

  export type legajo_virtual_serviciosMaxOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosMinOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
    archivo?: SortOrder
    fecha_subida?: SortOrder
    empresa?: SortOrder
  }

  export type legajo_virtual_serviciosSumOrderByAggregateInput = {
    idlegajo?: SortOrder
    servicio?: SortOrder
  }

  export type novedadesCountOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesAvgOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type novedadesMaxOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesMinOrderByAggregateInput = {
    idnovedad?: SortOrder
    novedad?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type novedadesSumOrderByAggregateInput = {
    idnovedad?: SortOrder
  }

  export type operadorsepCountOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepAvgOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type operadorsepMaxOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepMinOrderByAggregateInput = {
    idoperador?: SortOrder
    operador?: SortOrder
  }

  export type operadorsepSumOrderByAggregateInput = {
    idoperador?: SortOrder
  }

  export type parcelasCountOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasAvgOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMaxOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasMinOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    parcela?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    asignada?: SortOrder
    fecha?: SortOrder
    cementerio?: SortOrder
    operador?: SortOrder
    fecha_alta?: SortOrder
    operador_asignacion?: SortOrder
    fecha_asignacion?: SortOrder
    lugares?: SortOrder
  }

  export type parcelasSumOrderByAggregateInput = {
    idparcela?: SortOrder
    idservicio?: SortOrder
    dni_extinto?: SortOrder
    ficha?: SortOrder
    mza?: SortOrder
    lote?: SortOrder
    lugares?: SortOrder
  }

  export type planificacion_guardiasCountOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasAvgOrderByAggregateInput = {
    idturno?: SortOrder
    horas?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasMaxOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasMinOrderByAggregateInput = {
    idturno?: SortOrder
    lugar?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    mes_planificacion?: SortOrder
    feriado?: SortOrder
    tarea?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type planificacion_guardiasSumOrderByAggregateInput = {
    idturno?: SortOrder
    horas?: SortOrder
    ano_planificacion?: SortOrder
  }

  export type precio_servicioCountOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioAvgOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type precio_servicioMaxOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioMinOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
    fecha_vigencia?: SortOrder
  }

  export type precio_servicioSumOrderByAggregateInput = {
    idprecio?: SortOrder
    codigo?: SortOrder
    contado?: SortOrder
    contado_cremacion?: SortOrder
    descuento1?: SortOrder
    descuento1_cremacion?: SortOrder
    descuento2?: SortOrder
    descuento2_cremacion?: SortOrder
  }

  export type proveedoresCountOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresAvgOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type proveedoresMaxOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresMinOrderByAggregateInput = {
    idproveedor?: SortOrder
    razon?: SortOrder
    cuit?: SortOrder
    domicilio?: SortOrder
    telefonos?: SortOrder
    estado?: SortOrder
    operador?: SortOrder
  }

  export type proveedoresSumOrderByAggregateInput = {
    idproveedor?: SortOrder
    estado?: SortOrder
  }

  export type servicio_detallesCountOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesAvgOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_detallesMaxOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesMinOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
    detalle?: SortOrder
    lugar?: SortOrder
    monto?: SortOrder
    patente?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    observacion?: SortOrder
  }

  export type servicio_detallesSumOrderByAggregateInput = {
    iddetalles?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_gastosCountOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosAvgOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_gastosMaxOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosMinOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
    tipo_gasto?: SortOrder
    horas?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
  }

  export type servicio_gastosSumOrderByAggregateInput = {
    idgastos?: SortOrder
    idservicio?: SortOrder
  }

  export type servicio_ventaCountOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaAvgOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMaxOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaMinOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    operador?: SortOrder
    fecha_venta?: SortOrder
    apellido_sol?: SortOrder
    nombre_sol?: SortOrder
    dni_sol?: SortOrder
    parentesco?: SortOrder
    operador_venta?: SortOrder
    liquidado?: SortOrder
    operadorliq?: SortOrder
    fecha_liquidacion?: SortOrder
    aprobado?: SortOrder
    operadorap?: SortOrder
    fecha_aprobacion?: SortOrder
    comision?: SortOrder
    fecha_carga?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type servicio_ventaSumOrderByAggregateInput = {
    idventa?: SortOrder
    idservicio?: SortOrder
    monto?: SortOrder
    dni_sol?: SortOrder
    comision?: SortOrder
    valor_cuota?: SortOrder
    plan_cuota?: SortOrder
    monto_financiacion?: SortOrder
    efectivo?: SortOrder
  }

  export type serviciosCountOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosAvgOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
  }

  export type serviciosMaxOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosMinOrderByAggregateInput = {
    idservicio?: SortOrder
    empresa?: SortOrder
    dni?: SortOrder
    apellido?: SortOrder
    nombre?: SortOrder
    edad?: SortOrder
    fecha_fallecimiento?: SortOrder
    lugar_fallecimiento?: SortOrder
    tipo_servicio?: SortOrder
    casa_mortuaria?: SortOrder
    fecha_inhumacion?: SortOrder
    hora_inhumacion?: SortOrder
    cementerio?: SortOrder
    estado?: SortOrder
    contrato?: SortOrder
    fecha_recepcion?: SortOrder
    sucursal?: SortOrder
    motivo?: SortOrder
    retiro?: SortOrder
    solicitado?: SortOrder
    parentesco?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    operador?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    impactado?: SortOrder
    cremacion?: SortOrder
    idparcela?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    gastos_cargados?: SortOrder
    obra_soc?: SortOrder
    importe?: SortOrder
    donacion?: SortOrder
    domicilio_solicitante?: SortOrder
  }

  export type serviciosSumOrderByAggregateInput = {
    idservicio?: SortOrder
    dni?: SortOrder
    edad?: SortOrder
    contrato?: SortOrder
    altura?: SortOrder
    peso?: SortOrder
    dni_nuevotitular?: SortOrder
    idataud?: SortOrder
    dni_solicitante?: SortOrder
    idparcela?: SortOrder
    gastos_cargados?: SortOrder
    importe?: SortOrder
  }

  export type servicios_liquidacionCountOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionAvgOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
  }

  export type servicios_liquidacionMaxOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionMinOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
    fecha_liquidacion?: SortOrder
    operador?: SortOrder
  }

  export type servicios_liquidacionSumOrderByAggregateInput = {
    idliquidacion?: SortOrder
    idservicio?: SortOrder
    total_liquidacion?: SortOrder
  }

  export type tareasCountOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasAvgOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type tareasMaxOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasMinOrderByAggregateInput = {
    idevents?: SortOrder
    title?: SortOrder
    allDay?: SortOrder
    start?: SortOrder
    end?: SortOrder
    priority?: SortOrder
  }

  export type tareasSumOrderByAggregateInput = {
    idevents?: SortOrder
    allDay?: SortOrder
    priority?: SortOrder
  }

  export type tareas_adicionalesCountOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesAvgOrderByAggregateInput = {
    idtarea?: SortOrder
    feriado?: SortOrder
  }

  export type tareas_adicionalesMaxOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesMinOrderByAggregateInput = {
    idtarea?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    tarea?: SortOrder
    operador?: SortOrder
    observaciones?: SortOrder
    horas?: SortOrder
    feriado?: SortOrder
    liquidado?: SortOrder
    fecha_liquidacion?: SortOrder
    operadorliq?: SortOrder
    aprobado?: SortOrder
    fecha_aprobacion?: SortOrder
    operadorap?: SortOrder
    mes_planificacion?: SortOrder
  }

  export type tareas_adicionalesSumOrderByAggregateInput = {
    idtarea?: SortOrder
    feriado?: SortOrder
  }

  export type tipo_detalleCountOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleAvgOrderByAggregateInput = {
    idtipodetalle?: SortOrder
  }

  export type tipo_detalleMaxOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleMinOrderByAggregateInput = {
    idtipodetalle?: SortOrder
    tipo_detalle?: SortOrder
    observacion?: SortOrder
  }

  export type tipo_detalleSumOrderByAggregateInput = {
    idtipodetalle?: SortOrder
  }

  export type visitantesCountOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesAvgOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type visitantesMaxOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesMinOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
    parentezco?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
    temperatura?: SortOrder
  }

  export type visitantesSumOrderByAggregateInput = {
    idvisitante?: SortOrder
    idservicio?: SortOrder
    dni?: SortOrder
    telefono?: SortOrder
  }

  export type parcelas_lugaresCountOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresAvgOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
  }

  export type parcelas_lugaresMaxOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresMinOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
    fecha?: SortOrder
    operador?: SortOrder
  }

  export type parcelas_lugaresSumOrderByAggregateInput = {
    idlugar?: SortOrder
    idparcela?: SortOrder
    idservicio?: SortOrder
    lugar?: SortOrder
    contrato?: SortOrder
    dni?: SortOrder
  }

  export type caja_saCountOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_saMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saMinOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_saSumOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_srlCountOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlAvgOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type caja_srlMaxOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlMinOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    cuenta?: SortOrder
    tipo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    comentarios?: SortOrder
    nro_caja?: SortOrder
    movim?: SortOrder
    fecha?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
    cuit?: SortOrder
    proveedor?: SortOrder
    sucursal?: SortOrder
  }

  export type caja_srlSumOrderByAggregateInput = {
    idcaja?: SortOrder
    codigo?: SortOrder
    serie?: SortOrder
    factura?: SortOrder
    importe?: SortOrder
    nro_caja?: SortOrder
    puesto?: SortOrder
    operador?: SortOrder
  }

  export type generacion_cajasCountOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasAvgOrderByAggregateInput = {
    idgeneracion?: SortOrder
  }

  export type generacion_cajasMaxOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasMinOrderByAggregateInput = {
    idgeneracion?: SortOrder
    desde?: SortOrder
    hasta?: SortOrder
    empresa?: SortOrder
    operador?: SortOrder
    fecha?: SortOrder
  }

  export type generacion_cajasSumOrderByAggregateInput = {
    idgeneracion?: SortOrder
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[]
    notIn?: number[]
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}